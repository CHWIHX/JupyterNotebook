/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module) => {



/* eslint-env browser */

/* eslint-disable no-undef, no-use-before-define, new-cap */
module.exports = function (content, workerConstructor, workerOptions, url) {
  var globalScope = self || window;

  try {
    try {
      var blob;

      try {
        // New API
        blob = new globalScope.Blob([content]);
      } catch (e) {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;
        blob = new BlobBuilder();
        blob.append(content);
        blob = blob.getBlob();
      }

      var URL = globalScope.URL || globalScope.webkitURL;
      var objectURL = URL.createObjectURL(blob);
      var worker = new globalScope[workerConstructor](objectURL, workerOptions);
      URL.revokeObjectURL(objectURL);
      return worker;
    } catch (e) {
      return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);
    }
  } catch (e) {
    if (!url) {
      throw Error("Inline worker is not supported");
    }

    return new globalScope[workerConstructor](url, workerOptions);
  }
};

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Worker_fn)
/* harmony export */ });
/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);



function Worker_fn() {
  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()("/******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AttachState\": () => (/* reexport safe */ _containerDefinitions__WEBPACK_IMPORTED_MODULE_0__.AttachState),\n/* harmony export */   \"ConnectionState\": () => (/* reexport safe */ _containerLoader__WEBPACK_IMPORTED_MODULE_1__.ConnectionState),\n/* harmony export */   \"ContainerErrorType\": () => (/* reexport safe */ _containerDefinitions__WEBPACK_IMPORTED_MODULE_0__.ContainerErrorType),\n/* harmony export */   \"DOProviderContainerRuntimeFactory\": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.DOProviderContainerRuntimeFactory),\n/* harmony export */   \"DirectoryFactory\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.DirectoryFactory),\n/* harmony export */   \"DriverErrorType\": () => (/* reexport safe */ _driverDefinitions__WEBPACK_IMPORTED_MODULE_2__.DriverErrorType),\n/* harmony export */   \"FluidContainer\": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.FluidContainer),\n/* harmony export */   \"Interval\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.Interval),\n/* harmony export */   \"IntervalCollection\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.IntervalCollection),\n/* harmony export */   \"IntervalCollectionIterator\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.IntervalCollectionIterator),\n/* harmony export */   \"IntervalType\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.IntervalType),\n/* harmony export */   \"LocalValueMaker\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.LocalValueMaker),\n/* harmony export */   \"MapFactory\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.MapFactory),\n/* harmony export */   \"PaddingSegment\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.PaddingSegment),\n/* harmony export */   \"RootDataObject\": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.RootDataObject),\n/* harmony export */   \"RunSegment\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.RunSegment),\n/* harmony export */   \"SequenceDeltaEvent\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceDeltaEvent),\n/* harmony export */   \"SequenceEvent\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceEvent),\n/* harmony export */   \"SequenceInterval\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceInterval),\n/* harmony export */   \"SequenceMaintenanceEvent\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceMaintenanceEvent),\n/* harmony export */   \"ServiceAudience\": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.ServiceAudience),\n/* harmony export */   \"SharedDirectory\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.SharedDirectory),\n/* harmony export */   \"SharedIntervalCollection\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedIntervalCollection),\n/* harmony export */   \"SharedIntervalCollectionFactory\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedIntervalCollectionFactory),\n/* harmony export */   \"SharedMap\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.SharedMap),\n/* harmony export */   \"SharedNumberSequence\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedNumberSequence),\n/* harmony export */   \"SharedNumberSequenceFactory\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedNumberSequenceFactory),\n/* harmony export */   \"SharedObjectSequence\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence),\n/* harmony export */   \"SharedObjectSequenceFactory\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequenceFactory),\n/* harmony export */   \"SharedSegmentSequence\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedSegmentSequence),\n/* harmony export */   \"SharedSequence\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedSequence),\n/* harmony export */   \"SharedString\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedString),\n/* harmony export */   \"SharedStringFactory\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedStringFactory),\n/* harmony export */   \"SparseMatrix\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SparseMatrix),\n/* harmony export */   \"SparseMatrixFactory\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SparseMatrixFactory),\n/* harmony export */   \"SubSequence\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SubSequence),\n/* harmony export */   \"maxCellPosition\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxCellPosition),\n/* harmony export */   \"maxCol\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxCol),\n/* harmony export */   \"maxCols\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxCols),\n/* harmony export */   \"maxRow\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxRow),\n/* harmony export */   \"maxRows\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxRows),\n/* harmony export */   \"positionToRowCol\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.positionToRowCol),\n/* harmony export */   \"rowColToPosition\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.rowColToPosition)\n/* harmony export */ });\n/* harmony import */ var _containerDefinitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _containerLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n/* harmony import */ var _driverDefinitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);\n/* harmony import */ var _fluidStatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(275);\n/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(277);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * The **fluid-framework** package bundles a collection of Fluid Framework client packages for easy use when paired with\n * a corresponding service client package (for example, `\\@fluidframework/azure-client` or\n * `\\@fluidframework/tinylicious-client`).\n *\n * @packageDocumentation\n */\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AttachState\": () => (/* reexport safe */ _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState),\n/* harmony export */   \"ContainerErrorType\": () => (/* reexport safe */ _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n//# sourceMappingURL=containerDefinitions.js.map\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AttachState\": () => (/* binding */ AttachState),\n/* harmony export */   \"BindState\": () => (/* binding */ BindState),\n/* harmony export */   \"IRuntimeFactory\": () => (/* binding */ IRuntimeFactory)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * The attachment state of some Fluid data (e.g. a container or data store), denoting whether it is uploaded to the\n * service.  The transition from detached to attached state is a one-way transition.\n */\nvar AttachState;\n(function (AttachState) {\n    /**\n     * In detached state, the data is only present on the local client's machine.  It has not yet been uploaded\n     * to the service.\n     */\n    AttachState[\"Detached\"] = \"Detached\";\n    /**\n     * In attaching state, the data has started the upload to the service, but has not yet completed.\n     */\n    AttachState[\"Attaching\"] = \"Attaching\";\n    /**\n     * In attached state, the data has completed upload to the service.  It can be accessed by other clients after\n     * reaching attached state.\n     */\n    AttachState[\"Attached\"] = \"Attached\";\n})(AttachState || (AttachState = {}));\n// Represents the bind state of the entity.\nvar BindState;\n(function (BindState) {\n    BindState[\"NotBound\"] = \"NotBound\";\n    BindState[\"Binding\"] = \"Binding\";\n    BindState[\"Bound\"] = \"Bound\";\n})(BindState || (BindState = {}));\nconst IRuntimeFactory = \"IRuntimeFactory\";\n//# sourceMappingURL=runtime.js.map\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContainerErrorType\": () => (/* binding */ ContainerErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Different error types the Container may report out to the Host\n */\nvar ContainerErrorType;\n(function (ContainerErrorType) {\n    /**\n     * Some error, most likely an exception caught by runtime and propagated to container as critical error\n     */\n    ContainerErrorType[\"genericError\"] = \"genericError\";\n    /**\n     * Throttling error from server. Server is busy and is asking not to reconnect for some time\n     */\n    ContainerErrorType[\"throttlingError\"] = \"throttlingError\";\n    /**\n     * Data loss error detected by Container / DeltaManager. Likely points to storage issue.\n     */\n    ContainerErrorType[\"dataCorruptionError\"] = \"dataCorruptionError\";\n    /**\n     * Error encountered when processing an operation. May correlate with data corruption.\n     */\n    ContainerErrorType[\"dataProcessingError\"] = \"dataProcessingError\";\n    /**\n     * Error indicating an API is being used improperly resulting in an invalid operation.\n     */\n    ContainerErrorType[\"usageError\"] = \"usageError\";\n    /**\n     * Error indicating an client session has expired. Currently this only happens when GC is allowed on a document and\n     * aids in safely deleting unused objects.\n     */\n    ContainerErrorType[\"clientSessionExpiredError\"] = \"clientSessionExpiredError\";\n})(ContainerErrorType || (ContainerErrorType = {}));\n//# sourceMappingURL=error.js.map\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConnectionState\": () => (/* reexport safe */ _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_0__.ConnectionState)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n//# sourceMappingURL=containerLoader.js.map\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConnectionState\": () => (/* binding */ ConnectionState)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar ConnectionState;\n(function (ConnectionState) {\n    /**\n     * The container is not connected to the ordering service\n     * Note - When in this state the container may be about to reconnect,\n     * or may remain disconnected until explicitly told to connect.\n     */\n    ConnectionState[ConnectionState[\"Disconnected\"] = 0] = \"Disconnected\";\n    /**\n     * The container is disconnected but actively trying to establish a new connection\n     * PLEASE NOTE that this numerical value falls out of the order you may expect for this state\n     */\n    ConnectionState[ConnectionState[\"EstablishingConnection\"] = 3] = \"EstablishingConnection\";\n    /**\n     * See {@link ConnectionState.CatchingUp}, which is the new name for this state.\n     * @deprecated - This state itself is not gone, just being renamed. Please use {@link ConnectionState.CatchingUp}.\n     */\n    ConnectionState[ConnectionState[\"Connecting\"] = 1] = \"Connecting\";\n    /**\n     * The container has an inbound connection only, and is catching up to the latest known state from the service.\n     */\n    ConnectionState[ConnectionState[\"CatchingUp\"] = 1] = \"CatchingUp\";\n    /**\n     * The container is fully connected and syncing\n     */\n    ConnectionState[ConnectionState[\"Connected\"] = 2] = \"Connected\";\n})(ConnectionState || (ConnectionState = {}));\n//# sourceMappingURL=connectionState.js.map\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DriverErrorType\": () => (/* reexport safe */ _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__.DriverErrorType)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n//# sourceMappingURL=driverDefinitions.js.map\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DriverErrorType\": () => (/* binding */ DriverErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Driver Error types\n * Lists types that are likely to be used by all drivers\n */\nvar DriverErrorType;\n(function (DriverErrorType) {\n    /**\n     * A fatal error with no specific interpretation covered by other DriverErrorType values\n     */\n    DriverErrorType[\"genericError\"] = \"genericError\";\n    /**\n     * Some non-categorized (below) networking error\n     * Include errors like  fatal server error (usually 500).\n     */\n    DriverErrorType[\"genericNetworkError\"] = \"genericNetworkError\";\n    /**\n     * Access denied - user does not have enough privileges to open a file, or continue to operate on a file\n     */\n    DriverErrorType[\"authorizationError\"] = \"authorizationError\";\n    /**\n     * File not found, or file deleted during session\n     */\n    DriverErrorType[\"fileNotFoundOrAccessDeniedError\"] = \"fileNotFoundOrAccessDeniedError\";\n    /**\n     * Throttling error from server. Server is busy and is asking not to reconnect for some time\n     */\n    DriverErrorType[\"throttlingError\"] = \"throttlingError\";\n    /**\n     * We can not reach server due to computer being offline.\n     */\n    DriverErrorType[\"offlineError\"] = \"offlineError\";\n    /*\n     * Unsupported client protocol\n     */\n    DriverErrorType[\"unsupportedClientProtocolVersion\"] = \"unsupportedClientProtocolVersion\";\n    /**\n     * User does not have write permissions to a file, but is changing content of a file.\n     * That might be indication of some data store error - data stores should not generate ops in readonly mode.\n     */\n    DriverErrorType[\"writeError\"] = \"writeError\";\n    /**\n     * A generic fetch failure that indicates we were not able to get a response from the server.\n     * This may be due to the client being offline (though, if we are able to detect offline state it will be\n     * logged as an offlineError instead).  Other possibilities could be DNS errors, malformed fetch request,\n     * CSP violation, etc.\n     */\n    DriverErrorType[\"fetchFailure\"] = \"fetchFailure\";\n    /**\n     * Unexpected response from server. Either JSON is malformed, or some required properties are missing\n     */\n    DriverErrorType[\"incorrectServerResponse\"] = \"incorrectServerResponse\";\n    /**\n     * This error occurs when the file is modified externally (not through Fluid protocol) in storage.\n     * It will occur in cases where client has some state or cache that is based on old content (identity) of a file,\n     * and storage / driver / loader detects such mismatch.\n     * When it's hit, client needs to forget all the knowlege about this file and start over.\n     */\n    DriverErrorType[\"fileOverwrittenInStorage\"] = \"fileOverwrittenInStorage\";\n    /**\n     * The document is read-only and delta stream connection is forbidden.\n     */\n    DriverErrorType[\"deltaStreamConnectionForbidden\"] = \"deltaStreamConnectionForbidden\";\n    /**\n     * The location of file/container can change on server. So if the file location moves and we try to access the old\n     * location, then this error is thrown to let the client know about the new location info.\n     */\n    DriverErrorType[\"locationRedirection\"] = \"locationRedirection\";\n})(DriverErrorType || (DriverErrorType = {}));\n//# sourceMappingURL=driverError.js.map\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOProviderContainerRuntimeFactory\": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.DOProviderContainerRuntimeFactory),\n/* harmony export */   \"FluidContainer\": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.FluidContainer),\n/* harmony export */   \"RootDataObject\": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.RootDataObject),\n/* harmony export */   \"ServiceAudience\": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.ServiceAudience)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n//# sourceMappingURL=fluidStatic.js.map\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOProviderContainerRuntimeFactory\": () => (/* reexport safe */ _rootDataObject__WEBPACK_IMPORTED_MODULE_1__.DOProviderContainerRuntimeFactory),\n/* harmony export */   \"FluidContainer\": () => (/* reexport safe */ _fluidContainer__WEBPACK_IMPORTED_MODULE_0__.FluidContainer),\n/* harmony export */   \"RootDataObject\": () => (/* reexport safe */ _rootDataObject__WEBPACK_IMPORTED_MODULE_1__.RootDataObject),\n/* harmony export */   \"ServiceAudience\": () => (/* reexport safe */ _serviceAudience__WEBPACK_IMPORTED_MODULE_2__.ServiceAudience)\n/* harmony export */ });\n/* harmony import */ var _fluidContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _rootDataObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);\n/* harmony import */ var _serviceAudience__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(274);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Provides a simple and powerful way to consume collaborative Fluid data.\n *\n * @packageDocumentation\n */\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FluidContainer\": () => (/* binding */ FluidContainer)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Base {@link IFluidContainer} implementation.\n *\n * @remarks Note: this implementation is not complete. Consumers who rely on {@link IFluidContainer.attach}\n * will need to utilize or provide a service-specific implementation of this type that implements that method.\n */\nclass FluidContainer extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(container, rootDataObject) {\n        super();\n        this.container = container;\n        this.rootDataObject = rootDataObject;\n        this.connectedHandler = () => this.emit(\"connected\");\n        this.disconnectedHandler = () => this.emit(\"disconnected\");\n        this.disposedHandler = (error) => this.emit(\"disposed\", error);\n        this.savedHandler = () => this.emit(\"saved\");\n        this.dirtyHandler = () => this.emit(\"dirty\");\n        container.on(\"connected\", this.connectedHandler);\n        container.on(\"closed\", this.disposedHandler);\n        container.on(\"disconnected\", this.disconnectedHandler);\n        container.on(\"saved\", this.savedHandler);\n        container.on(\"dirty\", this.dirtyHandler);\n    }\n    /**\n     * {@inheritDoc IFluidContainer.isDirty}\n     */\n    get isDirty() {\n        return this.container.isDirty;\n    }\n    /**\n     * {@inheritDoc IFluidContainer.attachState}\n     */\n    get attachState() {\n        return this.container.attachState;\n    }\n    /**\n     * {@inheritDoc IFluidContainer.disposed}\n     */\n    get disposed() {\n        return this.container.closed;\n    }\n    /**\n     * {@inheritDoc IFluidContainer.connectionState}\n     */\n    get connectionState() {\n        return this.container.connectionState;\n    }\n    /**\n     * {@inheritDoc IFluidContainer.initialObjects}\n     */\n    get initialObjects() {\n        return this.rootDataObject.initialObjects;\n    }\n    /**\n     * Incomplete base implementation of {@link IFluidContainer.attach}.\n     * @remarks Note: this implementation will unconditionally throw.\n     * Consumers who rely on this will need to utilize or provide a service specific implementation of this base type\n     * that provides an implementation of this method.\n     *\n     * The reason is because externally we are presenting a separation between the service and the `FluidContainer`,\n     * but internally this separation is not there.\n     */\n    async attach() {\n        throw new Error(\"Cannot attach container. Container is not in detached state\");\n    }\n    /**\n     * {@inheritDoc IFluidContainer.connect}\n     */\n    async connect() {\n        var _a, _b;\n        (_b = (_a = this.container).connect) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * {@inheritDoc IFluidContainer.connect}\n     */\n    async disconnect() {\n        var _a, _b;\n        (_b = (_a = this.container).disconnect) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * {@inheritDoc IFluidContainer.create}\n     */\n    async create(objectClass) {\n        return this.rootDataObject.create(objectClass);\n    }\n    /**\n     * {@inheritDoc IFluidContainer.dispose}\n     */\n    dispose() {\n        this.container.close();\n        this.container.off(\"connected\", this.connectedHandler);\n        this.container.off(\"closed\", this.disposedHandler);\n        this.container.off(\"disconnected\", this.disconnectedHandler);\n        this.container.off(\"saved\", this.savedHandler);\n        this.container.off(\"dirty\", this.dirtyHandler);\n    }\n}\n//# sourceMappingURL=fluidContainer.js.map\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 13 */\n/***/ ((module) => {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOProviderContainerRuntimeFactory\": () => (/* binding */ DOProviderContainerRuntimeFactory),\n/* harmony export */   \"RootDataObject\": () => (/* binding */ RootDataObject)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\n/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(145);\n/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(151);\n/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(144);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n/**\n * The entry-point/root collaborative object of the Fluid Container.\n * This class abstracts the dynamic code required to build a Fluid Container into a static representation\n * for end customers.\n */\nclass RootDataObject extends _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__.DataObject {\n    constructor() {\n        super(...arguments);\n        this.initialObjectsDirKey = \"initial-objects-key\";\n        this._initialObjects = {};\n    }\n    get initialObjectsDir() {\n        const dir = this.root.getSubDirectory(this.initialObjectsDirKey);\n        if (dir === undefined) {\n            throw new Error(\"InitialObjects sub-directory was not initialized\");\n        }\n        return dir;\n    }\n    /**\n     * The first time this object is initialized, creates each object identified in\n     * {@link RootDataObjectProps.initialObjects} and stores them as unique values in the root directory.\n     *\n     * See {@link @fluidframework/aqueduct#PureDataObject.initializingFirstTime}\n     */\n    async initializingFirstTime(props) {\n        this.root.createSubDirectory(this.initialObjectsDirKey);\n        // Create initial objects provided by the developer\n        const initialObjectsP = [];\n        Object.entries(props.initialObjects).forEach(([id, objectClass]) => {\n            const createObject = async () => {\n                const obj = await this.create(objectClass);\n                this.initialObjectsDir.set(id, obj.handle);\n            };\n            initialObjectsP.push(createObject());\n        });\n        await Promise.all(initialObjectsP);\n    }\n    /**\n     * Every time an instance is initialized, loads all of the initial objects in the root directory so they can be\n     * accessed immediately.\n     *\n     * See {@link @fluidframework/aqueduct#PureDataObject.hasInitialized}\n     */\n    async hasInitialized() {\n        // We will always load the initial objects so they are available to the developer\n        const loadInitialObjectsP = [];\n        for (const [key, value] of Array.from(this.initialObjectsDir.entries())) {\n            const loadDir = async () => {\n                const obj = await value.get();\n                Object.assign(this._initialObjects, { [key]: obj });\n            };\n            loadInitialObjectsP.push(loadDir());\n        }\n        await Promise.all(loadInitialObjectsP);\n    }\n    /**\n     * Provides a record of the initial objects defined on creation.\n     * See {@link RootDataObject.initializingFirstTime}\n     */\n    get initialObjects() {\n        if (Object.keys(this._initialObjects).length === 0) {\n            throw new Error(\"Initial Objects were not correctly initialized\");\n        }\n        return this._initialObjects;\n    }\n    /**\n     * Dynamically creates a new detached collaborative object (DDS/DataObject).\n     * @param objectClass - Type of the collaborative object to be created.\n     */\n    async create(objectClass) {\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isDataObjectClass)(objectClass)) {\n            return this.createDataObject(objectClass);\n        }\n        else if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isSharedObjectClass)(objectClass)) {\n            return this.createSharedObject(objectClass);\n        }\n        throw new Error(\"Could not create new Fluid object because an unknown object was passed\");\n    }\n    async createDataObject(dataObjectClass) {\n        const factory = dataObjectClass.factory;\n        const packagePath = [...this.context.packagePath, factory.type];\n        const router = await this.context.containerRuntime.createDataStore(packagePath);\n        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.requestFluidObject)(router, \"/\");\n    }\n    createSharedObject(sharedObjectClass) {\n        const factory = sharedObjectClass.getFactory();\n        const obj = this.runtime.createChannel(undefined, factory.type);\n        return obj;\n    }\n}\nconst rootDataStoreId = \"rootDOId\";\n/**\n * Container code that provides a single {@link RootDataObject}.  This data object is\n * dynamically customized (registry and initial objects) based on the schema provided to the container runtime factory.\n */\nclass DOProviderContainerRuntimeFactory extends _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_3__.BaseContainerRuntimeFactory {\n    constructor(schema) {\n        const [registryEntries, sharedObjects] = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.parseDataObjectsFromSharedObjects)(schema);\n        const rootDataObjectFactory = new _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_4__.DataObjectFactory(\"rootDO\", RootDataObject, sharedObjects, {}, registryEntries);\n        super([rootDataObjectFactory.registryEntry], undefined, [(0,_fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_5__.defaultRouteRequestHandler)(rootDataStoreId)], \n        // temporary workaround to disable message batching until the message batch size issue is resolved\n        // resolution progress is tracked by the Feature 465 work item in AzDO\n        { flushMode: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6__.FlushMode.Immediate });\n        this.rootDataObjectFactory = rootDataObjectFactory;\n        this.initialObjects = schema.initialObjects;\n    }\n    /**\n     * {@inheritDoc @fluidframework/aqueduct#BaseContainerRuntimeFactory.containerInitializingFirstTime}\n     */\n    async containerInitializingFirstTime(runtime) {\n        // The first time we create the container we create the RootDataObject\n        await this.rootDataObjectFactory.createRootInstance(rootDataStoreId, runtime, { initialObjects: this.initialObjects });\n    }\n}\n//# sourceMappingURL=rootDataObject.js.map\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataObject\": () => (/* binding */ DataObject)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);\n/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(142);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);\n/* harmony import */ var _pureDataObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * DataObject is a base data store that is primed with a root directory. It\n * ensures that it is created and ready before you can access it.\n *\n * Having a single root directory allows for easier development. Instead of creating\n * and registering channels with the runtime any new DDS that is set on the root\n * will automatically be registered.\n *\n * @typeParam I - The optional input types used to strongly type the data object\n */\nclass DataObject extends _pureDataObject__WEBPACK_IMPORTED_MODULE_0__.PureDataObject {\n    constructor() {\n        super(...arguments);\n        this.rootDirectoryId = \"root\";\n    }\n    /**\n     * {@inheritDoc PureDataObject.request}\n     */\n    async request(request) {\n        const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.RequestParser.create(request);\n        const itemId = requestParser.pathParts[0];\n        if (itemId === \"bigBlobs\") {\n            const value = this.root.get(requestParser.pathParts.join(\"/\"));\n            if (value === undefined) {\n                return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(requestParser);\n            }\n            return { mimeType: \"fluid/object\", status: 200, value };\n        }\n        else {\n            return super.request(requestParser);\n        }\n    }\n    /**\n     * The root directory will either be ready or will return an error. If an error is thrown\n     * the root has not been correctly created/set.\n     */\n    get root() {\n        if (!this.internalRoot) {\n            throw new Error(this.getUninitializedErrorString(`root`));\n        }\n        return this.internalRoot;\n    }\n    /**\n     * Initializes internal objects and calls initialization overrides.\n     * Caller is responsible for ensuring this is only invoked once.\n     */\n    async initializeInternal(existing) {\n        if (!existing) {\n            // Create a root directory and register it before calling initializingFirstTime\n            this.internalRoot = _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedDirectory.create(this.runtime, this.rootDirectoryId);\n            this.internalRoot.bindToContext();\n        }\n        else {\n            // data store has a root directory so we just need to set it before calling initializingFromExisting\n            this.internalRoot = await this.runtime.getChannel(this.rootDirectoryId);\n            // This will actually be an ISharedMap if the channel was previously created by the older version of\n            // DataObject which used a SharedMap.  Since SharedMap and SharedDirectory are compatible unless\n            // SharedDirectory-only commands are used on SharedMap, this will mostly just work for compatibility.\n            if (this.internalRoot.attributes.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_4__.MapFactory.Type) {\n                this.runtime.logger.send({\n                    category: \"generic\",\n                    eventName: \"MapDataObject\",\n                    message: \"Legacy document, SharedMap is masquerading as SharedDirectory in DataObject\",\n                });\n            }\n        }\n        await super.initializeInternal(existing);\n    }\n    /**\n     * Generates an error string indicating an item is uninitialized.\n     * @param item - The name of the item that was uninitialized.\n     */\n    getUninitializedErrorString(item) {\n        return `${item} must be initialized before being accessed.`;\n    }\n}\n//# sourceMappingURL=dataObject.js.map\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PureDataObject\": () => (/* binding */ PureDataObject)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);\n/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);\n/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);\n/* harmony import */ var _container_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);\n/* harmony import */ var _request_handlers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n/**\n * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.\n * You probably don't want to inherit from this data store directly unless\n * you are creating another base data store class\n *\n * @typeParam I - The optional input types used to strongly type the data object\n */\nclass PureDataObject extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {\n    constructor(props) {\n        super();\n        this._disposed = false;\n        this.runtime = props.runtime;\n        this.context = props.context;\n        this.providers = props.providers;\n        this.initProps = props.initProps;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime._dataObject === undefined, 0x0bd /* \"Object runtime already has DataObject!\" */);\n        this.runtime._dataObject = this;\n        // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the\n        // same as reaching its routeContext (FluidDataStoreRuntime) so the relative path to it from the\n        // routeContext is empty.\n        this.innerHandle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_2__.FluidObjectHandle(this, \"\", this.runtime.objectsRoutingContext);\n        // Container event handlers\n        this.runtime.once(\"dispose\", () => {\n            this._disposed = true;\n            this.dispose();\n        });\n    }\n    get disposed() { return this._disposed; }\n    get id() { return this.runtime.id; }\n    get IFluidRouter() { return this; }\n    get IFluidLoadable() { return this; }\n    get IFluidHandle() { return this.innerHandle; }\n    /**\n     * Handle to a data store\n     */\n    get handle() { return this.innerHandle; }\n    static async getDataObject(runtime) {\n        const obj = runtime._dataObject;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(obj !== undefined, 0x0bc /* \"Runtime has no DataObject!\" */);\n        await obj.finishInitialization(true);\n        return obj;\n    }\n    // #region IFluidRouter\n    /**\n     * Return this object if someone requests it directly\n     * We will return this object in two scenarios:\n     *  1. the request url is a \"/\"\n     *  2. the request url is empty\n     */\n    async request(req) {\n        return (0,_request_handlers__WEBPACK_IMPORTED_MODULE_3__.defaultFluidObjectRequestHandler)(this, req);\n    }\n    // #endregion IFluidRouter\n    // #region IFluidLoadable\n    // #endregion IFluidLoadable\n    /**\n     * Call this API to ensure PureDataObject is fully initialized.\n     * Initialization happens on demand, only on as-needed bases.\n     * In most cases you should allow factory/object to decide when to finish initialization.\n     * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods\n     * and need a fully initialized object, then you can call this API to ensure object is fully initialized.\n     */\n    async finishInitialization(existing) {\n        if (this.initializeP !== undefined) {\n            return this.initializeP;\n        }\n        this.initializeP = this.initializeInternal(existing);\n        return this.initializeP;\n    }\n    /**\n     * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should\n     * generally not be done.\n     *\n     * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is\n     * responsible for ensuring this is only invoked once.\n     */\n    async initializeInternal(existing) {\n        var _a;\n        await this.preInitialize();\n        if (existing) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.initProps === undefined, 0x0be /* \"Trying to initialize from existing while initProps is set!\" */);\n            await this.initializingFromExisting();\n        }\n        else {\n            await this.initializingFirstTime((_a = this.context.createProps) !== null && _a !== void 0 ? _a : this.initProps);\n        }\n        await this.hasInitialized();\n    }\n    /**\n     * Retrieve Fluid object using the handle get\n     *\n     * @param key - key that object (handle/id) is stored with in the directory\n     * @param directory - directory containing the object\n     * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to\n     * define custom types/getters for object retrieval\n     */\n    async getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {\n        const handleMaybe = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);\n        const handle = handleMaybe === null || handleMaybe === void 0 ? void 0 : handleMaybe.IFluidHandle;\n        if (handle) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return handle.get();\n        }\n    }\n    /**\n     * Gets the service at a given id.\n     * @param id - service id\n     */\n    async getService(id) {\n        return (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.handleFromLegacyUri)(`/${_container_services__WEBPACK_IMPORTED_MODULE_5__.serviceRoutePathRoot}/${id}`, this.context.containerRuntime).get();\n    }\n    /**\n     * Called every time the data store is initialized, before initializingFirstTime or\n     * initializingFromExisting is called.\n     */\n    async preInitialize() { }\n    /**\n     * Called the first time the data store is initialized (new creations with a new\n     * data store runtime)\n     *\n     * @param props - Optional props to be passed in on create\n     */\n    async initializingFirstTime(props) { }\n    /**\n     * Called every time but the first time the data store is initialized (creations\n     * with an existing data store runtime)\n     */\n    async initializingFromExisting() { }\n    /**\n     * Called every time the data store is initialized after create or existing.\n     */\n    async hasInitialized() { }\n    /**\n     * Called when the host container closes and disposes itself\n     */\n    dispose() {\n        super.dispose();\n    }\n}\n//# sourceMappingURL=pureDataObject.js.map\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventForwarder\": () => (/* binding */ EventForwarder)\n/* harmony export */ });\n/* harmony import */ var _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Base class used for forwarding events from a source EventEmitter.\n * This can be useful when all arbitrary listeners need to be removed,\n * but the primary source needs to stay intact.\n */\nclass EventForwarder extends _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(source) {\n        super();\n        this.isDisposed = false;\n        this.forwardingEvents = new Map();\n        if (source !== undefined) {\n            // NewListener event is raised whenever someone starts listening to this events, so\n            // we keep track of events being listened to, and start forwarding from the source\n            // event emitter per event listened to on this\n            const removeListenerHandler = (event) => this.unforwardEvent(source, event);\n            const newListenerHandler = (event) => this.forwardEvent(source, event);\n            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);\n            this.on(EventForwarder.newListenerEvent, newListenerHandler);\n        }\n    }\n    static isEmitterEvent(event) {\n        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;\n    }\n    get disposed() { return this.isDisposed; }\n    dispose() {\n        this.isDisposed = true;\n        for (const listenerRemovers of this.forwardingEvents.values()) {\n            for (const listenerRemover of listenerRemovers.values()) {\n                try {\n                    listenerRemover();\n                }\n                catch (_a) {\n                    // Should be fine because of removeAllListeners below\n                }\n            }\n        }\n        this.removeAllListeners();\n        this.forwardingEvents.clear();\n    }\n    forwardEvent(source, ...events) {\n        for (const event of events) {\n            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n                let sources = this.forwardingEvents.get(event);\n                if (sources === undefined) {\n                    sources = new Map();\n                    this.forwardingEvents.set(event, sources);\n                }\n                if (!sources.has(source)) {\n                    const listener = (...args) => this.emit(event, ...args);\n                    sources.set(source, () => source.off(event, listener));\n                    source.on(event, listener);\n                }\n            }\n        }\n    }\n    unforwardEvent(source, ...events) {\n        for (const event of events) {\n            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n                const sources = this.forwardingEvents.get(event);\n                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {\n                    if (this.listenerCount(event) === 0) {\n                        const listenerRemover = sources.get(source);\n                        if (listenerRemover !== undefined) {\n                            listenerRemover();\n                        }\n                        sources.delete(source);\n                        if (sources.size === 0) {\n                            this.forwardingEvents.delete(event);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nEventForwarder.newListenerEvent = \"newListener\";\nEventForwarder.removeListenerEvent = \"removeListener\";\n//# sourceMappingURL=eventForwarder.js.map\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FluidObjectHandle\": () => (/* binding */ FluidObjectHandle)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass FluidObjectHandle {\n    /**\n     * Creates a new FluidObjectHandle.\n     * @param value - The FluidObject object this handle is for.\n     * @param path - The path to this handle relative to the routeContext.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(value, path, routeContext) {\n        this.value = value;\n        this.path = path;\n        this.routeContext = routeContext;\n        this.pendingHandlesToMakeVisible = new Set();\n        // Tracks whether this handle is locally visible in the container.\n        this.locallyVisible = false;\n        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);\n    }\n    get IFluidHandle() { return this; }\n    get isAttached() {\n        return this.routeContext.isAttached;\n    }\n    /**\n     * Tells whether the object of this handle is visible in the container locally or globally.\n     */\n    get visible() {\n        /**\n         * If the object of this handle is attached, it is visible in the container. Ideally, checking local visibility\n         * should be enough for a handle. However, there are scenarios where the object becomes locally visible but the\n         * handle does not know this - This will happen is attachGraph is never called on the handle. Couple of examples\n         * where this can happen:\n         * 1. Handles to DDS other than the default handle won't know if the DDS becomes visible after the handle was\n         *    created.\n         * 2. Handles to root data stores will never know that it was visible because the handle will not be stores in\n         *    another DDS and so, attachGraph will never be called on it.\n         */\n        return this.isAttached || this.locallyVisible;\n    }\n    async get() {\n        return this.value;\n    }\n    attachGraph() {\n        if (this.visible) {\n            return;\n        }\n        this.locallyVisible = true;\n        this.pendingHandlesToMakeVisible.forEach((handle) => {\n            handle.attachGraph();\n        });\n        this.pendingHandlesToMakeVisible.clear();\n        this.routeContext.attachGraph();\n    }\n    bind(handle) {\n        // If this handle is visible, attach the graph of the incoming handle as well.\n        if (this.visible) {\n            handle.attachGraph();\n            return;\n        }\n        this.pendingHandlesToMakeVisible.add(handle);\n    }\n}\n//# sourceMappingURL=fluidHandle.js.map\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateHandleContextPath\": () => (/* binding */ generateHandleContextPath)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Generates the absolute path for a Fluid object given its path and its parent routeContext.\n * @param path - The path to the Fluid object relative to the route context.\n * @param routeContext - The route context that contains the Fluid object.\n * @returns The absolute path to the Fluid object from the root of the Container.\n */\nfunction generateHandleContextPath(path, routeContext) {\n    if (path === \"\") {\n        // The `path` is empty.\n        // If the routeContext does not exist, this is the root.\n        // If the routeContext exists, the absolute path is the same as that of the routeContext.\n        return routeContext === undefined ? \"\" : routeContext.absolutePath;\n    }\n    else {\n        // Remove beginning and trailing slashes, if any, from the path.\n        let normalizedPath = path.startsWith(\"/\") ? path.slice(1) : path;\n        normalizedPath = normalizedPath.endsWith(\"/\") ? normalizedPath.slice(0, -1) : normalizedPath;\n        // If the routeContext does not exist, path is the absolute path.\n        // If the routeContext exists, absolute path is routeContext's absolute path plus the path.\n        return routeContext === undefined\n            ? `/${normalizedPath}`\n            : `${routeContext.absolutePath === \"/\" ? \"\" : routeContext.absolutePath}/${normalizedPath}`;\n    }\n}\n//# sourceMappingURL=dataStoreHandleContextUtils.js.map\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultFluidObjectRequestHandler\": () => (/* binding */ defaultFluidObjectRequestHandler),\n/* harmony export */   \"defaultRouteRequestHandler\": () => (/* binding */ defaultRouteRequestHandler),\n/* harmony export */   \"mountableViewRequestHandler\": () => (/* binding */ mountableViewRequestHandler)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * A mountable view is only required if the view needs to be mounted across a bundle boundary.  Mounting across\n * bundle boundaries breaks some frameworks, so the mountable view is used to ensure the mounting is done within\n * the same bundle as the view.  For example, React hooks don't work if mounted across bundles since there will\n * be two React instances, breaking the Rules of Hooks.  When cross-bundle mounting isn't required, the mountable\n * view isn't necessary.\n *\n * When a request is received with a mountableView: true header, this request handler will reissue the request\n * without the header, and respond with a mountable view of the given class using the response.\n * @param MountableViewClass - The type of mountable view to use when responding\n */\nconst mountableViewRequestHandler = (MountableViewClass, handlers) => {\n    const nestedHandler = (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_0__.buildRuntimeRequestHandler)(...handlers);\n    return async (request, runtime) => {\n        var _a;\n        const mountableView = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.mountableView) === true;\n        let newRequest = request;\n        if (mountableView) {\n            // Reissue the request without the mountableView header.\n            // We'll repack whatever the response is if we can.\n            const headers = Object.assign({}, request.headers);\n            delete headers.mountableView;\n            newRequest = {\n                url: request.url,\n                headers,\n            };\n        }\n        const response = await nestedHandler(newRequest, runtime);\n        if (mountableView && response.status === 200 && MountableViewClass.canMount(response.value)) {\n            return {\n                status: 200,\n                mimeType: \"fluid/object\",\n                value: new MountableViewClass(response.value),\n            };\n        }\n        return response;\n    };\n};\n/**\n * Pipe through container request into internal request.\n * If request is empty and default url is provided, redirect request to such default url.\n * @param defaultRootId - optional default root data store ID to pass request in case request is empty.\n */\nconst defaultRouteRequestHandler = (defaultRootId) => {\n    return async (request, runtime) => {\n        const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.RequestParser.create(request);\n        if (parser.pathParts.length === 0) {\n            return runtime.IFluidHandleContext.resolveHandle({\n                url: `/${defaultRootId}${parser.query}`,\n                headers: request.headers\n            });\n        }\n        return undefined; // continue search\n    };\n};\n/**\n * Default request handler for a Fluid object that returns the object itself if:\n *  1. the request url is empty\n *  2. the request url is \"/\"\n *  3. the request url starts with \"/\" and is followed by a query param, such as /?key=value\n * Returns a 404 error for any other url.\n */\nfunction defaultFluidObjectRequestHandler(fluidObject, request) {\n    if (request.url === \"\" || request.url === \"/\" || request.url.startsWith(\"/?\")) {\n        return { mimeType: \"fluid/object\", status: 200, value: fluidObject };\n    }\n    else {\n        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(request);\n    }\n}\n//# sourceMappingURL=requestHandlers.js.map\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RuntimeRequestHandlerBuilder\": () => (/* binding */ RuntimeRequestHandlerBuilder),\n/* harmony export */   \"buildRuntimeRequestHandler\": () => (/* binding */ buildRuntimeRequestHandler)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n  * The RuntimeRequestHandlerBuilder creates a runtime request handler based on request handlers.\n  * The provided handlers sequentially applied until one is able to satisfy the request.\n  */\nclass RuntimeRequestHandlerBuilder {\n    constructor() {\n        this.handlers = [];\n    }\n    pushHandler(...handlers) {\n        if (handlers !== undefined) {\n            this.handlers.push(...handlers);\n        }\n    }\n    async handleRequest(request, runtime) {\n        const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RequestParser.create(request);\n        for (const handler of this.handlers) {\n            const response = await handler(parser, runtime);\n            if (response !== undefined) {\n                return response;\n            }\n        }\n        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.create404Response)(request);\n    }\n}\nfunction buildRuntimeRequestHandler(...handlers) {\n    const builder = new RuntimeRequestHandlerBuilder();\n    builder.pushHandler(...handlers);\n    return async (request, runtime) => builder.handleRequest(request, runtime);\n}\n//# sourceMappingURL=runtimeRequestHandlerBuilder.js.map\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RequestParser\": () => (/* binding */ RequestParser)\n/* harmony export */ });\n/**\n * The Request Parser takes an IRequest provides parsing and sub request creation\n */\nclass RequestParser {\n    constructor(request) {\n        this.request = request;\n        const queryStartIndex = this.request.url.indexOf(\"?\");\n        if (queryStartIndex >= 0) {\n            this.query = this.request.url.substring(queryStartIndex);\n        }\n        else {\n            this.query = \"\";\n        }\n    }\n    /**\n     * Splits the path of the url and decodes each path part\n     * @param url - the url to get path parts of\n     */\n    static getPathParts(url) {\n        const queryStartIndex = url.indexOf(\"?\");\n        return url\n            .substring(0, queryStartIndex < 0 ? url.length : queryStartIndex)\n            .split(\"/\")\n            .reduce((pv, cv) => {\n            if (cv !== undefined && cv.length > 0) {\n                pv.push(decodeURIComponent(cv));\n            }\n            return pv;\n        }, []);\n    }\n    static create(request) {\n        // Perf optimizations.\n        if (request instanceof RequestParser) {\n            return request;\n        }\n        return new RequestParser(request);\n    }\n    get url() {\n        return this.request.url;\n    }\n    get headers() {\n        return this.request.headers;\n    }\n    /**\n     * Returns the decoded path parts of the request's url\n     */\n    get pathParts() {\n        if (this.requestPathParts === undefined) {\n            this.requestPathParts = RequestParser.getPathParts(this.url);\n        }\n        return this.requestPathParts;\n    }\n    /**\n     * Returns true if it's a terminating path, i.e. no more elements after `elements` entries and empty query.\n     * @param elements - number of elements in path\n     */\n    isLeaf(elements) {\n        return this.query === \"\" && this.pathParts.length === elements;\n    }\n    /**\n     * Creates a sub request starting at a specific path part of this request's url\n     * The sub request url always has a leading slash, and always include query params if original url has any\n     * e.g. original url is /a/b/?queryParams, createSubRequest(0) is /a/b/?queryParams\n     * createSubRequest(1) is /b/?queryParams\n     * createSubRequest(2) is /?queryParams\n     * createSubRequest(n) where n is bigger than parts length, e.g. 2, or n is less than 0 will throw an exception\n     *\n     * note: query params are not counted towards path parts.\n     *\n     * @param startingPathIndex - The index of the first path part of the sub request\n     */\n    createSubRequest(startingPathIndex) {\n        const pathLen = this.pathParts.length;\n        if (startingPathIndex < 0 || startingPathIndex > pathLen) {\n            throw new Error(\"incorrect sub-request\");\n        }\n        if (startingPathIndex === pathLen && this.url.includes(\"?\")) {\n            return {\n                url: `/${this.query}`,\n                headers: this.headers,\n            };\n        }\n        const path = `/${this.pathParts.slice(startingPathIndex).join(\"/\")}`;\n        return {\n            url: this.query === \"\" ? path : `${path}/${this.query}`,\n            headers: this.headers,\n        };\n    }\n}\n//# sourceMappingURL=requestParser.js.map\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create404Response\": () => (/* binding */ create404Response),\n/* harmony export */   \"createDataStoreFactory\": () => (/* binding */ createDataStoreFactory),\n/* harmony export */   \"createResponseError\": () => (/* binding */ createResponseError),\n/* harmony export */   \"exceptionToResponse\": () => (/* binding */ exceptionToResponse),\n/* harmony export */   \"requestFluidObject\": () => (/* binding */ requestFluidObject),\n/* harmony export */   \"responseToException\": () => (/* binding */ responseToException)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nfunction exceptionToResponse(err) {\n    const status = 500;\n    if (err !== null && typeof err === \"object\" && err.errorFromRequestFluidObject === true) {\n        const responseErr = err;\n        return {\n            mimeType: \"text/plain\",\n            status: responseErr.code,\n            value: responseErr.message,\n            get stack() { return responseErr.stack; },\n        };\n    }\n    // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it\n    const errWithStack = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.generateErrorWithStack)();\n    return {\n        mimeType: \"text/plain\",\n        status,\n        value: `${err}`,\n        get stack() { var _a; return (_a = (err === null || err === void 0 ? void 0 : err.stack)) !== null && _a !== void 0 ? _a : errWithStack.stack; },\n    };\n}\nfunction responseToException(response, request) {\n    const message = response.value;\n    const errWithStack = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.generateErrorWithStack)();\n    const responseErr = {\n        errorFromRequestFluidObject: true,\n        message,\n        name: \"Error\",\n        code: response.status,\n        get stack() { var _a; return (_a = response.stack) !== null && _a !== void 0 ? _a : errWithStack.stack; },\n    };\n    return responseErr;\n}\nasync function requestFluidObject(router, url) {\n    const request = typeof url === \"string\" ? { url } : url;\n    const response = await router.request(request);\n    if (response.status !== 200 || response.mimeType !== \"fluid/object\") {\n        throw responseToException(response, request);\n    }\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(response.value, 0x19a /* \"Invalid response value for Fluid object request\" */);\n    return response.value;\n}\nconst create404Response = (request) => createResponseError(404, \"not found\", request);\nfunction createResponseError(status, value, request) {\n    var _a;\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(status !== 200, 0x19b /* \"Cannot not create response error on 200 status\" */);\n    // Omit query string which could contain personal data (aka \"PII\")\n    const urlNoQuery = (_a = request.url) === null || _a === void 0 ? void 0 : _a.split(\"?\")[0];\n    // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it\n    const errWithStack = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.generateErrorWithStack)();\n    return {\n        mimeType: \"text/plain\",\n        status,\n        value: urlNoQuery === undefined ? value : `${value}: ${urlNoQuery}`,\n        get stack() { return errWithStack.stack; },\n    };\n}\nfunction createDataStoreFactory(type, factory) {\n    return {\n        type,\n        get IFluidDataStoreFactory() { return this; },\n        get IFluidDataStoreRegistry() { return this; },\n        instantiateDataStore: async (context, existing) => (await factory).instantiateDataStore(context, existing),\n        get: async (name) => { var _a; return (_a = (await factory).IFluidDataStoreRegistry) === null || _a === void 0 ? void 0 : _a.get(name); },\n    };\n}\n//# sourceMappingURL=dataStoreHelpers.js.map\n\n/***/ }),\n/* 26 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoggingError\": () => (/* binding */ LoggingError),\n/* harmony export */   \"extractLogSafeErrorProperties\": () => (/* binding */ extractLogSafeErrorProperties),\n/* harmony export */   \"generateErrorWithStack\": () => (/* binding */ generateErrorWithStack),\n/* harmony export */   \"generateStack\": () => (/* binding */ generateStack),\n/* harmony export */   \"getCircularReplacer\": () => (/* binding */ getCircularReplacer),\n/* harmony export */   \"isExternalError\": () => (/* binding */ isExternalError),\n/* harmony export */   \"isILoggingError\": () => (/* binding */ isILoggingError),\n/* harmony export */   \"isTaggedTelemetryPropertyValue\": () => (/* binding */ isTaggedTelemetryPropertyValue),\n/* harmony export */   \"normalizeError\": () => (/* binding */ normalizeError),\n/* harmony export */   \"wrapError\": () => (/* binding */ wrapError),\n/* harmony export */   \"wrapErrorAndLog\": () => (/* binding */ wrapErrorAndLog)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);\n/* harmony import */ var _fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/** @returns true if value is an object but neither null nor an array */\nconst isRegularObject = (value) => {\n    return value !== null && !Array.isArray(value) && typeof value === \"object\";\n};\n/** Inspect the given error for common \"safe\" props and return them */\nfunction extractLogSafeErrorProperties(error, sanitizeStack) {\n    const removeMessageFromStack = (stack, errorName) => {\n        if (!sanitizeStack) {\n            return stack;\n        }\n        const stackFrames = stack.split(\"\\n\");\n        stackFrames.shift(); // Remove \"[ErrorName]: [ErrorMessage]\"\n        if (errorName !== undefined) {\n            stackFrames.unshift(errorName); // Add \"[ErrorName]\"\n        }\n        return stackFrames.join(\"\\n\");\n    };\n    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\")\n        ? error.message\n        : String(error);\n    const safeProps = {\n        message,\n    };\n    if (isRegularObject(error)) {\n        const { errorType, stack, name } = error;\n        if (typeof errorType === \"string\") {\n            safeProps.errorType = errorType;\n        }\n        if (typeof stack === \"string\") {\n            const errorName = (typeof name === \"string\") ? name : undefined;\n            safeProps.stack = removeMessageFromStack(stack, errorName);\n        }\n    }\n    return safeProps;\n}\n/** type guard for ILoggingError interface */\nconst isILoggingError = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === \"function\";\n/** Copy props from source onto target, but do not overwrite an existing prop that matches */\nfunction copyProps(target, source) {\n    for (const key of Object.keys(source)) {\n        if (target[key] === undefined) {\n            target[key] = source[key];\n        }\n    }\n}\n/** For backwards compatibility with pre-errorInstanceId valid errors */\nfunction patchLegacyError(legacyError) {\n    const patchMe = legacyError;\n    if (patchMe.errorInstanceId === undefined) {\n        patchMe.errorInstanceId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    }\n}\n/**\n * Normalize the given error yielding a valid Fluid Error\n * @returns A valid Fluid Error with any provided annotations applied\n * @param error - The error to normalize\n * @param annotations - Annotations to apply to the normalized error\n */\nfunction normalizeError(error, annotations = {}) {\n    var _a;\n    // Back-compat, while IFluidErrorBase is rolled out\n    if ((0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.isValidLegacyError)(error)) {\n        patchLegacyError(error);\n    }\n    if ((0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.isFluidError)(error)) {\n        // We can simply add the telemetry props to the error and return it\n        error.addTelemetryProperties((_a = annotations.props) !== null && _a !== void 0 ? _a : {});\n        return error;\n    }\n    // We have to construct a new Fluid Error, copying safe properties over\n    const { message, stack } = extractLogSafeErrorProperties(error, false /* sanitizeStack */);\n    const fluidError = new NormalizedExternalError({\n        message,\n        stack,\n    });\n    // We need to preserve these properties which are used in a non-typesafe way throughout driver code (see #8743)\n    // Anywhere they are set should be on a valid Fluid Error that would have been returned above,\n    // but we can't prove it with the types, so adding this defensive measure.\n    if (typeof error === \"object\" && error !== null) {\n        const { canRetry, retryAfterSeconds } = error;\n        Object.assign(normalizeError, { canRetry, retryAfterSeconds });\n    }\n    if (typeof (error) !== \"object\") {\n        // This is only interesting for non-objects\n        fluidError.addTelemetryProperties({ typeofError: typeof (error) });\n    }\n    const originalErrorTelemetryProps = isILoggingError(error) ? error.getTelemetryProperties() : {};\n    fluidError.addTelemetryProperties(Object.assign(Object.assign(Object.assign({}, originalErrorTelemetryProps), annotations.props), { untrustedOrigin: 1 }));\n    return fluidError;\n}\nlet stackPopulatedOnCreation;\n/**\n * The purpose of this function is to provide ability to capture stack context quickly.\n * Accessing new Error().stack is slow, and the slowest part is accessing stack property itself.\n * There are scenarios where we generate error with stack, but error is handled in most cases and\n * stack property is not accessed.\n * For such cases it's better to not read stack property right away, but rather delay it until / if it's needed\n * Some browsers will populate stack right away, others require throwing Error, so we do auto-detection on the fly.\n * @returns Error object that has stack populated.\n */\nfunction generateErrorWithStack() {\n    const err = new Error(\"<<generated stack>>\");\n    if (stackPopulatedOnCreation === undefined) {\n        stackPopulatedOnCreation = (err.stack !== undefined);\n    }\n    if (stackPopulatedOnCreation) {\n        return err;\n    }\n    try {\n        throw err;\n    }\n    catch (e) {\n        return e;\n    }\n}\nfunction generateStack() {\n    return generateErrorWithStack().stack;\n}\n/**\n * Create a new error using newErrorFn, wrapping and caused by the given unknown error.\n * Copies the inner error's stack, errorInstanceId and telemetry props over to the new error if present\n * @param innerError - An error from untrusted/unknown origins\n * @param newErrorFn - callback that will create a new error given the original error's message\n * @returns A new error object \"wrapping\" the given error\n */\nfunction wrapError(innerError, newErrorFn) {\n    const { message, stack, } = extractLogSafeErrorProperties(innerError, false /* sanitizeStack */);\n    const newError = newErrorFn(message);\n    if (stack !== undefined) {\n        overwriteStack(newError, stack);\n    }\n    // Mark external errors with untrustedOrigin flag\n    if (isExternalError(innerError)) {\n        newError.addTelemetryProperties({ untrustedOrigin: 1 });\n    }\n    // Reuse errorInstanceId\n    if ((0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.hasErrorInstanceId)(innerError)) {\n        newError.overwriteErrorInstanceId(innerError.errorInstanceId);\n        // For \"back-compat\" in the logs\n        newError.addTelemetryProperties({ innerErrorInstanceId: innerError.errorInstanceId });\n    }\n    // Lastly, copy over all other telemetry properties. Note these will not overwrite existing properties\n    // This will include the untrustedOrigin property if the inner error itself was created from an external error\n    if (isILoggingError(innerError)) {\n        newError.addTelemetryProperties(innerError.getTelemetryProperties());\n    }\n    return newError;\n}\n/** The same as wrapError, but also logs the innerError, including the wrapping error's instance id */\nfunction wrapErrorAndLog(innerError, newErrorFn, logger) {\n    const newError = wrapError(innerError, newErrorFn);\n    // This will match innerError.errorInstanceId if present (see wrapError)\n    const errorInstanceId = newError.errorInstanceId;\n    // For \"back-compat\" in the logs\n    const wrappedByErrorInstanceId = errorInstanceId;\n    logger.sendTelemetryEvent({\n        eventName: \"WrapError\",\n        errorInstanceId,\n        wrappedByErrorInstanceId,\n    }, innerError);\n    return newError;\n}\nfunction overwriteStack(error, stack) {\n    // supposedly setting stack on an Error can throw.\n    try {\n        Object.assign(error, { stack });\n    }\n    catch (errorSettingStack) {\n        error.addTelemetryProperties({ stack2: stack });\n    }\n}\n/**\n * True for any error object that is an (optionally normalized) external error\n * False for any error we created and raised within the FF codebase, or wrapped in a well-known error type\n */\nfunction isExternalError(e) {\n    return !(0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.isValidLegacyError)(e) ||\n        (e.getTelemetryProperties().untrustedOrigin === 1 &&\n            e.errorType === NormalizedExternalError.normalizedErrorType);\n}\n/**\n * Type guard to identify if a particular value (loosely) appears to be a tagged telemetry property\n */\nfunction isTaggedTelemetryPropertyValue(x) {\n    return (typeof (x === null || x === void 0 ? void 0 : x.value) !== \"object\" && typeof (x === null || x === void 0 ? void 0 : x.tag) === \"string\");\n}\n/**\n * Walk an object's enumerable properties to find those fit for telemetry.\n */\nfunction getValidTelemetryProps(obj, keysToOmit) {\n    const props = {};\n    for (const key of Object.keys(obj)) {\n        if (keysToOmit.has(key)) {\n            continue;\n        }\n        const val = obj[key];\n        switch (typeof val) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"undefined\":\n                props[key] = val;\n                break;\n            default: {\n                if (isTaggedTelemetryPropertyValue(val)) {\n                    props[key] = val;\n                }\n                else {\n                    // We don't support logging arbitrary objects\n                    props[key] = \"REDACTED (arbitrary object)\";\n                }\n                break;\n            }\n        }\n    }\n    return props;\n}\n/**\n * Borrowed from\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value#examples}\n * Avoids runtime errors with circular references.\n * Not ideal, as will cut values that are not necessarily circular references.\n * Could be improved by implementing Node's util.inspect() for browser (minus all the coloring code)\n*/\nconst getCircularReplacer = () => {\n    const seen = new WeakSet();\n    return (key, value) => {\n        if (typeof value === \"object\" && value !== null) {\n            if (seen.has(value)) {\n                return \"<removed/circular>\";\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n};\n/**\n * Base class for \"trusted\" errors we create, whose properties can generally be logged to telemetry safely.\n * All properties set on the object, or passed in (via the constructor or addTelemetryProperties),\n * will be logged in accordance with their tag, if present.\n *\n * PLEASE take care to avoid setting sensitive data on this object without proper tagging!\n */\nclass LoggingError extends Error {\n    /**\n     * Create a new LoggingError\n     * @param message - Error message to use for Error base class\n     * @param props - telemetry props to include on the error for when it's logged\n     * @param omitPropsFromLogging - properties by name to omit from telemetry props\n     */\n    constructor(message, props, omitPropsFromLogging = new Set()) {\n        super(message);\n        this.omitPropsFromLogging = omitPropsFromLogging;\n        this._errorInstanceId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        /** Back-compat to appease isFluidError typeguard in old code that may handle this error */\n        // @ts-expect-error - This field shouldn't be referenced in the current version, but needs to exist at runtime.\n        this.fluidErrorCode = \"-\";\n        // Don't log this list itself, or the private _errorInstanceId\n        omitPropsFromLogging.add(\"omitPropsFromLogging\");\n        omitPropsFromLogging.add(\"_errorInstanceId\");\n        if (props) {\n            this.addTelemetryProperties(props);\n        }\n    }\n    get errorInstanceId() { return this._errorInstanceId; }\n    overwriteErrorInstanceId(id) { this._errorInstanceId = id; }\n    /**\n     * Add additional properties to be logged\n     */\n    addTelemetryProperties(props) {\n        copyProps(this, props);\n    }\n    /**\n     * Get all properties fit to be logged to telemetry for this error\n     */\n    getTelemetryProperties() {\n        const taggableProps = getValidTelemetryProps(this, this.omitPropsFromLogging);\n        // Include non-enumerable props that are not returned by getValidTelemetryProps\n        return Object.assign(Object.assign({}, taggableProps), { stack: this.stack, message: this.message, errorInstanceId: this._errorInstanceId });\n    }\n}\n/** The Error class used when normalizing an external error */\nclass NormalizedExternalError extends LoggingError {\n    constructor(errorProps) {\n        super(errorProps.message);\n        this.errorType = NormalizedExternalError.normalizedErrorType;\n        if (errorProps.stack !== undefined) {\n            overwriteStack(this, errorProps.stack);\n        }\n    }\n}\n// errorType \"genericError\" is used as a default value throughout the code.\n// Note that this matches ContainerErrorType/DriverErrorType's genericError\nNormalizedExternalError.normalizedErrorType = \"genericError\";\n//# sourceMappingURL=errorLogging.js.map\n\n/***/ }),\n/* 27 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n/***/ }),\n/* 28 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n/***/ }),\n/* 29 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n/***/ }),\n/* 30 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n/***/ }),\n/* 31 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n/***/ }),\n/* 32 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasErrorInstanceId\": () => (/* binding */ hasErrorInstanceId),\n/* harmony export */   \"isFluidError\": () => (/* binding */ isFluidError),\n/* harmony export */   \"isValidLegacyError\": () => (/* binding */ isValidLegacyError)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst hasTelemetryPropFunctions = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === \"function\" &&\n    typeof (x === null || x === void 0 ? void 0 : x.addTelemetryProperties) === \"function\";\nconst hasErrorInstanceId = (x) => typeof (x === null || x === void 0 ? void 0 : x.errorInstanceId) === \"string\";\n/** type guard for IFluidErrorBase interface */\nfunction isFluidError(e) {\n    return typeof (e === null || e === void 0 ? void 0 : e.errorType) === \"string\" &&\n        typeof (e === null || e === void 0 ? void 0 : e.message) === \"string\" &&\n        hasErrorInstanceId(e) &&\n        hasTelemetryPropFunctions(e);\n}\n/** type guard for old standard of valid/known errors */\nfunction isValidLegacyError(e) {\n    return typeof (e === null || e === void 0 ? void 0 : e.errorType) === \"string\" &&\n        typeof (e === null || e === void 0 ? void 0 : e.message) === \"string\" &&\n        hasTelemetryPropFunctions(e);\n}\n//# sourceMappingURL=fluidErrorBase.js.map\n\n/***/ }),\n/* 33 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 34 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createFluidObjectResponse\": () => (/* binding */ createFluidObjectResponse),\n/* harmony export */   \"handleFromLegacyUri\": () => (/* binding */ handleFromLegacyUri),\n/* harmony export */   \"rootDataStoreRequestHandler\": () => (/* binding */ rootDataStoreRequestHandler)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * A request handler to expose access to all root data stores in the container by id.\n * @param request - the request for the root data store.  The first path part must be the data store's ID.\n * @param runtime - the container runtime\n * @returns the result of the request\n */\nconst rootDataStoreRequestHandler = async (request, runtime) => {\n    var _a;\n    const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RequestParser.create(request);\n    const id = requestParser.pathParts[0];\n    const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.wait) === \"boolean\" ? request.headers.wait : undefined;\n    let rootDataStore;\n    try {\n        // getRootDataStore currently throws if the data store is not found\n        rootDataStore = await runtime.getRootDataStore(id, wait);\n    }\n    catch (error) {\n        return undefined; // continue search\n    }\n    try {\n        return rootDataStore.IFluidRouter.request(requestParser.createSubRequest(1));\n    }\n    catch (error) {\n        return { status: 500, mimeType: \"fluid/object\", value: error };\n    }\n};\nconst createFluidObjectResponse = (fluidObject) => {\n    return { status: 200, mimeType: \"fluid/object\", value: fluidObject };\n};\nclass LegacyUriHandle {\n    constructor(absolutePath, runtime) {\n        this.absolutePath = absolutePath;\n        this.runtime = runtime;\n        this.isAttached = true;\n    }\n    get IFluidHandle() { return this; }\n    attachGraph() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(false, 0x0ca /* \"Trying to use legacy graph attach!\" */);\n    }\n    async get() {\n        const response = await this.runtime.IFluidHandleContext.resolveHandle({ url: this.absolutePath });\n        if (response.status === 200 && response.mimeType === \"fluid/object\") {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return response.value;\n        }\n        throw new Error(`Failed to resolve container path ${this.absolutePath}`);\n    }\n    bind(handle) {\n        throw new Error(\"Cannot bind to LegacyUriHandle\");\n    }\n}\nfunction handleFromLegacyUri(uri, runtime) {\n    return new LegacyUriHandle(uri, runtime);\n}\n//# sourceMappingURL=requestHandlers.js.map\n\n/***/ }),\n/* 35 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 36 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseContainerService\": () => (/* binding */ BaseContainerService),\n/* harmony export */   \"generateContainerServicesRequestHandler\": () => (/* binding */ generateContainerServicesRequestHandler),\n/* harmony export */   \"serviceRoutePathRoot\": () => (/* binding */ serviceRoutePathRoot)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// TODO: should this just be \"s\"?\nconst serviceRoutePathRoot = \"_services\";\n/**\n * This class is a simple starter class for building a Container Service. It simply provides routing\n */\nclass BaseContainerService {\n    constructor(runtime) {\n        this.runtime = runtime;\n    }\n    get IFluidRouter() { return this; }\n    async request(request) {\n        return {\n            status: 200,\n            mimeType: \"fluid/object\",\n            value: this,\n        };\n    }\n}\n/**\n * ContainerService Factory that will only create one instance of the service for the Container.\n */\nclass SingletonContainerServiceFactory {\n    constructor(serviceFn) {\n        this.serviceFn = serviceFn;\n    }\n    async getService(runtime) {\n        if (!this.service) {\n            this.service = this.serviceFn(runtime);\n        }\n        return this.service;\n    }\n}\n/**\n * Given a collection of IContainerServices will produce a RequestHandler for them all\n * @param serviceRegistry - Collection of Container Services\n */\nconst generateContainerServicesRequestHandler = (serviceRegistry) => {\n    const factories = new Map();\n    new Map(serviceRegistry).forEach((fn, id) => {\n        factories.set(id, new SingletonContainerServiceFactory(fn));\n    });\n    return async (request, runtime) => {\n        if (request.pathParts[0] !== serviceRoutePathRoot) {\n            // If the request is not for a service we return undefined so the next handler can use it\n            return undefined;\n        }\n        if (request.pathParts.length < 2) {\n            // If there is not service to route to then return a failure\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.createResponseError)(400, \"request did not specify a service to route to\", request);\n        }\n        const factory = factories.get(request.pathParts[1]);\n        if (!factory) {\n            // If we can't find a registry entry then return\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.create404Response)(request);\n        }\n        const service = await factory.getService(runtime);\n        const router = service.IFluidRouter;\n        const subRequest = request.createSubRequest(2);\n        if (router) {\n            return router.request(subRequest);\n        }\n        if (!request.isLeaf(2)) {\n            // If there is not terminating route but a sub-route was requested then we will fail.\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.createResponseError)(400, \"request sub-url for service that doesn't support routing\", request);\n        }\n        // Otherwise we will just return the service\n        return {\n            status: 200,\n            mimeType: \"fluid/object\",\n            value: service,\n        };\n    };\n};\n//# sourceMappingURL=containerServices.js.map\n\n/***/ }),\n/* 37 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirectoryFactory\": () => (/* binding */ DirectoryFactory),\n/* harmony export */   \"SharedDirectory\": () => (/* binding */ SharedDirectory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(139);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(141);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(140);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(137);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(91);\n/* harmony import */ var path_browserify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);\n/* harmony import */ var path_browserify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_browserify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(136);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a, _b;\n\n\n\n\n\n\n\n\n\n// We use path-browserify since this code can run safely on the server or the browser.\n// We standardize on using posix slashes everywhere.\nconst posix = path_browserify__WEBPACK_IMPORTED_MODULE_0__.posix;\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the directory.\n * @sealed\n */\nclass DirectoryFactory {\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n     */\n    get type() {\n        return DirectoryFactory.Type;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n     */\n    get attributes() {\n        return DirectoryFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const directory = new SharedDirectory(id, runtime, attributes);\n        await directory.load(services);\n        return directory;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n     */\n    create(runtime, id) {\n        const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);\n        directory.initializeLocal();\n        return directory;\n    }\n}\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n */\nDirectoryFactory.Type = \"https://graph.microsoft.com/types/directory\";\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n */\nDirectoryFactory.Attributes = {\n    type: DirectoryFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion,\n};\n/**\n * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.\n * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.\n * SubDirectories can be retrieved for use as working directories.\n *\n * @example\n * ```typescript\n * mySharedDirectory.createSubDirectory(\"a\").createSubDirectory(\"b\").createSubDirectory(\"c\").set(\"foo\", val1);\n * const mySubDir = mySharedDirectory.getWorkingDirectory(\"/a/b/c\");\n * mySubDir.get(\"foo\"); // returns val1\n * ```\n *\n * @sealed\n */\nclass SharedDirectory extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.SharedObject {\n    /**\n     * Constructs a new shared directory. If the object is non-local an id and service interfaces will\n     * be provided.\n     * @param id - String identifier for the SharedDirectory\n     * @param runtime - Data store runtime\n     * @param type - Type identifier\n     */\n    constructor(id, runtime, attributes) {\n        super(id, runtime, attributes, \"fluid_directory_\");\n        /**\n         * String representation for the class.\n         */\n        this[_a] = \"SharedDirectory\";\n        /**\n         * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.\n         */\n        this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);\n        /**\n         * Mapping of op types to message handlers.\n         */\n        this.messageHandlers = new Map();\n        this.localValueMaker = new _localValues__WEBPACK_IMPORTED_MODULE_3__.LocalValueMaker(this.serializer);\n        this.setMessageHandlers();\n        // Mirror the containedValueChanged op on the SharedDirectory\n        this.root.on(\"containedValueChanged\", (changed, local) => {\n            this.emit(\"containedValueChanged\", changed, local, this);\n        });\n        this.root.on(\"subDirectoryCreated\", (relativePath, local) => {\n            this.emit(\"subDirectoryCreated\", relativePath, local, this);\n        });\n        this.root.on(\"subDirectoryDeleted\", (relativePath, local) => {\n            this.emit(\"subDirectoryDeleted\", relativePath, local, this);\n        });\n    }\n    /**\n     * Create a new shared directory\n     *\n     * @param runtime - Data store runtime the new shared directory belongs to\n     * @param id - Optional name of the shared directory\n     * @returns Newly create shared directory (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, DirectoryFactory.Type);\n    }\n    /**\n     * Get a factory for SharedDirectory to register with the data store.\n     *\n     * @returns A factory that creates and load SharedDirectory\n     */\n    static getFactory() {\n        return new DirectoryFactory();\n    }\n    /**\n     * {@inheritDoc IDirectory.absolutePath}\n     */\n    get absolutePath() {\n        return this.root.absolutePath;\n    }\n    /**\n     * {@inheritDoc IDirectory.get}\n     */\n    get(key) {\n        return this.root.get(key);\n    }\n    /**\n     * {@inheritDoc IDirectory.set}\n     */\n    set(key, value) {\n        this.root.set(key, value);\n        return this;\n    }\n    dispose(error) {\n        this.root.dispose(error);\n    }\n    get disposed() {\n        return this.root.disposed;\n    }\n    /**\n     * Deletes the given key from within this IDirectory.\n     * @param key - The key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        return this.root.delete(key);\n    }\n    /**\n     * Deletes all keys from within this IDirectory.\n     */\n    clear() {\n        this.root.clear();\n    }\n    /**\n     * Checks whether the given key exists in this IDirectory.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this.root.has(key);\n    }\n    /**\n     * The number of entries under this IDirectory.\n     */\n    get size() {\n        return this.root.size;\n    }\n    /**\n     * Issue a callback on each entry under this IDirectory.\n     * @param callback - Callback to issue\n     */\n    forEach(callback) {\n        this.root.forEach(callback);\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.root[Symbol.iterator]();\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    entries() {\n        return this.root.entries();\n    }\n    /**\n     * {@inheritDoc IDirectory.countSubDirectory}\n     */\n    countSubDirectory() {\n        return this.root.countSubDirectory();\n    }\n    /**\n     * Get an iterator over the keys under this IDirectory.\n     * @returns The iterator\n     */\n    keys() {\n        return this.root.keys();\n    }\n    /**\n     * Get an iterator over the values under this IDirectory.\n     * @returns The iterator\n     */\n    values() {\n        return this.root.values();\n    }\n    /**\n     * {@inheritDoc IDirectory.createSubDirectory}\n     */\n    createSubDirectory(subdirName) {\n        return this.root.createSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.getSubDirectory}\n     */\n    getSubDirectory(subdirName) {\n        return this.root.getSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.hasSubDirectory}\n     */\n    hasSubDirectory(subdirName) {\n        return this.root.hasSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.deleteSubDirectory}\n     */\n    deleteSubDirectory(subdirName) {\n        return this.root.deleteSubDirectory(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.subdirectories}\n     */\n    subdirectories() {\n        return this.root.subdirectories();\n    }\n    /**\n     * {@inheritDoc IDirectory.getWorkingDirectory}\n     */\n    getWorkingDirectory(relativePath) {\n        const absolutePath = this.makeAbsolute(relativePath);\n        if (absolutePath === posix.sep) {\n            return this.root;\n        }\n        let currentSubDir = this.root;\n        const subdirs = absolutePath.substr(1).split(posix.sep);\n        for (const subdir of subdirs) {\n            currentSubDir = currentSubDir.getSubDirectory(subdir);\n            if (!currentSubDir) {\n                return undefined;\n            }\n        }\n        return currentSubDir;\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}\n     * @internal\n     */\n    summarizeCore(serializer, telemetryContext) {\n        return this.serializeDirectory(this.root, serializer);\n    }\n    /**\n     * Submits an operation\n     * @param op - Op to submit\n     * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track\n     * this op while it has not been ack'd. This will be sent when we receive this op back from the server.\n     * @internal\n     */\n    submitDirectoryMessage(op, localOpMetadata) {\n        this.submitLocalMessage(op, localOpMetadata);\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n     * @internal\n     */\n    onDisconnect() { }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n     * @internal\n     */\n    reSubmitCore(content, localOpMetadata) {\n        const message = content;\n        const handler = this.messageHandlers.get(message.type);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(handler !== undefined, 0x00d /* Missing message handler for message type */);\n        handler.submit(message, localOpMetadata);\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     * @internal\n     */\n    async loadCore(storage) {\n        const data = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.readAndParse)(storage, snapshotFileName);\n        const newFormat = data;\n        if (Array.isArray(newFormat.blobs)) {\n            // New storage format\n            this.populate(newFormat.content);\n            await Promise.all(newFormat.blobs.map(async (value) => {\n                const dataExtra = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.readAndParse)(storage, value);\n                this.populate(dataExtra);\n            }));\n        }\n        else {\n            // Old storage format\n            this.populate(data);\n        }\n    }\n    /**\n     * Populate the directory with the given directory data.\n     * @param data - A JSON string containing serialized directory data\n     * @internal\n     */\n    populate(data) {\n        const stack = [];\n        stack.push([this.root, data]);\n        while (stack.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const [currentSubDir, currentSubDirObject] = stack.pop();\n            if (currentSubDirObject.subdirectories) {\n                for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {\n                    let newSubDir = currentSubDir.getSubDirectory(subdirName);\n                    if (!newSubDir) {\n                        newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));\n                        currentSubDir.populateSubDirectory(subdirName, newSubDir);\n                    }\n                    stack.push([newSubDir, subdirObject]);\n                }\n            }\n            if (currentSubDirObject.storage) {\n                for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {\n                    const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);\n                    currentSubDir.populateStorage(key, localValue);\n                }\n            }\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n     * @internal\n     */\n    processCore(message, local, localOpMetadata) {\n        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.Operation) {\n            const op = message.contents;\n            const handler = this.messageHandlers.get(op.type);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(handler !== undefined, 0x00e /* Missing message handler for message type */);\n            handler.process(op, local, localOpMetadata);\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}\n     * @internal\n    */\n    rollback(content, localOpMetadata) {\n        const op = content;\n        const subdir = this.getWorkingDirectory(op.path);\n        if (subdir) {\n            subdir.rollback(op, localOpMetadata);\n        }\n    }\n    /**\n     * Converts the given relative path to absolute against the root.\n     * @param relativePath - The path to convert\n     */\n    makeAbsolute(relativePath) {\n        return posix.resolve(posix.sep, relativePath);\n    }\n    /**\n     * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)\n     * will have the information we need to create a real object, but will not be the real object yet.  For example,\n     * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job\n     * is to convert that information into a real object for local usage.\n     * @param key - Key of element being converted\n     * @param absolutePath - Path of element being converted\n     * @param serializable - The remote information that we can convert into a real object\n     * @returns The local value that was produced\n     */\n    makeLocal(key, absolutePath, serializable) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType.Plain] || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType.Shared], 0x1e4 /* \"Unexpected serializable type\" */);\n        return this.localValueMaker.fromSerializable(serializable);\n    }\n    /**\n     * Set the message handlers for the directory.\n     */\n    setMessageHandlers() {\n        this.messageHandlers.set(\"clear\", {\n            process: (op, local, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.processClearMessage(op, local, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.resubmitClearMessage(op, localOpMetadata);\n                }\n            },\n        });\n        this.messageHandlers.set(\"delete\", {\n            process: (op, local, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.processDeleteMessage(op, local, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.resubmitKeyMessage(op, localOpMetadata);\n                }\n            },\n        });\n        this.messageHandlers.set(\"set\", {\n            process: (op, local, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);\n                    subdir.processSetMessage(op, context, local, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const subdir = this.getWorkingDirectory(op.path);\n                if (subdir) {\n                    subdir.resubmitKeyMessage(op, localOpMetadata);\n                }\n            },\n        });\n        this.messageHandlers.set(\"createSubDirectory\", {\n            process: (op, local, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    parentSubdir.processCreateSubDirectoryMessage(op, local, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);\n                }\n            },\n        });\n        this.messageHandlers.set(\"deleteSubDirectory\", {\n            process: (op, local, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    parentSubdir.processDeleteSubDirectoryMessage(op, local, localOpMetadata);\n                }\n            },\n            submit: (op, localOpMetadata) => {\n                const parentSubdir = this.getWorkingDirectory(op.path);\n                if (parentSubdir) {\n                    // We don't reuse the metadata but send a new one on each submit.\n                    parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);\n                }\n            },\n        });\n    }\n    /**\n     * @internal\n     */\n    applyStashedOp() {\n        throw new Error(\"not implemented\");\n    }\n    serializeDirectory(root, serializer, telemetryContext) {\n        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.SummaryTreeBuilder();\n        let counter = 0;\n        const blobs = [];\n        const stack = [];\n        const content = {};\n        stack.push([root, content]);\n        while (stack.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const [currentSubDir, currentSubDirObject] = stack.pop();\n            for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {\n                if (!currentSubDirObject.storage) {\n                    currentSubDirObject.storage = {};\n                }\n                const result = {\n                    type: value.type,\n                    // eslint-disable-next-line @typescript-eslint/ban-types\n                    value: value.value && JSON.parse(value.value),\n                };\n                if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n                    const extraContent = {};\n                    let largeContent = extraContent;\n                    if (currentSubDir.absolutePath !== posix.sep) {\n                        for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {\n                            const subDataObject = {};\n                            largeContent.subdirectories = { [dir]: subDataObject };\n                            largeContent = subDataObject;\n                        }\n                    }\n                    largeContent.storage = { [key]: result };\n                    const blobName = `blob${counter}`;\n                    counter++;\n                    blobs.push(blobName);\n                    builder.addBlob(blobName, JSON.stringify(extraContent));\n                }\n                else {\n                    currentSubDirObject.storage[key] = result;\n                }\n            }\n            for (const [subdirName, subdir] of currentSubDir.subdirectories()) {\n                if (!currentSubDirObject.subdirectories) {\n                    currentSubDirObject.subdirectories = {};\n                }\n                const subDataObject = {};\n                currentSubDirObject.subdirectories[subdirName] = subDataObject;\n                stack.push([subdir, subDataObject]);\n            }\n        }\n        const newFormat = {\n            blobs,\n            content,\n        };\n        builder.addBlob(snapshotFileName, JSON.stringify(newFormat));\n        return builder.getSummaryTree();\n    }\n}\nfunction isKeyEditLocalOpMetadata(metadata) {\n    return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" && metadata.type === \"edit\";\n}\nfunction isClearLocalOpMetadata(metadata) {\n    return metadata !== undefined && metadata.type === \"clear\" && typeof metadata.pendingMessageId === \"number\" &&\n        typeof metadata.previousStorage === \"object\";\n}\nfunction isSubDirLocalOpMetadata(metadata) {\n    return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" &&\n        ((metadata.type === \"createSubDir\" && typeof metadata.previouslyExisted === \"boolean\") ||\n            metadata.type === \"deleteSubDir\");\n}\nfunction isDirectoryLocalOpMetadata(metadata) {\n    return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" &&\n        (metadata.type === \"edit\" || metadata.type === \"deleteSubDir\" ||\n            (metadata.type === \"clear\" && typeof metadata.previousStorage === \"object\") ||\n            (metadata.type === \"createSubDir\" && typeof metadata.previouslyExisted === \"boolean\"));\n}\n/**\n * Node of the directory tree.\n * @sealed\n */\nclass SubDirectory extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.TypedEventEmitter {\n    /**\n     * Constructor.\n     * @param directory - Reference back to the SharedDirectory to perform operations\n     * @param runtime - The data store runtime this directory is associated with\n     * @param serializer - The serializer to serialize / parse handles\n     * @param absolutePath - The absolute path of this IDirectory\n     */\n    constructor(directory, runtime, serializer, absolutePath) {\n        super();\n        this.directory = directory;\n        this.runtime = runtime;\n        this.serializer = serializer;\n        this.absolutePath = absolutePath;\n        /**\n         * Tells if the sub directory is deleted or not.\n         */\n        this._deleted = false;\n        /**\n         * String representation for the class.\n         */\n        this[_b] = \"SubDirectory\";\n        /**\n         * The in-memory data the directory is storing.\n         */\n        this._storage = new Map();\n        /**\n         * The subdirectories the directory is holding.\n         */\n        this._subdirectories = new Map();\n        /**\n         * Keys that have been modified locally but not yet ack'd from the server.\n         */\n        this.pendingKeys = new Map();\n        /**\n         * Subdirectories that have been modified locally but not yet ack'd from the server.\n         */\n        this.pendingSubDirectories = new Map();\n        /**\n         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n         */\n        this.pendingMessageId = -1;\n        /**\n         * The pending ids of any clears that have been performed locally but not yet ack'd from the server\n         */\n        this.pendingClearMessageIds = [];\n    }\n    dispose(error) {\n        this._deleted = true;\n        this.emit(\"disposed\", this);\n    }\n    /**\n     * Unmark the deleted property when rolling back delete.\n     */\n    undispose() {\n        this._deleted = false;\n    }\n    get disposed() {\n        return this._deleted;\n    }\n    throwIfDisposed() {\n        if (this._deleted) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.UsageError(\"Cannot access Disposed subDirectory\");\n        }\n    }\n    /**\n     * Checks whether the given key exists in this IDirectory.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        this.throwIfDisposed();\n        return this._storage.has(key);\n    }\n    /**\n     * {@inheritDoc IDirectory.get}\n     */\n    get(key) {\n        var _c;\n        this.throwIfDisposed();\n        return (_c = this._storage.get(key)) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    /**\n     * {@inheritDoc IDirectory.set}\n     */\n    set(key, value) {\n        this.throwIfDisposed();\n        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n        if (key === undefined || key === null) {\n            throw new Error(\"Undefined and null keys are not supported\");\n        }\n        // Create a local value and serialize it.\n        const localValue = this.directory.localValueMaker.fromInMemory(value);\n        const serializableValue = (0,_localValues__WEBPACK_IMPORTED_MODULE_3__.makeSerializable)(localValue, this.serializer, this.directory.handle);\n        // Set the value locally.\n        const previousValue = this.setCore(key, localValue, true);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return this;\n        }\n        const op = {\n            key,\n            path: this.absolutePath,\n            type: \"set\",\n            value: serializableValue,\n        };\n        this.submitKeyMessage(op, previousValue);\n        return this;\n    }\n    /**\n     * {@inheritDoc IDirectory.countSubDirectory}\n     */\n    countSubDirectory() {\n        return this._subdirectories.size;\n    }\n    /**\n     * {@inheritDoc IDirectory.createSubDirectory}\n     */\n    createSubDirectory(subdirName) {\n        this.throwIfDisposed();\n        // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.\n        if (subdirName === undefined || subdirName === null) {\n            throw new Error(\"SubDirectory name may not be undefined or null\");\n        }\n        if (subdirName.includes(posix.sep)) {\n            throw new Error(`SubDirectory name may not contain ${posix.sep}`);\n        }\n        // Create the sub directory locally first.\n        const isNew = this.createSubDirectoryCore(subdirName, true);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const subDir = this._subdirectories.get(subdirName);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return subDir;\n        }\n        const op = {\n            path: this.absolutePath,\n            subdirName,\n            type: \"createSubDirectory\",\n        };\n        this.submitCreateSubDirectoryMessage(op, !isNew);\n        return subDir;\n    }\n    /**\n     * {@inheritDoc IDirectory.getSubDirectory}\n     */\n    getSubDirectory(subdirName) {\n        this.throwIfDisposed();\n        return this._subdirectories.get(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.hasSubDirectory}\n     */\n    hasSubDirectory(subdirName) {\n        this.throwIfDisposed();\n        return this._subdirectories.has(subdirName);\n    }\n    /**\n     * {@inheritDoc IDirectory.deleteSubDirectory}\n     */\n    deleteSubDirectory(subdirName) {\n        this.throwIfDisposed();\n        // Delete the sub directory locally first.\n        const subDir = this.deleteSubDirectoryCore(subdirName, true);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return subDir !== undefined;\n        }\n        const op = {\n            path: this.absolutePath,\n            subdirName,\n            type: \"deleteSubDirectory\",\n        };\n        this.submitDeleteSubDirectoryMessage(op, subDir);\n        return subDir !== undefined;\n    }\n    /**\n     * {@inheritDoc IDirectory.subdirectories}\n     */\n    subdirectories() {\n        this.throwIfDisposed();\n        return this._subdirectories.entries();\n    }\n    /**\n     * {@inheritDoc IDirectory.getWorkingDirectory}\n     */\n    getWorkingDirectory(relativePath) {\n        this.throwIfDisposed();\n        return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));\n    }\n    /**\n     * Deletes the given key from within this IDirectory.\n     * @param key - The key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        this.throwIfDisposed();\n        // Delete the key locally first.\n        const previousValue = this.deleteCore(key, true);\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            return previousValue !== undefined;\n        }\n        const op = {\n            key,\n            path: this.absolutePath,\n            type: \"delete\",\n        };\n        this.submitKeyMessage(op, previousValue);\n        return previousValue !== undefined;\n    }\n    /**\n     * Deletes all keys from within this IDirectory.\n     */\n    clear() {\n        this.throwIfDisposed();\n        // If we are not attached, don't submit the op.\n        if (!this.directory.isAttached()) {\n            this.clearCore(true);\n            return;\n        }\n        const copy = new Map(this._storage);\n        this.clearCore(true);\n        const op = {\n            path: this.absolutePath,\n            type: \"clear\",\n        };\n        this.submitClearMessage(op, copy);\n    }\n    /**\n     * Issue a callback on each entry under this IDirectory.\n     * @param callback - Callback to issue\n     */\n    forEach(callback) {\n        this.throwIfDisposed();\n        this._storage.forEach((localValue, key, map) => {\n            callback(localValue.value, key, map);\n        });\n    }\n    /**\n     * The number of entries under this IDirectory.\n     */\n    get size() {\n        this.throwIfDisposed();\n        return this._storage.size;\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    entries() {\n        this.throwIfDisposed();\n        const localEntriesIterator = this._storage.entries();\n        const iterator = {\n            next() {\n                const nextVal = localEntriesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the keys under this IDirectory.\n     * @returns The iterator\n     */\n    keys() {\n        this.throwIfDisposed();\n        return this._storage.keys();\n    }\n    /**\n     * Get an iterator over the values under this IDirectory.\n     * @returns The iterator\n     */\n    values() {\n        this.throwIfDisposed();\n        const localValuesIterator = this._storage.values();\n        const iterator = {\n            next() {\n                const nextVal = localValuesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: nextVal.value.value, done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the entries under this IDirectory.\n     * @returns The iterator\n     */\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n        this.throwIfDisposed();\n        return this.entries();\n    }\n    /**\n     * Process a clear operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processClearMessage(op, local, localOpMetadata) {\n        this.throwIfDisposed();\n        if (local) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x00f /* pendingMessageId is missing from the local client's operation */);\n            const pendingClearMessageId = this.pendingClearMessageIds.shift();\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32a /* pendingMessageId does not match */);\n            return;\n        }\n        this.clearExceptPendingKeys();\n    }\n    /**\n     * Process a delete operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processDeleteMessage(op, local, localOpMetadata) {\n        this.throwIfDisposed();\n        if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {\n            return;\n        }\n        this.deleteCore(op.key, local);\n    }\n    /**\n     * Process a set operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processSetMessage(op, context, local, localOpMetadata) {\n        this.throwIfDisposed();\n        if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {\n            return;\n        }\n        // needProcessStorageOperation should have returned false if local is true\n        // so we can assume context is not undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.setCore(op.key, context, local);\n    }\n    /**\n     * Process a create subdirectory operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processCreateSubDirectoryMessage(op, local, localOpMetadata) {\n        this.throwIfDisposed();\n        if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {\n            return;\n        }\n        this.createSubDirectoryCore(op.subdirName, local);\n    }\n    /**\n     * Process a delete subdirectory operation.\n     * @param op - The op to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @internal\n     */\n    processDeleteSubDirectoryMessage(op, local, localOpMetadata) {\n        this.throwIfDisposed();\n        if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {\n            return;\n        }\n        this.deleteSubDirectoryCore(op.subdirName, local);\n    }\n    /**\n     * Submit a clear operation.\n     * @param op - The operation\n     */\n    submitClearMessage(op, previousValue) {\n        this.throwIfDisposed();\n        const pendingMsgId = ++this.pendingMessageId;\n        this.pendingClearMessageIds.push(pendingMsgId);\n        const metadata = {\n            type: \"clear\",\n            pendingMessageId: pendingMsgId,\n            previousStorage: previousValue,\n        };\n        this.directory.submitDirectoryMessage(op, metadata);\n    }\n    /**\n     * Resubmit a clear operation.\n     * @param op - The operation\n     * @internal\n     */\n    resubmitClearMessage(op, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x32b /* Invalid localOpMetadata for clear */);\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        const pendingClearMessageId = this.pendingClearMessageIds.shift();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32c /* pendingMessageId does not match */);\n        this.submitClearMessage(op, localOpMetadata.previousStorage);\n    }\n    /**\n     * Get a new pending message id for the op and cache it to track the pending op\n     */\n    getKeyMessageId(op) {\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        const pendingMessageId = ++this.pendingMessageId;\n        const pendingMessageIds = this.pendingKeys.get(op.key);\n        if (pendingMessageIds !== undefined) {\n            pendingMessageIds.push(pendingMessageId);\n        }\n        else {\n            this.pendingKeys.set(op.key, [pendingMessageId]);\n        }\n        return pendingMessageId;\n    }\n    /**\n     * Submit a key operation.\n     * @param op - The operation\n     * @param previousValue - The value of the key before this op\n     */\n    submitKeyMessage(op, previousValue) {\n        this.throwIfDisposed();\n        const pendingMessageId = this.getKeyMessageId(op);\n        const localMetadata = { type: \"edit\", pendingMessageId, previousValue };\n        this.directory.submitDirectoryMessage(op, localMetadata);\n    }\n    /**\n     * Submit a key message to remote clients based on a previous submit.\n     * @param op - The map key message\n     * @param localOpMetadata - Metadata from the previous submit\n     * @internal\n     */\n    resubmitKeyMessage(op, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isKeyEditLocalOpMetadata(localOpMetadata), 0x32d /* Invalid localOpMetadata in submit */);\n        // clear the old pending message id\n        const pendingMessageIds = this.pendingKeys.get(op.key);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x32e /* Unexpected pending message received */);\n        pendingMessageIds.shift();\n        if (pendingMessageIds.length === 0) {\n            this.pendingKeys.delete(op.key);\n        }\n        this.submitKeyMessage(op, localOpMetadata.previousValue);\n    }\n    /**\n     * Get a new pending message id for the op and cache it to track the pending op\n     */\n    getSubDirMessageId(op) {\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        const newMessageId = ++this.pendingMessageId;\n        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);\n        if (pendingMessageIds !== undefined) {\n            pendingMessageIds.push(newMessageId);\n        }\n        else {\n            this.pendingSubDirectories.set(op.subdirName, [newMessageId]);\n        }\n        return newMessageId;\n    }\n    /**\n     * Submit a create subdirectory operation.\n     * @param op - The operation\n     * @param prevExisted - Whether the subdirectory existed before the op\n     */\n    submitCreateSubDirectoryMessage(op, prevExisted) {\n        this.throwIfDisposed();\n        const newMessageId = this.getSubDirMessageId(op);\n        const localOpMetadata = {\n            type: \"createSubDir\",\n            pendingMessageId: newMessageId,\n            previouslyExisted: prevExisted,\n        };\n        this.directory.submitDirectoryMessage(op, localOpMetadata);\n    }\n    /**\n     * Submit a delete subdirectory operation.\n     * @param op - The operation\n     * @param subDir - Any subdirectory deleted by the op\n     */\n    submitDeleteSubDirectoryMessage(op, subDir) {\n        this.throwIfDisposed();\n        const newMessageId = this.getSubDirMessageId(op);\n        const localOpMetadata = {\n            type: \"deleteSubDir\",\n            pendingMessageId: newMessageId,\n            subDirectory: subDir,\n        };\n        this.directory.submitDirectoryMessage(op, localOpMetadata);\n    }\n    /**\n     * Submit a subdirectory operation again\n     * @param op - The operation\n     * @param localOpMetadata - metadata submitted with the op originally\n     * @internal\n     */\n    resubmitSubDirectoryMessage(op, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isSubDirLocalOpMetadata(localOpMetadata), 0x32f /* Invalid localOpMetadata for sub directory op */);\n        // clear the old pending message id\n        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x330 /* Unexpected pending message received */);\n        pendingMessageIds.shift();\n        if (pendingMessageIds.length === 0) {\n            this.pendingSubDirectories.delete(op.subdirName);\n        }\n        if (localOpMetadata.type === \"createSubDir\") {\n            this.submitCreateSubDirectoryMessage(op, localOpMetadata.previouslyExisted);\n        }\n        else {\n            this.submitDeleteSubDirectoryMessage(op, localOpMetadata.subDirectory);\n        }\n    }\n    /**\n     * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.\n     * @param serializer - The serializer to use to serialize handles in its values.\n     * @returns The JSONable string representing the storage of this subdirectory\n     * @internal\n     */\n    *getSerializedStorage(serializer) {\n        this.throwIfDisposed();\n        for (const [key, localValue] of this._storage) {\n            const value = localValue.makeSerialized(serializer, this.directory.handle);\n            const res = [key, value];\n            yield res;\n        }\n    }\n    /**\n     * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.\n     * @param key - The key to populate\n     * @param localValue - The local value to populate into it\n     * @internal\n     */\n    populateStorage(key, localValue) {\n        this.throwIfDisposed();\n        this._storage.set(key, localValue);\n    }\n    /**\n     * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.\n     * @param subdirName - The name of the subdirectory to add\n     * @param newSubDir - The new subdirectory to add\n     * @internal\n     */\n    populateSubDirectory(subdirName, newSubDir) {\n        this.throwIfDisposed();\n        this._subdirectories.set(subdirName, newSubDir);\n    }\n    /**\n     * Retrieve the local value at the given key.  This is used to get value type information stashed on the local\n     * value so op handlers can be retrieved\n     * @param key - The key to retrieve from\n     * @returns The local value\n     * @internal\n     */\n    getLocalValue(key) {\n        this.throwIfDisposed();\n        return this._storage.get(key);\n    }\n    /**\n     * Remove the pendingMessageId from the map tracking it on rollback\n     * @param map - map tracking the pending messages\n     * @param key - key of the edit in the op\n     */\n    rollbackPendingMessageId(map, key, pendingMessageId) {\n        const pendingMessageIds = map.get(key);\n        const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();\n        if (!pendingMessageIds || lastPendingMessageId !== pendingMessageId) {\n            throw new Error(\"Rollback op does not match last pending\");\n        }\n        if (pendingMessageIds.length === 0) {\n            map.delete(key);\n        }\n    }\n    /**\n     * Rollback a local op\n     * @param op - The operation to rollback\n     * @param localOpMetadata - The local metadata associated with the op.\n     */\n    rollback(op, localOpMetadata) {\n        if (!isDirectoryLocalOpMetadata(localOpMetadata)) {\n            throw new Error(\"Invalid localOpMetadata\");\n        }\n        if (op.type === \"clear\" && localOpMetadata.type === \"clear\") {\n            localOpMetadata.previousStorage.forEach((localValue, key) => {\n                this.setCore(key, localValue, true);\n            });\n            const lastPendingClearId = this.pendingClearMessageIds.pop();\n            if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {\n                throw new Error(\"Rollback op does match last clear\");\n            }\n        }\n        else if ((op.type === \"delete\" || op.type === \"set\") && localOpMetadata.type === \"edit\") {\n            if (localOpMetadata.previousValue === undefined) {\n                this.deleteCore(op.key, true);\n            }\n            else {\n                this.setCore(op.key, localOpMetadata.previousValue, true);\n            }\n            this.rollbackPendingMessageId(this.pendingKeys, op.key, localOpMetadata.pendingMessageId);\n        }\n        else if (op.type === \"createSubDirectory\" && localOpMetadata.type === \"createSubDir\") {\n            if (!localOpMetadata.previouslyExisted) {\n                this.deleteSubDirectoryCore(op.subdirName, true);\n            }\n            this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);\n        }\n        else if (op.type === \"deleteSubDirectory\" && localOpMetadata.type === \"deleteSubDir\") {\n            if (localOpMetadata.subDirectory !== undefined) {\n                this.undeleteSubDirectoryTree(localOpMetadata.subDirectory);\n                // don't need to register events because deleting never unregistered\n                this._subdirectories.set(op.subdirName, localOpMetadata.subDirectory);\n                this.emit(\"subDirectoryCreated\", op.subdirName, true, this);\n            }\n            this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);\n        }\n        else {\n            throw new Error(\"Unsupported op for rollback\");\n        }\n    }\n    /**\n     * Converts the given relative path into an absolute path.\n     * @param path - Relative path to convert\n     * @returns The equivalent absolute path\n     */\n    makeAbsolute(relativePath) {\n        return posix.resolve(this.absolutePath, relativePath);\n    }\n    /**\n     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n     * not process the incoming operation.\n     * @param op - Operation to check\n     * @param local - Whether the operation originated from the local client\n     * @param localOpMetadata - For local client ops, this is the metadata that was submitted with the op.\n     * For ops from a remote client, this will be undefined.\n     * @returns True if the operation should be processed, false otherwise\n     */\n    needProcessStorageOperation(op, local, localOpMetadata) {\n        if (this.pendingClearMessageIds.length > 0) {\n            if (local) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata) &&\n                    localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x010 /* \"Received out of order storage op when there is an unackd clear message\" */);\n            }\n            // If I have a NACK clear, we can ignore all ops.\n            return false;\n        }\n        const pendingKeyMessageId = this.pendingKeys.get(op.key);\n        if (pendingKeyMessageId !== undefined) {\n            // Found an NACK op, clear it from the directory if the latest sequence number in the directory\n            // match the message's and don't process the op.\n            if (local) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata), 0x011 /* pendingMessageId is missing from the local client's operation */);\n                const pendingMessageIds = this.pendingKeys.get(op.key);\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x331 /* Unexpected pending message received */);\n                pendingMessageIds.shift();\n                if (pendingMessageIds.length === 0) {\n                    this.pendingKeys.delete(op.key);\n                }\n            }\n            return false;\n        }\n        // If we don't have a NACK op on the key, we need to process the remote ops.\n        return !local;\n    }\n    /**\n     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n     * not process the incoming operation.\n     * @param op - Operation to check\n     * @param local - Whether the message originated from the local client\n     * @param message - The message\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation should be processed, false otherwise\n     */\n    needProcessSubDirectoryOperation(op, local, localOpMetadata) {\n        const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);\n        if (pendingSubDirectoryMessageId !== undefined) {\n            if (local) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isSubDirLocalOpMetadata(localOpMetadata), 0x012 /* pendingMessageId is missing from the local client's operation */);\n                const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x332 /* Unexpected pending message received */);\n                pendingMessageIds.shift();\n                if (pendingMessageIds.length === 0) {\n                    this.pendingSubDirectories.delete(op.subdirName);\n                }\n            }\n            return false;\n        }\n        return !local;\n    }\n    /**\n     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n     */\n    clearExceptPendingKeys() {\n        // Assuming the pendingKeys is small and the map is large\n        // we will get the value for the pendingKeys and clear the map\n        const temp = new Map();\n        this.pendingKeys.forEach((value, key, map) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            temp.set(key, this._storage.get(key));\n        });\n        this.clearCore(false);\n        temp.forEach((value, key, map) => {\n            this.setCore(key, value, true);\n        });\n    }\n    /**\n     * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n     * @param local - Whether the message originated from the local client\n     */\n    clearCore(local) {\n        this._storage.clear();\n        this.directory.emit(\"clear\", local, this.directory);\n    }\n    /**\n     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n     * @param key - The key being deleted\n     * @param local - Whether the message originated from the local client\n     * @returns Previous local value of the key if it existed, undefined if it did not exist\n     */\n    deleteCore(key, local) {\n        const previousLocalValue = this._storage.get(key);\n        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n        const successfullyRemoved = this._storage.delete(key);\n        if (successfullyRemoved) {\n            const event = { key, path: this.absolutePath, previousValue };\n            this.directory.emit(\"valueChanged\", event, local, this.directory);\n            const containedEvent = { key, previousValue };\n            this.emit(\"containedValueChanged\", containedEvent, local, this);\n        }\n        return previousLocalValue;\n    }\n    /**\n     * Set implementation used for both locally sourced sets as well as incoming remote sets.\n     * @param key - The key being set\n     * @param value - The value being set\n     * @param local - Whether the message originated from the local client\n     * @returns Previous local value of the key, if any\n     */\n    setCore(key, value, local) {\n        const previousLocalValue = this._storage.get(key);\n        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n        this._storage.set(key, value);\n        const event = { key, path: this.absolutePath, previousValue };\n        this.directory.emit(\"valueChanged\", event, local, this.directory);\n        const containedEvent = { key, previousValue };\n        this.emit(\"containedValueChanged\", containedEvent, local, this);\n        return previousLocalValue;\n    }\n    /**\n     * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n     * @param subdirName - The name of the subdirectory being created\n     * @param local - Whether the message originated from the local client\n     * @returns - True if is newly created, false if it already existed.\n     */\n    createSubDirectoryCore(subdirName, local) {\n        if (!this._subdirectories.has(subdirName)) {\n            const absolutePath = posix.join(this.absolutePath, subdirName);\n            const subDir = new SubDirectory(this.directory, this.runtime, this.serializer, absolutePath);\n            this.registerEventsOnSubDirectory(subDir, subdirName);\n            this._subdirectories.set(subdirName, subDir);\n            this.emit(\"subDirectoryCreated\", subdirName, local, this);\n            return true;\n        }\n        return false;\n    }\n    registerEventsOnSubDirectory(subDirectory, subDirName) {\n        subDirectory.on(\"subDirectoryCreated\", (relativePath, local) => {\n            this.emit(\"subDirectoryCreated\", posix.join(subDirName, relativePath), local, this);\n        });\n        subDirectory.on(\"subDirectoryDeleted\", (relativePath, local) => {\n            this.emit(\"subDirectoryDeleted\", posix.join(subDirName, relativePath), local, this);\n        });\n    }\n    /**\n     * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n     * @param subdirName - The name of the subdirectory being deleted\n     * @param local - Whether the message originated from the local client\n     */\n    deleteSubDirectoryCore(subdirName, local) {\n        const previousValue = this._subdirectories.get(subdirName);\n        // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots\n        // Might want to consider cleaning out the structure more exhaustively though? But not when rollback.\n        if (previousValue !== undefined) {\n            this._subdirectories.delete(subdirName);\n            this.disposeSubDirectoryTree(previousValue);\n            this.emit(\"subDirectoryDeleted\", subdirName, local, this);\n        }\n        return previousValue;\n    }\n    disposeSubDirectoryTree(directory) {\n        if (!directory) {\n            return;\n        }\n        // Dispose the subdirectory tree. This will dispose the subdirectories from bottom to top.\n        const subDirectories = directory.subdirectories();\n        for (const [_, subDirectory] of subDirectories) {\n            this.disposeSubDirectoryTree(subDirectory);\n        }\n        if (typeof directory.dispose === \"function\") {\n            directory.dispose();\n        }\n    }\n    undeleteSubDirectoryTree(directory) {\n        // Restore deleted subdirectory tree. This will unmark \"deleted\" from the subdirectories from bottom to top.\n        for (const [_, subDirectory] of this._subdirectories.entries()) {\n            this.undeleteSubDirectoryTree(subDirectory);\n        }\n        directory.undispose();\n    }\n}\n//# sourceMappingURL=directory.js.map\n\n/***/ }),\n/* 38 */\n/***/ ((module) => {\n\n\"use strict\";\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n/***/ }),\n/* 39 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/map\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 40 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedObject\": () => (/* binding */ SharedObject),\n/* harmony export */   \"SharedObjectCore\": () => (/* binding */ SharedObjectCore)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51);\n/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(52);\n/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);\n/* harmony import */ var _summarySerializer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(135);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n/**\n *  Base class from which all shared objects derive\n */\nclass SharedObjectCore extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitterWithErrorHandling {\n    /**\n     * @param id - The id of the shared object\n     * @param runtime - The IFluidDataStoreRuntime which contains the shared object\n     * @param attributes - Attributes of the shared object\n     */\n    constructor(id, runtime, attributes) {\n        super((event, e) => this.eventListenerErrorHandler(event, e));\n        this.id = id;\n        this.runtime = runtime;\n        this.attributes = attributes;\n        /**\n         * Connection state\n         */\n        this._connected = false;\n        /**\n         * True if the dds is bound to its parent.\n         */\n        this._isBoundToContext = false;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!id.includes(\"/\"), 0x304 /* Id cannot contain slashes */);\n        this.handle = new _handle__WEBPACK_IMPORTED_MODULE_2__.SharedObjectHandle(this, id, runtime.IFluidHandleContext);\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(runtime.logger, undefined, {\n            all: {\n                sharedObjectId: (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(),\n                ddsType: {\n                    value: this.attributes.type,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.TelemetryDataTag.CodeArtifact,\n                },\n            },\n        });\n        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.loggerToMonitoringContext)(this.logger);\n        [this.opProcessingHelper, this.callbacksHelper] = this.setUpSampledTelemetryHelpers();\n        this.attachListeners();\n    }\n    get IFluidLoadable() { return this; }\n    /**\n     * Gets the connection state\n     * @returns The state of the connection\n     */\n    get connected() {\n        return this._connected;\n    }\n    /**\n     * This function is only supposed to be called from SharedObjectCore's constructor and\n     * depends on a few things being set already. assert() calls make sure of it.\n     * @returns The telemetry sampling helpers, so the constructor can be the one to assign them\n     * to variables to avoid complaints from TypeScript.\n     */\n    setUpSampledTelemetryHelpers() {\n        var _a, _b;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.mc !== undefined && this.logger !== undefined, \"this.mc and/or this.logger has not been set\");\n        const opProcessingHelper = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.SampledTelemetryHelper({\n            eventName: \"ddsOpProcessing\",\n            category: \"performance\",\n        }, this.logger, (_a = this.mc.config.getNumber(\"Fluid.SharedObject.OpProcessingTelemetrySampling\")) !== null && _a !== void 0 ? _a : 100, true, new Map([\n            [\"local\", { localOp: true }],\n            [\"remote\", { localOp: false }],\n        ]));\n        const callbacksHelper = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.SampledTelemetryHelper({\n            eventName: \"ddsEventCallbacks\",\n            category: \"performance\",\n        }, this.logger, (_b = this.mc.config.getNumber(\"Fluid.SharedObject.DdsCallbacksTelemetrySampling\")) !== null && _b !== void 0 ? _b : 100, true);\n        this.runtime.once(\"dispose\", () => {\n            this.callbacksHelper.dispose();\n            this.opProcessingHelper.dispose();\n        });\n        return [opProcessingHelper, callbacksHelper];\n    }\n    /**\n     * Marks this objects as closed. Any attempt to change it (local changes or processing remote ops)\n     * would result in same error thrown. If called multiple times, only first error is remembered.\n     * @param error - error object that is thrown whenever an attempt is made to modify this object\n     */\n    closeWithError(error) {\n        if (this.closeError === undefined) {\n            this.closeError = error;\n        }\n    }\n    /**\n     * Verifies that this object is not closed via closeWithError(). If it is, throws an error used to close it.\n     */\n    verifyNotClosed() {\n        if (this.closeError !== undefined) {\n            throw this.closeError;\n        }\n    }\n    /**\n     * Event listener handler helper that can be used to react to exceptions thrown from event listeners\n     * It wraps error with DataProcessingError, closes this object and throws resulting error.\n     * See closeWithError() for more details\n     * Ideally such situation never happens, as consumers of DDS should never throw exceptions\n     * in event listeners (i.e. catch any of the issues and make determination on how to handle it).\n     * When such exceptions propagate through, most likely data model is no longer consistent, i.e.\n     * DDS state does not match what user sees. Because of it DDS moves to \"corrupted state\" and does not\n     * allow processing of ops or local changes, which very quickly results in container closure.\n     */\n    eventListenerErrorHandler(event, e) {\n        const error = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_7__.DataProcessingError.wrapIfUnrecognized(e, \"SharedObjectEventListenerException\");\n        error.addTelemetryProperties({ emittedEventName: String(event) });\n        this.closeWithError(error);\n        throw error;\n    }\n    attachListeners() {\n        // Only listen to these events if not attached.\n        if (!this.isAttached()) {\n            this.runtime.once(\"attaching\", () => {\n                // Calling this will let the dds to do any custom processing based on attached\n                // like starting generating ops.\n                this.didAttach();\n            });\n        }\n    }\n    /**\n     * A shared object, after construction, can either be loaded in the case that it is already part of\n     * a shared document. Or later attached if it is being newly added.\n     * @param services - Services used by the shared object\n     */\n    async load(services) {\n        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached) {\n            this.services = services;\n        }\n        await this.loadCore(services.objectStorage);\n        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached) {\n            this.attachDeltaHandler();\n        }\n    }\n    /**\n     * Initializes the object as a local, non-shared object. This object can become shared after\n     * it is attached to the document.\n     */\n    initializeLocal() {\n        this.initializeLocalCore();\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).bindToContext}\n     */\n    bindToContext() {\n        if (this._isBoundToContext) {\n            return;\n        }\n        this._isBoundToContext = true;\n        this.runtime.bindChannel(this);\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).connect}\n     */\n    connect(services) {\n        this.services = services;\n        this.attachDeltaHandler();\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).isAttached}\n     */\n    isAttached() {\n        return this.services !== undefined && this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached;\n    }\n    /**\n     * Called when a handle is decoded by this object. A handle in the object's data represents an outbound reference\n     * to another object in the container.\n     * @param decodedHandle - The handle of the Fluid object that is decoded.\n     */\n    handleDecoded(decodedHandle) {\n        var _a, _b, _c;\n        if (this.isAttached()) {\n            // This represents an outbound reference from this object to the node represented by decodedHandle.\n            (_c = (_a = this.services) === null || _a === void 0 ? void 0 : (_b = _a.deltaConnection).addedGCOutboundReference) === null || _c === void 0 ? void 0 : _c.call(_b, this.handle, decodedHandle);\n        }\n    }\n    /**\n     * Allows the distributed data type to perform custom local loading.\n     */\n    initializeLocalCore() {\n        return;\n    }\n    /**\n     * Allows the distributive data type the ability to perform custom processing once an attach has happened.\n     * Also called after non-local data type get loaded.\n     */\n    didAttach() {\n        return;\n    }\n    /**\n     * Submits a message by the local client to the runtime.\n     * @param content - Content of the message\n     * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime\n     * and not sent to the server. This will be sent back when this message is received back from the server. This is\n     * also sent if we are asked to resubmit the message.\n     */\n    submitLocalMessage(content, localOpMetadata = undefined) {\n        this.verifyNotClosed();\n        if (this.isAttached()) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.services.deltaConnection.submit(content, localOpMetadata);\n        }\n    }\n    /**\n     * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock\n     * that want to be part of summary but does not generate ops.\n     */\n    dirty() {\n        if (!this.isAttached()) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.services.deltaConnection.dirty();\n    }\n    /**\n     * Called when the object has fully connected to the delta stream\n     * Default implementation for DDS, override if different behavior is required.\n     */\n    onConnect() { }\n    /**\n     * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.\n     * The default implementation here is to resubmit the same message. The client can override if different behavior\n     * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit\n     * anything at all.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmitCore(content, localOpMetadata) {\n        this.submitLocalMessage(content, localOpMetadata);\n    }\n    /**\n     * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.\n     * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),\n     * the Promise will reject.\n     * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.\n     */\n    async newAckBasedPromise(executor) {\n        let rejectBecauseDispose;\n        return new Promise((resolve, reject) => {\n            rejectBecauseDispose =\n                () => reject(new Error(\"FluidDataStoreRuntime disposed while this ack-based Promise was pending\"));\n            if (this.runtime.disposed) {\n                rejectBecauseDispose();\n                return;\n            }\n            this.runtime.on(\"dispose\", rejectBecauseDispose);\n            executor(resolve, reject);\n        }).finally(() => {\n            // Note: rejectBecauseDispose will never be undefined here\n            this.runtime.off(\"dispose\", rejectBecauseDispose);\n        });\n    }\n    attachDeltaHandler() {\n        // Services should already be there in case we are attaching delta handler.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.services !== undefined, 0x07a /* \"Services should be there to attach delta handler\" */);\n        this._isBoundToContext = true;\n        // Allows objects to do any custom processing if it is attached.\n        this.didAttach();\n        // attachDeltaHandler is only called after services is assigned\n        this.services.deltaConnection.attach({\n            process: (message, local, localOpMetadata) => {\n                this.process(message, local, localOpMetadata);\n            },\n            setConnectionState: (connected) => {\n                this.setConnectionState(connected);\n            },\n            reSubmit: (content, localOpMetadata) => {\n                this.reSubmit(content, localOpMetadata);\n            },\n            applyStashedOp: (content) => {\n                return this.applyStashedOp(content);\n            },\n            rollback: (content, localOpMetadata) => {\n                this.rollback(content, localOpMetadata);\n            },\n        });\n        // Trigger initial state\n        // attachDeltaHandler is only called after services is assigned\n        this.setConnectionState(this.services.deltaConnection.connected);\n    }\n    /**\n     * Set the state of connection to services.\n     * @param connected - true if connected, false otherwise.\n     */\n    setConnectionState(connected) {\n        if (this._connected === connected) {\n            // Not changing state, nothing the same.\n            return;\n        }\n        // Should I change the state at the end? So that we *can't* send new stuff before we send old?\n        this._connected = connected;\n        if (!connected) {\n            // Things that are true now...\n            // - if we had a connection we can no longer send messages over it\n            // - if we had outbound messages some may or may not be ACK'd. Won't know until next message\n            //\n            // - nack could get a new msn - but might as well do it in the join?\n            this.onDisconnect();\n        }\n        else {\n            // Call this for now so that DDSes like ConsensusOrderedCollection that maintain their own pending\n            // messages will work.\n            this.onConnect();\n        }\n    }\n    /**\n     * Handles a message being received from the remote delta server.\n     * @param message - The message to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     */\n    process(message, local, localOpMetadata) {\n        this.verifyNotClosed(); // This will result in container closure.\n        this.emitInternal(\"pre-op\", message, local, this);\n        this.opProcessingHelper.measure(() => { this.processCore(message, local, localOpMetadata); }, local ? \"local\" : \"remote\");\n        this.emitInternal(\"op\", message, local, this);\n    }\n    /**\n     * Called when a message has to be resubmitted. This typically happens for unacked messages after a\n     * reconnection.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmit(content, localOpMetadata) {\n        this.reSubmitCore(content, localOpMetadata);\n    }\n    /**\n     * Revert an op\n     */\n    rollback(content, localOpMetadata) {\n        throw new Error(\"rollback not supported\");\n    }\n    /**\n     * Emit an event. This function is only intended for use by DDS classes that extend SharedObject/SharedObjectCore,\n     * specifically to emit events that are part of the public interface of the DDS (i.e. those that can have listeners\n     * attached to them by the consumers of the DDS). It should not be called from outside the class or to emit events\n     * which are only internal to the DDS. Support for calling it from outside the DDS instance might be removed in the\n     * future.\n     *\n     * @internal\n     *\n     * @param event - The event to emit.\n     * @param args - Arguments to pass to the event listeners.\n     * @returns `true` if the event had listeners, `false` otherwise.\n     */\n    emit(event, ...args) {\n        return this.callbacksHelper.measure(() => super.emit(event, ...args));\n    }\n    /**\n     * Use to emit events inside {@link SharedObjectCore}, with no telemetry measurement\n     * done on the duration of the callbacks. Simply calls `super.emit()`.\n     * @param event - Event to emit\n     * @param args - Arguments for the event\n     * @returns Whatever `super.emit()` returns.\n     */\n    emitInternal(event, ...args) {\n        return super.emit(event, ...args);\n    }\n}\n/**\n * SharedObject with simplified, synchronous summarization and GC.\n * DDS implementations with async and incremental summarization should extend SharedObjectCore directly instead.\n */\nclass SharedObject extends SharedObjectCore {\n    /**\n     * @param id - The id of the shared object\n     * @param runtime - The IFluidDataStoreRuntime which contains the shared object\n     * @param attributes - Attributes of the shared object\n     */\n    constructor(id, runtime, attributes, telemetryContextPrefix) {\n        super(id, runtime, attributes);\n        this.telemetryContextPrefix = telemetryContextPrefix;\n        /**\n         * True while we are garbage collecting this object's data.\n         */\n        this._isGCing = false;\n        this._serializer = new _serializer__WEBPACK_IMPORTED_MODULE_9__.FluidSerializer(this.runtime.channelsRoutingContext, (handle) => this.handleDecoded(handle));\n    }\n    get serializer() {\n        /**\n         * During garbage collection, the SummarySerializer keeps track of IFluidHandles that are serialized. These\n         * handles represent references to other Fluid objects.\n         *\n         * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content\n         * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.\n         */\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this._isGCing, 0x075 /* \"SummarySerializer should be used for serializing data during summary.\" */);\n        return this._serializer;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).getAttachSummary}\n     */\n    getAttachSummary(fullTree = false, trackState = false, telemetryContext) {\n        const result = this.summarizeCore(this.serializer, telemetryContext);\n        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);\n        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);\n        return result;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).summarize}\n     */\n    async summarize(fullTree = false, trackState = false, telemetryContext) {\n        const result = this.summarizeCore(this.serializer, telemetryContext);\n        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);\n        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);\n        return result;\n    }\n    /**\n     * {@inheritDoc (ISharedObject:interface).getGCData}\n     */\n    getGCData(fullGC = false) {\n        // Set _isGCing to true. This flag is used to ensure that we only use SummarySerializer to serialize handles\n        // in this object's data.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this._isGCing, 0x078 /* \"Possible re-entrancy! Summary should not already be in progress.\" */);\n        this._isGCing = true;\n        let gcData;\n        try {\n            const serializer = new _summarySerializer__WEBPACK_IMPORTED_MODULE_11__.SummarySerializer(this.runtime.channelsRoutingContext, (handle) => this.handleDecoded(handle));\n            this.processGCDataCore(serializer);\n            // The GC data for this shared object contains a single GC node. The outbound routes of this node are the\n            // routes of handles serialized during summarization.\n            gcData = { gcNodes: { \"/\": serializer.getSerializedRoutes() } };\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this._isGCing, 0x079 /* \"Possible re-entrancy! Summary should have been in progress.\" */);\n        }\n        finally {\n            this._isGCing = false;\n        }\n        return gcData;\n    }\n    /**\n     * Calls the serializer over all data in this object that reference other GC nodes.\n     * Derived classes must override this to provide custom list of references to other GC nodes.\n     */\n    processGCDataCore(serializer) {\n        // We run the full summarize logic to get the list of outbound routes from this object. This is a little\n        // expensive but its okay for now. It will be updated to not use full summarize and make it more efficient.\n        // See: https://github.com/microsoft/FluidFramework/issues/4547\n        this.summarizeCore(serializer);\n    }\n    incrementTelemetryMetric(propertyName, incrementBy, telemetryContext) {\n        var _a;\n        const prevTotal = ((_a = telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.get(this.telemetryContextPrefix, propertyName)) !== null && _a !== void 0 ? _a : 0);\n        telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.set(this.telemetryContextPrefix, propertyName, prevTotal + incrementBy);\n    }\n}\n//# sourceMappingURL=sharedObject.js.map\n\n/***/ }),\n/* 41 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventEmitterWithErrorHandling\": () => (/* binding */ EventEmitterWithErrorHandling)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);\n\n/**\n * Event Emitter helper class\n * Any exceptions thrown by listeners will be caught and raised through \"error\" event.\n * Any exception thrown by \"error\" listeners will propagate to the caller.\n */\nclass EventEmitterWithErrorHandling extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(errorHandler) {\n        super();\n        this.errorHandler = errorHandler;\n    }\n    emit(event, ...args) {\n        try {\n            return super.emit(event, ...args);\n        }\n        catch (error) {\n            this.errorHandler(event, error);\n            return true;\n        }\n    }\n}\n//# sourceMappingURL=eventEmitterWithErrorHandling.js.map\n\n/***/ }),\n/* 42 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 43 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 44 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedObjectHandle\": () => (/* binding */ SharedObjectHandle)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Handle for shared object\n * This object is used for already loaded (in-memory) shared object\n * and is used only for serialization purposes.\n * De-serialization process goes through FluidObjectHandle and request flow:\n * FluidDataStoreRuntime.request() recognizes requests in the form of '/\\<shared object id\\>'\n * and loads shared object.\n */\nclass SharedObjectHandle extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidObjectHandle {\n    /**\n     * Whether services have been attached for the associated shared object.\n     */\n    get isAttached() {\n        return this.value.isAttached();\n    }\n    /**\n     * Creates a new SharedObjectHandle.\n     * @param value - The shared object this handle is for.\n     * @param path - The id of the shared object. It is also the path to this object relative to the routeContext.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(value, path, routeContext) {\n        super(value, path, routeContext);\n    }\n    /**\n     * Attaches all bound handles first (which may in turn attach further handles), then attaches this handle.\n     * When attaching the handle, it registers the associated shared object.\n     */\n    attachGraph() {\n        this.value.bindToContext();\n        super.attachGraph();\n    }\n}\n//# sourceMappingURL=handle.js.map\n\n/***/ }),\n/* 45 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChildLogger\": () => (/* binding */ ChildLogger),\n/* harmony export */   \"MultiSinkLogger\": () => (/* binding */ MultiSinkLogger),\n/* harmony export */   \"PerformanceEvent\": () => (/* binding */ PerformanceEvent),\n/* harmony export */   \"TaggedLoggerAdapter\": () => (/* binding */ TaggedLoggerAdapter),\n/* harmony export */   \"TelemetryDataTag\": () => (/* binding */ TelemetryDataTag),\n/* harmony export */   \"TelemetryLogger\": () => (/* binding */ TelemetryLogger),\n/* harmony export */   \"TelemetryUTLogger\": () => (/* binding */ TelemetryUTLogger)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);\n/* harmony import */ var _errorLogging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Broad classifications to be applied to individual properties as they're prepared to be logged to telemetry.\n * Please do not modify existing entries for backwards compatibility.\n */\nvar TelemetryDataTag;\n(function (TelemetryDataTag) {\n    /**\n     * Data containing terms from code packages that may have been dynamically loaded\n     * @deprecated 1.0, will be removed in next release (see issue #6603). Use `TelemetryDataTag.CodeArtifact` instead.\n     */\n    TelemetryDataTag[\"PackageData\"] = \"PackageData\";\n    /** Data containing terms or IDs from code packages that may have been dynamically loaded */\n    TelemetryDataTag[\"CodeArtifact\"] = \"CodeArtifact\";\n    /** Personal data of a variety of classifications that pertains to the user */\n    TelemetryDataTag[\"UserData\"] = \"UserData\";\n})(TelemetryDataTag || (TelemetryDataTag = {}));\n/**\n * TelemetryLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\nclass TelemetryLogger {\n    constructor(namespace, properties) {\n        this.namespace = namespace;\n        this.properties = properties;\n    }\n    static formatTick(tick) {\n        return Math.floor(tick);\n    }\n    /**\n     * Attempts to parse number from string.\n     * If fails,returns original string.\n     * Used to make telemetry data typed (and support math operations, like comparison),\n     * in places where we do expect numbers (like contentsize/duration property in http header)\n     */\n    static numberFromString(str) {\n        if (str === undefined || str === null) {\n            return undefined;\n        }\n        const num = Number(str);\n        return Number.isNaN(num) ? str : num;\n    }\n    static sanitizePkgName(name) {\n        return name.replace(\"@\", \"\").replace(\"/\", \"-\");\n    }\n    /**\n     * Take an unknown error object and add the appropriate info from it to the event. Message and stack will be copied\n     * over from the error object, along with other telemetry properties if it's an ILoggingError.\n     * @param event - Event being logged\n     * @param error - Error to extract info from\n     * @param fetchStack - Whether to fetch the current callstack if error.stack is undefined\n     */\n    static prepareErrorObject(event, error, fetchStack) {\n        const { message, errorType, stack } = (0,_errorLogging__WEBPACK_IMPORTED_MODULE_0__.extractLogSafeErrorProperties)(error, true /* sanitizeStack */);\n        // First, copy over error message, stack, and errorType directly (overwrite if present on event)\n        event.stack = stack;\n        event.error = message; // Note that the error message goes on the 'error' field\n        event.errorType = errorType;\n        if ((0,_errorLogging__WEBPACK_IMPORTED_MODULE_0__.isILoggingError)(error)) {\n            // Add any other telemetry properties from the LoggingError\n            const telemetryProp = error.getTelemetryProperties();\n            for (const key of Object.keys(telemetryProp)) {\n                if (event[key] !== undefined) {\n                    // Don't overwrite existing properties on the event\n                    continue;\n                }\n                event[key] = telemetryProp[key];\n            }\n        }\n        // Collect stack if we were not able to extract it from error\n        if (event.stack === undefined && fetchStack) {\n            event.stack = (0,_errorLogging__WEBPACK_IMPORTED_MODULE_0__.generateStack)();\n        }\n    }\n    /**\n     * Send a telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendTelemetryEvent(event, error) {\n        var _a;\n        this.sendTelemetryEventCore(Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : \"generic\" }), error);\n    }\n    /**\n     * Send a telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendTelemetryEventCore(event, error) {\n        const newEvent = Object.assign({}, event);\n        if (error !== undefined) {\n            TelemetryLogger.prepareErrorObject(newEvent, error, false);\n        }\n        // Will include Nan & Infinity, but probably we do not care\n        if (typeof newEvent.duration === \"number\") {\n            newEvent.duration = TelemetryLogger.formatTick(newEvent.duration);\n        }\n        this.send(newEvent);\n    }\n    /**\n     * Send an error telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n    sendErrorEvent(event, error) {\n        this.sendTelemetryEventCore(Object.assign(Object.assign({ \n            // ensure the error field has some value,\n            // this can and will be overridden by event, or error\n            error: event.eventName }, event), { category: \"error\" }), error);\n    }\n    /**\n     * Send a performance telemetry event with the logger\n     *\n     * @param event - Event to send\n     * @param error - optional error object to log\n     */\n    sendPerformanceEvent(event, error) {\n        var _a;\n        const perfEvent = Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : \"performance\" });\n        this.sendTelemetryEventCore(perfEvent, error);\n    }\n    prepareEvent(event) {\n        const includeErrorProps = event.category === \"error\" || event.error !== undefined;\n        const newEvent = Object.assign({}, event);\n        if (this.namespace !== undefined) {\n            newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;\n        }\n        if (this.properties) {\n            const properties = [];\n            properties.push(this.properties.all);\n            if (includeErrorProps) {\n                properties.push(this.properties.error);\n            }\n            for (const props of properties) {\n                if (props !== undefined) {\n                    for (const key of Object.keys(props)) {\n                        if (event[key] !== undefined) {\n                            continue;\n                        }\n                        const getterOrValue = props[key];\n                        // If this throws, hopefully it is handled elsewhere\n                        const value = typeof getterOrValue === \"function\" ? getterOrValue() : getterOrValue;\n                        if (value !== undefined) {\n                            newEvent[key] = value;\n                        }\n                    }\n                }\n            }\n        }\n        return newEvent;\n    }\n}\nTelemetryLogger.eventNamespaceSeparator = \":\";\n/**\n * @deprecated 0.56, remove TaggedLoggerAdapter once its usage is removed from\n * container-runtime. Issue: #8191\n * TaggedLoggerAdapter class can add tag handling to your logger.\n */\nclass TaggedLoggerAdapter {\n    constructor(logger) {\n        this.logger = logger;\n    }\n    send(eventWithTagsMaybe) {\n        const newEvent = {\n            category: eventWithTagsMaybe.category,\n            eventName: eventWithTagsMaybe.eventName,\n        };\n        for (const key of Object.keys(eventWithTagsMaybe)) {\n            const taggableProp = eventWithTagsMaybe[key];\n            const { value, tag } = (typeof taggableProp === \"object\")\n                ? taggableProp\n                : { value: taggableProp, tag: undefined };\n            switch (tag) {\n                case undefined:\n                    // No tag means we can log plainly\n                    newEvent[key] = value;\n                    break;\n                case TelemetryDataTag.PackageData:\n                    // For Microsoft applications, PackageData is safe for now\n                    // (we don't load 3P code in 1P apps)\n                    newEvent[key] = value;\n                    break;\n                case TelemetryDataTag.UserData:\n                    // Strip out anything tagged explicitly as PII.\n                    // Alternate strategy would be to hash these props\n                    newEvent[key] = \"REDACTED (UserData)\";\n                    break;\n                default:\n                    // If we encounter a tag we don't recognize\n                    // then we must assume we should scrub.\n                    newEvent[key] = \"REDACTED (unknown tag)\";\n                    break;\n            }\n        }\n        this.logger.send(newEvent);\n    }\n}\n/**\n * ChildLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\nclass ChildLogger extends TelemetryLogger {\n    constructor(baseLogger, namespace, properties) {\n        super(namespace, properties);\n        this.baseLogger = baseLogger;\n        // propagate the monitoring context\n        if ((0,_config__WEBPACK_IMPORTED_MODULE_1__.loggerIsMonitoringContext)(baseLogger)) {\n            (0,_config__WEBPACK_IMPORTED_MODULE_1__.mixinMonitoringContext)(this, new _config__WEBPACK_IMPORTED_MODULE_1__.CachedConfigProvider(baseLogger.config));\n        }\n    }\n    /**\n     * Create child logger\n     * @param baseLogger - Base logger to use to output events. If undefined, proper child logger\n     * is created, but it does not sends telemetry events anywhere.\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     */\n    static create(baseLogger, namespace, properties) {\n        // if we are creating a child of a child, rather than nest, which will increase\n        // the callstack overhead, just generate a new logger that includes everything from the previous\n        if (baseLogger instanceof ChildLogger) {\n            const combinedProperties = {};\n            for (const extendedProps of [baseLogger.properties, properties]) {\n                if (extendedProps !== undefined) {\n                    if (extendedProps.all !== undefined) {\n                        combinedProperties.all = Object.assign(Object.assign({}, combinedProperties.all), extendedProps.all);\n                    }\n                    if (extendedProps.error !== undefined) {\n                        combinedProperties.error = Object.assign(Object.assign({}, combinedProperties.error), extendedProps.error);\n                    }\n                }\n            }\n            const combinedNamespace = baseLogger.namespace === undefined\n                ? namespace\n                : namespace === undefined\n                    ? baseLogger.namespace\n                    : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;\n            return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties);\n        }\n        return new ChildLogger(baseLogger ? baseLogger : new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTelemetryNullLogger(), namespace, properties);\n    }\n    /**\n     * Send an event with the logger\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        this.baseLogger.send(this.prepareEvent(event));\n    }\n}\n/**\n * Multi-sink logger\n * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink\n * Implements ITelemetryBaseLogger (through static create() method)\n */\nclass MultiSinkLogger extends TelemetryLogger {\n    /**\n     * Create multiple sink logger (i.e. logger that sends events to multiple sinks)\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     */\n    constructor(namespace, properties) {\n        super(namespace, properties);\n        this.loggers = [];\n    }\n    /**\n     * Add logger to send all events to\n     * @param logger - Logger to add\n     */\n    addLogger(logger) {\n        if (logger !== undefined && logger !== null) {\n            this.loggers.push(logger);\n        }\n    }\n    /**\n     * Send an event to the loggers\n     *\n     * @param event - the event to send to all the registered logger\n     */\n    send(event) {\n        const newEvent = this.prepareEvent(event);\n        this.loggers.forEach((logger) => {\n            logger.send(newEvent);\n        });\n    }\n}\n/**\n * Helper class to log performance events\n */\nclass PerformanceEvent {\n    constructor(logger, event, markers = { end: true, cancel: \"generic\" }) {\n        this.logger = logger;\n        this.markers = markers;\n        this.startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now();\n        this.event = Object.assign({}, event);\n        if (this.markers.start) {\n            this.reportEvent(\"start\");\n        }\n        if (typeof window === \"object\" && window != null && window.performance) {\n            this.startMark = `${event.eventName}-start`;\n            window.performance.mark(this.startMark);\n        }\n    }\n    static start(logger, event, markers) {\n        return new PerformanceEvent(logger, event, markers);\n    }\n    static timedExec(logger, event, callback, markers) {\n        const perfEvent = PerformanceEvent.start(logger, event, markers);\n        try {\n            const ret = callback(perfEvent);\n            perfEvent.autoEnd();\n            return ret;\n        }\n        catch (error) {\n            perfEvent.cancel(undefined, error);\n            throw error;\n        }\n    }\n    static async timedExecAsync(logger, event, callback, markers) {\n        const perfEvent = PerformanceEvent.start(logger, event, markers);\n        try {\n            const ret = await callback(perfEvent);\n            perfEvent.autoEnd();\n            return ret;\n        }\n        catch (error) {\n            perfEvent.cancel(undefined, error);\n            throw error;\n        }\n    }\n    get duration() { return _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now() - this.startTime; }\n    reportProgress(props, eventNameSuffix = \"update\") {\n        this.reportEvent(eventNameSuffix, props);\n    }\n    autoEnd() {\n        // Event might have been cancelled or ended in the callback\n        if (this.event && this.markers.end) {\n            this.reportEvent(\"end\");\n        }\n        this.performanceEndMark();\n        this.event = undefined;\n    }\n    end(props) {\n        this.reportEvent(\"end\", props);\n        this.performanceEndMark();\n        this.event = undefined;\n    }\n    performanceEndMark() {\n        if (this.startMark && this.event) {\n            const endMark = `${this.event.eventName}-end`;\n            window.performance.mark(endMark);\n            window.performance.measure(`${this.event.eventName}`, this.startMark, endMark);\n            this.startMark = undefined;\n        }\n    }\n    cancel(props, error) {\n        if (this.markers.cancel !== undefined) {\n            this.reportEvent(\"cancel\", Object.assign({ category: this.markers.cancel }, props), error);\n        }\n        this.event = undefined;\n    }\n    /**\n     * Report the event, if it hasn't already been reported.\n     */\n    reportEvent(eventNameSuffix, props, error) {\n        // There are strange sequences involving multiple Promise chains\n        // where the event can be cancelled and then later a callback is invoked\n        // and the caller attempts to end directly, e.g. issue #3936. Just return.\n        if (!this.event) {\n            return;\n        }\n        const event = Object.assign(Object.assign({}, this.event), props);\n        event.eventName = `${event.eventName}_${eventNameSuffix}`;\n        if (eventNameSuffix !== \"start\") {\n            event.duration = this.duration;\n        }\n        this.logger.sendPerformanceEvent(event, error);\n    }\n}\n/**\n * Logger that is useful for UT\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass TelemetryUTLogger {\n    send(event) {\n    }\n    sendTelemetryEvent(event, error) {\n    }\n    sendErrorEvent(event, error) {\n        this.reportError(\"errorEvent in UT logger!\", event, error);\n    }\n    sendPerformanceEvent(event, error) {\n    }\n    logGenericError(eventName, error) {\n        this.reportError(`genericError in UT logger!`, { eventName }, error);\n    }\n    logException(event, exception) {\n        this.reportError(\"exception in UT logger!\", event, exception);\n    }\n    debugAssert(condition, event) {\n        this.reportError(\"debugAssert in UT logger!\");\n    }\n    shipAssert(condition, event) {\n        this.reportError(\"shipAssert in UT logger!\");\n    }\n    reportError(message, event, err) {\n        const error = new Error(message);\n        error.error = error;\n        error.event = event;\n        // report to console as exception can be eaten\n        console.error(message);\n        console.error(error);\n        throw error;\n    }\n}\n//# sourceMappingURL=logger.js.map\n\n/***/ }),\n/* 46 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CachedConfigProvider\": () => (/* binding */ CachedConfigProvider),\n/* harmony export */   \"inMemoryConfigProvider\": () => (/* binding */ inMemoryConfigProvider),\n/* harmony export */   \"loggerIsMonitoringContext\": () => (/* binding */ loggerIsMonitoringContext),\n/* harmony export */   \"loggerToMonitoringContext\": () => (/* binding */ loggerToMonitoringContext),\n/* harmony export */   \"mixinMonitoringContext\": () => (/* binding */ mixinMonitoringContext),\n/* harmony export */   \"sessionStorageConfigProvider\": () => (/* binding */ sessionStorageConfigProvider)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);\n\n/**\n * Creates a base configuration provider based on `sessionStorage`\n *\n * @returns A lazy initialized base configuration provider with `sessionStorage` as the underlying config store\n */\nconst sessionStorageConfigProvider = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => inMemoryConfigProvider(safeSessionStorage()));\nconst NullConfigProvider = {\n    getRawConfig: () => undefined,\n};\n/**\n * Creates a base configuration provider based on the supplied `Storage` instance\n *\n * @param storage - instance of `Storage` to be used as storage media for the config\n * @returns A base configuration provider with\n * the supplied `Storage` instance as the underlying config store\n */\nconst inMemoryConfigProvider = (storage) => {\n    if (storage !== undefined && storage !== null) {\n        return new CachedConfigProvider({\n            getRawConfig: (name) => {\n                var _a, _b;\n                try {\n                    return (_b = stronglyTypedParse((_a = storage.getItem(name)) !== null && _a !== void 0 ? _a : undefined)) === null || _b === void 0 ? void 0 : _b.raw;\n                }\n                catch (_c) { }\n                return undefined;\n            },\n        });\n    }\n    return NullConfigProvider;\n};\nfunction isPrimitiveType(type) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            return true;\n        default:\n            return false;\n    }\n}\n/**\n * Takes any supported config type, and returns the value with a strong type. If the type of\n * the config is not a supported type undefined will be returned.\n * The user of this function should cache the result to avoid duplicated work.\n *\n * Strings will be attempted to be parsed and coerced into a strong config type.\n * if it is not possible to parsed and coerce a string to a strong config type the original string\n * will be return with a string type for the consumer to handle further if necessary.\n */\nfunction stronglyTypedParse(input) {\n    let output = input;\n    let defaultReturn;\n    // we do special handling for strings to try and coerce\n    // them into a config type if we can. This makes it easy\n    // for config sources like sessionStorage which only\n    // holds strings\n    if (typeof input === \"string\") {\n        try {\n            output = JSON.parse(input);\n            // we succeeded in parsing, but we don't support parsing\n            // for any object as we can't do it type safely\n            // so in this case, the default return will be string\n            // rather than undefined, and the consumer\n            // can parse, as we don't want to provide\n            // a false sense of security by just\n            // casting.\n            defaultReturn = { raw: input, string: input };\n        }\n        catch (_a) { }\n    }\n    if (output === undefined) {\n        return defaultReturn;\n    }\n    const outputType = typeof output;\n    if (isPrimitiveType(outputType)) {\n        return Object.assign(Object.assign({}, defaultReturn), { raw: input, [outputType]: output });\n    }\n    if (Array.isArray(output)) {\n        const firstType = typeof output[0];\n        // ensure the first elements is a primitive type\n        if (!isPrimitiveType(firstType)) {\n            return defaultReturn;\n        }\n        // ensue all the elements types are homogeneous\n        // aka they all have the same type as the first\n        for (const v of output) {\n            if (typeof v !== firstType) {\n                return defaultReturn;\n            }\n        }\n        return Object.assign(Object.assign({}, defaultReturn), { raw: input, [`${firstType}[]`]: output });\n    }\n    return defaultReturn;\n}\n/** Referencing the `sessionStorage` variable can throw in some environments such as Node */\nconst safeSessionStorage = () => {\n    try {\n        return sessionStorage !== null ? sessionStorage : undefined;\n    }\n    catch (_a) {\n        return undefined;\n    }\n};\n/**\n * Implementation of {@link IConfigProvider} which contains nested {@link IConfigProviderBase} instances\n */\nclass CachedConfigProvider {\n    constructor(...orderedBaseProviders) {\n        this.configCache = new Map();\n        this.orderedBaseProviders = [];\n        const knownProviders = new Set();\n        const candidateProviders = [...orderedBaseProviders];\n        while (candidateProviders.length > 0) {\n            const baseProvider = candidateProviders.shift();\n            if (baseProvider !== undefined\n                && isConfigProviderBase(baseProvider)\n                && !knownProviders.has(baseProvider)) {\n                knownProviders.add(baseProvider);\n                if (baseProvider instanceof CachedConfigProvider) {\n                    candidateProviders.push(...baseProvider.orderedBaseProviders);\n                }\n                else {\n                    this.orderedBaseProviders.push(baseProvider);\n                }\n            }\n        }\n    }\n    getBoolean(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.boolean;\n    }\n    getNumber(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.number;\n    }\n    getString(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.string;\n    }\n    getBooleanArray(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a[\"boolean[]\"];\n    }\n    getNumberArray(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a[\"number[]\"];\n    }\n    getStringArray(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a[\"string[]\"];\n    }\n    getRawConfig(name) {\n        var _a;\n        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.raw;\n    }\n    getCacheEntry(name) {\n        if (!this.configCache.has(name)) {\n            for (const provider of this.orderedBaseProviders) {\n                const parsed = stronglyTypedParse(provider === null || provider === void 0 ? void 0 : provider.getRawConfig(name));\n                if (parsed !== undefined) {\n                    this.configCache.set(name, parsed);\n                    return parsed;\n                }\n            }\n            // configs are immutable, if the first lookup returned no results, all lookups should\n            this.configCache.set(name, { raw: undefined });\n        }\n        return this.configCache.get(name);\n    }\n}\nfunction loggerIsMonitoringContext(obj) {\n    const maybeConfig = obj;\n    return isConfigProviderBase(maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.config) && (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.logger) !== undefined;\n}\nfunction loggerToMonitoringContext(logger) {\n    if (loggerIsMonitoringContext(logger)) {\n        return logger;\n    }\n    return mixinMonitoringContext(logger, sessionStorageConfigProvider.value);\n}\nfunction mixinMonitoringContext(logger, ...configs) {\n    if (loggerIsMonitoringContext(logger)) {\n        throw new Error(\"Logger is already a monitoring context\");\n    }\n    /**\n     * this is the tricky bit we use for now to smuggle monitoring context around.\n     * To the logger we mixin both config and  itself, so mc.logger === logger as it is self-referential.\n     * We then expose it as a Monitoring context, so via types we hide the outer logger methods.\n     * To layers that expect just a logger we can pass mc.logger, but this is still a MonitoringContext\n     * so if a deeper layer then converts that logger to a monitoring context it can find the smuggled properties\n     * of the MonitoringContext and get the config provider.\n     */\n    const mc = logger;\n    mc.config = new CachedConfigProvider(...configs);\n    mc.logger = logger;\n    return mc;\n}\nfunction isConfigProviderBase(obj) {\n    const maybeConfig = obj;\n    return typeof (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.getRawConfig) === \"function\";\n}\n//# sourceMappingURL=config.js.map\n\n/***/ }),\n/* 47 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lazy\": () => (/* binding */ Lazy)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable\n  */\nclass Lazy {\n    /**\n     * Instantiates an instance of Lazy<T>\n     * @param valueGenerator - the function that will generate the value when value is accessed the first time\n     */\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this._evaluated = false;\n    }\n    /**\n     * Return true if the value as been generated, otherwise false\n     */\n    get evaluated() {\n        return this._evaluated;\n    }\n    /**\n     * Get the value. If this is the first call the value will be generated\n     */\n    get value() {\n        if (!this._evaluated) {\n            this._evaluated = true;\n            this._value = this.valueGenerator();\n        }\n        return this._value;\n    }\n}\n//# sourceMappingURL=lazy.js.map\n\n/***/ }),\n/* 48 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTelemetryNullLogger\": () => (/* binding */ BaseTelemetryNullLogger),\n/* harmony export */   \"TelemetryNullLogger\": () => (/* binding */ TelemetryNullLogger),\n/* harmony export */   \"extractLogSafeErrorProperties\": () => (/* binding */ extractLogSafeErrorProperties)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass BaseTelemetryNullLogger {\n    /**\n     * Send an event with the logger\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        return;\n    }\n}\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass TelemetryNullLogger {\n    send(event) {\n    }\n    sendTelemetryEvent(event, error) {\n    }\n    sendErrorEvent(event, error) {\n    }\n    sendPerformanceEvent(event, error) {\n    }\n}\nfunction extractLogSafeErrorProperties(error) {\n    const isRegularObject = (value) => {\n        return value !== null && !Array.isArray(value) && typeof value === \"object\";\n    };\n    const removeMessageFromStack = (stack, errorName) => {\n        const stackFrames = stack.split(\"\\n\");\n        stackFrames.shift(); // Remove \"[ErrorName]: [ErrorMessage]\"\n        if (errorName !== undefined) {\n            stackFrames.unshift(errorName); // Add \"[ErrorName]\"\n        }\n        return stackFrames.join(\"\\n\");\n    };\n    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\")\n        ? error.message\n        : String(error);\n    const safeProps = {\n        message,\n    };\n    if (isRegularObject(error)) {\n        const { errorType, stack, name } = error;\n        if (typeof errorType === \"string\") {\n            safeProps.errorType = errorType;\n        }\n        if (typeof stack === \"string\") {\n            const errorName = (typeof name === \"string\") ? name : undefined;\n            safeProps.stack = removeMessageFromStack(stack, errorName);\n        }\n    }\n    return safeProps;\n}\n//# sourceMappingURL=logger.js.map\n\n/***/ }),\n/* 49 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst performance = window.performance;\n//# sourceMappingURL=performanceBrowser.js.map\n\n/***/ }),\n/* 50 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SampledTelemetryHelper\": () => (/* binding */ SampledTelemetryHelper)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Helper class that executes a specified code block and writes an\n * {@link @fluidframework/common-definitions#ITelemetryPerformanceEvent} to a specified logger every time a specified\n * number of executions is reached (or when the class is disposed). The `duration` field in the telemetry event is\n * the duration of the latest execution (sample) of the specified function. See the documentation of the\n * `includeAggregateMetrics` parameter for additional details that can be included.\n */\nclass SampledTelemetryHelper {\n    /**\n     * @param eventBase -\n     * Custom properties to include in the telemetry performance event when it is written.\n     * @param logger -\n     * The logger to use to write the telemetry performance event.\n     * @param sampleThreshold -\n     * Telemetry performance events will be generated every time we hit this many executions of the code block.\n     * @param includeAggregateMetrics -\n     * If set to `true`, the telemetry performance event will include aggregated metrics (total duration, min duration,\n     * max duration) for all the executions in between generated events.\n     * @param perBucketProperties -\n     * Map of strings that represent different buckets (which can be specified when calling the 'measure' method), to\n     * properties which should be added to the telemetry event for that bucket. If a bucket being measured does not\n     * have an entry in this map, no additional properties will be added to its telemetry events. The following keys are\n     * reserved for use by this class: \"duration\", \"count\", \"totalDuration\", \"minDuration\", \"maxDuration\". If any of\n     * them is specified as a key in one of the ITelemetryProperties objects in this map, that key-value pair will be\n     * ignored.\n     */\n    constructor(eventBase, logger, sampleThreshold, includeAggregateMetrics = false, perBucketProperties = new Map()) {\n        this.eventBase = eventBase;\n        this.logger = logger;\n        this.sampleThreshold = sampleThreshold;\n        this.includeAggregateMetrics = includeAggregateMetrics;\n        this.perBucketProperties = perBucketProperties;\n        this.disposed = false;\n        this.measurementsMap = new Map();\n    }\n    /**\n     * @param codeToMeasure -\n     * The code to be executed and measured.\n     * @param bucket -\n     * A key to track executions of the code block separately. Each different value of this parameter has a separate\n     * set of executions and metrics tracked by the class. If no such distinction needs to be made, do not provide a\n     * value.\n     * @returns Whatever the passed-in code block returns.\n     */\n    measure(codeToMeasure, bucket = \"\") {\n        var _a, _b, _c;\n        const start = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        const returnValue = codeToMeasure();\n        const duration = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - start;\n        let m = this.measurementsMap.get(bucket);\n        if (m === undefined) {\n            m = { count: 0, duration: -1 };\n            this.measurementsMap.set(bucket, m);\n        }\n        m.count++;\n        m.duration = duration;\n        if (this.includeAggregateMetrics) {\n            m.totalDuration = ((_a = m.totalDuration) !== null && _a !== void 0 ? _a : 0) + duration;\n            m.minDuration = Math.min((_b = m.minDuration) !== null && _b !== void 0 ? _b : duration, duration);\n            m.maxDuration = Math.max((_c = m.maxDuration) !== null && _c !== void 0 ? _c : 0, duration);\n        }\n        if (m.count >= this.sampleThreshold) {\n            this.flushBucket(bucket);\n        }\n        return returnValue;\n    }\n    flushBucket(bucket) {\n        const measurements = this.measurementsMap.get(bucket);\n        if (measurements === undefined) {\n            return;\n        }\n        if (measurements.count !== 0) {\n            const bucketProperties = this.perBucketProperties.get(bucket);\n            const telemetryEvent = Object.assign(Object.assign(Object.assign({}, this.eventBase), bucketProperties), measurements);\n            this.logger.sendPerformanceEvent(telemetryEvent);\n            this.measurementsMap.delete(bucket);\n        }\n    }\n    dispose(error) {\n        this.measurementsMap.forEach((_, k) => this.flushBucket(k));\n    }\n}\n//# sourceMappingURL=sampledTelemetryHelper.js.map\n\n/***/ }),\n/* 51 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ClientSessionExpiredError\": () => (/* binding */ ClientSessionExpiredError),\n/* harmony export */   \"DataCorruptionError\": () => (/* binding */ DataCorruptionError),\n/* harmony export */   \"DataProcessingError\": () => (/* binding */ DataProcessingError),\n/* harmony export */   \"GenericError\": () => (/* binding */ GenericError),\n/* harmony export */   \"ThrottlingWarning\": () => (/* binding */ ThrottlingWarning),\n/* harmony export */   \"UsageError\": () => (/* binding */ UsageError),\n/* harmony export */   \"extractSafePropertiesFromMessage\": () => (/* binding */ extractSafePropertiesFromMessage)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Generic wrapper for an unrecognized/uncategorized error object\n */\nclass GenericError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    /**\n     * Create a new GenericError\n     * @param message - Error message\n     * @param error - inner error object\n     * @param props - Telemetry props to include when the error is logged\n     */\n    constructor(message, error, props) {\n        // Don't try to log the inner error\n        super(message, props, new Set([\"error\"]));\n        this.error = error;\n        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.genericError;\n    }\n}\n/**\n * Warning emitted when requests to storage are being throttled.\n */\nclass ThrottlingWarning extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, retryAfterSeconds, props) {\n        super(message, props);\n        this.retryAfterSeconds = retryAfterSeconds;\n        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.throttlingError;\n    }\n    /**\n     * Wrap the given error as a ThrottlingWarning\n     * Only preserves the error message, and applies the given retry after to the new warning object\n     */\n    static wrap(error, retryAfterSeconds, logger) {\n        const newErrorFn = (errMsg) => new ThrottlingWarning(errMsg, retryAfterSeconds);\n        return (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.wrapErrorAndLog)(error, newErrorFn, logger);\n    }\n}\n/** Error indicating an API is being used improperly resulting in an invalid operation. */\nclass UsageError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message) {\n        super(message, { usageError: true });\n        // TODO: implement IUsageError once available\n        this.errorType = \"usageError\";\n    }\n}\n/** Error indicating that a client's session has reached its time limit and is closed. */\nclass ClientSessionExpiredError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, expiryMs) {\n        super(message, { timeoutMs: expiryMs });\n        this.expiryMs = expiryMs;\n        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.clientSessionExpiredError;\n    }\n}\n/**\n * DataCorruptionError indicates that we encountered definitive evidence that the data at rest\n * backing this container is corrupted, and this container would never be expected to load properly again\n */\nclass DataCorruptionError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, props) {\n        super(message, Object.assign(Object.assign({}, props), { dataProcessingError: 1 }));\n        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataCorruptionError;\n        this.canRetry = false;\n    }\n}\n/**\n * DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service.\n * The error will often originate in the dataStore or DDS implementation that is responding to incoming changes.\n * This differs from DataCorruptionError in that this may be a transient error that will not repro in another\n * client or session.\n */\nclass DataProcessingError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(errorMessage) {\n        super(errorMessage);\n        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataProcessingError;\n        this.canRetry = false;\n    }\n    /** Create a new DataProcessingError detected and raised with the FF code */\n    static create(errorMessage, dataProcessingCodepath, sequencedMessage, props = {}) {\n        const dataProcessingError = DataProcessingError.wrapIfUnrecognized(errorMessage, dataProcessingCodepath, sequencedMessage);\n        dataProcessingError.addTelemetryProperties(props);\n        return dataProcessingError;\n    }\n    /**\n     * Wrap the given error in a DataProcessingError, unless the error is already of a known type.\n     * In either case, the error will have some relevant properties added for telemetry\n     * We wrap conditionally since known error types represent well-understood failure modes, and ideally\n     * one day we will move away from throwing these errors but rather we'll return them.\n     * But an unrecognized error needs to be classified as DataProcessingError.\n     * @param originalError - error to be converted\n     * @param dataProcessingCodepath - which codepath failed while processing data\n     * @param sequencedMessage - Sequenced message to include info about via telemetry props\n     * @returns Either a new DataProcessingError, or (if wrapping is deemed unnecessary) the given error\n     */\n    static wrapIfUnrecognized(originalError, dataProcessingCodepath, sequencedMessage) {\n        const props = Object.assign({ dataProcessingError: 1, dataProcessingCodepath }, (sequencedMessage === undefined ? undefined : extractSafePropertiesFromMessage(sequencedMessage)));\n        const normalizedError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.normalizeError)(originalError, { props });\n        if (!(0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.isExternalError)(normalizedError)) {\n            return normalizedError;\n        }\n        // Create a new DataProcessingError to wrap this external error\n        const dataProcessingError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.wrapError)(normalizedError, (message) => new DataProcessingError(message));\n        // Copy over the props above and any others added to this error since first being normalized\n        dataProcessingError.addTelemetryProperties(normalizedError.getTelemetryProperties());\n        return dataProcessingError;\n    }\n}\nconst extractSafePropertiesFromMessage = (message) => ({\n    messageClientId: message.clientId,\n    messageSequenceNumber: message.sequenceNumber,\n    messageClientSequenceNumber: message.clientSequenceNumber,\n    messageReferenceSequenceNumber: message.referenceSequenceNumber,\n    messageMinimumSequenceNumber: message.minimumSequenceNumber,\n    messageTimestamp: message.timestamp,\n});\n//# sourceMappingURL=error.js.map\n\n/***/ }),\n/* 52 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FluidSerializer\": () => (/* binding */ FluidSerializer),\n/* harmony export */   \"isSerializedHandle\": () => (/* binding */ isSerializedHandle)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\n/* harmony import */ var _remoteObjectHandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// RATIONALE: Many methods consume and return 'any' by necessity.\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n\nconst isSerializedHandle = (value) => (value === null || value === void 0 ? void 0 : value.type) === \"__fluid_handle__\";\n/**\n * Data Store serializer implementation\n */\nclass FluidSerializer {\n    constructor(context, \n    // To be called whenever a handle is parsed by this serializer.\n    handleParsedCb) {\n        this.context = context;\n        this.handleParsedCb = handleParsedCb;\n        // If the given 'value' is an IFluidHandle, returns the encoded IFluidHandle.\n        // Otherwise returns the original 'value'.  Used by 'encode()' and 'stringify()'.\n        this.encodeValue = (value, bind) => {\n            // Detect if 'value' is an IFluidHandle.\n            const handle = value === null || value === void 0 ? void 0 : value.IFluidHandle;\n            // If 'value' is an IFluidHandle return its encoded form.\n            return handle !== undefined\n                ? this.serializeHandle(handle, bind)\n                : value;\n        };\n        // If the given 'value' is an encoded IFluidHandle, returns the decoded IFluidHandle.\n        // Otherwise returns the original 'value'.  Used by 'decode()' and 'parse()'.\n        this.decodeValue = (value) => {\n            // If 'value' is a serialized IFluidHandle return the deserialized result.\n            if (isSerializedHandle(value)) {\n                // Old documents may have handles with relative path in their summaries. Convert these to absolute\n                // paths. This will ensure that future summaries will have absolute paths for these handles.\n                const absolutePath = value.url.startsWith(\"/\")\n                    ? value.url\n                    : (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(value.url, this.context);\n                const parsedHandle = new _remoteObjectHandle__WEBPACK_IMPORTED_MODULE_1__.RemoteFluidObjectHandle(absolutePath, this.root);\n                this.handleParsedCb(parsedHandle);\n                return parsedHandle;\n            }\n            else {\n                return value;\n            }\n        };\n        this.root = this.context;\n        while (this.root.routeContext !== undefined) {\n            this.root = this.root.routeContext;\n        }\n    }\n    get IFluidSerializer() { return this; }\n    /**\n     * Given a mostly-jsonable object tree that may have handle objects embedded within, will return a\n     * fully-jsonable object tree where any embedded IFluidHandles have been replaced with a serializable form.\n     *\n     * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from\n     * the root to any replaced handles.  (If no handles are found, returns the original object.)\n     *\n     * Any unbound handles encountered are bound to the provided IFluidHandle.\n     */\n    encode(input, bind) {\n        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,\n        // return the result of 'recursivelyReplace()'.\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        return !!input && typeof input === \"object\"\n            ? this.recursivelyReplace(input, this.encodeValue, bind)\n            : input;\n    }\n    /**\n     * Given a fully-jsonable object tree that may have encoded handle objects embedded within, will return an\n     * equivalent object tree where any encoded IFluidHandles have been replaced with their decoded form.\n     *\n     * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from\n     * the root to any replaced handles.  (If no handles are found, returns the original object.)\n     *\n     * The decoded handles are implicitly bound to the handle context of this serializer.\n     */\n    decode(input) {\n        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,\n        // return the result of 'recursivelyReplace()'.\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        return !!input && typeof input === \"object\"\n            ? this.recursivelyReplace(input, this.decodeValue)\n            : input;\n    }\n    stringify(input, bind) {\n        return JSON.stringify(input, (key, value) => this.encodeValue(value, bind));\n    }\n    // Parses the serialized data - context must match the context with which the JSON was stringified\n    parse(input) {\n        return JSON.parse(input, (key, value) => this.decodeValue(value));\n    }\n    // Invoked for non-null objects to recursively replace references to IFluidHandles.\n    // Clones as-needed to avoid mutating the `input` object.  If no IFluidHandes are present,\n    // returns the original `input`.\n    recursivelyReplace(input, replacer, context) {\n        // Note: Caller is responsible for ensuring that `input` is defined / non-null.\n        //       (Required for Object.keys() below.)\n        // Execute the `replace` on the current input.  Note that Caller is responsible for ensuring that `input`\n        // is a non-null object.\n        const maybeReplaced = replacer(input, context);\n        // If the replacer made a substitution there is no need to decscend further. IFluidHandles are always\n        // leaves in the object graph.\n        if (maybeReplaced !== input) {\n            return maybeReplaced;\n        }\n        // Otherwise descend into the object graph looking for IFluidHandle instances.\n        let clone;\n        for (const key of Object.keys(input)) {\n            const value = input[key];\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (!!value && typeof value === \"object\") {\n                // Note: Except for IFluidHandle, `input` must not contain circular references (as object must\n                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only\n                //       lead to a later error when attempting to stringify().\n                const replaced = this.recursivelyReplace(value, replacer, context);\n                // If the `replaced` object is different than the original `value` then the subgraph contained one\n                // or more handles.  If this happens, we need to return a clone of the `input` object where the\n                // current property is replaced by the `replaced` value.\n                if (replaced !== value) {\n                    // Lazily create a shallow clone of the `input` object if we haven't done so already.\n                    clone = clone !== null && clone !== void 0 ? clone : (Array.isArray(input)\n                        ? [...input]\n                        : Object.assign({}, input));\n                    // Overwrite the current property `key` in the clone with the `replaced` value.\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    clone[key] = replaced;\n                }\n            }\n        }\n        return clone !== null && clone !== void 0 ? clone : input;\n    }\n    serializeHandle(handle, bind) {\n        bind.bind(handle);\n        return {\n            type: \"__fluid_handle__\",\n            url: handle.absolutePath,\n        };\n    }\n}\n//# sourceMappingURL=serializer.js.map\n\n/***/ }),\n/* 53 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RemoteFluidObjectHandle\": () => (/* binding */ RemoteFluidObjectHandle)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);\n/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * This handle is used to dynamically load a Fluid object on a remote client and is created on parsing a serialized\n * FluidObjectHandle.\n * This class is used to generate an IFluidHandle when de-serializing any all handles (including handles to DDSes,\n * custom objects) that are stored in SharedObjects. The Data Store or SharedObject corresponding to the\n * IFluidHandle can be retrieved by calling `get` on it.\n */\nclass RemoteFluidObjectHandle {\n    /**\n     * Creates a new RemoteFluidObjectHandle when parsing an IFluidHandle.\n     * @param absolutePath - The absolute path to the handle from the container runtime.\n     * @param routeContext - The root IFluidHandleContext that has a route to this handle.\n     */\n    constructor(absolutePath, routeContext) {\n        this.absolutePath = absolutePath;\n        this.routeContext = routeContext;\n        this.isAttached = true;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(absolutePath.startsWith(\"/\"), 0x19d /* \"Handles should always have absolute paths\" */);\n    }\n    get IFluidRouter() { return this; }\n    get IFluidHandleContext() { return this; }\n    get IFluidHandle() { return this; }\n    async get() {\n        if (this.objectP === undefined) {\n            // Add `viaHandle` header to distinguish from requests from non-handle paths.\n            const request = { url: this.absolutePath, headers: { [_fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__.RuntimeHeaders.viaHandle]: true } };\n            this.objectP = this.routeContext.resolveHandle(request)\n                .then((response) => {\n                if (response.mimeType === \"fluid/object\") {\n                    const fluidObject = response.value;\n                    return fluidObject;\n                }\n                throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.responseToException)(response, request);\n            });\n        }\n        return this.objectP;\n    }\n    attachGraph() {\n        return;\n    }\n    bind(handle) {\n        handle.attachGraph();\n    }\n    async request(request) {\n        try {\n            const object = await this.get();\n            const router = object.IFluidRouter;\n            return router !== undefined\n                ? router.request(request)\n                : (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(request);\n        }\n        catch (error) {\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.exceptionToResponse)(error);\n        }\n    }\n}\n//# sourceMappingURL=remoteObjectHandle.js.map\n\n/***/ }),\n/* 54 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContainerMessageType\": () => (/* binding */ ContainerMessageType),\n/* harmony export */   \"ContainerRuntime\": () => (/* binding */ ContainerRuntime),\n/* harmony export */   \"DefaultSummaryConfiguration\": () => (/* binding */ DefaultSummaryConfiguration),\n/* harmony export */   \"RuntimeHeaders\": () => (/* binding */ RuntimeHeaders),\n/* harmony export */   \"RuntimeMessage\": () => (/* binding */ RuntimeMessage),\n/* harmony export */   \"ScheduleManager\": () => (/* binding */ ScheduleManager),\n/* harmony export */   \"agentSchedulerId\": () => (/* binding */ agentSchedulerId),\n/* harmony export */   \"getDeviceSpec\": () => (/* binding */ getDeviceSpec),\n/* harmony export */   \"isRuntimeMessage\": () => (/* binding */ isRuntimeMessage),\n/* harmony export */   \"unpackRuntimeMessage\": () => (/* binding */ unpackRuntimeMessage)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(119);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(70);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(102);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(133);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(46);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(132);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(120);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(64);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(77);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(106);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(24);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(25);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(134);\n/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(103);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(27);\n/* harmony import */ var _containerHandleContext__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(72);\n/* harmony import */ var _dataStoreRegistry__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(131);\n/* harmony import */ var _summarizer__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(115);\n/* harmony import */ var _summaryManager__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(125);\n/* harmony import */ var _deltaScheduler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69);\n/* harmony import */ var _connectionTelemetry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67);\n/* harmony import */ var _pendingStateManager__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(111);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);\n/* harmony import */ var _blobManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(110);\n/* harmony import */ var _dataStores__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(82);\n/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(76);\n/* harmony import */ var _summaryCollection__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(113);\n/* harmony import */ var _orderedClientElection__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(114);\n/* harmony import */ var _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(71);\n/* harmony import */ var _throttler__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(126);\n/* harmony import */ var _runWhileConnectedCoordinator__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(124);\n/* harmony import */ var _garbageCollection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(73);\n/* harmony import */ var _dataStore__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(101);\n/* harmony import */ var _batchTracker__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(127);\n/* harmony import */ var _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(129);\n/* harmony import */ var _opTelemetry__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(128);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ContainerMessageType;\n(function (ContainerMessageType) {\n    // An op to be delivered to store\n    ContainerMessageType[\"FluidDataStoreOp\"] = \"component\";\n    // Creates a new store\n    ContainerMessageType[\"Attach\"] = \"attach\";\n    // Chunked operation.\n    ContainerMessageType[\"ChunkedOp\"] = \"chunkedOp\";\n    // Signifies that a blob has been attached and should not be garbage collected by storage\n    ContainerMessageType[\"BlobAttach\"] = \"blobAttach\";\n    // Ties our new clientId to our old one on reconnect\n    ContainerMessageType[\"Rejoin\"] = \"rejoin\";\n    // Sets the alias of a root data store\n    ContainerMessageType[\"Alias\"] = \"alias\";\n})(ContainerMessageType || (ContainerMessageType = {}));\nconst DefaultSummaryConfiguration = {\n    state: \"enabled\",\n    idleTime: 5000 * 3,\n    maxTime: 5000 * 12,\n    maxOps: 100,\n    minOpsForLastSummaryAttempt: 10,\n    maxAckWaitTime: 6 * 10 * 1000,\n    maxOpsSinceLastSummary: 7000,\n    initialSummarizerDelayMs: 5000,\n    summarizerClientElection: false,\n};\n/**\n * Accepted header keys for requests coming to the runtime.\n */\nvar RuntimeHeaders;\n(function (RuntimeHeaders) {\n    /** True to wait for a data store to be created and loaded before returning it. */\n    RuntimeHeaders[\"wait\"] = \"wait\";\n    /**\n     * True if the request is from an external app. Used for GC to handle scenarios where a data store\n     * is deleted and requested via an external app.\n     */\n    RuntimeHeaders[\"externalRequest\"] = \"externalRequest\";\n    /** True if the request is coming from an IFluidHandle. */\n    RuntimeHeaders[\"viaHandle\"] = \"viaHandle\";\n})(RuntimeHeaders || (RuntimeHeaders = {}));\nconst useDataStoreAliasingKey = \"Fluid.ContainerRuntime.UseDataStoreAliasing\";\nconst maxConsecutiveReconnectsKey = \"Fluid.ContainerRuntime.MaxConsecutiveReconnects\";\n// Feature gate for the max op size. If the value is negative, chunking is enabled\n// and all ops over 16k would be chunked. If the value is positive, all ops with\n// a size strictly larger will be rejected and the container closed with an error.\nconst maxOpSizeInBytesKey = \"Fluid.ContainerRuntime.MaxOpSizeInBytes\";\n// By default, we should reject any op larger than 768KB,\n// in order to account for some extra overhead from serialization\n// to not reach the 1MB limits in socket.io and Kafka.\nconst defaultMaxOpSizeInBytes = 768000;\n// By default, the size of the contents for the incoming ops is tracked.\n// However, in certain situations, this may incur a performance hit.\n// The feature-gate below can be used to disable this feature.\nconst disableOpTrackingKey = \"Fluid.ContainerRuntime.DisableOpTracking\";\nconst defaultFlushMode = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased;\nvar RuntimeMessage;\n(function (RuntimeMessage) {\n    RuntimeMessage[\"FluidDataStoreOp\"] = \"component\";\n    RuntimeMessage[\"Attach\"] = \"attach\";\n    RuntimeMessage[\"ChunkedOp\"] = \"chunkedOp\";\n    RuntimeMessage[\"BlobAttach\"] = \"blobAttach\";\n    RuntimeMessage[\"Rejoin\"] = \"rejoin\";\n    RuntimeMessage[\"Alias\"] = \"alias\";\n    RuntimeMessage[\"Operation\"] = \"op\";\n})(RuntimeMessage || (RuntimeMessage = {}));\nfunction isRuntimeMessage(message) {\n    if (Object.values(RuntimeMessage).includes(message.type)) {\n        return true;\n    }\n    return false;\n}\nfunction unpackRuntimeMessage(message) {\n    if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.Operation) {\n        // legacy op format?\n        if (message.contents.address !== undefined && message.contents.type === undefined) {\n            message.type = ContainerMessageType.FluidDataStoreOp;\n        }\n        else {\n            // new format\n            const innerContents = message.contents;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(innerContents.type !== undefined, 0x121 /* \"Undefined inner contents type!\" */);\n            message.type = innerContents.type;\n            message.contents = innerContents.contents;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.isUnpackedRuntimeMessage)(message), 0x122 /* \"Message to unpack is not proper runtime message\" */);\n    }\n    else {\n        // Legacy format, but it's already \"unpacked\",\n        // i.e. message.type is actually ContainerMessageType.\n        // Nothing to do in such case.\n    }\n    return message;\n}\n/**\n * This class controls pausing and resuming of inbound queue to ensure that we never\n * start processing ops in a batch IF we do not have all ops in the batch.\n */\nclass ScheduleManagerCore {\n    constructor(deltaManager, logger) {\n        this.deltaManager = deltaManager;\n        this.logger = logger;\n        this.localPaused = false;\n        this.timePaused = 0;\n        this.batchCount = 0;\n        // Listen for delta manager sends and add batch metadata to messages\n        this.deltaManager.on(\"prepareSend\", (messages) => {\n            if (messages.length === 0) {\n                return;\n            }\n            // First message will have the batch flag set to true if doing a batched send\n            const firstMessageMetadata = messages[0].metadata;\n            if (!(firstMessageMetadata === null || firstMessageMetadata === void 0 ? void 0 : firstMessageMetadata.batch)) {\n                return;\n            }\n            // If the batch contains only a single op, clear the batch flag.\n            if (messages.length === 1) {\n                delete firstMessageMetadata.batch;\n                return;\n            }\n            // Set the batch flag to false on the last message to indicate the end of the send batch\n            const lastMessage = messages[messages.length - 1];\n            lastMessage.metadata = Object.assign(Object.assign({}, lastMessage.metadata), { batch: false });\n        });\n        // Listen for updates and peek at the inbound\n        this.deltaManager.inbound.on(\"push\", (message) => {\n            this.trackPending(message);\n        });\n        // Start with baseline - empty inbound queue.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x293 /* \"initial state\" */);\n        const allPending = this.deltaManager.inbound.toArray();\n        for (const pending of allPending) {\n            this.trackPending(pending);\n        }\n        // We are intentionally directly listening to the \"op\" to inspect system ops as well.\n        // If we do not observe system ops, we are likely to hit 0x296 assert when system ops\n        // precedes start of incomplete batch.\n        this.deltaManager.on(\"op\", (message) => this.afterOpProcessing(message.sequenceNumber));\n    }\n    /**\n     * The only public function in this class - called when we processed an op,\n     * to make decision if op processing should be paused or not afer that.\n     */\n    afterOpProcessing(sequenceNumber) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x294 /* \"can't have op processing paused if we are processing an op\" */);\n        // If the inbound queue is ever empty, nothing to do!\n        if (this.deltaManager.inbound.length === 0) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseSequenceNumber === undefined, 0x295 /* \"there should be no pending batch if we have no ops\" */);\n            return;\n        }\n        // The queue is\n        // 1. paused only when the next message to be processed is the beginning of a batch. Done in two places:\n        //    - here (processing ops until reaching start of incomplete batch)\n        //    - in trackPending(), when queue was empty and start of batch showed up.\n        // 2. resumed when batch end comes in (in trackPending())\n        // do we have incomplete batch to worry about?\n        if (this.pauseSequenceNumber !== undefined) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(sequenceNumber < this.pauseSequenceNumber, 0x296 /* \"we should never start processing incomplete batch!\" */);\n            // If the next op is the start of incomplete batch, then we can't process it until it's fully in - pause!\n            if (sequenceNumber + 1 === this.pauseSequenceNumber) {\n                this.pauseQueue();\n            }\n        }\n    }\n    pauseQueue() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x297 /* \"always called from resumed state\" */);\n        this.localPaused = true;\n        this.timePaused = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.performance.now();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.deltaManager.inbound.pause();\n    }\n    resumeQueue(startBatch, messageEndBatch) {\n        const endBatch = messageEndBatch.sequenceNumber;\n        const duration = this.localPaused ? (_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.performance.now() - this.timePaused) : undefined;\n        this.batchCount++;\n        if (this.batchCount % 1000 === 1) {\n            this.logger.sendTelemetryEvent({\n                eventName: \"BatchStats\",\n                sequenceNumber: endBatch,\n                length: endBatch - startBatch + 1,\n                msnDistance: endBatch - messageEndBatch.minimumSequenceNumber,\n                duration,\n                batchCount: this.batchCount,\n                interrupted: this.localPaused,\n            });\n        }\n        // Return early if no change in value\n        if (!this.localPaused) {\n            return;\n        }\n        this.localPaused = false;\n        // Random round number - we want to know when batch waiting paused op processing.\n        if (duration !== undefined && duration > _connectionTelemetry__WEBPACK_IMPORTED_MODULE_5__.latencyThreshold) {\n            this.logger.sendErrorEvent({\n                eventName: \"MaxBatchWaitTimeExceeded\",\n                duration,\n                sequenceNumber: endBatch,\n                length: endBatch - startBatch,\n            });\n        }\n        this.deltaManager.inbound.resume();\n    }\n    /**\n     * Called for each incoming op (i.e. inbound \"push\" notification)\n     */\n    trackPending(message) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.deltaManager.inbound.length !== 0, 0x298 /* \"we have something in the queue that generates this event\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)((this.currentBatchClientId === undefined) === (this.pauseSequenceNumber === undefined), 0x299 /* \"non-synchronized state\" */);\n        const metadata = message.metadata;\n        const batchMetadata = metadata === null || metadata === void 0 ? void 0 : metadata.batch;\n        // Protocol messages are never part of a runtime batch of messages\n        if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.isUnpackedRuntimeMessage)(message)) {\n            // Protocol messages should never show up in the middle of the batch!\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.currentBatchClientId === undefined, 0x29a /* \"System message in the middle of batch!\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchMetadata === undefined, 0x29b /* \"system op in a batch?\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x29c /* \"we should be processing ops when there is no active batch\" */);\n            return;\n        }\n        if (this.currentBatchClientId === undefined && batchMetadata === undefined) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x29d /* \"we should be processing ops when there is no active batch\" */);\n            return;\n        }\n        // If the client ID changes then we can move the pause point. If it stayed the same then we need to check.\n        // If batchMetadata is not undefined then if it's true we've begun a new batch - if false we've ended\n        // the previous one\n        if (this.currentBatchClientId !== undefined || batchMetadata === false) {\n            if (this.currentBatchClientId !== message.clientId) {\n                // \"Batch not closed, yet message from another client!\"\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError(\"OpBatchIncomplete\", Object.assign({ runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion, batchClientId: this.currentBatchClientId }, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.extractSafePropertiesFromMessage)(message)));\n            }\n        }\n        // The queue is\n        // 1. paused only when the next message to be processed is the beginning of a batch. Done in two places:\n        //    - in afterOpProcessing() - processing ops until reaching start of incomplete batch\n        //    - here (batchMetadata == false below), when queue was empty and start of batch showed up.\n        // 2. resumed when batch end comes in (batchMetadata === true case below)\n        if (batchMetadata) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.currentBatchClientId === undefined, 0x29e /* \"there can't be active batch\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x29f /* \"we should be processing ops when there is no active batch\" */);\n            this.pauseSequenceNumber = message.sequenceNumber;\n            this.currentBatchClientId = message.clientId;\n            // Start of the batch\n            // Only pause processing if queue has no other ops!\n            // If there are any other ops in the queue, processing will be stopped when they are processed!\n            if (this.deltaManager.inbound.length === 1) {\n                this.pauseQueue();\n            }\n        }\n        else if (batchMetadata === false) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseSequenceNumber !== undefined, 0x2a0 /* \"batch presence was validated above\" */);\n            // Batch is complete, we can process it!\n            this.resumeQueue(this.pauseSequenceNumber, message);\n            this.pauseSequenceNumber = undefined;\n            this.currentBatchClientId = undefined;\n        }\n        else {\n            // Continuation of current batch. Do nothing\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.currentBatchClientId !== undefined, 0x2a1 /* \"logic error\" */);\n        }\n    }\n}\n/**\n * This class has the following responsibilities:\n * 1. It tracks batches as we process ops and raises \"batchBegin\" and \"batchEnd\" events.\n *    As part of it, it validates batch correctness (i.e. no system ops in the middle of batch)\n * 2. It creates instance of ScheduleManagerCore that ensures we never start processing ops from batch\n *    unless all ops of the batch are in.\n */\nclass ScheduleManager {\n    constructor(deltaManager, emitter, logger) {\n        this.deltaManager = deltaManager;\n        this.emitter = emitter;\n        this.logger = logger;\n        this.hitError = false;\n        this.deltaScheduler = new _deltaScheduler__WEBPACK_IMPORTED_MODULE_8__.DeltaScheduler(this.deltaManager, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, \"DeltaScheduler\"));\n        void new ScheduleManagerCore(deltaManager, logger);\n    }\n    beforeOpProcessing(message) {\n        var _a;\n        if (this.batchClientId !== message.clientId) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.batchClientId === undefined, 0x2a2 /* \"Batch is interrupted by other client op. Should be caught by trackPending()\" */);\n            // This could be the beginning of a new batch or an individual message.\n            this.emitter.emit(\"batchBegin\", message);\n            this.deltaScheduler.batchBegin(message);\n            const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n            if (batch) {\n                this.batchClientId = message.clientId;\n            }\n            else {\n                this.batchClientId = undefined;\n            }\n        }\n    }\n    afterOpProcessing(error, message) {\n        var _a;\n        // If this is no longer true, we need to revisit what we do where we set this.hitError.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.hitError, 0x2a3 /* \"container should be closed on any error\" */);\n        if (error) {\n            // We assume here that loader will close container and stop processing all future ops.\n            // This is implicit dependency. If this flow changes, this code might no longer be correct.\n            this.hitError = true;\n            this.batchClientId = undefined;\n            this.emitter.emit(\"batchEnd\", error, message);\n            this.deltaScheduler.batchEnd(message);\n            return;\n        }\n        const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n        // If no batchClientId has been set then we're in an individual batch. Else, if we get\n        // batch end metadata, this is end of the current batch.\n        if (this.batchClientId === undefined || batch === false) {\n            this.batchClientId = undefined;\n            this.emitter.emit(\"batchEnd\", undefined, message);\n            this.deltaScheduler.batchEnd(message);\n            return;\n        }\n    }\n}\n/**\n * Legacy ID for the built-in AgentScheduler.  To minimize disruption while removing it, retaining this as a\n * special-case for document dirty state.  Ultimately we should have no special-cases from the\n * ContainerRuntime's perspective.\n */\nconst agentSchedulerId = \"_scheduler\";\n// safely check navigator and get the hardware spec value\nfunction getDeviceSpec() {\n    try {\n        if (typeof navigator === \"object\" && navigator !== null) {\n            return {\n                deviceMemory: navigator.deviceMemory,\n                hardwareConcurrency: navigator.hardwareConcurrency,\n            };\n        }\n    }\n    catch (_a) {\n    }\n    return {};\n}\n/**\n * Represents the runtime of the container. Contains helper functions/state of the container.\n * It will define the store level mappings.\n */\nclass ContainerRuntime extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_10__.TypedEventEmitter {\n    constructor(context, registry, metadata, electedSummarizerData, chunks, dataStoreAliasMap, runtimeOptions, containerScope, logger, existing, blobManagerSnapshot, _storage, requestHandler, summaryConfiguration) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (summaryConfiguration === void 0) { summaryConfiguration = Object.assign(Object.assign({}, DefaultSummaryConfiguration), (_a = runtimeOptions.summaryOptions) === null || _a === void 0 ? void 0 : _a.summaryConfigOverrides); }\n        super();\n        this.context = context;\n        this.registry = registry;\n        this.runtimeOptions = runtimeOptions;\n        this.containerScope = containerScope;\n        this.logger = logger;\n        this._storage = _storage;\n        this.requestHandler = requestHandler;\n        this.summaryConfiguration = summaryConfiguration;\n        this.defaultMaxConsecutiveReconnects = 15;\n        this._orderSequentiallyCalls = 0;\n        this.needsFlush = false;\n        this.flushTrigger = false;\n        this.savedOps = [];\n        this.consecutiveReconnects = 0;\n        this._disposed = false;\n        this.emitDirtyDocumentEvent = true;\n        this.defaultTelemetrySignalSampleCount = 100;\n        this._perfSignalData = {\n            signalsLost: 0,\n            signalSequenceNumber: 0,\n            signalTimestamp: 0,\n            trackingSignalSequenceNumber: undefined,\n        };\n        this.summarizeOnDemand = (...args) => {\n            if (this.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType) {\n                return this.summarizer.summarizeOnDemand(...args);\n            }\n            else if (this.summaryManager !== undefined) {\n                return this.summaryManager.summarizeOnDemand(...args);\n            }\n            else {\n                // If we're not the summarizer, and we don't have a summaryManager, we expect that\n                // disableSummaries is turned on. We are throwing instead of returning a failure here,\n                // because it is a misuse of the API rather than an expected failure.\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Can't summarize, disableSummaries: ${this.summariesDisabled}`);\n            }\n        };\n        this.enqueueSummarize = (...args) => {\n            if (this.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType) {\n                return this.summarizer.enqueueSummarize(...args);\n            }\n            else if (this.summaryManager !== undefined) {\n                return this.summaryManager.enqueueSummarize(...args);\n            }\n            else {\n                // If we're not the summarizer, and we don't have a summaryManager, we expect that\n                // generateSummaries is turned off. We are throwing instead of returning a failure here,\n                // because it is a misuse of the API rather than an expected failure.\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Can't summarize, disableSummaries: ${this.summariesDisabled}`);\n            }\n        };\n        this.messageAtLastSummary = metadata === null || metadata === void 0 ? void 0 : metadata.message;\n        // Default to false (enabled).\n        this.disableIsolatedChannels = (_b = this.runtimeOptions.summaryOptions.disableIsolatedChannels) !== null && _b !== void 0 ? _b : false;\n        this._connected = this.context.connected;\n        this.chunkMap = new Map(chunks);\n        this.handleContext = new _containerHandleContext__WEBPACK_IMPORTED_MODULE_12__.ContainerFluidHandleContext(\"\", this);\n        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, \"ContainerRuntime\"));\n        this.summariesDisabled = this.isSummariesDisabled();\n        this.heuristicsDisabled = this.isHeuristicsDisabled();\n        this.summarizerClientElectionEnabled = this.isSummarizerClientElectionEnabled();\n        this.maxOpsSinceLastSummary = this.getMaxOpsSinceLastSummary();\n        this.initialSummarizerDelayMs = this.getInitialSummarizerDelayMs();\n        this._aliasingEnabled =\n            ((_c = this.mc.config.getBoolean(useDataStoreAliasingKey)) !== null && _c !== void 0 ? _c : false) ||\n                ((_d = runtimeOptions.useDataStoreAliasing) !== null && _d !== void 0 ? _d : false);\n        this._maxOpSizeInBytes = ((_e = this.mc.config.getNumber(maxOpSizeInBytesKey)) !== null && _e !== void 0 ? _e : defaultMaxOpSizeInBytes);\n        this.maxConsecutiveReconnects =\n            (_f = this.mc.config.getNumber(maxConsecutiveReconnectsKey)) !== null && _f !== void 0 ? _f : this.defaultMaxConsecutiveReconnects;\n        this._flushMode = runtimeOptions.flushMode;\n        const pendingRuntimeState = context.pendingLocalState;\n        const baseSnapshot = (_g = pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.baseSnapshot) !== null && _g !== void 0 ? _g : context.baseSnapshot;\n        this.garbageCollector = _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GarbageCollector.create({\n            runtime: this,\n            gcOptions: this.runtimeOptions.gcOptions,\n            baseSnapshot,\n            baseLogger: this.mc.logger,\n            existing,\n            metadata,\n            isSummarizerClient: this.context.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType,\n            getNodePackagePath: async (nodePath) => this.getGCNodePackagePath(nodePath),\n            getLastSummaryTimestampMs: () => { var _a; return (_a = this.messageAtLastSummary) === null || _a === void 0 ? void 0 : _a.timestamp; },\n            readAndParseBlob: async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(this.storage, id),\n        });\n        const loadedFromSequenceNumber = this.deltaManager.initialSequenceNumber;\n        this.summarizerNode = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.createRootSummarizerNodeWithGC)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, \"SummarizerNode\"), \n        // Summarize function to call when summarize is called. Summarizer node always tracks summary state.\n        async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext), \n        // Latest change sequence number, no changes since summary applied yet\n        loadedFromSequenceNumber, \n        // Summary reference sequence number, undefined if no summary yet\n        baseSnapshot ? loadedFromSequenceNumber : undefined, {\n            // Must set to false to prevent sending summary handle which would be pointing to\n            // a summary with an older protocol state.\n            canReuseHandle: false,\n            // Must set to true to throw on any data stores failure that was too severe to be handled.\n            // We also are not decoding the base summaries at the root.\n            throwOnFailure: true,\n            // If GC should not run, let the summarizer node know so that it does not track GC state.\n            gcDisabled: !this.garbageCollector.shouldRunGC,\n        });\n        if (baseSnapshot) {\n            this.summarizerNode.loadBaseSummaryWithoutDifferential(baseSnapshot);\n        }\n        this.dataStores = new _dataStores__WEBPACK_IMPORTED_MODULE_17__.DataStores((0,_dataStores__WEBPACK_IMPORTED_MODULE_17__.getSummaryForDatastores)(baseSnapshot, metadata), this, (attachMsg) => this.submit(ContainerMessageType.Attach, attachMsg), (id, createParam) => (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, undefined, getGCDataFn, getBaseGCDetailsFn), (id) => this.summarizerNode.deleteChild(id), this.mc.logger, async () => this.garbageCollector.getBaseGCDetails(), (path, timestampMs, packagePath) => this.garbageCollector.nodeUpdated(path, \"Changed\", timestampMs, packagePath), new Map(dataStoreAliasMap), this.garbageCollector.writeDataAtRoot);\n        this.blobManager = new _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager(this.handleContext, blobManagerSnapshot, () => this.storage, (blobId) => this.submit(ContainerMessageType.BlobAttach, undefined, undefined, { blobId }), (blobPath) => this.garbageCollector.nodeUpdated(blobPath, \"Loaded\"), this, this.logger);\n        this.scheduleManager = new ScheduleManager(context.deltaManager, this, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, \"ScheduleManager\"));\n        this.deltaSender = this.deltaManager;\n        this.pendingStateManager = new _pendingStateManager__WEBPACK_IMPORTED_MODULE_19__.PendingStateManager({\n            applyStashedOp: this.applyStashedOp.bind(this),\n            clientId: () => this.clientId,\n            close: this.closeFn,\n            connected: () => this.connected,\n            flush: this.flush.bind(this),\n            flushMode: () => this.flushMode,\n            reSubmit: this.reSubmit.bind(this),\n            rollback: this.rollback.bind(this),\n            setFlushMode: (mode) => this.setFlushMode(mode),\n        }, this._flushMode, pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.pending);\n        this.context.quorum.on(\"removeMember\", (clientId) => {\n            this.clearPartialChunks(clientId);\n        });\n        this.summaryCollection = new _summaryCollection__WEBPACK_IMPORTED_MODULE_20__.SummaryCollection(this.deltaManager, this.logger);\n        this.dirtyContainer = this.context.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached\n            || this.pendingStateManager.hasPendingMessages();\n        this.context.updateDirtyContainerState(this.dirtyContainer);\n        if (this.summariesDisabled) {\n            this.mc.logger.sendTelemetryEvent({ eventName: \"SummariesDisabled\" });\n        }\n        else {\n            const orderedClientLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, \"OrderedClientElection\");\n            const orderedClientCollection = new _orderedClientElection__WEBPACK_IMPORTED_MODULE_22__.OrderedClientCollection(orderedClientLogger, this.context.deltaManager, this.context.quorum);\n            const orderedClientElectionForSummarizer = new _orderedClientElection__WEBPACK_IMPORTED_MODULE_22__.OrderedClientElection(orderedClientLogger, orderedClientCollection, electedSummarizerData !== null && electedSummarizerData !== void 0 ? electedSummarizerData : this.context.deltaManager.lastSequenceNumber, _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.SummarizerClientElection.isClientEligible);\n            this.summarizerClientElection = new _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.SummarizerClientElection(orderedClientLogger, this.summaryCollection, orderedClientElectionForSummarizer, this.maxOpsSinceLastSummary, this.summarizerClientElectionEnabled);\n            if (this.context.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType) {\n                this._summarizer = new _summarizer__WEBPACK_IMPORTED_MODULE_23__.Summarizer(\"/_summarizer\", this /* ISummarizerRuntime */, () => this.summaryConfiguration, this /* ISummarizerInternalsProvider */, this.handleContext, this.summaryCollection, async (runtime) => _runWhileConnectedCoordinator__WEBPACK_IMPORTED_MODULE_24__.RunWhileConnectedCoordinator.create(runtime));\n            }\n            else if (_summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.SummarizerClientElection.clientDetailsPermitElection(this.context.clientDetails)) {\n                // Only create a SummaryManager and SummarizerClientElection\n                // if summaries are enabled and we are not the summarizer client.\n                const defaultAction = () => {\n                    if (this.summaryCollection.opsSinceLastAck > this.maxOpsSinceLastSummary) {\n                        this.logger.sendErrorEvent({ eventName: \"SummaryStatus:Behind\" });\n                        // unregister default to no log on every op after falling behind\n                        // and register summary ack handler to re-register this handler\n                        // after successful summary\n                        this.summaryCollection.once(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.SummaryAck, () => {\n                            this.logger.sendTelemetryEvent({ eventName: \"SummaryStatus:CaughtUp\" });\n                            // we've caught up, so re-register the default action to monitor for\n                            // falling behind, and unregister ourself\n                            this.summaryCollection.on(\"default\", defaultAction);\n                        });\n                        this.summaryCollection.off(\"default\", defaultAction);\n                    }\n                };\n                this.summaryCollection.on(\"default\", defaultAction);\n                // Create the SummaryManager and mark the initial state\n                this.summaryManager = new _summaryManager__WEBPACK_IMPORTED_MODULE_25__.SummaryManager(this.summarizerClientElection, this, // IConnectedState\n                this.summaryCollection, this.logger, this.formRequestSummarizerFn(this.context.loader), new _throttler__WEBPACK_IMPORTED_MODULE_26__.Throttler(60 * 1000, // 60 sec delay window\n                30 * 1000, // 30 sec max delay\n                // throttling function increases exponentially (0ms, 40ms, 80ms, 160ms, etc)\n                (0,_throttler__WEBPACK_IMPORTED_MODULE_26__.formExponentialFn)({ coefficient: 20, initialDelay: 0 })), {\n                    initialDelayMs: this.initialSummarizerDelayMs,\n                }, this.heuristicsDisabled);\n                this.summaryManager.start();\n            }\n        }\n        this.deltaManager.on(\"readonly\", (readonly) => {\n            // we accumulate ops while being in read-only state.\n            // once user gets write permissions and we have active connection, flush all pending ops.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(readonly === this.deltaManager.readOnlyInfo.readonly, 0x124 /* \"inconsistent readonly property/event state\" */);\n            // We need to be very careful with when we (re)send pending ops, to ensure that we only send ops\n            // when we either never send an op, or attempted to send it but we know for sure it was not\n            // sequenced by server and will never be sequenced (i.e. was lost)\n            // For loss of connection, we wait for our own \"join\" op and use it a a barrier to know all the\n            // ops that made it from previous connection, before switching clientId and raising \"connected\" event\n            // But with read-only permissions, if we transition between read-only and r/w states while on same\n            // connection, then we have no good signal to tell us when it's safe to send ops we accumulated while\n            // being in read-only state.\n            // For that reason, we support getting to read-only state only when disconnected. This ensures that we\n            // can rely on same safety mechanism and resend ops only when we establish new connection.\n            // This is applicable for read-only permissions (event is raised before connection is properly registered),\n            // but it's an extra requirement for Container.forceReadonly() API\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!readonly || !this.connected, 0x125 /* \"Unsafe to transition to read-only state!\" */);\n            this.replayPendingStates();\n        });\n        // logging hardware telemetry\n        logger.sendTelemetryEvent(Object.assign({ eventName: \"DeviceSpec\" }, getDeviceSpec()));\n        let loadSummaryNumber;\n        // Get the container creation metadata. For new container, we initialize these. For existing containers,\n        // get the values from the metadata blob.\n        if (existing) {\n            this.createContainerMetadata = {\n                createContainerRuntimeVersion: metadata === null || metadata === void 0 ? void 0 : metadata.createContainerRuntimeVersion,\n                createContainerTimestamp: metadata === null || metadata === void 0 ? void 0 : metadata.createContainerTimestamp,\n            };\n            // back-compat 0.59.3000 - Older document may either write summaryCount or not write it at all. If it does\n            // not write it, initialize summaryNumber to 0.\n            loadSummaryNumber = (_j = (_h = metadata === null || metadata === void 0 ? void 0 : metadata.summaryNumber) !== null && _h !== void 0 ? _h : metadata === null || metadata === void 0 ? void 0 : metadata.summaryCount) !== null && _j !== void 0 ? _j : 0;\n        }\n        else {\n            this.createContainerMetadata = {\n                createContainerRuntimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion,\n                createContainerTimestamp: Date.now(),\n            };\n            loadSummaryNumber = 0;\n        }\n        this.nextSummaryNumber = loadSummaryNumber + 1;\n        this.logger.sendTelemetryEvent(Object.assign(Object.assign(Object.assign({ eventName: \"ContainerLoadStats\" }, this.createContainerMetadata), this.dataStores.containerLoadStats), { summaryNumber: loadSummaryNumber, summaryFormatVersion: metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion, disableIsolatedChannels: metadata === null || metadata === void 0 ? void 0 : metadata.disableIsolatedChannels, gcVersion: metadata === null || metadata === void 0 ? void 0 : metadata.gcFeature }));\n        (0,_connectionTelemetry__WEBPACK_IMPORTED_MODULE_5__.ReportOpPerfTelemetry)(this.context.clientId, this.deltaManager, this.logger);\n        (0,_batchTracker__WEBPACK_IMPORTED_MODULE_27__.BindBatchTracker)(this, this.logger);\n        this.opTracker = new _opTelemetry__WEBPACK_IMPORTED_MODULE_28__.OpTracker(this.deltaManager, this.mc.config.getBoolean(disableOpTrackingKey) === true);\n    }\n    get IContainerRuntime() { return this; }\n    get IFluidRouter() { return this; }\n    /**\n     * Load the stores from a snapshot and returns the runtime.\n     * @param context - Context of the container.\n     * @param registryEntries - Mapping to the stores.\n     * @param requestHandler - Request handlers for the container runtime\n     * @param runtimeOptions - Additional options to be passed to the runtime\n     * @param existing - (optional) When loading from an existing snapshot. Precedes context.existing if provided\n     */\n    static async load(context, registryEntries, requestHandler, runtimeOptions = {}, containerScope = context.scope, existing) {\n        var _a, _b, _c;\n        // If taggedLogger exists, use it. Otherwise, wrap the vanilla logger:\n        // back-compat: Remove the TaggedLoggerAdapter fallback once all the host are using loader > 0.45\n        const backCompatContext = context;\n        const passLogger = (_a = backCompatContext.taggedLogger) !== null && _a !== void 0 ? _a : new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TaggedLoggerAdapter(backCompatContext.logger);\n        const logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(passLogger, undefined, {\n            all: {\n                runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion,\n            },\n        });\n        const { summaryOptions = {}, gcOptions = {}, loadSequenceNumberVerification = \"close\", useDataStoreAliasing = false, flushMode = defaultFlushMode, enableOfflineLoad = false, } = runtimeOptions;\n        const pendingRuntimeState = context.pendingLocalState;\n        const baseSnapshot = (_b = pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.baseSnapshot) !== null && _b !== void 0 ? _b : context.baseSnapshot;\n        const storage = !pendingRuntimeState ?\n            context.storage :\n            new _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__.SerializedSnapshotStorage(() => { return context.storage; }, pendingRuntimeState.snapshotBlobs);\n        const registry = new _dataStoreRegistry__WEBPACK_IMPORTED_MODULE_30__.FluidDataStoreRegistry(registryEntries);\n        const tryFetchBlob = async (blobName) => {\n            const blobId = baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.blobs[blobName];\n            if (baseSnapshot && blobId) {\n                // IContainerContext storage api return type still has undefined in 0.39 package version.\n                // So once we release 0.40 container-defn package we can remove this check.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(storage !== undefined, 0x1f5 /* \"Attached state should have storage\" */);\n                return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(storage, blobId);\n            }\n        };\n        const [chunks, metadata, electedSummarizerData, aliases] = await Promise.all([\n            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.chunksBlobName),\n            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.metadataBlobName),\n            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.electedSummarizerBlobName),\n            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.aliasBlobName),\n        ]);\n        const loadExisting = existing === true || context.existing === true;\n        // read snapshot blobs needed for BlobManager to load\n        const blobManagerSnapshot = await _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.load(baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.blobsTreeName], async (id) => {\n            // IContainerContext storage api return type still has undefined in 0.39 package version.\n            // So once we release 0.40 container-defn package we can remove this check.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(storage !== undefined, 0x256 /* \"storage undefined in attached container\" */);\n            return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(storage, id);\n        });\n        // Verify summary runtime sequence number matches protocol sequence number.\n        const runtimeSequenceNumber = (_c = metadata === null || metadata === void 0 ? void 0 : metadata.message) === null || _c === void 0 ? void 0 : _c.sequenceNumber;\n        // When we load with pending state, we reuse an old snapshot so we don't expect these numbers to match\n        if (!pendingRuntimeState && runtimeSequenceNumber !== undefined) {\n            const protocolSequenceNumber = context.deltaManager.initialSequenceNumber;\n            // Unless bypass is explicitly set, then take action when sequence numbers mismatch.\n            if (loadSequenceNumberVerification !== \"bypass\" && runtimeSequenceNumber !== protocolSequenceNumber) {\n                // \"Load from summary, runtime metadata sequenceNumber !== initialSequenceNumber\"\n                const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError(\n                // pre-0.58 error message: SummaryMetadataMismatch\n                \"Summary metadata mismatch\", { runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion, runtimeSequenceNumber, protocolSequenceNumber });\n                if (loadSequenceNumberVerification === \"log\") {\n                    logger.sendErrorEvent({ eventName: \"SequenceNumberMismatch\" }, error);\n                }\n                else {\n                    context.closeFn(error);\n                }\n            }\n        }\n        const runtime = new ContainerRuntime(context, registry, metadata, electedSummarizerData, chunks !== null && chunks !== void 0 ? chunks : [], aliases !== null && aliases !== void 0 ? aliases : [], {\n            summaryOptions,\n            gcOptions,\n            loadSequenceNumberVerification,\n            useDataStoreAliasing,\n            flushMode,\n            enableOfflineLoad,\n        }, containerScope, logger, loadExisting, blobManagerSnapshot, storage, requestHandler);\n        if (pendingRuntimeState) {\n            await runtime.processSavedOps(pendingRuntimeState);\n            // delete these once runtime has seen them to save space\n            pendingRuntimeState.savedOps = [];\n        }\n        await runtime.getSnapshotBlobs();\n        return runtime;\n    }\n    get options() {\n        return this.context.options;\n    }\n    get clientId() {\n        return this.context.clientId;\n    }\n    get clientDetails() {\n        return this.context.clientDetails;\n    }\n    get deltaManager() {\n        return this.context.deltaManager;\n    }\n    get storage() {\n        return this._storage;\n    }\n    get reSubmitFn() {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        return this.reSubmit;\n    }\n    get closeFn() {\n        return this.context.closeFn;\n    }\n    get flushMode() {\n        return this._flushMode;\n    }\n    get scope() {\n        return this.containerScope;\n    }\n    get IFluidDataStoreRegistry() {\n        return this.registry;\n    }\n    get attachState() {\n        return this.context.attachState;\n    }\n    get IFluidHandleContext() {\n        return this.handleContext;\n    }\n    get connected() {\n        return this._connected;\n    }\n    /** clientId of parent (non-summarizing) container that owns summarizer container */\n    get summarizerClientId() {\n        var _a;\n        return (_a = this.summarizerClientElection) === null || _a === void 0 ? void 0 : _a.electedClientId;\n    }\n    get disposed() { return this._disposed; }\n    get summarizer() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this._summarizer !== undefined, 0x257 /* \"This is not summarizing container\" */);\n        return this._summarizer;\n    }\n    isSummariesDisabled() {\n        // back-compat: disableSummaries was moved from ISummaryRuntimeOptions\n        //   to ISummaryConfiguration in 0.60.\n        if (this.runtimeOptions.summaryOptions.disableSummaries === true) {\n            return true;\n        }\n        return this.summaryConfiguration.state === \"disabled\";\n    }\n    isHeuristicsDisabled() {\n        var _a;\n        // back-compat: disableHeuristics was moved from ISummarizerOptions\n        //   to ISummaryConfiguration in 0.60.\n        if (((_a = this.runtimeOptions.summaryOptions.summarizerOptions) === null || _a === void 0 ? void 0 : _a.disableHeuristics) === true) {\n            return true;\n        }\n        return this.summaryConfiguration.state === \"disableHeuristics\";\n    }\n    isSummarizerClientElectionEnabled() {\n        var _a;\n        if (this.mc.config.getBoolean(\"Fluid.ContainerRuntime.summarizerClientElection\")) {\n            return (_a = this.mc.config.getBoolean(\"Fluid.ContainerRuntime.summarizerClientElection\")) !== null && _a !== void 0 ? _a : true;\n        }\n        // back-compat: summarizerClientElection was moved from ISummaryRuntimeOptions\n        //   to ISummaryConfiguration in 0.60.\n        if (this.runtimeOptions.summaryOptions.summarizerClientElection === true) {\n            return true;\n        }\n        if (this.summaryConfiguration.state !== \"disabled\") {\n            return this.summaryConfiguration.summarizerClientElection === true;\n        }\n        else {\n            return false;\n        }\n    }\n    getMaxOpsSinceLastSummary() {\n        // back-compat: maxOpsSinceLastSummary was moved from ISummaryRuntimeOptions\n        //   to ISummaryConfiguration in 0.60.\n        if (this.runtimeOptions.summaryOptions.maxOpsSinceLastSummary !== undefined) {\n            return this.runtimeOptions.summaryOptions.maxOpsSinceLastSummary;\n        }\n        if (this.summaryConfiguration.state !== \"disabled\") {\n            return this.summaryConfiguration.maxOpsSinceLastSummary;\n        }\n        else {\n            return 0;\n        }\n    }\n    getInitialSummarizerDelayMs() {\n        // back-compat: initialSummarizerDelayMs was moved from ISummaryRuntimeOptions\n        //   to ISummaryConfiguration in 0.60.\n        if (this.runtimeOptions.summaryOptions.initialSummarizerDelayMs !== undefined) {\n            return this.runtimeOptions.summaryOptions.initialSummarizerDelayMs;\n        }\n        if (this.summaryConfiguration.state !== \"disabled\") {\n            return this.summaryConfiguration.initialSummarizerDelayMs;\n        }\n        else {\n            return 0;\n        }\n    }\n    dispose(error) {\n        var _a;\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this.logger.sendTelemetryEvent({\n            eventName: \"ContainerRuntimeDisposed\",\n            isDirty: this.isDirty,\n            lastSequenceNumber: this.deltaManager.lastSequenceNumber,\n            attachState: this.attachState,\n        }, error);\n        if (this.summaryManager !== undefined) {\n            this.summaryManager.dispose();\n        }\n        this.garbageCollector.dispose();\n        (_a = this._summarizer) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.dataStores.dispose();\n        this.pendingStateManager.dispose();\n        this.emit(\"dispose\");\n        this.removeAllListeners();\n    }\n    get IFluidTokenProvider() {\n        var _a;\n        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.intelligence) {\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            return {\n                intelligence: this.options.intelligence,\n            };\n        }\n        return undefined;\n    }\n    /**\n     * Notifies this object about the request made to the container.\n     * @param request - Request made to the handler.\n     */\n    async request(request) {\n        try {\n            const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_32__.RequestParser.create(request);\n            const id = parser.pathParts[0];\n            if (id === \"_summarizer\" && parser.pathParts.length === 1) {\n                if (this._summarizer !== undefined) {\n                    return {\n                        status: 200,\n                        mimeType: \"fluid/object\",\n                        value: this.summarizer,\n                    };\n                }\n                return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);\n            }\n            if (this.requestHandler !== undefined) {\n                return this.requestHandler(parser, this);\n            }\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);\n        }\n        catch (error) {\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.exceptionToResponse)(error);\n        }\n    }\n    /**\n     * Resolves URI representing handle\n     * @param request - Request made to the handler.\n     */\n    async resolveHandle(request) {\n        try {\n            const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_32__.RequestParser.create(request);\n            const id = requestParser.pathParts[0];\n            if (id === \"_channels\") {\n                return this.resolveHandle(requestParser.createSubRequest(1));\n            }\n            if (id === _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.basePath && requestParser.isLeaf(2)) {\n                const handle = await this.blobManager.getBlob(requestParser.pathParts[1]);\n                if (handle) {\n                    return {\n                        status: 200,\n                        mimeType: \"fluid/object\",\n                        value: handle.get(),\n                    };\n                }\n                else {\n                    return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);\n                }\n            }\n            else if (requestParser.pathParts.length > 0) {\n                const dataStore = await this.getDataStoreFromRequest(id, request);\n                const subRequest = requestParser.createSubRequest(1);\n                // We always expect createSubRequest to include a leading slash, but asserting here to protect against\n                // unintentionally modifying the url if that changes.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(subRequest.url.startsWith(\"/\"), 0x126 /* \"Expected createSubRequest url to include a leading slash\" */);\n                return dataStore.IFluidRouter.request(subRequest);\n            }\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);\n        }\n        catch (error) {\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.exceptionToResponse)(error);\n        }\n    }\n    internalId(maybeAlias) {\n        var _a;\n        return (_a = this.dataStores.aliases().get(maybeAlias)) !== null && _a !== void 0 ? _a : maybeAlias;\n    }\n    async getDataStoreFromRequest(id, request) {\n        var _a, _b, _c;\n        const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[RuntimeHeaders.wait]) === \"boolean\"\n            ? (_b = request.headers) === null || _b === void 0 ? void 0 : _b[RuntimeHeaders.wait]\n            : true;\n        const internalId = this.internalId(id);\n        const dataStoreContext = await this.dataStores.getDataStore(internalId, wait);\n        /**\n         * If GC should run and this an external app request with \"externalRequest\" header, we need to return\n         * an error if the data store being requested is marked as unreferenced as per the data store's base\n         * GC data.\n         *\n         * This is a workaround to handle scenarios where a data store shared with an external app is deleted\n         * and marked as unreferenced by GC. Returning an error will fail to load the data store for the app.\n         */\n        if (((_c = request.headers) === null || _c === void 0 ? void 0 : _c[RuntimeHeaders.externalRequest]) && this.garbageCollector.shouldRunGC) {\n            // The data store is referenced if used routes in the base summary has a route to self.\n            // Older documents may not have used routes in the summary. They are considered referenced.\n            const usedRoutes = (await dataStoreContext.getBaseGCDetails()).usedRoutes;\n            if (!(usedRoutes === undefined || usedRoutes.includes(\"\") || usedRoutes.includes(\"/\"))) {\n                throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.responseToException)((0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request), request);\n            }\n        }\n        const dataStoreChannel = await dataStoreContext.realize();\n        // Remove query params, leading and trailing slashes from the url. This is done to make sure the format is\n        // the same as GC nodes id.\n        const urlWithoutQuery = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_34__.trimLeadingAndTrailingSlashes)(request.url.split(\"?\")[0]);\n        this.garbageCollector.nodeUpdated(`/${urlWithoutQuery}`, \"Loaded\", undefined /* timestampMs */, dataStoreContext.packagePath, request === null || request === void 0 ? void 0 : request.headers);\n        return dataStoreChannel;\n    }\n    /** Adds the container's metadata to the given summary tree. */\n    addMetadataToSummary(summaryTree) {\n        var _a;\n        const metadata = Object.assign(Object.assign(Object.assign(Object.assign({}, this.createContainerMetadata), { \n            // back-compat 0.59.3000: This is renamed to summaryNumber. Can be removed when 0.59.3000 saturates.\n            summaryCount: this.nextSummaryNumber, \n            // Increment the summary number for the next summary that will be generated.\n            summaryNumber: this.nextSummaryNumber++, summaryFormatVersion: 1, disableIsolatedChannels: this.disableIsolatedChannels || undefined }), this.garbageCollector.getMetadata()), { \n            // The last message processed at the time of summary. If there are no new messages, use the message from the\n            // last summary.\n            message: (_a = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.extractSummaryMetadataMessage)(this.deltaManager.lastMessage)) !== null && _a !== void 0 ? _a : this.messageAtLastSummary });\n        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.metadataBlobName, JSON.stringify(metadata));\n    }\n    addContainerStateToSummary(summaryTree, fullTree, trackState, telemetryContext) {\n        var _a;\n        this.addMetadataToSummary(summaryTree);\n        if (this.chunkMap.size > 0) {\n            const content = JSON.stringify([...this.chunkMap]);\n            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.chunksBlobName, content);\n        }\n        const dataStoreAliases = this.dataStores.aliases();\n        if (dataStoreAliases.size > 0) {\n            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.aliasBlobName, JSON.stringify([...dataStoreAliases]));\n        }\n        if (this.summarizerClientElection) {\n            const electedSummarizerContent = JSON.stringify((_a = this.summarizerClientElection) === null || _a === void 0 ? void 0 : _a.serialize());\n            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.electedSummarizerBlobName, electedSummarizerContent);\n        }\n        const blobManagerSummary = this.blobManager.summarize();\n        // Some storage (like git) doesn't allow empty tree, so we can omit it.\n        // and the blob manager can handle the tree not existing when loading\n        if (Object.keys(blobManagerSummary.summary.tree).length > 0) {\n            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addTreeToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.blobsTreeName, blobManagerSummary);\n        }\n        if (this.garbageCollector.writeDataAtRoot) {\n            const gcSummary = this.garbageCollector.summarize(fullTree, trackState, telemetryContext);\n            if (gcSummary !== undefined) {\n                (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addSummarizeResultToSummary)(summaryTree, _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.gcTreeKey, gcSummary);\n            }\n        }\n    }\n    // Track how many times the container tries to reconnect with pending messages.\n    // This happens when the connection state is changed and we reset the counter\n    // when we are able to process a local op or when there are no pending messages.\n    // If this counter reaches a max, it's a good indicator that the container\n    // is not making progress and it is stuck in a retry loop.\n    shouldContinueReconnecting() {\n        if (this.maxConsecutiveReconnects <= 0) {\n            // Feature disabled, we never stop reconnecting\n            return true;\n        }\n        if (!this.pendingStateManager.hasPendingMessages()) {\n            // If there are no pending messages, we can always reconnect\n            this.resetReconnectCount();\n            return true;\n        }\n        if (this.consecutiveReconnects === Math.floor(this.maxConsecutiveReconnects / 2)) {\n            // If we're halfway through the max reconnects, send an event in order\n            // to better identify false positives, if any. If the rate of this event\n            // matches Container Close count below, we can safely cut down\n            // maxConsecutiveReconnects to half.\n            this.mc.logger.sendTelemetryEvent({\n                eventName: \"ReconnectsWithNoProgress\",\n                attempts: this.consecutiveReconnects,\n                pendingMessages: this.pendingStateManager.pendingMessagesCount,\n            });\n        }\n        return this.consecutiveReconnects < this.maxConsecutiveReconnects;\n    }\n    resetReconnectCount() {\n        this.consecutiveReconnects = 0;\n    }\n    replayPendingStates() {\n        // We need to be able to send ops to replay states\n        if (!this.canSendOps()) {\n            return;\n        }\n        // We need to temporary clear the dirty flags and disable\n        // dirty state change events to detect whether replaying ops\n        // has any effect.\n        // Save the old state, reset to false, disable event emit\n        const oldState = this.dirtyContainer;\n        this.dirtyContainer = false;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.emitDirtyDocumentEvent, 0x127 /* \"dirty document event not set on replay\" */);\n        this.emitDirtyDocumentEvent = false;\n        let newState;\n        try {\n            // replay the ops\n            this.pendingStateManager.replayPendingStates();\n        }\n        finally {\n            // Save the new start and restore the old state, re-enable event emit\n            newState = this.dirtyContainer;\n            this.dirtyContainer = oldState;\n            this.emitDirtyDocumentEvent = true;\n        }\n        // Officially transition from the old state to the new state.\n        this.updateDocumentDirtyState(newState);\n    }\n    async applyStashedOp(type, op) {\n        switch (type) {\n            case ContainerMessageType.FluidDataStoreOp:\n                return this.dataStores.applyStashedOp(op);\n            case ContainerMessageType.Attach:\n                return this.dataStores.applyStashedAttachOp(op);\n            case ContainerMessageType.Alias:\n            case ContainerMessageType.BlobAttach:\n                return;\n            case ContainerMessageType.ChunkedOp:\n                throw new Error(\"chunkedOp not expected here\");\n            case ContainerMessageType.Rejoin:\n                throw new Error(\"rejoin not expected here\");\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_36__.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);\n        }\n    }\n    setConnectionState(connected, clientId) {\n        this.verifyNotClosed();\n        // There might be no change of state due to Container calling this API after loading runtime.\n        const changeOfState = this._connected !== connected;\n        const reconnection = changeOfState && connected;\n        this._connected = connected;\n        if (!connected) {\n            this._perfSignalData.signalsLost = 0;\n            this._perfSignalData.signalTimestamp = 0;\n            this._perfSignalData.trackingSignalSequenceNumber = undefined;\n        }\n        if (reconnection) {\n            this.consecutiveReconnects++;\n            if (!this.shouldContinueReconnecting()) {\n                this.closeFn(\n                // pre-0.58 error message: MaxReconnectsWithNoProgress\n                _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataProcessingError.create(\"Runtime detected too many reconnects with no progress syncing local ops\", \"setConnectionState\", undefined, {\n                    dataLoss: 1,\n                    attempts: this.consecutiveReconnects,\n                    pendingMessages: this.pendingStateManager.pendingMessagesCount,\n                }));\n                return;\n            }\n        }\n        if (changeOfState) {\n            this.replayPendingStates();\n        }\n        this.dataStores.setConnectionState(connected, clientId);\n        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_37__.raiseConnectedEvent)(this.mc.logger, this, connected, clientId);\n    }\n    process(messageArg, local) {\n        var _a, _b;\n        this.verifyNotClosed();\n        // If it's not message for runtime, bail out right away.\n        if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.isUnpackedRuntimeMessage)(messageArg)) {\n            return;\n        }\n        if ((_a = this.mc.config.getBoolean(\"enableOfflineLoad\")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) {\n            this.savedOps.push(messageArg);\n        }\n        // Do shallow copy of message, as methods below will modify it.\n        // There might be multiple container instances receiving same message\n        // We do not need to make deep copy, as each layer will just replace message.content itself,\n        // but would not modify contents details\n        let message = Object.assign({}, messageArg);\n        // Surround the actual processing of the operation with messages to the schedule manager indicating\n        // the beginning and end. This allows it to emit appropriate events and/or pause the processing of new\n        // messages once a batch has been fully processed.\n        this.scheduleManager.beforeOpProcessing(message);\n        try {\n            message = unpackRuntimeMessage(message);\n            // Chunk processing must come first given that we will transform the message to the unchunked version\n            // once all pieces are available\n            message = this.processRemoteChunkedMessage(message);\n            let localOpMetadata;\n            if (local) {\n                // Call the PendingStateManager to process local messages.\n                // Do not process local chunked ops until all pieces are available.\n                if (message.type !== ContainerMessageType.ChunkedOp) {\n                    localOpMetadata = this.pendingStateManager.processPendingLocalMessage(message);\n                }\n            }\n            // If there are no more pending messages after processing a local message,\n            // the document is no longer dirty.\n            if (!this.pendingStateManager.hasPendingMessages()) {\n                this.updateDocumentDirtyState(false);\n            }\n            switch (message.type) {\n                case ContainerMessageType.Attach:\n                    this.dataStores.processAttachMessage(message, local);\n                    break;\n                case ContainerMessageType.Alias:\n                    this.processAliasMessage(message, localOpMetadata, local);\n                    break;\n                case ContainerMessageType.FluidDataStoreOp:\n                    this.dataStores.processFluidDataStoreOp(message, local, localOpMetadata);\n                    break;\n                case ContainerMessageType.BlobAttach:\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)((_b = message === null || message === void 0 ? void 0 : message.metadata) === null || _b === void 0 ? void 0 : _b.blobId, 0x12a /* \"Missing blob id on metadata\" */);\n                    this.blobManager.processBlobAttachOp(message.metadata.blobId, local);\n                    break;\n                default:\n            }\n            this.emit(\"op\", message);\n            this.scheduleManager.afterOpProcessing(undefined, message);\n            if (local) {\n                // If we have processed a local op, this means that the container is\n                // making progress and we can reset the counter for how many times\n                // we have consecutively replayed the pending states\n                this.resetReconnectCount();\n            }\n        }\n        catch (e) {\n            this.scheduleManager.afterOpProcessing(e, message);\n            throw e;\n        }\n    }\n    processAliasMessage(message, localOpMetadata, local) {\n        this.dataStores.processAliasMessage(message, localOpMetadata, local);\n    }\n    /**\n     * Emits the Signal event and update the perf signal data.\n     * @param clientSignalSequenceNumber - is the client signal sequence number to be uploaded.\n     */\n    sendSignalTelemetryEvent(clientSignalSequenceNumber) {\n        const duration = Date.now() - this._perfSignalData.signalTimestamp;\n        this.logger.sendPerformanceEvent({\n            eventName: \"SignalLatency\",\n            duration,\n            signalsLost: this._perfSignalData.signalsLost,\n        });\n        this._perfSignalData.signalsLost = 0;\n        this._perfSignalData.signalTimestamp = 0;\n    }\n    processSignal(message, local) {\n        const envelope = message.content;\n        const transformed = {\n            clientId: message.clientId,\n            content: envelope.contents.content,\n            type: envelope.contents.type,\n        };\n        // Only collect signal telemetry for messages sent by the current client.\n        if (message.clientId === this.clientId && this.connected) {\n            // Check to see if the signal was lost.\n            if (this._perfSignalData.trackingSignalSequenceNumber !== undefined &&\n                envelope.clientSignalSequenceNumber > this._perfSignalData.trackingSignalSequenceNumber) {\n                this._perfSignalData.signalsLost++;\n                this._perfSignalData.trackingSignalSequenceNumber = undefined;\n                this.logger.sendErrorEvent({\n                    eventName: \"SignalLost\",\n                    type: envelope.contents.type,\n                    signalsLost: this._perfSignalData.signalsLost,\n                    trackingSequenceNumber: this._perfSignalData.trackingSignalSequenceNumber,\n                    clientSignalSequenceNumber: envelope.clientSignalSequenceNumber,\n                });\n            }\n            else if (envelope.clientSignalSequenceNumber === this._perfSignalData.trackingSignalSequenceNumber) {\n                this.sendSignalTelemetryEvent(envelope.clientSignalSequenceNumber);\n                this._perfSignalData.trackingSignalSequenceNumber = undefined;\n            }\n        }\n        if (envelope.address === undefined) {\n            // No address indicates a container signal message.\n            this.emit(\"signal\", transformed, local);\n            return;\n        }\n        this.dataStores.processSignal(envelope.address, transformed, local);\n    }\n    async getRootDataStore(id, wait = true) {\n        const internalId = this.internalId(id);\n        const context = await this.dataStores.getDataStore(internalId, wait);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(await context.isRoot(), 0x12b /* \"did not get root data store\" */);\n        return context.realize();\n    }\n    setFlushMode(mode) {\n        if (mode === this._flushMode) {\n            return;\n        }\n        this.mc.logger.sendTelemetryEvent({\n            eventName: \"FlushMode Updated\",\n            old: this._flushMode,\n            new: mode,\n        });\n        // Flush any pending batches if switching to immediate\n        if (mode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.Immediate) {\n            this.flush();\n        }\n        this._flushMode = mode;\n        // Let the PendingStateManager know that FlushMode has been updated.\n        this.pendingStateManager.onFlushModeUpdated(mode);\n    }\n    flush() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this._orderSequentiallyCalls === 0, 0x24c /* \"Cannot call `flush()` from `orderSequentially`'s callback\" */);\n        if (!this.deltaSender) {\n            return;\n        }\n        // Let the PendingStateManager know that there was an attempt to flush messages.\n        // Note that this should happen before the `this.needsFlush` check below because in the scenario where we are\n        // not connected, `this.needsFlush` will be false but the PendingStateManager might have pending messages and\n        // hence needs to track this.\n        this.pendingStateManager.onFlush();\n        // If flush has already been called then exit early\n        if (!this.needsFlush) {\n            return;\n        }\n        this.needsFlush = false;\n        // Did we disconnect in the middle of turn-based batch?\n        // If so, do nothing, as pending state manager will resubmit it correctly on reconnect.\n        if (!this.canSendOps()) {\n            return;\n        }\n        return this.deltaSender.flush();\n    }\n    orderSequentially(callback) {\n        // If flush mode is already TurnBased we are either\n        // nested in another orderSequentially, or\n        // the app is flushing manually, in which\n        // case this invocation doesn't own\n        // flushing.\n        if (this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased) {\n            this.trackOrderSequentiallyCalls(callback);\n            return;\n        }\n        const savedFlushMode = this.flushMode;\n        this.setFlushMode(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased);\n        try {\n            this.trackOrderSequentiallyCalls(callback);\n            this.flush();\n        }\n        finally {\n            this.setFlushMode(savedFlushMode);\n        }\n    }\n    trackOrderSequentiallyCalls(callback) {\n        let checkpoint;\n        if (this.mc.config.getBoolean(\"Fluid.ContainerRuntime.EnableRollback\")) {\n            checkpoint = this.pendingStateManager.checkpoint();\n        }\n        try {\n            this._orderSequentiallyCalls++;\n            callback();\n        }\n        catch (error) {\n            if (checkpoint) {\n                // This will throw and close the container if rollback fails\n                checkpoint.rollback();\n            }\n            else {\n                // pre-0.58 error message: orderSequentiallyCallbackException\n                this.closeFn(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.GenericError(\"orderSequentially callback exception\", error));\n            }\n            throw error; // throw the original error for the consumer of the runtime\n        }\n        finally {\n            this._orderSequentiallyCalls--;\n        }\n    }\n    async createDataStore(pkg) {\n        const internalId = (0,uuid__WEBPACK_IMPORTED_MODULE_38__[\"default\"])();\n        return (0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.channelToDataStore)(await this._createDataStore(pkg, false /* isRoot */, internalId), internalId, this, this.dataStores, this.mc.logger);\n    }\n    /**\n     * Creates a root datastore directly with a user generated id and attaches it to storage.\n     * It is vulnerable to name collisions and should not be used.\n     *\n     * This method will be removed. See #6465.\n     */\n    async createRootDataStoreLegacy(pkg, rootDataStoreId) {\n        const fluidDataStore = await this._createDataStore(pkg, true /* isRoot */, rootDataStoreId);\n        // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For\n        // older versions, we still have to call bindToContext.\n        if (fluidDataStore.makeVisibleAndAttachGraph !== undefined) {\n            fluidDataStore.makeVisibleAndAttachGraph();\n        }\n        else {\n            fluidDataStore.bindToContext();\n        }\n        return fluidDataStore;\n    }\n    /**\n     * @deprecated - will be removed in an upcoming release. See #9660.\n     */\n    async createRootDataStore(pkg, rootDataStoreId) {\n        if (rootDataStoreId.includes(\"/\")) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Id cannot contain slashes: '${rootDataStoreId}'`);\n        }\n        return this._aliasingEnabled === true ?\n            this.createAndAliasDataStore(pkg, rootDataStoreId) :\n            this.createRootDataStoreLegacy(pkg, rootDataStoreId);\n    }\n    /**\n     * Creates a data store then attempts to alias it.\n     * If aliasing fails, it will raise an exception.\n     *\n     * This method will be removed. See #6465.\n     *\n     * @param pkg - Package name of the data store\n     * @param alias - Alias to be assigned to the data store\n     * @param props - Properties for the data store\n     * @returns - An aliased data store which can can be found / loaded by alias.\n     */\n    async createAndAliasDataStore(pkg, alias, props) {\n        const internalId = (0,uuid__WEBPACK_IMPORTED_MODULE_38__[\"default\"])();\n        const dataStore = await this._createDataStore(pkg, false /* isRoot */, internalId, props);\n        const aliasedDataStore = (0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.channelToDataStore)(dataStore, internalId, this, this.dataStores, this.mc.logger);\n        const result = await aliasedDataStore.trySetAlias(alias);\n        if (result !== \"Success\") {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.GenericError(\"dataStoreAliasFailure\", undefined /* error */, {\n                alias: {\n                    value: alias,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.UserData,\n                },\n                internalId: {\n                    value: internalId,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.PackageData,\n                },\n                aliasResult: result,\n            });\n        }\n        return aliasedDataStore;\n    }\n    createDetachedRootDataStore(pkg, rootDataStoreId) {\n        if (rootDataStoreId.includes(\"/\")) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Id cannot contain slashes: '${rootDataStoreId}'`);\n        }\n        return this.dataStores.createDetachedDataStoreCore(pkg, true, rootDataStoreId);\n    }\n    createDetachedDataStore(pkg) {\n        return this.dataStores.createDetachedDataStoreCore(pkg, false);\n    }\n    /**\n     * Creates a possibly root datastore directly with a possibly user generated id and attaches it to storage.\n     * It is vulnerable to name collisions if both aforementioned conditions are true, and should not be used.\n     *\n     * This method will be removed. See #6465.\n     */\n    async _createDataStoreWithPropsLegacy(pkg, props, id = (0,uuid__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(), isRoot = false) {\n        const fluidDataStore = await this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props).realize();\n        if (isRoot) {\n            // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.\n            // For older versions, we still have to call bindToContext.\n            if (fluidDataStore.makeVisibleAndAttachGraph !== undefined) {\n                fluidDataStore.makeVisibleAndAttachGraph();\n            }\n            else {\n                fluidDataStore.bindToContext();\n            }\n            this.logger.sendTelemetryEvent({\n                eventName: \"Root datastore with props\",\n                hasProps: props !== undefined,\n            });\n        }\n        return (0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.channelToDataStore)(fluidDataStore, id, this, this.dataStores, this.mc.logger);\n    }\n    async _createDataStoreWithProps(pkg, props, id = (0,uuid__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(), isRoot = false) {\n        return this._aliasingEnabled === true && isRoot ?\n            this.createAndAliasDataStore(pkg, id, props) :\n            this._createDataStoreWithPropsLegacy(pkg, props, id, isRoot);\n    }\n    async _createDataStore(pkg, isRoot, id = (0,uuid__WEBPACK_IMPORTED_MODULE_38__[\"default\"])(), props) {\n        return this.dataStores\n            ._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props)\n            .realize();\n    }\n    canSendOps() {\n        return this.connected && !this.deltaManager.readOnlyInfo.readonly;\n    }\n    getQuorum() {\n        return this.context.quorum;\n    }\n    getAudience() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.context.audience;\n    }\n    /**\n     * Returns true of container is dirty, i.e. there are some pending local changes that\n     * either were not sent out to delta stream or were not yet acknowledged.\n     */\n    get isDirty() {\n        return this.dirtyContainer;\n    }\n    isContainerMessageDirtyable(type, contents) {\n        // For legacy purposes, exclude the old built-in AgentScheduler from dirty consideration as a special-case.\n        // Ultimately we should have no special-cases from the ContainerRuntime's perspective.\n        if (type === ContainerMessageType.Attach) {\n            const attachMessage = contents;\n            if (attachMessage.id === agentSchedulerId) {\n                return false;\n            }\n        }\n        else if (type === ContainerMessageType.FluidDataStoreOp) {\n            const envelope = contents;\n            if (envelope.address === agentSchedulerId) {\n                return false;\n            }\n        }\n        return true;\n    }\n    createNewSignalEnvelope(address, type, content) {\n        const newSequenceNumber = ++this._perfSignalData.signalSequenceNumber;\n        const newEnvelope = {\n            address,\n            clientSignalSequenceNumber: newSequenceNumber,\n            contents: { type, content },\n        };\n        // We should not track any signals in case we already have a tracking number.\n        if (newSequenceNumber % this.defaultTelemetrySignalSampleCount === 1 &&\n            this._perfSignalData.trackingSignalSequenceNumber === undefined) {\n            this._perfSignalData.signalTimestamp = Date.now();\n            this._perfSignalData.trackingSignalSequenceNumber = newSequenceNumber;\n        }\n        return newEnvelope;\n    }\n    /**\n     * Submits the signal to be sent to other clients.\n     * @param type - Type of the signal.\n     * @param content - Content of the signal.\n     */\n    submitSignal(type, content) {\n        this.verifyNotClosed();\n        const envelope = this.createNewSignalEnvelope(undefined /* address */, type, content);\n        return this.context.submitSignalFn(envelope);\n    }\n    submitDataStoreSignal(address, type, content) {\n        const envelope = this.createNewSignalEnvelope(address, type, content);\n        return this.context.submitSignalFn(envelope);\n    }\n    setAttachState(attachState) {\n        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attaching) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attaching, 0x12d /* \"Container Context should already be in attaching state\" */);\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached, 0x12e /* \"Container Context should already be in attached state\" */);\n            this.emit(\"attached\");\n        }\n        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached && !this.pendingStateManager.hasPendingMessages()) {\n            this.updateDocumentDirtyState(false);\n        }\n        this.dataStores.setAttachState(attachState);\n    }\n    /**\n     * Create a summary. Used when attaching or serializing a detached container.\n     *\n     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported\n     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the\n     * new storage IDs so requests can be redirected.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n    createSummary(blobRedirectTable, telemetryContext) {\n        if (blobRedirectTable) {\n            this.blobManager.setRedirectTable(blobRedirectTable);\n        }\n        const summarizeResult = this.dataStores.createSummary(telemetryContext);\n        if (!this.disableIsolatedChannels) {\n            // Wrap data store summaries in .channels subtree.\n            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.wrapSummaryInChannelsTree)(summarizeResult);\n        }\n        this.addContainerStateToSummary(summarizeResult, true /* fullTree */, false /* trackState */, telemetryContext);\n        return summarizeResult.summary;\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        if (this.context.getAbsoluteUrl === undefined) {\n            throw new Error(\"Driver does not implement getAbsoluteUrl\");\n        }\n        if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached) {\n            return undefined;\n        }\n        return this.context.getAbsoluteUrl(relativeUrl);\n    }\n    async summarizeInternal(fullTree, trackState, telemetryContext) {\n        const summarizeResult = await this.dataStores.summarize(fullTree, trackState, telemetryContext);\n        let pathPartsForChildren;\n        if (!this.disableIsolatedChannels) {\n            // Wrap data store summaries in .channels subtree.\n            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.wrapSummaryInChannelsTree)(summarizeResult);\n            pathPartsForChildren = [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.channelsTreeName];\n        }\n        this.addContainerStateToSummary(summarizeResult, fullTree, trackState, telemetryContext);\n        return Object.assign(Object.assign({}, summarizeResult), { id: \"\", pathPartsForChildren });\n    }\n    /**\n     * Returns a summary of the runtime at the current sequence number.\n     */\n    async summarize(options) {\n        this.verifyNotClosed();\n        const { fullTree = false, trackState = true, summaryLogger = this.mc.logger, runGC = this.garbageCollector.shouldRunGC, runSweep, fullGC, } = options;\n        let gcStats;\n        if (runGC) {\n            gcStats = await this.collectGarbage({ logger: summaryLogger, runSweep, fullGC });\n        }\n        const telemetryContext = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.TelemetryContext();\n        const { stats, summary } = await this.summarizerNode.summarize(fullTree, trackState, telemetryContext);\n        this.logger.sendTelemetryEvent({ eventName: \"SummarizeTelemetry\", details: telemetryContext.serialize() });\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(summary.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__.SummaryType.Tree, 0x12f /* \"Container Runtime's summarize should always return a tree\" */);\n        return { stats, summary, gcStats };\n    }\n    /**\n     * Implementation of IGarbageCollectionRuntime::updateStateBeforeGC.\n     * Before GC runs, called by the garbage collector to update any pending GC state. This is mainly used to notify\n     * the garbage collector of references detected since the last GC run. Most references are notified immediately\n     * but there can be some for which async operation is required (such as detecting new root data stores).\n     */\n    async updateStateBeforeGC() {\n        return this.dataStores.updateStateBeforeGC();\n    }\n    /**\n     * Implementation of IGarbageCollectionRuntime::getGCData.\n     * Generates and returns the GC data for this container.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC) {\n        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_34__.GCDataBuilder();\n        const dsGCData = await this.dataStores.getGCData(fullGC);\n        builder.addNodes(dsGCData.gcNodes);\n        const blobsGCData = this.blobManager.getGCData(fullGC);\n        builder.addNodes(blobsGCData.gcNodes);\n        return builder.getGCData();\n    }\n    /**\n     * Implementation of IGarbageCollectionRuntime::updateUsedRoutes.\n     * After GC has run, called to notify this container's nodes of routes that are used in it.\n     * @param usedRoutes - The routes that are used in all nodes in this Container.\n     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes\n     * unreferenced as part of this GC run, this should be used to update the time when it happens.\n     */\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        // Update our summarizer node's used routes. Updating used routes in summarizer node before\n        // summarizing is required and asserted by the the summarizer node. We are the root and are\n        // always referenced, so the used routes is only self-route (empty string).\n        this.summarizerNode.updateUsedRoutes([\"\"]);\n        const dataStoreUsedRoutes = [];\n        for (const route of usedRoutes) {\n            if (route.split(\"/\")[1] !== _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.basePath) {\n                dataStoreUsedRoutes.push(route);\n            }\n        }\n        return this.dataStores.updateUsedRoutes(dataStoreUsedRoutes, gcTimestamp);\n    }\n    /**\n     * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing\n     * scenarios with accessing deleted content.\n     * @param unusedRoutes - The routes that are unused in all data stores in this Container.\n     */\n    deleteUnusedRoutes(unusedRoutes) {\n        const blobManagerUnusedRoutes = [];\n        const dataStoreUnusedRoutes = [];\n        for (const route of unusedRoutes) {\n            if (this.isBlobPath(route)) {\n                blobManagerUnusedRoutes.push(route);\n            }\n            else {\n                dataStoreUnusedRoutes.push(route);\n            }\n        }\n        this.blobManager.deleteUnusedRoutes(blobManagerUnusedRoutes);\n        this.dataStores.deleteUnusedRoutes(dataStoreUnusedRoutes);\n    }\n    /**\n     * Returns a server generated referenced timestamp to be used to track unreferenced nodes by GC.\n     */\n    getCurrentReferenceTimestampMs() {\n        var _a, _b, _c;\n        // Use the timestamp of the last message seen by this client as that is server generated. If no messages have\n        // been processed, use the timestamp of the message from the last summary.\n        return (_b = (_a = this.deltaManager.lastMessage) === null || _a === void 0 ? void 0 : _a.timestamp) !== null && _b !== void 0 ? _b : (_c = this.messageAtLastSummary) === null || _c === void 0 ? void 0 : _c.timestamp;\n    }\n    /**\n     * Returns the type of the GC node. Currently, there are nodes that belong to the root (\"/\"), data stores or\n     * blob manager.\n     */\n    getNodeType(nodePath) {\n        var _a;\n        if (this.isBlobPath(nodePath)) {\n            return _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.Blob;\n        }\n        return (_a = this.dataStores.getGCNodeType(nodePath)) !== null && _a !== void 0 ? _a : _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.Other;\n    }\n    /**\n     * Called by GC to retrieve the package path of the node with the given path. The node should belong to a\n     * data store or an attachment blob.\n     */\n    async getGCNodePackagePath(nodePath) {\n        switch (this.getNodeType(nodePath)) {\n            case _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.Blob:\n                return [\"_blobs\"];\n            case _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.DataStore:\n            case _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.SubDataStore:\n                return this.dataStores.getDataStorePackagePath(nodePath);\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 0x2de /* \"Package path requested for unsupported node type.\" */);\n        }\n    }\n    /**\n     * Returns whether a given path is for attachment blobs that are in the format - \"/BlobManager.basePath/...\".\n     */\n    isBlobPath(path) {\n        const pathParts = path.split(\"/\");\n        if (pathParts.length < 2 || pathParts[1] !== _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.basePath) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Runs garbage collection and updates the reference / used state of the nodes in the container.\n     * @returns the statistics of the garbage collection run.\n     */\n    async collectGarbage(options) {\n        return this.garbageCollector.collectGarbage(options);\n    }\n    /**\n     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify\n     * all references added in the system.\n     * @param srcHandle - The handle of the node that added the reference.\n     * @param outboundHandle - The handle of the outbound node that is referenced.\n     */\n    addedGCOutboundReference(srcHandle, outboundHandle) {\n        this.garbageCollector.addedOutboundReference(srcHandle.absolutePath, outboundHandle.absolutePath);\n    }\n    /**\n     * Generates the summary tree, uploads it to storage, and then submits the summarize op.\n     * This is intended to be called by the summarizer, since it is the implementation of\n     * ISummarizerInternalsProvider.submitSummary.\n     * It takes care of state management at the container level, including pausing inbound\n     * op processing, updating SummarizerNode state tracking, and garbage collection.\n     * @param options - options controlling how the summary is generated or submitted\n     */\n    async submitSummary(options) {\n        var _a, _b, _c;\n        const { fullTree, refreshLatestAck, summaryLogger } = options;\n        // The summary number for this summary. This will be updated during the summary process, so get it now and\n        // use it for all events logged during this summary.\n        const summaryNumber = this.nextSummaryNumber;\n        const summaryNumberLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(summaryLogger, undefined, {\n            all: { summaryNumber },\n        });\n        let latestSnapshotVersionId;\n        if (refreshLatestAck) {\n            const latestSnapshotInfo = await this.refreshLatestSummaryAckFromServer(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(summaryNumberLogger, undefined, { all: { safeSummary: true } }));\n            const latestSnapshotRefSeq = latestSnapshotInfo.latestSnapshotRefSeq;\n            latestSnapshotVersionId = latestSnapshotInfo.latestSnapshotVersionId;\n            if (latestSnapshotRefSeq > this.deltaManager.lastSequenceNumber) {\n                // We need to catch up to the latest summary's reference sequence number before pausing.\n                await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(summaryNumberLogger, {\n                    eventName: \"WaitingForSeq\",\n                    lastSequenceNumber: this.deltaManager.lastSequenceNumber,\n                    targetSequenceNumber: latestSnapshotRefSeq,\n                    lastKnownSeqNumber: this.deltaManager.lastKnownSeqNumber,\n                }, async () => waitForSeq(this.deltaManager, latestSnapshotRefSeq), { start: true, end: true, cancel: \"error\" });\n            }\n        }\n        try {\n            await this.deltaManager.inbound.pause();\n            const summaryRefSeqNum = this.deltaManager.lastSequenceNumber;\n            const minimumSequenceNumber = this.deltaManager.minimumSequenceNumber;\n            const message = `Summary @${summaryRefSeqNum}:${this.deltaManager.minimumSequenceNumber}`;\n            // We should be here is we haven't processed be here. If we are of if the last message's sequence number\n            // doesn't match the last processed sequence number, log an error.\n            if (summaryRefSeqNum !== ((_a = this.deltaManager.lastMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber)) {\n                summaryNumberLogger.sendErrorEvent({\n                    eventName: \"LastSequenceMismatch\",\n                    error: message,\n                });\n            }\n            this.summarizerNode.startSummary(summaryRefSeqNum, summaryNumberLogger);\n            // Helper function to check whether we should still continue between each async step.\n            const checkContinue = () => {\n                // Do not check for loss of connectivity directly! Instead leave it up to\n                // RunWhileConnectedCoordinator to control policy in a single place.\n                // This will allow easier change of design if we chose to. For example, we may chose to allow\n                // summarizer to reconnect in the future.\n                // Also checking for cancellation is a must as summary process may be abandoned for other reasons,\n                // like loss of connectivity for main (interactive) client.\n                if (options.cancellationToken.cancelled) {\n                    return { continue: false, error: \"disconnected\" };\n                }\n                // That said, we rely on submitSystemMessage() that today only works in connected state.\n                // So if we fail here, it either means that RunWhileConnectedCoordinator does not work correctly,\n                // OR that design changed and we need to remove this check and fix submitSystemMessage.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected, 0x258 /* \"connected\" */);\n                // Ensure that lastSequenceNumber has not changed after pausing.\n                // We need the summary op's reference sequence number to match our summary sequence number,\n                // otherwise we'll get the wrong sequence number stamped on the summary's .protocol attributes.\n                if (this.deltaManager.lastSequenceNumber !== summaryRefSeqNum) {\n                    return {\n                        continue: false,\n                        // eslint-disable-next-line max-len\n                        error: `lastSequenceNumber changed before uploading to storage. ${this.deltaManager.lastSequenceNumber} !== ${summaryRefSeqNum}`,\n                    };\n                }\n                return { continue: true };\n            };\n            let continueResult = checkContinue();\n            if (!continueResult.continue) {\n                return {\n                    stage: \"base\",\n                    referenceSequenceNumber: summaryRefSeqNum,\n                    minimumSequenceNumber,\n                    error: continueResult.error,\n                };\n            }\n            const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_41__.Trace.start();\n            let summarizeResult;\n            // If the GC state needs to be reset, we need to force a full tree summary and update the unreferenced\n            // state of all the nodes.\n            const forcedFullTree = this.garbageCollector.summaryStateNeedsReset;\n            try {\n                summarizeResult = await this.summarize({\n                    fullTree: fullTree || forcedFullTree,\n                    trackState: true,\n                    summaryLogger: summaryNumberLogger,\n                    runGC: this.garbageCollector.shouldRunGC,\n                });\n            }\n            catch (error) {\n                return {\n                    stage: \"base\",\n                    referenceSequenceNumber: summaryRefSeqNum,\n                    minimumSequenceNumber,\n                    error,\n                };\n            }\n            const { summary: summaryTree, stats: partialStats } = summarizeResult;\n            // Now that we have generated the summary, update the message at last summary to the last message processed.\n            this.messageAtLastSummary = this.deltaManager.lastMessage;\n            // Counting dataStores and handles\n            // Because handles are unchanged dataStores in the current logic,\n            // summarized dataStore count is total dataStore count minus handle count\n            const dataStoreTree = this.disableIsolatedChannels ? summaryTree : summaryTree.tree[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.channelsTreeName];\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(dataStoreTree.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__.SummaryType.Tree, 0x1fc /* \"summary is not a tree\" */);\n            const handleCount = Object.values(dataStoreTree.tree).filter((value) => value.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__.SummaryType.Handle).length;\n            const gcSummaryTreeStats = summaryTree.tree[_garbageCollection__WEBPACK_IMPORTED_MODULE_14__.gcTreeKey]\n                ? (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.calculateStats)(summaryTree.tree[_garbageCollection__WEBPACK_IMPORTED_MODULE_14__.gcTreeKey])\n                : undefined;\n            const summaryStats = Object.assign({ dataStoreCount: this.dataStores.size, summarizedDataStoreCount: this.dataStores.size - handleCount, gcStateUpdatedDataStoreCount: (_b = summarizeResult.gcStats) === null || _b === void 0 ? void 0 : _b.updatedDataStoreCount, gcBlobNodeCount: gcSummaryTreeStats === null || gcSummaryTreeStats === void 0 ? void 0 : gcSummaryTreeStats.blobNodeCount, gcTotalBlobsSize: gcSummaryTreeStats === null || gcSummaryTreeStats === void 0 ? void 0 : gcSummaryTreeStats.totalBlobSize, opsSizesSinceLastSummary: this.opTracker.opsSizeAccumulator, nonSystemOpsSinceLastSummary: this.opTracker.nonSystemOpCount, summaryNumber }, partialStats);\n            const generateSummaryData = {\n                referenceSequenceNumber: summaryRefSeqNum,\n                minimumSequenceNumber,\n                summaryTree,\n                summaryStats,\n                generateDuration: trace.trace().duration,\n                forcedFullTree,\n            };\n            continueResult = checkContinue();\n            if (!continueResult.continue) {\n                return Object.assign(Object.assign({ stage: \"generate\" }, generateSummaryData), { error: continueResult.error });\n            }\n            // It may happen that the lastAck it not correct due to missing summaryAck in case of single commit\n            // summary. So if the previous summarizer closes just after submitting the summary and before\n            // submitting the summaryOp then we can't rely on summaryAck. So in case we have\n            // latestSnapshotVersionId from storage and it does not match with the lastAck ackHandle, then use\n            // the one fetched from storage as parent as that is the latest.\n            const lastAck = this.summaryCollection.latestAck;\n            let summaryContext;\n            if ((lastAck === null || lastAck === void 0 ? void 0 : lastAck.summaryAck.contents.handle) !== latestSnapshotVersionId\n                && latestSnapshotVersionId !== undefined) {\n                summaryContext = {\n                    proposalHandle: undefined,\n                    ackHandle: latestSnapshotVersionId,\n                    referenceSequenceNumber: summaryRefSeqNum,\n                };\n            }\n            else if (lastAck === undefined) {\n                summaryContext = {\n                    proposalHandle: undefined,\n                    ackHandle: (_c = this.context.getLoadedFromVersion()) === null || _c === void 0 ? void 0 : _c.id,\n                    referenceSequenceNumber: summaryRefSeqNum,\n                };\n            }\n            else {\n                summaryContext = {\n                    proposalHandle: lastAck.summaryOp.contents.handle,\n                    ackHandle: lastAck.summaryAck.contents.handle,\n                    referenceSequenceNumber: summaryRefSeqNum,\n                };\n            }\n            let handle;\n            try {\n                handle = await this.storage.uploadSummaryWithContext(summarizeResult.summary, summaryContext);\n            }\n            catch (error) {\n                return Object.assign(Object.assign({ stage: \"generate\" }, generateSummaryData), { error });\n            }\n            const parent = summaryContext.ackHandle;\n            const summaryMessage = {\n                handle,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                head: parent,\n                message,\n                parents: parent ? [parent] : [],\n            };\n            const uploadData = Object.assign(Object.assign({}, generateSummaryData), { handle, uploadDuration: trace.trace().duration });\n            continueResult = checkContinue();\n            if (!continueResult.continue) {\n                return Object.assign(Object.assign({ stage: \"upload\" }, uploadData), { error: continueResult.error });\n            }\n            let clientSequenceNumber;\n            try {\n                clientSequenceNumber = this.submitSystemMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.Summarize, summaryMessage);\n            }\n            catch (error) {\n                return Object.assign(Object.assign({ stage: \"upload\" }, uploadData), { error });\n            }\n            const submitData = Object.assign(Object.assign({ stage: \"submit\" }, uploadData), { clientSequenceNumber, submitOpDuration: trace.trace().duration });\n            this.summarizerNode.completeSummary(handle);\n            this.opTracker.reset();\n            return submitData;\n        }\n        finally {\n            // Cleanup wip summary in case of failure\n            this.summarizerNode.clearSummary();\n            // Restart the delta manager\n            this.deltaManager.inbound.resume();\n        }\n    }\n    processRemoteChunkedMessage(message) {\n        if (message.type !== ContainerMessageType.ChunkedOp) {\n            return message;\n        }\n        const clientId = message.clientId;\n        const chunkedContent = message.contents;\n        this.addChunk(clientId, chunkedContent);\n        if (chunkedContent.chunkId === chunkedContent.totalChunks) {\n            const newMessage = Object.assign({}, message);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const serializedContent = this.chunkMap.get(clientId).join(\"\");\n            newMessage.contents = JSON.parse(serializedContent);\n            newMessage.type = chunkedContent.originalType;\n            this.clearPartialChunks(clientId);\n            return newMessage;\n        }\n        return message;\n    }\n    addChunk(clientId, chunkedContent) {\n        let map = this.chunkMap.get(clientId);\n        if (map === undefined) {\n            map = [];\n            this.chunkMap.set(clientId, map);\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(chunkedContent.chunkId === map.length + 1, 0x131 /* \"Mismatch between new chunkId and expected chunkMap\" */); // 1-based indexing\n        map.push(chunkedContent.contents);\n    }\n    clearPartialChunks(clientId) {\n        if (this.chunkMap.has(clientId)) {\n            this.chunkMap.delete(clientId);\n        }\n    }\n    updateDocumentDirtyState(dirty) {\n        if (this.dirtyContainer === dirty) {\n            return;\n        }\n        this.dirtyContainer = dirty;\n        if (this.emitDirtyDocumentEvent) {\n            this.emit(dirty ? \"dirty\" : \"saved\");\n            this.context.updateDirtyContainerState(dirty);\n        }\n    }\n    submitDataStoreOp(id, contents, localOpMetadata = undefined) {\n        const envelope = {\n            address: id,\n            contents,\n        };\n        this.submit(ContainerMessageType.FluidDataStoreOp, envelope, localOpMetadata);\n    }\n    submitDataStoreAliasOp(contents, localOpMetadata) {\n        const aliasMessage = contents;\n        if (!(0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.isDataStoreAliasMessage)(aliasMessage)) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(\"malformedDataStoreAliasMessage\");\n        }\n        this.submit(ContainerMessageType.Alias, contents, localOpMetadata);\n    }\n    async uploadBlob(blob) {\n        this.verifyNotClosed();\n        return this.blobManager.createBlob(blob);\n    }\n    submit(type, content, localOpMetadata = undefined, opMetadata = undefined) {\n        this.verifyNotClosed();\n        // There should be no ops in detached container state!\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Detached, 0x132 /* \"sending ops in detached container\" */);\n        let clientSequenceNumber = -1;\n        let opMetadataInternal = opMetadata;\n        if (this.canSendOps()) {\n            const serializedContent = JSON.stringify(content);\n            const maxOpSize = this.context.deltaManager.maxMessageSize;\n            // If in TurnBased flush mode we will trigger a flush at the next turn break\n            if (this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased && !this.needsFlush) {\n                opMetadataInternal = Object.assign(Object.assign({}, opMetadata), { batch: true });\n                this.needsFlush = true;\n                // Use Promise.resolve().then() to queue a microtask to detect the end of the turn and force a flush.\n                if (!this.flushTrigger) {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    Promise.resolve().then(() => {\n                        this.flushTrigger = false;\n                        this.flush();\n                    });\n                }\n            }\n            clientSequenceNumber = this.submitMaybeChunkedMessages(type, content, serializedContent, maxOpSize, this._flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased, opMetadataInternal);\n        }\n        // Let the PendingStateManager know that a message was submitted.\n        this.pendingStateManager.onSubmitMessage(type, clientSequenceNumber, this.deltaManager.lastSequenceNumber, content, localOpMetadata, opMetadataInternal);\n        if (this.isContainerMessageDirtyable(type, content)) {\n            this.updateDocumentDirtyState(true);\n        }\n    }\n    submitMaybeChunkedMessages(type, content, serializedContent, serverMaxOpSize, batch, opMetadataInternal = undefined) {\n        if (this._maxOpSizeInBytes >= 0) {\n            // Chunking disabled\n            if (!serializedContent || serializedContent.length <= this._maxOpSizeInBytes) {\n                return this.submitRuntimeMessage(type, content, batch, opMetadataInternal);\n            }\n            // When chunking is disabled, we ignore the server max message size\n            // and if the content length is larger than the client configured message size\n            // instead of splitting the content, we will fail by explicitly close the container\n            this.closeFn(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.GenericError(\"OpTooLarge\", \n            /* error */ undefined, {\n                length: {\n                    value: serializedContent.length,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.PackageData,\n                },\n                limit: {\n                    value: this._maxOpSizeInBytes,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.PackageData,\n                },\n            }));\n            return -1;\n        }\n        // Chunking enabled, fallback on the server's max message size\n        // and split the content accordingly\n        if (!serializedContent || serializedContent.length <= serverMaxOpSize) {\n            return this.submitRuntimeMessage(type, content, batch, opMetadataInternal);\n        }\n        return this.submitChunkedMessage(type, serializedContent, serverMaxOpSize);\n    }\n    submitChunkedMessage(type, content, maxOpSize) {\n        const contentLength = content.length;\n        const chunkN = Math.floor((contentLength - 1) / maxOpSize) + 1;\n        let offset = 0;\n        let clientSequenceNumber = 0;\n        for (let i = 1; i <= chunkN; i = i + 1) {\n            const chunkedOp = {\n                chunkId: i,\n                contents: content.substr(offset, maxOpSize),\n                originalType: type,\n                totalChunks: chunkN,\n            };\n            offset += maxOpSize;\n            clientSequenceNumber = this.submitRuntimeMessage(ContainerMessageType.ChunkedOp, chunkedOp, false);\n        }\n        return clientSequenceNumber;\n    }\n    submitSystemMessage(type, contents) {\n        this.verifyNotClosed();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected, 0x133 /* \"Container disconnected when trying to submit system message\" */);\n        // System message should not be sent in the middle of the batch.\n        // That said, we can preserve existing behavior by not flushing existing buffer.\n        // That might be not what caller hopes to get, but we can look deeper if telemetry tells us it's a problem.\n        const middleOfBatch = this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased && this.needsFlush;\n        if (middleOfBatch) {\n            this.mc.logger.sendErrorEvent({ eventName: \"submitSystemMessageError\", type });\n        }\n        return this.context.submitFn(type, contents, middleOfBatch);\n    }\n    submitRuntimeMessage(type, contents, batch, appData) {\n        this.verifyNotClosed();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected, 0x259 /* \"Container disconnected when trying to submit system message\" */);\n        const payload = { type, contents };\n        return this.context.submitFn(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.Operation, payload, batch, appData);\n    }\n    /**\n     * Throw an error if the runtime is closed.  Methods that are expected to potentially\n     * be called after dispose due to asynchrony should not call this.\n     */\n    verifyNotClosed() {\n        if (this._disposed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n    /**\n     * Finds the right store and asks it to resubmit the message. This typically happens when we\n     * reconnect and there are pending messages.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmit(type, content, localOpMetadata, opMetadata) {\n        switch (type) {\n            case ContainerMessageType.FluidDataStoreOp:\n                // For Operations, call resubmitDataStoreOp which will find the right store\n                // and trigger resubmission on it.\n                this.dataStores.resubmitDataStoreOp(content, localOpMetadata);\n                break;\n            case ContainerMessageType.Attach:\n            case ContainerMessageType.Alias:\n                this.submit(type, content, localOpMetadata);\n                break;\n            case ContainerMessageType.ChunkedOp:\n                throw new Error(`chunkedOp not expected here`);\n            case ContainerMessageType.BlobAttach:\n                this.submit(type, content, localOpMetadata, opMetadata);\n                break;\n            case ContainerMessageType.Rejoin:\n                this.submit(type, content);\n                break;\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_36__.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);\n        }\n    }\n    rollback(type, content, localOpMetadata) {\n        switch (type) {\n            case ContainerMessageType.FluidDataStoreOp:\n                // For operations, call rollbackDataStoreOp which will find the right store\n                // and trigger rollback on it.\n                this.dataStores.rollbackDataStoreOp(content, localOpMetadata);\n                break;\n            default:\n                throw new Error(`Can't rollback ${type}`);\n        }\n    }\n    /** Implementation of ISummarizerInternalsProvider.refreshLatestSummaryAck */\n    async refreshLatestSummaryAck(proposalHandle, ackHandle, summaryRefSeq, summaryLogger) {\n        const readAndParseBlob = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(this.storage, id);\n        const { snapshotTree } = await this.fetchSnapshotFromStorage(ackHandle, summaryLogger, {\n            eventName: \"RefreshLatestSummaryGetSnapshot\",\n            ackHandle,\n            summaryRefSeq,\n            fetchLatest: false,\n        });\n        const result = await this.summarizerNode.refreshLatestSummary(proposalHandle, summaryRefSeq, async () => snapshotTree, readAndParseBlob, summaryLogger);\n        // Notify the garbage collector so it can update its latest summary state.\n        await this.garbageCollector.latestSummaryStateRefreshed(result, readAndParseBlob);\n    }\n    /**\n     * Fetches the latest snapshot from storage and uses it to refresh SummarizerNode's\n     * internal state as it should be considered the latest summary ack.\n     * @param summaryLogger - logger to use when fetching snapshot from storage\n     * @returns downloaded snapshot's reference sequence number\n     */\n    async refreshLatestSummaryAckFromServer(summaryLogger) {\n        const { snapshotTree, versionId } = await this.fetchSnapshotFromStorage(null, summaryLogger, {\n            eventName: \"RefreshLatestSummaryGetSnapshot\",\n            fetchLatest: true,\n        });\n        const readAndParseBlob = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(this.storage, id);\n        const latestSnapshotRefSeq = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_42__.seqFromTree)(snapshotTree, readAndParseBlob);\n        const result = await this.summarizerNode.refreshLatestSummary(undefined, latestSnapshotRefSeq, async () => snapshotTree, readAndParseBlob, summaryLogger);\n        // Notify the garbage collector so it can update its latest summary state.\n        await this.garbageCollector.latestSummaryStateRefreshed(result, readAndParseBlob);\n        return { latestSnapshotRefSeq, latestSnapshotVersionId: versionId };\n    }\n    async fetchSnapshotFromStorage(versionId, logger, event) {\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(logger, event, async (perfEvent) => {\n            const stats = {};\n            const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_41__.Trace.start();\n            const versions = await this.storage.getVersions(versionId, 1);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!versions && !!versions[0], 0x137 /* \"Failed to get version from storage\" */);\n            stats.getVersionDuration = trace.trace().duration;\n            const maybeSnapshot = await this.storage.getSnapshotTree(versions[0]);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!maybeSnapshot, 0x138 /* \"Failed to get snapshot from storage\" */);\n            stats.getSnapshotDuration = trace.trace().duration;\n            perfEvent.end(stats);\n            return { snapshotTree: maybeSnapshot, versionId: versions[0].id };\n        });\n    }\n    notifyAttaching(snapshot) {\n        var _a;\n        if ((_a = this.mc.config.getBoolean(\"enableOfflineLoad\")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) {\n            this.baseSnapshotBlobs = _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__.SerializedSnapshotStorage.serializeTreeWithBlobContents(snapshot);\n        }\n    }\n    async getSnapshotBlobs() {\n        var _a;\n        if (!((_a = this.mc.config.getBoolean(\"enableOfflineLoad\")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) ||\n            this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached || this.context.pendingLocalState) {\n            return;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.context.baseSnapshot, 0x2e5 /* \"Must have a base snapshot\" */);\n        this.baseSnapshotBlobs = await _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__.SerializedSnapshotStorage.serializeTree(this.context.baseSnapshot, this.storage);\n    }\n    getPendingLocalState() {\n        var _a;\n        if (!((_a = this.mc.config.getBoolean(\"enableOfflineLoad\")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad)) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(\"can't get state when offline load disabled\");\n        }\n        const previousPendingState = this.context.pendingLocalState;\n        if (previousPendingState) {\n            return {\n                pending: this.pendingStateManager.getLocalState(),\n                snapshotBlobs: previousPendingState.snapshotBlobs,\n                baseSnapshot: previousPendingState.baseSnapshot,\n                savedOps: this.savedOps,\n            };\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.context.baseSnapshot, 0x2e6 /* \"Must have a base snapshot\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.baseSnapshotBlobs, 0x2e7 /* \"Must serialize base snapshot blobs before getting runtime state\" */);\n        return {\n            pending: this.pendingStateManager.getLocalState(),\n            snapshotBlobs: this.baseSnapshotBlobs,\n            baseSnapshot: this.context.baseSnapshot,\n            savedOps: this.savedOps,\n        };\n    }\n    /**\n     * * Forms a function that will request a Summarizer.\n     * @param loaderRouter - the loader acting as an IFluidRouter\n     * */\n    formRequestSummarizerFn(loaderRouter) {\n        return async () => {\n            const request = {\n                headers: {\n                    [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__.LoaderHeader.cache]: false,\n                    [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__.LoaderHeader.clientDetails]: {\n                        capabilities: { interactive: false },\n                        type: _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType,\n                    },\n                    [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_44__.DriverHeader.summarizingClient]: true,\n                    [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__.LoaderHeader.reconnect]: false,\n                },\n                url: \"/_summarizer\",\n            };\n            const fluidObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.requestFluidObject)(loaderRouter, request);\n            const summarizer = fluidObject.ISummarizer;\n            if (!summarizer) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(\"Fluid object does not implement ISummarizer\");\n            }\n            return summarizer;\n        };\n    }\n    async processSavedOps(state) {\n        for (const op of state.savedOps) {\n            this.process(op, false);\n            await this.pendingStateManager.applyStashedOpsAt(op.sequenceNumber);\n        }\n        // we may not have seen every sequence number (because of system ops) so apply everything once we\n        // don't have any more saved ops\n        await this.pendingStateManager.applyStashedOpsAt();\n    }\n}\n/**\n * Wait for a specific sequence number. Promise should resolve when we reach that number,\n * or reject if closed.\n */\nconst waitForSeq = async (deltaManager, targetSeq) => new Promise((resolve, reject) => {\n    // TODO: remove cast to any when actual event is determined\n    deltaManager.on(\"closed\", reject);\n    const handleOp = (message) => {\n        if (message.sequenceNumber >= targetSeq) {\n            resolve();\n            deltaManager.off(\"op\", handleOp);\n        }\n    };\n    deltaManager.on(\"op\", handleOp);\n});\n//# sourceMappingURL=containerRuntime.js.map\n\n/***/ }),\n/* 55 */\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(56), exports);\n__exportStar(__webpack_require__(57), exports);\n__exportStar(__webpack_require__(58), exports);\n__exportStar(__webpack_require__(59), exports);\n__exportStar(__webpack_require__(60), exports);\n__exportStar(__webpack_require__(61), exports);\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 56 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IFluidDataStoreFactory = void 0;\nexports.IFluidDataStoreFactory = \"IFluidDataStoreFactory\";\n//# sourceMappingURL=dataStoreFactory.js.map\n\n/***/ }),\n/* 57 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IFluidDataStoreRegistry = void 0;\nexports.IFluidDataStoreRegistry = \"IFluidDataStoreRegistry\";\n//# sourceMappingURL=dataStoreRegistry.js.map\n\n/***/ }),\n/* 58 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VisibilityState = exports.FlushMode = void 0;\n/**\n * Runtime flush mode handling\n */\nvar FlushMode;\n(function (FlushMode) {\n    /**\n     * In Immediate flush mode the runtime will immediately send all operations to the driver layer.\n     */\n    FlushMode[FlushMode[\"Immediate\"] = 0] = \"Immediate\";\n    /**\n     * When in TurnBased flush mode the runtime will buffer operations in the current turn and send them as a single\n     * batch at the end of the turn. The flush call on the runtime can be used to force send the current batch.\n     */\n    FlushMode[FlushMode[\"TurnBased\"] = 1] = \"TurnBased\";\n})(FlushMode = exports.FlushMode || (exports.FlushMode = {}));\n/**\n * This tells the visibility state of a Fluid object. It basically tracks whether the object is not visible, visible\n * locally within the container only or visible globally to all clients.\n */\nexports.VisibilityState = {\n    /** Indicates that the object is not visible. This is the state when an object is first created. */\n    NotVisible: \"NotVisible\",\n    /**\n     * Indicates that the object is visible locally within the container. This is the state when an object is attached\n     * to the container's graph but the container itself isn't globally visible. The object's state goes from not\n     * visible to locally visible.\n     */\n    LocallyVisible: \"LocallyVisible\",\n    /**\n     * Indicates that the object is visible globally to all clients. This is the state of an object in 2 scenarios:\n     * 1. It is attached to the container's graph when the container is globally visible. The object's state goes from\n     *    not visible to globally visible.\n     * 2. When a container becomes globally visible, all locally visible objects go from locally visible to globally\n     *    visible.\n     */\n    GloballyVisible: \"GloballyVisible\",\n};\n//# sourceMappingURL=dataStoreContext.js.map\n\n/***/ }),\n/* 59 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.gcBlobKey = void 0;\n// The key to use for storing garbage collection blob in summary.\nexports.gcBlobKey = \"gc\";\n//# sourceMappingURL=garbageCollection.js.map\n\n/***/ }),\n/* 60 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 61 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.totalBlobSizePropertyName = exports.blobCountPropertyName = exports.channelsTreeName = exports.CreateSummarizerNodeSource = void 0;\nvar CreateSummarizerNodeSource;\n(function (CreateSummarizerNodeSource) {\n    CreateSummarizerNodeSource[CreateSummarizerNodeSource[\"FromSummary\"] = 0] = \"FromSummary\";\n    CreateSummarizerNodeSource[CreateSummarizerNodeSource[\"FromAttach\"] = 1] = \"FromAttach\";\n    CreateSummarizerNodeSource[CreateSummarizerNodeSource[\"Local\"] = 2] = \"Local\";\n})(CreateSummarizerNodeSource = exports.CreateSummarizerNodeSource || (exports.CreateSummarizerNodeSource = {}));\nexports.channelsTreeName = \".channels\";\nexports.blobCountPropertyName = \"BlobCount\";\nexports.totalBlobSizePropertyName = \"TotalBlobSize\";\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 62 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 63 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 64 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isClientMessage\": () => (/* binding */ isClientMessage),\n/* harmony export */   \"isRuntimeMessage\": () => (/* binding */ isRuntimeMessage),\n/* harmony export */   \"isUnpackedRuntimeMessage\": () => (/* binding */ isUnpackedRuntimeMessage)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n *\n * @param message-message\n * @returns whether or not the message type is one listed below\n * \"op\"\n * \"summarize\"\n * \"propose\"\n * \"reject\"\n * \"noop\"\n */\nfunction isClientMessage(message) {\n    if (isRuntimeMessage(message)) {\n        return true;\n    }\n    switch (message.type) {\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp:\n            return true;\n        default:\n            return false;\n    }\n}\n/**\n *\n * @param message-message\n * @returns whether or not the message type is one listed below\n * \"op\"\n * \"summarize\"\n */\nfunction isRuntimeMessage(message) {\n    return message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Operation || message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Summarize;\n}\nvar RuntimeMessage;\n(function (RuntimeMessage) {\n    RuntimeMessage[\"FluidDataStoreOp\"] = \"component\";\n    RuntimeMessage[\"Attach\"] = \"attach\";\n    RuntimeMessage[\"ChunkedOp\"] = \"chunkedOp\";\n    RuntimeMessage[\"BlobAttach\"] = \"blobAttach\";\n    RuntimeMessage[\"Rejoin\"] = \"rejoin\";\n    RuntimeMessage[\"Alias\"] = \"alias\";\n    RuntimeMessage[\"Operation\"] = \"op\";\n})(RuntimeMessage || (RuntimeMessage = {}));\n/**\n *\n * @param message-message\n * @returns whether or not the message type is one listed below (legacy)\n * \"component\"\n * \"attach\"\n * \"chunkedOp\"\n * \"blobAttach\"\n * \"rejoin\"\n * \"alias\"\n * \"op\"\n */\nfunction isUnpackedRuntimeMessage(message) {\n    if (Object.values(RuntimeMessage).includes(message.type)) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=messageRecognition.js.map\n\n/***/ }),\n/* 65 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 66 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst performance = window.performance;\n//# sourceMappingURL=performanceBrowser.js.map\n\n/***/ }),\n/* 67 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReportOpPerfTelemetry\": () => (/* binding */ ReportOpPerfTelemetry),\n/* harmony export */   \"latencyThreshold\": () => (/* binding */ latencyThreshold)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * We report various latency-related errors when waiting for op roundtrip takes longer than that amout of time.\n */\nconst latencyThreshold = 5000;\nclass OpPerfTelemetry {\n    constructor(clientId, deltaManager, logger) {\n        this.clientId = clientId;\n        this.deltaManager = deltaManager;\n        this.pongCount = 0;\n        this.msnTrackingTimestamp = 0;\n        this.opProcessingTimes = {};\n        // Performance Data to be reported for ops round trips and processing.\n        this.opPerfData = {};\n        this.firstConnection = true;\n        this.bootTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        this.connectionStartTime = 0;\n        this.gap = 0;\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, \"OpPerf\");\n        this.deltaManager.on(\"pong\", (latency) => this.recordPingTime(latency));\n        this.deltaManager.on(\"submitOp\", (message) => this.beforeOpSubmit(message));\n        this.deltaManager.on(\"op\", (message) => this.afterProcessingOp(message));\n        this.deltaManager.on(\"connect\", (details, opsBehind) => {\n            this.clientId = details.clientId;\n            if (opsBehind !== undefined) {\n                this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;\n                this.gap = opsBehind;\n                this.connectionStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n                // We might be already up-today. If so, report it right away.\n                if (this.gap <= 0) {\n                    this.reportGettingUpToDate();\n                }\n            }\n        });\n        this.deltaManager.on(\"disconnect\", () => {\n            this.sequenceNumberForMsnTracking = undefined;\n            this.clientSequenceNumberForLatencyStatistics = undefined;\n            this.opProcessingTimes = {};\n            this.opPerfData = {};\n            this.connectionOpSeqNumber = undefined;\n            this.firstConnection = false;\n            this.pongCount = 0;\n        });\n        this.deltaManager.outbound.on(\"push\", (messages) => {\n            for (const msg of messages) {\n                if (msg.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Operation &&\n                    this.clientSequenceNumberForLatencyStatistics === msg.clientSequenceNumber) {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2c8 /* \"outboundPushEventTime should be undefined\" */);\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opPerfData.durationNetwork === undefined, 0x2c9 /* \"durationNetwork should be undefined\" */);\n                    this.opProcessingTimes.outboundPushEventTime = Date.now();\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opPerfData.durationOutboundBatching === undefined, 0x2ca /* \"durationOutboundBatching should be undefined\" */);\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.submitOpEventTime !== undefined, 0x2cb /* \"submitOpEventTime should be undefined\" */);\n                    this.opPerfData.durationOutboundBatching = this.opProcessingTimes.outboundPushEventTime\n                        - this.opProcessingTimes.submitOpEventTime;\n                }\n            }\n        });\n        this.deltaManager.inbound.on(\"push\", (message) => {\n            if (this.clientId === message.clientId &&\n                message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Operation &&\n                this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber &&\n                this.opProcessingTimes.outboundPushEventTime !== undefined) {\n                this.opProcessingTimes.inboundPushEventTime = Date.now();\n                this.opPerfData.durationNetwork = this.opProcessingTimes.inboundPushEventTime\n                    - this.opProcessingTimes.outboundPushEventTime;\n                this.opProcessingTimes.outboundPushEventTime = undefined;\n                this.opPerfData.lengthInboundQueue = this.deltaManager.inbound.length;\n            }\n        });\n        this.deltaManager.inbound.on(\"idle\", (count, duration) => {\n            // Do not want to log zero for sure.\n            // We are more interested in aggregates, so logging only if we are processing some number of ops\n            // Cut-off is arbitrary - can be increased or decreased based on amount of data collected and questions we\n            // want to get answered\n            // back-compat: Once 0.36 loader version saturates (count & duration args were added there),\n            // we can remove typeof check.\n            if (typeof count === \"number\" && count >= 100) {\n                this.logger.sendPerformanceEvent({\n                    eventName: \"GetDeltas_OpProcessing\",\n                    count,\n                    duration,\n                });\n            }\n        });\n    }\n    reportGettingUpToDate() {\n        this.connectionOpSeqNumber = undefined;\n        this.logger.sendPerformanceEvent({\n            eventName: \"ConnectionSpeed\",\n            duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - this.connectionStartTime,\n            ops: this.gap,\n            // track time to connect only for first connection.\n            timeToConnect: this.firstConnection ?\n                _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) :\n                undefined,\n            firstConnection: this.firstConnection,\n        });\n    }\n    recordPingTime(latency) {\n        this.pingLatency = latency;\n        // logging one in every 1000 pongs, including the first time, if it is a \"write\" client.\n        if (this.pongCount % 100 === 0 && this.deltaManager.active) {\n            this.logger.sendPerformanceEvent({\n                eventName: \"DeltaLatency\",\n                duration: latency,\n            });\n        }\n        this.pongCount++;\n    }\n    beforeOpSubmit(message) {\n        // start with first client op and measure latency every 500 client ops\n        if (this.clientSequenceNumberForLatencyStatistics === undefined &&\n            message.clientSequenceNumber % 500 === 1) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2cc /* \"OpTimeSittingInboundQueue should be undefined\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opPerfData.durationNetwork === undefined, 0x2cd /* \"durationNetwork should be undefined\" */);\n            this.opProcessingTimes.submitOpEventTime = Date.now();\n            this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;\n        }\n    }\n    afterProcessingOp(message) {\n        const sequenceNumber = message.sequenceNumber;\n        if (sequenceNumber === this.connectionOpSeqNumber) {\n            this.reportGettingUpToDate();\n        }\n        // Record collab window max size after every 1000th op.\n        if (this.sequenceNumberForMsnTracking === undefined && sequenceNumber % 1000 === 0) {\n            this.sequenceNumberForMsnTracking = sequenceNumber;\n            this.msnTrackingTimestamp = message.timestamp;\n        }\n        if (this.sequenceNumberForMsnTracking !== undefined &&\n            message.minimumSequenceNumber >= this.sequenceNumberForMsnTracking) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.msnTrackingTimestamp !== undefined, 0x2ce /* \"msnTrackingTimestamp should not be undefined\" */);\n            this.logger.sendPerformanceEvent({\n                eventName: \"MsnStatistics\",\n                sequenceNumber,\n                msnDistance: sequenceNumber - this.sequenceNumberForMsnTracking,\n                duration: message.timestamp - this.msnTrackingTimestamp,\n            });\n            this.sequenceNumberForMsnTracking = undefined;\n        }\n        if (this.clientId === message.clientId &&\n            this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.submitOpEventTime !== undefined, 0x120 /* \"Undefined latency statistics (op send time)\" */);\n            const currentTime = Date.now();\n            if (this.opProcessingTimes.inboundPushEventTime !== undefined) {\n                this.opPerfData.durationInboundToProcessing = currentTime\n                    - this.opProcessingTimes.inboundPushEventTime;\n            }\n            const duration = currentTime - this.opProcessingTimes.submitOpEventTime;\n            // One of the core expectations for Fluid service is to be fast.\n            // When it's not the case, we want to learn about it and be able to investigate, so\n            // raise awareness.\n            // This also helps identify cases where it's due to client behavior (sending too many ops)\n            // that results in overwhelming ordering service and thus starting to see long latencies.\n            // The threshold could be adjusted, but ideally it stays  workload-agnostic, as service\n            // performance impacts all workloads relying on service.\n            const category = duration > latencyThreshold ? \"error\" : \"performance\";\n            this.logger.sendPerformanceEvent(Object.assign({ eventName: \"OpRoundtripTime\", sequenceNumber, referenceSequenceNumber: message.referenceSequenceNumber, duration,\n                category, pingLatency: this.pingLatency, msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber }, this.opPerfData));\n            this.clientSequenceNumberForLatencyStatistics = undefined;\n            this.opPerfData = {};\n        }\n    }\n}\nfunction ReportOpPerfTelemetry(clientId, deltaManager, logger) {\n    new OpPerfTelemetry(clientId, deltaManager, logger);\n}\n//# sourceMappingURL=connectionTelemetry.js.map\n\n/***/ }),\n/* 68 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/container-runtime\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 69 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeltaScheduler\": () => (/* binding */ DeltaScheduler)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there\n * is more than one op a particular run of the queue. It does not schedule if there is just one\n * op or just one batch in the run. It does the following two things:\n * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue\n *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block\n *    the JS thread for a long time processing ops synchronously (for example, when catching up\n *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).\n * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops\n *    processed, the time and number of turns it took to process the ops.\n */\nclass DeltaScheduler {\n    constructor(deltaManager, logger) {\n        this.logger = logger;\n        // The increase in time for processing ops after each turn.\n        this.processingTimeIncrement = 10;\n        this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;\n        // This keeps track of the number of times inbound queue has been scheduled. After a particular\n        // count, we log telemetry for the number of ops processed, the time and number of turns it took\n        // to process the ops.\n        this.schedulingCount = 0;\n        this.deltaManager = deltaManager;\n        this.deltaManager.inbound.on(\"idle\", () => { this.inboundQueueIdle(); });\n    }\n    batchBegin(message) {\n        if (!this.processingStartTime) {\n            this.processingStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        }\n        if (this.schedulingLog === undefined && this.schedulingCount % 500 === 0) {\n            // Every 500th time we are scheduling the inbound queue, we log telemetry for the\n            // number of ops processed, the time and number of turns it took to process the ops.\n            this.schedulingLog = {\n                opsRemainingToProcess: 0,\n                numberOfTurns: 1,\n                totalProcessingTime: 0,\n                numberOfBatchesProcessed: 0,\n                firstSequenceNumber: message.sequenceNumber,\n                lastSequenceNumber: message.sequenceNumber,\n                startTime: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now(),\n            };\n        }\n    }\n    batchEnd(message) {\n        if (this.schedulingLog) {\n            this.schedulingLog.numberOfBatchesProcessed++;\n            this.schedulingLog.lastSequenceNumber = message.sequenceNumber;\n            this.schedulingLog.opsRemainingToProcess = this.deltaManager.inbound.length;\n        }\n        if (this.shouldRunScheduler()) {\n            const currentTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const elapsedTime = currentTime - this.processingStartTime;\n            if (elapsedTime > this.currentAllowedProcessingTimeForTurn) {\n                // We have processed ops for more than the total processing time. So, pause the\n                // queue, yield the thread and schedule a resume.\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this.deltaManager.inbound.pause();\n                // Increase the total processing time. Keep doing this after each turn until all the ops have\n                // been processed. This way we keep the responsiveness at the beginning while also making sure\n                // that all the ops process fairly quickly.\n                this.currentAllowedProcessingTimeForTurn += this.processingTimeIncrement;\n                // If we are logging the telemetry this time, update the telemetry log object.\n                if (this.schedulingLog) {\n                    this.schedulingLog.numberOfTurns++;\n                    this.schedulingLog.totalProcessingTime += elapsedTime;\n                }\n                setTimeout(() => {\n                    if (this.schedulingLog) {\n                        this.logger.sendTelemetryEvent({\n                            eventName: \"InboundOpsPartialProcessingTime\",\n                            duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(elapsedTime),\n                            opsProcessed: this.schedulingLog.lastSequenceNumber -\n                                this.schedulingLog.firstSequenceNumber + 1,\n                            opsRemainingToProcess: this.deltaManager.inbound.length,\n                            processingTime: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),\n                            numberOfTurns: this.schedulingLog.numberOfTurns,\n                            batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,\n                            timeToResume: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - currentTime),\n                        });\n                    }\n                    this.deltaManager.inbound.resume();\n                });\n                this.processingStartTime = undefined;\n            }\n        }\n    }\n    inboundQueueIdle() {\n        if (this.schedulingLog) {\n            // Add the time taken for processing the final ops to the total processing time in the\n            // telemetry log object.\n            const currentTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.schedulingLog.totalProcessingTime += currentTime - this.processingStartTime;\n            this.logger.sendTelemetryEvent({\n                eventName: \"InboundOpsProcessingTime\",\n                opsRemainingToProcess: this.schedulingLog.opsRemainingToProcess,\n                numberOfTurns: this.schedulingLog.numberOfTurns,\n                processingTime: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),\n                opsProcessed: this.schedulingLog.lastSequenceNumber - this.schedulingLog.firstSequenceNumber + 1,\n                batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,\n                duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(currentTime - this.schedulingLog.startTime),\n                schedulingCount: this.schedulingCount,\n            });\n            this.schedulingLog = undefined;\n        }\n        // If we scheduled this batch of the inbound queue, increment the counter that tracks the\n        // number of times we have done this.\n        this.schedulingCount++;\n        // Reset the processing times.\n        this.processingStartTime = undefined;\n        this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;\n    }\n    /**\n     * This function tells whether we should run the scheduler.\n     */\n    shouldRunScheduler() {\n        // If there are still ops in the queue after the one we are processing now, we should\n        // run the scheduler.\n        return this.deltaManager.inbound.length > 0;\n    }\n}\n// The time for processing ops in a single turn.\nDeltaScheduler.processingTime = 50;\n//# sourceMappingURL=deltaScheduler.js.map\n\n/***/ }),\n/* 70 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 71 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarizerClientElection\": () => (/* binding */ SummarizerClientElection),\n/* harmony export */   \"summarizerClientType\": () => (/* binding */ summarizerClientType)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nconst summarizerClientType = \"summarizer\";\n/**\n * This class encapsulates logic around tracking the elected summarizer client.\n * It will handle updating the elected client when a summary ack hasn't been seen\n * for some configured number of ops.\n */\nclass SummarizerClientElection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(logger, summaryCollection, clientElection, maxOpsSinceLastSummary, electionEnabled) {\n        super();\n        this.logger = logger;\n        this.summaryCollection = summaryCollection;\n        this.clientElection = clientElection;\n        this.maxOpsSinceLastSummary = maxOpsSinceLastSummary;\n        this.electionEnabled = electionEnabled;\n        /**\n         * Used to prevent excess logging by recording the sequence number that we last reported at,\n         * and making sure we don't report another event to telemetry. If things work as intended,\n         * this is not needed, otherwise it could report an event on every op in worst case scenario.\n         */\n        this.lastReportedSeq = 0;\n        // On every inbound op, if enough ops pass without seeing a summary ack (per elected client),\n        // elect a new client and log to telemetry.\n        this.summaryCollection.on(\"default\", ({ sequenceNumber }) => {\n            var _a, _b, _c;\n            const electedClientId = this.electedClientId;\n            if (electedClientId === undefined) {\n                // Reset election if no elected client, but eligible clients are connected.\n                // This should be uncommon, but is possible if the initial state of the\n                // ordered client election contains an undefined client id or one not found\n                // in the quorum (the latter would already log an error).\n                if (this.clientElection.eligibleCount > 0) {\n                    this.clientElection.resetElectedClient(sequenceNumber);\n                }\n                return;\n            }\n            let electionSequenceNumber = this.clientElection.electionSequenceNumber;\n            const opsWithoutSummary = sequenceNumber - ((_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber);\n            if (opsWithoutSummary > this.maxOpsSinceLastSummary) {\n                // Log and elect a new summarizer client.\n                const opsSinceLastReport = sequenceNumber - this.lastReportedSeq;\n                if (opsSinceLastReport > this.maxOpsSinceLastSummary) {\n                    this.logger.sendErrorEvent({\n                        eventName: \"ElectedClientNotSummarizing\",\n                        electedClientId,\n                        lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,\n                        electionSequenceNumber,\n                        nextElectedClientId: (_b = this.clientElection.peekNextElectedClient()) === null || _b === void 0 ? void 0 : _b.clientId,\n                        electionEnabled: this.electionEnabled,\n                    });\n                    this.lastReportedSeq = sequenceNumber;\n                }\n                if (this.electionEnabled) {\n                    const previousParentId = this.electedParentId;\n                    this.clientElection.incrementElectedClient(sequenceNumber);\n                    // Verify that state incremented as expected. This should be reliable,\n                    // since all of OrderedClientElection is synchronous.\n                    electionSequenceNumber = this.clientElection.electionSequenceNumber;\n                    if (sequenceNumber > ((_c = this.lastSummaryAckSeqForClient) !== null && _c !== void 0 ? _c : electionSequenceNumber)) {\n                        if (opsSinceLastReport > this.maxOpsSinceLastSummary) {\n                            this.logger.sendErrorEvent({\n                                eventName: \"UnexpectedElectionSequenceNumber\",\n                                // Expected to be undefined\n                                lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,\n                                // Expected to be same as op sequenceNumber\n                                electionSequenceNumber,\n                                sequenceNumber,\n                                previousClientId: electedClientId,\n                                previousParentId,\n                                electedParentId: this.electedParentId,\n                                electedClientId: this.electedClientId,\n                                opsSinceLastReport,\n                                maxOpsSinceLastSummary,\n                            });\n                        }\n                    }\n                }\n            }\n        });\n        // When a summary ack comes in, reset our op seq counter.\n        this.summaryCollection.on(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.SummaryAck, (op) => {\n            this.lastSummaryAckSeqForClient = op.sequenceNumber;\n        });\n        // Use oldest client election for unanimously and deterministically deciding\n        // which client should summarize.\n        this.clientElection.on(\"election\", (client, sequenceNumber) => {\n            this.lastSummaryAckSeqForClient = undefined;\n            if (client === undefined && this.clientElection.eligibleCount > 0) {\n                // If no client is valid for election, reset to the oldest again.\n                // Also make extra sure not to get stuck in an infinite loop here:\n                // If there are no eligible clients, just wait until a client joins\n                // and will be auto-elected.\n                this.clientElection.resetElectedClient(sequenceNumber);\n            }\n            // Election can trigger a change in SummaryManager state.\n            this.emit(\"electedSummarizerChanged\");\n        });\n    }\n    get electedClientId() {\n        var _a;\n        return (_a = this.clientElection.electedClient) === null || _a === void 0 ? void 0 : _a.clientId;\n    }\n    get electedParentId() {\n        var _a;\n        return (_a = this.clientElection.electedParent) === null || _a === void 0 ? void 0 : _a.clientId;\n    }\n    serialize() {\n        var _a;\n        const { electedClientId, electedParentId, electionSequenceNumber } = this.clientElection.serialize();\n        return {\n            electedClientId,\n            electedParentId,\n            electionSequenceNumber: (_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber,\n        };\n    }\n    static isClientEligible(client) {\n        const details = client.client.details;\n        if (details === undefined) {\n            // Very old clients back-compat\n            return true;\n        }\n        return SummarizerClientElection.clientDetailsPermitElection(details);\n    }\n}\nSummarizerClientElection.clientDetailsPermitElection = (details) => details.capabilities.interactive || details.type === summarizerClientType;\n//# sourceMappingURL=summarizerClientElection.js.map\n\n/***/ }),\n/* 72 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContainerFluidHandleContext\": () => (/* binding */ ContainerFluidHandleContext)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass ContainerFluidHandleContext {\n    /**\n     * Creates a new ContainerFluidHandleContext.\n     * @param path - The path to this handle relative to the routeContext.\n     * @param runtime - The IRuntime object this context represents.\n     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.\n     */\n    constructor(path, runtime, routeContext) {\n        this.path = path;\n        this.runtime = runtime;\n        this.routeContext = routeContext;\n        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);\n    }\n    get IFluidHandleContext() { return this; }\n    attachGraph() {\n        throw new Error(\"can't attach container runtime form within container!\");\n    }\n    get isAttached() {\n        return this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.AttachState.Detached;\n    }\n    async resolveHandle(request) {\n        return this.runtime.resolveHandle(request);\n    }\n}\n//# sourceMappingURL=containerHandleContext.js.map\n\n/***/ }),\n/* 73 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GCNodeType\": () => (/* binding */ GCNodeType),\n/* harmony export */   \"GarbageCollector\": () => (/* binding */ GarbageCollector),\n/* harmony export */   \"defaultSessionExpiryDurationMs\": () => (/* binding */ defaultSessionExpiryDurationMs),\n/* harmony export */   \"disableSessionExpiryKey\": () => (/* binding */ disableSessionExpiryKey),\n/* harmony export */   \"gcBlobPrefix\": () => (/* binding */ gcBlobPrefix),\n/* harmony export */   \"gcTreeKey\": () => (/* binding */ gcTreeKey),\n/* harmony export */   \"oneDayMs\": () => (/* binding */ oneDayMs),\n/* harmony export */   \"runSessionExpiryKey\": () => (/* binding */ runSessionExpiryKey),\n/* harmony export */   \"trackGCStateKey\": () => (/* binding */ trackGCStateKey)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(105);\n/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(103);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(77);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);\n/* harmony import */ var _containerRuntime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(54);\n/* harmony import */ var _dataStores__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82);\n/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\n\n\n\n\n\n\n/** This is the current version of garbage collection. */\nconst GCVersion = 1;\n// The key for the GC tree in summary.\nconst gcTreeKey = \"gc\";\n// They prefix for GC blobs in the GC tree in summary.\nconst gcBlobPrefix = \"__gc\";\n// Feature gate key to turn GC on / off.\nconst runGCKey = \"Fluid.GarbageCollection.RunGC\";\n// Feature gate key to turn GC sweep on / off.\nconst runSweepKey = \"Fluid.GarbageCollection.RunSweep\";\n// Feature gate key to turn GC test mode on / off.\nconst gcTestModeKey = \"Fluid.GarbageCollection.GCTestMode\";\n// Feature gate key to write GC data at the root of the summary tree.\nconst writeAtRootKey = \"Fluid.GarbageCollection.WriteDataAtRoot\";\n// Feature gate key to expire a session after a set period of time.\nconst runSessionExpiryKey = \"Fluid.GarbageCollection.RunSessionExpiry\";\n// Feature gate key to disable expiring session after a set period of time, even if expiry value is present\nconst disableSessionExpiryKey = \"Fluid.GarbageCollection.DisableSessionExpiry\";\n// Feature gate key to write the gc blob as a handle if the data is the same.\nconst trackGCStateKey = \"Fluid.GarbageCollection.TrackGCState\";\n// Feature gate key to turn GC sweep log off.\nconst disableSweepLogKey = \"Fluid.GarbageCollection.DisableSweepLog\";\n// One day in milliseconds.\nconst oneDayMs = 1 * 24 * 60 * 60 * 1000;\nconst defaultInactiveTimeoutMs = 7 * oneDayMs; // 7 days\nconst defaultSessionExpiryDurationMs = 30 * oneDayMs; // 30 days\n/** The types of GC nodes in the GC reference graph. */\nconst GCNodeType = {\n    // Nodes that are for data stores.\n    DataStore: \"DataStore\",\n    // Nodes that are within a data store. For example, DDS nodes.\n    SubDataStore: \"SubDataStore\",\n    // Nodes that are for attachment blobs, i.e., blobs uploaded via BlobManager.\n    Blob: \"Blob\",\n    // Nodes that are neither of the above. For example, root node.\n    Other: \"Other\",\n};\n/** The state of node that is unreferenced. */\nconst UnreferencedState = {\n    /** The node is active, i.e., it can become referenced again. */\n    Active: \"Active\",\n    /** The node is inactive, i.e., it should not become referenced. */\n    Inactive: \"Inactive\",\n    /** The node is ready to be deleted by the sweep phase. */\n    SweepReady: \"SweepReady\",\n};\n/**\n * Helper class that tracks the state of an unreferenced node such as the time it was unreferenced and if it can\n * be deleted by the sweep phase.\n */\nclass UnreferencedStateTracker {\n    constructor(unreferencedTimestampMs, \n    /** The time after which node transitions to Inactive state. */\n    inactiveTimeoutMs, \n    /** The time after which node transitions to SweepReady state; undefined if session expiry is disabled. */\n    sweepTimeoutMs, \n    /** The current reference timestamp; undefined if no ops have ever been processed which can happen in tests. */\n    currentReferenceTimestampMs) {\n        this.unreferencedTimestampMs = unreferencedTimestampMs;\n        this.inactiveTimeoutMs = inactiveTimeoutMs;\n        this.sweepTimeoutMs = sweepTimeoutMs;\n        this._state = UnreferencedState.Active;\n        // If there is no current reference timestamp, don't track the node's unreferenced state. This will happen\n        // later when updateTracking is called with a reference timestamp.\n        if (currentReferenceTimestampMs !== undefined) {\n            this.updateTracking(currentReferenceTimestampMs);\n        }\n    }\n    get state() {\n        return this._state;\n    }\n    /* Updates the unreferenced state based on the provided timestamp. */\n    updateTracking(currentReferenceTimestampMs) {\n        const unreferencedDurationMs = currentReferenceTimestampMs - this.unreferencedTimestampMs;\n        // If the node has been unreferenced for sweep timeout amount of time, update the state to SweepReady.\n        if (this.sweepTimeoutMs !== undefined && unreferencedDurationMs >= this.sweepTimeoutMs) {\n            this._state = UnreferencedState.SweepReady;\n            this.clearTimers();\n            return;\n        }\n        // If the node has been unreferenced for inactive timeoutMs amount of time, update the state to inactive.\n        // Also, start a timer for the sweep timeout.\n        if (unreferencedDurationMs >= this.inactiveTimeoutMs) {\n            this._state = UnreferencedState.Inactive;\n            this.clearTimers();\n            if (this.sweepTimeoutMs !== undefined) {\n                setLongTimeout(this.sweepTimeoutMs - unreferencedDurationMs, () => { this._state = UnreferencedState.SweepReady; }, (timer) => { this.sweepTimer = timer; });\n            }\n            return;\n        }\n        // The node is still active. Start the inactive timer for the remaining duration.\n        const remainingDurationMs = this.inactiveTimeoutMs - unreferencedDurationMs;\n        if (this.inactiveTimer === undefined) {\n            const inactiveTimeoutHandler = () => {\n                this._state = UnreferencedState.Inactive;\n                // After the node becomes inactive, start the sweep timer after which the node will be ready for sweep.\n                if (this.sweepTimeoutMs !== undefined) {\n                    setLongTimeout(this.sweepTimeoutMs - this.inactiveTimeoutMs, () => { this._state = UnreferencedState.SweepReady; }, (timer) => { this.sweepTimer = timer; });\n                }\n            };\n            this.inactiveTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Timer(remainingDurationMs, () => inactiveTimeoutHandler());\n        }\n        this.inactiveTimer.restart(remainingDurationMs);\n    }\n    clearTimers() {\n        var _a;\n        (_a = this.inactiveTimer) === null || _a === void 0 ? void 0 : _a.clear();\n        if (this.sweepTimer !== undefined) {\n            clearTimeout(this.sweepTimer);\n        }\n    }\n    /** Stop tracking this node. Reset the unreferenced timers and state, if any. */\n    stopTracking() {\n        this.clearTimers();\n        this._state = UnreferencedState.Active;\n    }\n}\n/**\n * The garbage collector for the container runtime. It consolidates the garbage collection functionality and maintains\n * its state across summaries.\n *\n * Node - represented as nodeId, it's a node on the GC graph\n * Outbound Route - a path from one node to another node, think `nodeA` -\\> `nodeB`\n * Graph - all nodes with their respective routes\n *             GC Graph\n *\n *               Node\n *        NodeId = \"datastore1\"\n *           /             \\\\\n *    OutboundRoute   OutboundRoute\n *         /                 \\\\\n *       Node               Node\n *  NodeId = \"dds1\"     NodeId = \"dds2\"\n */\nclass GarbageCollector {\n    constructor(createParams) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Tells whether the GC data should be written to the root of the summary tree.\n         */\n        this._writeDataAtRoot = true;\n        /**\n         * Tells whether the initial GC state needs to be reset. This can happen under 2 conditions:\n         * 1. The base snapshot contains GC state but GC is disabled. This will happen the first time GC is disabled after\n         *    it was enabled before. GC state needs to be removed from summary and all nodes should be marked referenced.\n         * 2. The base snapshot does not have GC state but GC is enabled. This will happen the very first time GC runs on\n         *    a document and the first time GC is enabled after is was disabled before.\n         *\n         * Note that the state needs reset only for the very first time summary is generated by this client. After that, the\n         * state will be up-to-date and this flag will be reset.\n        */\n        this.initialStateNeedsReset = false;\n        // The current GC version that this container is running.\n        this.currentGCVersion = GCVersion;\n        // Keeps a list of references (edges in the GC graph) between GC runs. Each entry has a node id and a list of\n        // outbound routes from that node.\n        this.newReferencesSinceLastRun = new Map();\n        // Map of node ids to their unreferenced state tracker.\n        this.unreferencedNodesState = new Map();\n        // Keeps track of unreferenced events that are logged for a node. This is used to limit the log generation to one\n        // per event per node.\n        this.loggedUnreferencedEvents = new Set();\n        // Queue for unreferenced events that should be logged the next time GC runs.\n        this.pendingEventsQueue = [];\n        // The number of times GC has successfully completed on this instance of GarbageCollector.\n        this.completedRuns = 0;\n        this.runtime = createParams.runtime;\n        this.isSummarizerClient = createParams.isSummarizerClient;\n        this.gcOptions = createParams.gcOptions;\n        this.getNodePackagePath = createParams.getNodePackagePath;\n        this.getLastSummaryTimestampMs = createParams.getLastSummaryTimestampMs;\n        const baseSnapshot = createParams.baseSnapshot;\n        const metadata = createParams.metadata;\n        const readAndParseBlob = createParams.readAndParseBlob;\n        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(createParams.baseLogger, \"GarbageCollector\", { all: { completedGCRuns: () => this.completedRuns } }));\n        let prevSummaryGCVersion;\n        /**\n         * The following GC state is enabled during container creation and cannot be changed throughout its lifetime:\n         * 1. Whether running GC mark phase is allowed or not.\n         * 2. Whether running GC sweep phase is allowed or not.\n         * 3. Whether GC session expiry is enabled or not.\n         * For existing containers, we get this information from the metadata blob of its summary.\n         */\n        if (createParams.existing) {\n            prevSummaryGCVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.getGCVersion)(metadata);\n            // Existing documents which did not have metadata blob or had GC disabled have version as 0. For all\n            // other existing documents, GC is enabled.\n            this.gcEnabled = prevSummaryGCVersion > 0;\n            this.sweepEnabled = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.sweepEnabled) !== null && _a !== void 0 ? _a : false;\n            this.sessionExpiryTimeoutMs = metadata === null || metadata === void 0 ? void 0 : metadata.sessionExpiryTimeoutMs;\n        }\n        else {\n            // Sweep should not be enabled without enabling GC mark phase. We could silently disable sweep in this\n            // scenario but explicitly failing makes it clearer and promotes correct usage.\n            if (this.gcOptions.sweepAllowed && this.gcOptions.gcAllowed === false) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError(\"GC sweep phase cannot be enabled without enabling GC mark phase\");\n            }\n            // For new documents, GC is enabled by default. It can be explicitly disabled by setting the gcAllowed\n            // flag in GC options to false.\n            this.gcEnabled = this.gcOptions.gcAllowed !== false;\n            // The sweep phase has to be explicitly enabled by setting the sweepAllowed flag in GC options to true.\n            this.sweepEnabled = this.gcOptions.sweepAllowed === true;\n            // Set the Session Expiry only if the flag is enabled or the test option is set.\n            if (this.mc.config.getBoolean(runSessionExpiryKey) && this.gcEnabled) {\n                this.sessionExpiryTimeoutMs = defaultSessionExpiryDurationMs;\n            }\n        }\n        // If session expiry is enabled, we need to close the container when the session expiry timeout expires.\n        if (this.sessionExpiryTimeoutMs !== undefined && this.mc.config.getBoolean(disableSessionExpiryKey) !== true) {\n            // If Test Override config is set, override Session Expiry timeout.\n            const overrideSessionExpiryTimeoutMs = this.mc.config.getNumber(\"Fluid.GarbageCollection.TestOverride.SessionExpiryMs\");\n            const timeoutMs = overrideSessionExpiryTimeoutMs !== null && overrideSessionExpiryTimeoutMs !== void 0 ? overrideSessionExpiryTimeoutMs : this.sessionExpiryTimeoutMs;\n            setLongTimeout(timeoutMs, () => { this.runtime.closeFn(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.ClientSessionExpiredError(`Client session expired.`, timeoutMs)); }, (timer) => { this.sessionExpiryTimer = timer; });\n            /**\n             * Sweep timeout is the time after which unreferenced content can be swept.\n             * Sweep timeout = session expiry timeout + snapshot cache expiry timeout + one day buffer. The buffer is\n             * added to account for any clock skew. We use server timestamps throughout so the skew should be minimal\n             * but make it one day to be safe.\n             */\n            if (createParams.snapshotCacheExpiryMs !== undefined) {\n                this.sweepTimeoutMs = this.sessionExpiryTimeoutMs + createParams.snapshotCacheExpiryMs + oneDayMs;\n            }\n        }\n        // For existing document, the latest summary is the one that we loaded from. So, use its GC version as the\n        // latest tracked GC version. For new documents, we will be writing the first summary with the current version.\n        this.latestSummaryGCVersion = prevSummaryGCVersion !== null && prevSummaryGCVersion !== void 0 ? prevSummaryGCVersion : this.currentGCVersion;\n        /**\n         * Whether GC should run or not. The following conditions have to be met to run sweep:\n         * 1. GC should be enabled for this container.\n         * 2. GC should not be disabled via disableGC GC option.\n         * These conditions can be overridden via runGCKey feature flag.\n         */\n        this.shouldRunGC = (_b = this.mc.config.getBoolean(runGCKey)) !== null && _b !== void 0 ? _b : (\n        // GC must be enabled for the document.\n        this.gcEnabled\n            // GC must not be disabled via GC options.\n            && !this.gcOptions.disableGC);\n        /**\n         * Whether sweep should run or not. The following conditions have to be met to run sweep:\n         * 1. Overall GC or mark phase must be enabled (this.shouldRunGC).\n         * 2. Sweep timeout should be available. Without this, we wouldn't know when an object should be deleted.\n         * 3. Sweep should be enabled for this container (this.sweepEnabled). This can be overridden via runSweep\n         *    feature flag.\n         */\n        this.shouldRunSweep = this.shouldRunGC\n            && this.sweepTimeoutMs !== undefined\n            && ((_c = this.mc.config.getBoolean(runSweepKey)) !== null && _c !== void 0 ? _c : this.sweepEnabled);\n        this.trackGCState = this.mc.config.getBoolean(trackGCStateKey) === true;\n        // Override inactive timeout if test config or gc options to override it is set.\n        this.inactiveTimeoutMs = (_e = (_d = this.mc.config.getNumber(\"Fluid.GarbageCollection.TestOverride.InactiveTimeoutMs\")) !== null && _d !== void 0 ? _d : this.gcOptions.inactiveTimeoutMs) !== null && _e !== void 0 ? _e : defaultInactiveTimeoutMs;\n        // Inactive timeout must be greater than sweep timeout since a node goes from active -> inactive -> sweep ready.\n        if (this.sweepTimeoutMs !== undefined && this.inactiveTimeoutMs > this.sweepTimeoutMs) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError(\"inactive timeout should not be greated than the sweep timeout\");\n        }\n        // Whether we are running in test mode. In this mode, unreferenced nodes are immediately deleted.\n        this.testMode = (_f = this.mc.config.getBoolean(gcTestModeKey)) !== null && _f !== void 0 ? _f : this.gcOptions.runGCInTestMode === true;\n        // GC state is written into root of the summary tree by default. Can be overridden via feature flag for now.\n        this._writeDataAtRoot = (_g = this.mc.config.getBoolean(writeAtRootKey)) !== null && _g !== void 0 ? _g : true;\n        if (this._writeDataAtRoot) {\n            // The GC state needs to be reset if the base snapshot contains GC tree and GC is disabled or it doesn't\n            // contain GC tree and GC is enabled.\n            const gcTreePresent = (baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[gcTreeKey]) !== undefined;\n            this.initialStateNeedsReset = gcTreePresent !== this.shouldRunGC;\n        }\n        // Get the GC state from the GC blob in the base snapshot. Use LazyPromise because we only want to do\n        // this once since it involves fetching blobs from storage which is expensive.\n        const baseSummaryStateP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.LazyPromise(async () => {\n            var _a;\n            if (baseSnapshot === undefined) {\n                return undefined;\n            }\n            // For newer documents, GC data should be present in the GC tree in the root of the snapshot.\n            const gcSnapshotTree = baseSnapshot.trees[gcTreeKey];\n            if (gcSnapshotTree !== undefined) {\n                // If the GC tree is written at root, we should also do the same.\n                this._writeDataAtRoot = true;\n                const baseGCState = await getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);\n                if (this.trackGCState) {\n                    this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(baseGCState));\n                }\n                return baseGCState;\n            }\n            // back-compat - Older documents will have the GC blobs in each data store's summary tree. Get them and\n            // consolidate into IGarbageCollectionState format.\n            // Add a node for the root node that is not present in older snapshot format.\n            const gcState = { gcNodes: { \"/\": { outboundRoutes: [] } } };\n            const dataStoreSnapshotTree = (0,_dataStores__WEBPACK_IMPORTED_MODULE_6__.getSummaryForDatastores)(baseSnapshot, metadata);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(dataStoreSnapshotTree !== undefined, 0x2a8 /* \"Expected data store snapshot tree in base snapshot\" */);\n            for (const [dsId, dsSnapshotTree] of Object.entries(dataStoreSnapshotTree.trees)) {\n                const blobId = dsSnapshotTree.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.gcBlobKey];\n                if (blobId === undefined) {\n                    continue;\n                }\n                const gcSummaryDetails = await readAndParseBlob(blobId);\n                // If there are no nodes for this data store, skip it.\n                if (((_a = gcSummaryDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) === undefined) {\n                    continue;\n                }\n                const dsRootId = `/${dsId}`;\n                // Since we used to write GC data at data store level, we won't have an entry for the root (\"/\").\n                // Construct that entry by adding root data store ids to its outbound routes.\n                const initialSnapshotDetails = await readAndParseBlob(dsSnapshotTree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.dataStoreAttributesBlobName]);\n                if (initialSnapshotDetails.isRootDataStore) {\n                    gcState.gcNodes[\"/\"].outboundRoutes.push(dsRootId);\n                }\n                for (const [id, outboundRoutes] of Object.entries(gcSummaryDetails.gcData.gcNodes)) {\n                    // Prefix the data store id to the GC node ids to make them relative to the root from being\n                    // relative to the data store. Similar to how its done in DataStore::getGCData.\n                    const rootId = id === \"/\" ? dsRootId : `${dsRootId}${id}`;\n                    gcState.gcNodes[rootId] = { outboundRoutes: Array.from(outboundRoutes) };\n                }\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(gcState.gcNodes[dsRootId] !== undefined, 0x2a9 /* GC nodes for data store not in GC blob */);\n                gcState.gcNodes[dsRootId].unreferencedTimestampMs = gcSummaryDetails.unrefTimestamp;\n            }\n            // If there is only one node (root node just added above), either GC is disabled or we are loading from the\n            // very first summary generated by detached container. In both cases, GC was not run - return undefined.\n            return Object.keys(gcState.gcNodes).length === 1 ? undefined : gcState;\n        });\n        /**\n         * Set up the initializer which initializes the base GC state from the base snapshot. Note that the reference\n         * timestamp maybe from old ops which were not summarized and stored in the file. So, the unreferenced state\n         * may be out of date. This is fine because the state is updated every time GC runs based on the time then.\n         */\n        this.initializeBaseStateP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.LazyPromise(async () => {\n            const currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs();\n            const baseState = await baseSummaryStateP;\n            if (baseState === undefined) {\n                return;\n            }\n            const gcNodes = {};\n            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {\n                if (nodeData.unreferencedTimestampMs !== undefined) {\n                    this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(nodeData.unreferencedTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));\n                }\n                gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);\n            }\n            this.previousGCDataFromLastRun = { gcNodes };\n        });\n        // Get the GC details for each node from the GC state in the base summary. This is returned in getBaseGCDetails\n        // which the caller uses to initialize each node's GC state.\n        this.baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.LazyPromise(async () => {\n            const baseState = await baseSummaryStateP;\n            if (baseState === undefined) {\n                return new Map();\n            }\n            const gcNodes = {};\n            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {\n                gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);\n            }\n            // Run GC on the nodes in the base summary to get the routes used in each node in the container.\n            // This is an optimization for space (vs performance) wherein we don't need to store the used routes of\n            // each node in the summary.\n            const usedRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__.runGarbageCollection)(gcNodes, [\"/\"]).referencedNodeIds;\n            const baseGCDetailsMap = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.unpackChildNodesGCDetails)({ gcData: { gcNodes }, usedRoutes });\n            // Currently, the nodes may write the GC data. So, we need to update it's base GC details with the\n            // unreferenced timestamp. Once we start writing the GC data here, we won't need to do this anymore.\n            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {\n                if (nodeData.unreferencedTimestampMs !== undefined) {\n                    const dataStoreGCDetails = baseGCDetailsMap.get(nodeId.slice(1));\n                    if (dataStoreGCDetails !== undefined) {\n                        dataStoreGCDetails.unrefTimestamp = nodeData.unreferencedTimestampMs;\n                    }\n                }\n            }\n            return baseGCDetailsMap;\n        });\n        // Log all the GC options and the state determined by the garbage collector. This is interesting only for the\n        // summarizer client since it is the only one that runs GC. It also helps keep the telemetry less noisy.\n        const gcConfigProps = JSON.stringify(Object.assign({ gcEnabled: this.gcEnabled, sweepEnabled: this.sweepEnabled, runGC: this.shouldRunGC, runSweep: this.shouldRunSweep, writeAtRoot: this._writeDataAtRoot, testMode: this.testMode, sessionExpiry: this.sessionExpiryTimeoutMs, inactiveTimeout: this.inactiveTimeoutMs, existing: createParams.existing, trackGCState: this.trackGCState }, this.gcOptions));\n        if (this.isSummarizerClient) {\n            this.mc.logger.sendTelemetryEvent({\n                eventName: \"GarbageCollectorLoaded\",\n                gcConfigs: gcConfigProps,\n            });\n        }\n        // Initialize the base state that is used to detect when inactive objects are used.\n        if (this.shouldRunGC) {\n            this.initializeBaseStateP.catch((error) => {\n                const dpe = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.wrapIfUnrecognized(error, \"FailedToInitializeGC\");\n                dpe.addTelemetryProperties({ gcConfigs: gcConfigProps });\n                throw dpe;\n            });\n        }\n    }\n    static create(createParams) {\n        return new GarbageCollector(createParams);\n    }\n    /**\n     * Tells whether the GC state needs to be reset in the next summary. We need to do this if:\n     * 1. GC was enabled and is now disabled. The GC state needs to be removed and everything becomes referenced.\n     * 2. GC was disabled and is now enabled. The GC state needs to be regenerated and added to summary.\n     * 3. The GC version in the latest summary is different from the current GC version. This can happen if:\n     *    3.1. The summary this client loaded with has data from a different GC version.\n     *    3.2. This client's latest summary was updated from a snapshot that has a different GC version.\n     */\n    get summaryStateNeedsReset() {\n        return this.initialStateNeedsReset ||\n            (this.shouldRunGC && this.latestSummaryGCVersion !== this.currentGCVersion);\n    }\n    get writeDataAtRoot() {\n        return this._writeDataAtRoot;\n    }\n    /**\n     * Runs garbage collection and updates the reference / used state of the nodes in the container.\n     * @returns the number of data stores that have been marked as unreferenced.\n     */\n    async collectGarbage(options) {\n        const { fullGC = this.gcOptions.runFullGC === true || this.summaryStateNeedsReset, } = options;\n        const logger = options.logger\n            ? _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(options.logger, undefined, { all: { completedGCRuns: () => this.completedRuns } })\n            : this.mc.logger;\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(logger, { eventName: \"GarbageCollection\" }, async (event) => {\n            await this.runPreGCSteps();\n            // Get the runtime's GC data and run GC on the reference graph in it.\n            const gcData = await this.runtime.getGCData(fullGC);\n            const gcResult = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__.runGarbageCollection)(gcData.gcNodes, [\"/\"]);\n            const gcStats = await this.runPostGCSteps(gcData, gcResult, logger);\n            event.end(Object.assign({}, gcStats));\n            this.completedRuns++;\n            return gcStats;\n        }, { end: true, cancel: \"error\" });\n    }\n    async runPreGCSteps() {\n        // Ensure that base state has been initialized.\n        await this.initializeBaseStateP;\n        // Let the runtime update its pending state before GC runs.\n        await this.runtime.updateStateBeforeGC();\n    }\n    async runPostGCSteps(gcData, gcResult, logger) {\n        // Generate statistics from the current run. This is done before updating the current state because it\n        // generates some of its data based on previous state of the system.\n        const gcStats = this.generateStats(gcResult);\n        // Update the state since the last GC run. There can be nodes that were referenced between the last and\n        // the current run. We need to identify than and update their unreferenced state if needed.\n        this.updateStateSinceLastRun(gcData, logger);\n        // Update the current state and update the runtime of all routes or ids that used as per the GC run.\n        const currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs();\n        this.updateCurrentState(gcData, gcResult, currentReferenceTimestampMs);\n        this.runtime.updateUsedRoutes(gcResult.referencedNodeIds, currentReferenceTimestampMs);\n        // Log events for objects that are ready to be deleted by sweep. When we have sweep enabled, we will\n        // delete these objects here instead.\n        this.logSweepEvents(logger, currentReferenceTimestampMs);\n        // If we are running in GC test mode, delete objects for unused routes. This enables testing scenarios\n        // involving access to deleted data.\n        if (this.testMode) {\n            this.runtime.deleteUnusedRoutes(gcResult.deletedNodeIds);\n        }\n        // Log pending unreferenced events such as a node being used after inactive. This is done after GC runs and\n        // updates its state so that we don't send false positives based on intermediate state. For example, we may get\n        // reference to an unreferenced node from another unreferenced node which means the node wasn't revived.\n        await this.logUnreferencedEvents(logger);\n        return gcStats;\n    }\n    /**\n     * Summarizes the GC data and returns it as a summary tree.\n     * We current write the entire GC state in a single blob. This can be modified later to write multiple\n     * blobs. All the blob keys should start with `gcBlobPrefix`.\n     */\n    summarize(fullTree, trackState, telemetryContext) {\n        var _a;\n        if (!this.shouldRunGC || this.previousGCDataFromLastRun === undefined) {\n            return;\n        }\n        const gcState = { gcNodes: {} };\n        for (const [nodeId, outboundRoutes] of Object.entries(this.previousGCDataFromLastRun.gcNodes)) {\n            gcState.gcNodes[nodeId] = {\n                outboundRoutes,\n                unreferencedTimestampMs: (_a = this.unreferencedNodesState.get(nodeId)) === null || _a === void 0 ? void 0 : _a.unreferencedTimestampMs,\n            };\n        }\n        const newSerializedSummaryState = JSON.stringify(generateSortedGCState(gcState));\n        /**\n         * As an optimization if the GC tree hasn't changed and we're tracking the gc state, return a tree handle\n         * instead of returning the whole GC tree. If there are changes, then we want to return the whole tree.\n         */\n        if (this.trackGCState) {\n            this.pendingSerializedSummaryState = newSerializedSummaryState;\n            if (this.latestSerializedSummaryState !== undefined &&\n                this.latestSerializedSummaryState === newSerializedSummaryState &&\n                !fullTree &&\n                trackState) {\n                const stats = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.mergeStats)();\n                stats.handleNodeCount++;\n                return {\n                    summary: {\n                        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.SummaryType.Handle,\n                        handle: `/${gcTreeKey}`,\n                        handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.SummaryType.Tree,\n                    },\n                    stats,\n                };\n            }\n        }\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.SummaryTreeBuilder();\n        builder.addBlob(`${gcBlobPrefix}_root`, newSerializedSummaryState);\n        return builder.getSummaryTree();\n    }\n    getMetadata() {\n        return {\n            /**\n             * If GC is enabled, the GC data is written using the current GC version and that is the gcFeature that goes\n             * into the metadata blob. If GC is disabled, the gcFeature is 0.\n             */\n            gcFeature: this.gcEnabled ? this.currentGCVersion : 0,\n            sessionExpiryTimeoutMs: this.sessionExpiryTimeoutMs,\n            sweepEnabled: this.sweepEnabled,\n        };\n    }\n    /**\n     * Returns a map of node ids to their base GC details generated from the base summary. This is used by the caller\n     * to initialize the GC state of the nodes.\n     */\n    async getBaseGCDetails() {\n        return this.baseGCDetailsP;\n    }\n    /**\n     * Called when the latest summary of the system has been refreshed. This will be used to update the state of the\n     * latest summary tracked.\n     */\n    async latestSummaryStateRefreshed(result, readAndParseBlob) {\n        if (!this.shouldRunGC || !result.latestSummaryUpdated) {\n            return;\n        }\n        // If the summary was tracked by this client, it was the one that generated the summary in the first place.\n        // Basically, it was written in the current GC version.\n        if (result.wasSummaryTracked) {\n            this.latestSummaryGCVersion = this.currentGCVersion;\n            this.initialStateNeedsReset = false;\n            if (this.trackGCState) {\n                this.latestSerializedSummaryState = this.pendingSerializedSummaryState;\n                this.pendingSerializedSummaryState = undefined;\n            }\n            return;\n        }\n        // If the summary was not tracked by this client, update latest GC version and blob from the snapshot in the\n        // result as that is now the latest summary.\n        const snapshot = result.snapshot;\n        const metadataBlobId = snapshot.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.metadataBlobName];\n        if (metadataBlobId) {\n            const metadata = await readAndParseBlob(metadataBlobId);\n            this.latestSummaryGCVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.getGCVersion)(metadata);\n        }\n        const gcSnapshotTree = snapshot.trees[gcTreeKey];\n        if (gcSnapshotTree !== undefined && this.trackGCState) {\n            const latestGCState = await getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);\n            this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(latestGCState));\n        }\n        else {\n            this.latestSerializedSummaryState = undefined;\n        }\n        this.pendingSerializedSummaryState = undefined;\n    }\n    /**\n     * Called when a node with the given id is updated. If the node is inactive, log an error.\n     * @param nodePath - The id of the node that changed.\n     * @param reason - Whether the node was loaded or changed.\n     * @param timestampMs - The timestamp when the node changed.\n     * @param packagePath - The package path of the node. This may not be available if the node hasn't been loaded yet.\n     * @param requestHeaders - If the node was loaded via request path, the headers in the request.\n     */\n    nodeUpdated(nodePath, reason, timestampMs, packagePath, requestHeaders) {\n        if (!this.shouldRunGC) {\n            return;\n        }\n        const nodeStateTracker = this.unreferencedNodesState.get(nodePath);\n        if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {\n            this.inactiveNodeUsed(reason, nodePath, nodeStateTracker, undefined /* fromNodeId */, packagePath, timestampMs, requestHeaders);\n        }\n    }\n    /**\n     * Called when an outbound reference is added to a node. This is used to identify all nodes that have been\n     * referenced between summaries so that their unreferenced timestamp can be reset.\n     *\n     * @param fromNodePath - The node from which the reference is added.\n     * @param toNodePath - The node to which the reference is added.\n     */\n    addedOutboundReference(fromNodePath, toNodePath) {\n        var _a;\n        if (!this.shouldRunGC) {\n            return;\n        }\n        const outboundRoutes = (_a = this.newReferencesSinceLastRun.get(fromNodePath)) !== null && _a !== void 0 ? _a : [];\n        outboundRoutes.push(toNodePath);\n        this.newReferencesSinceLastRun.set(fromNodePath, outboundRoutes);\n        const nodeStateTracker = this.unreferencedNodesState.get(toNodePath);\n        if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {\n            this.inactiveNodeUsed(\"Revived\", toNodePath, nodeStateTracker, fromNodePath);\n        }\n    }\n    dispose() {\n        if (this.sessionExpiryTimer !== undefined) {\n            clearTimeout(this.sessionExpiryTimer);\n            this.sessionExpiryTimer = undefined;\n        }\n    }\n    /**\n     * Updates the state of the system as per the current GC run. It does the following:\n     * 1. Sets up the current GC state as per the gcData.\n     * 2. Starts tracking for nodes that have become unreferenced in this run.\n     * 3. Clears tracking for nodes that were unreferenced but became referenced in this run.\n     * @param gcData - The data representing the reference graph on which GC is run.\n     * @param gcResult - The result of the GC run on the gcData.\n     * @param currentReferenceTimestampMs - The timestamp to be used for unreferenced nodes' timestamp.\n     */\n    updateCurrentState(gcData, gcResult, currentReferenceTimestampMs) {\n        this.previousGCDataFromLastRun = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.cloneGCData)(gcData);\n        this.newReferencesSinceLastRun.clear();\n        // Iterate through the referenced nodes and stop tracking if they were unreferenced before.\n        for (const nodeId of gcResult.referencedNodeIds) {\n            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);\n            if (nodeStateTracker !== undefined) {\n                // Stop tracking so as to clear out any running timers.\n                nodeStateTracker.stopTracking();\n                // Delete the node as we don't need to track it any more.\n                this.unreferencedNodesState.delete(nodeId);\n            }\n        }\n        /**\n         * If there is no current reference time, skip tracking when a node becomes unreferenced. This would happen\n         * if no ops have been processed ever and we still try to run GC. If so, there is nothing interesting to track\n         * anyway.\n         */\n        if (currentReferenceTimestampMs === undefined) {\n            return;\n        }\n        /**\n         * If a node became unreferenced in this run, start tracking it.\n         * If a node was already unreferenced, update its tracking information. Since the current reference time is\n         * from the ops seen, this will ensure that we keep updating the unreferenced state as time moves forward.\n         */\n        for (const nodeId of gcResult.deletedNodeIds) {\n            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);\n            if (nodeStateTracker === undefined) {\n                this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(currentReferenceTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));\n            }\n            else {\n                nodeStateTracker.updateTracking(currentReferenceTimestampMs);\n            }\n        }\n    }\n    /**\n     * Since GC runs periodically, the GC data that is generated only tells us the state of the world at that point in\n     * time. It's possible that nodes transition from `unreferenced -> referenced -> unreferenced` between two runs. The\n     * unreferenced timestamp of such nodes needs to be reset as they may have been accessed when they were referenced.\n     *\n     * This function identifies nodes that were referenced since last run and removes their unreferenced state, if any.\n     * If these nodes are currently unreferenced, they will be assigned new unreferenced state by the current run.\n     */\n    updateStateSinceLastRun(currentGCData, logger) {\n        // If we haven't run GC before there is nothing to do.\n        if (this.previousGCDataFromLastRun === undefined) {\n            return;\n        }\n        // Find any references that haven't been identified correctly.\n        const missingExplicitReferences = this.findMissingExplicitReferences(currentGCData, this.previousGCDataFromLastRun, this.newReferencesSinceLastRun);\n        if (this.writeDataAtRoot && missingExplicitReferences.length > 0) {\n            missingExplicitReferences.forEach((missingExplicitReference) => {\n                const event = {\n                    eventName: \"gcUnknownOutboundReferences\",\n                    gcNodeId: missingExplicitReference[0],\n                    gcRoutes: JSON.stringify(missingExplicitReference[1]),\n                };\n                logger.sendPerformanceEvent(event);\n            });\n        }\n        // No references were added since the last run so we don't have to update reference states of any unreferenced\n        // nodes\n        if (this.newReferencesSinceLastRun.size === 0) {\n            return;\n        }\n        /**\n         * Generate a super set of the GC data that contains the nodes and edges from last run, plus any new node and\n         * edges that have been added since then. To do this, combine the GC data from the last run and the current\n         * run, and then add the references since last run.\n         *\n         * Note on why we need to combine the data from previous run, current run and all references in between -\n         * 1. We need data from last run because some of its references may have been deleted since then. If those\n         *    references added new outbound references before getting deleted, we need to detect them.\n         * 2. We need new outbound references since last run because some of them may have been deleted later. If those\n         *    references added new outbound references before getting deleted, we need to detect them.\n         * 3. We need data from the current run because currently we may not detect when DDSes are referenced:\n         *    - We don't require DDSes handles to be stored in a referenced DDS. For this, we need GC at DDS level\n         *      which is tracked by https://github.com/microsoft/FluidFramework/issues/8470.\n         *    - A new data store may have \"root\" DDSes already created and we don't detect them today.\n         */\n        const gcDataSuperSet = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.concatGarbageCollectionData)(this.previousGCDataFromLastRun, currentGCData);\n        this.newReferencesSinceLastRun.forEach((outboundRoutes, sourceNodeId) => {\n            if (gcDataSuperSet.gcNodes[sourceNodeId] === undefined) {\n                gcDataSuperSet.gcNodes[sourceNodeId] = outboundRoutes;\n            }\n            else {\n                gcDataSuperSet.gcNodes[sourceNodeId].push(...outboundRoutes);\n            }\n        });\n        /**\n         * Run GC on the above reference graph to find all nodes that are referenced. For each one, if they are\n         * unreferenced, stop tracking them and remove from unreferenced list.\n         * Some of these nodes may be unreferenced now and if so, the current run will add unreferenced state for them.\n         */\n        const gcResult = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__.runGarbageCollection)(gcDataSuperSet.gcNodes, [\"/\"]);\n        for (const nodeId of gcResult.referencedNodeIds) {\n            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);\n            if (nodeStateTracker !== undefined) {\n                // Stop tracking so as to clear out any running timers.\n                nodeStateTracker.stopTracking();\n                // Delete the node as we don't need to track it any more.\n                this.unreferencedNodesState.delete(nodeId);\n            }\n        }\n    }\n    /**\n     * Finds all new references or outbound routes in the current graph that haven't been explicitly notified to GC.\n     * The principle is that every new reference or outbound route must be notified to GC via the\n     * addedOutboundReference method. It it hasn't, its a bug and we want to identify these scenarios.\n     *\n     * In more simple terms:\n     * Missing Explicit References = Current References - Previous References - Explicitly Added References;\n     *\n     * @param currentGCData - The GC data (reference graph) from the current GC run.\n     * @param previousGCData - The GC data (reference graph) from the previous GC run.\n     * @param explicitReferences - New references added explicity between the previous and the current run.\n     * @returns - a list of missing explicit references\n     */\n    findMissingExplicitReferences(currentGCData, previousGCData, explicitReferences) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(previousGCData !== undefined, 0x2b7);\n        const currentGraph = Object.entries(currentGCData.gcNodes);\n        const missingExplicitReferences = [];\n        currentGraph.forEach(([nodeId, currentOutboundRoutes]) => {\n            var _a, _b;\n            const previousRoutes = (_a = previousGCData.gcNodes[nodeId]) !== null && _a !== void 0 ? _a : [];\n            const explicitRoutes = (_b = explicitReferences.get(nodeId)) !== null && _b !== void 0 ? _b : [];\n            const missingExplicitRoutes = [];\n            currentOutboundRoutes.forEach((route) => {\n                const isBlobOrDataStoreRoute = this.runtime.getNodeType(route) === GCNodeType.Blob ||\n                    this.runtime.getNodeType(route) === GCNodeType.DataStore;\n                // Ignore implicitly added DDS routes to their parent datastores\n                const notRouteFromDDSToParentDataStore = !nodeId.startsWith(route);\n                if (isBlobOrDataStoreRoute &&\n                    notRouteFromDDSToParentDataStore &&\n                    (!previousRoutes.includes(route) && !explicitRoutes.includes(route))) {\n                    missingExplicitRoutes.push(route);\n                }\n            });\n            if (missingExplicitRoutes.length > 0) {\n                missingExplicitReferences.push([nodeId, missingExplicitRoutes]);\n            }\n        });\n        // Ideally missingExplicitReferences should always have a size 0\n        return missingExplicitReferences;\n    }\n    /**\n     * Generates the stats of a garbage collection run from the given results of the run.\n     * @param gcResult - The result of a GC run.\n     * @returns the GC stats of the GC run.\n     */\n    generateStats(gcResult) {\n        const gcStats = {\n            nodeCount: 0,\n            dataStoreCount: 0,\n            attachmentBlobCount: 0,\n            unrefNodeCount: 0,\n            unrefDataStoreCount: 0,\n            unrefAttachmentBlobCount: 0,\n            updatedNodeCount: 0,\n            updatedDataStoreCount: 0,\n            updatedAttachmentBlobCount: 0,\n        };\n        const updateNodeStats = (nodeId, referenced) => {\n            gcStats.nodeCount++;\n            // If there is no previous GC data, every node's state is generated and is considered as updated.\n            // Otherwise, find out if any node went from referenced to unreferenced or vice-versa.\n            const stateUpdated = this.previousGCDataFromLastRun === undefined ||\n                this.unreferencedNodesState.has(nodeId) === referenced;\n            if (stateUpdated) {\n                gcStats.updatedNodeCount++;\n            }\n            if (!referenced) {\n                gcStats.unrefNodeCount++;\n            }\n            if (this.runtime.getNodeType(nodeId) === GCNodeType.DataStore) {\n                gcStats.dataStoreCount++;\n                if (stateUpdated) {\n                    gcStats.updatedDataStoreCount++;\n                }\n                if (!referenced) {\n                    gcStats.unrefDataStoreCount++;\n                }\n            }\n            if (this.runtime.getNodeType(nodeId) === GCNodeType.Blob) {\n                gcStats.attachmentBlobCount++;\n                if (stateUpdated) {\n                    gcStats.updatedAttachmentBlobCount++;\n                }\n                if (!referenced) {\n                    gcStats.unrefAttachmentBlobCount++;\n                }\n            }\n        };\n        for (const nodeId of gcResult.referencedNodeIds) {\n            updateNodeStats(nodeId, true /* referenced */);\n        }\n        for (const nodeId of gcResult.deletedNodeIds) {\n            updateNodeStats(nodeId, false /* referenced */);\n        }\n        return gcStats;\n    }\n    /**\n     * For nodes that are ready to sweep, log an event for now. Until we start running sweep which deletes objects,\n     * this will give us a view into how much deleted content a container has.\n     */\n    logSweepEvents(logger, currentReferenceTimestampMs) {\n        if (this.mc.config.getBoolean(disableSweepLogKey) === true\n            || currentReferenceTimestampMs === undefined\n            || this.sweepTimeoutMs === undefined) {\n            return;\n        }\n        this.unreferencedNodesState.forEach((nodeStateTracker, nodeId) => {\n            if (nodeStateTracker.state !== UnreferencedState.SweepReady) {\n                return;\n            }\n            const nodeType = this.runtime.getNodeType(nodeId);\n            if (nodeType !== GCNodeType.DataStore && nodeType !== GCNodeType.Blob) {\n                return;\n            }\n            // Log deleted event for each node only once to reduce noise in telemetry.\n            const uniqueEventId = `Deleted-${nodeId}`;\n            if (this.loggedUnreferencedEvents.has(uniqueEventId)) {\n                return;\n            }\n            this.loggedUnreferencedEvents.add(uniqueEventId);\n            logger.sendTelemetryEvent({\n                eventName: \"GCObjectDeleted\",\n                id: nodeId,\n                type: nodeType,\n                age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,\n                timeout: this.sweepTimeoutMs,\n                completedGCRuns: this.completedRuns,\n                lastSummaryTime: this.getLastSummaryTimestampMs(),\n            });\n        });\n    }\n    /**\n     * Called when an inactive node is used after. Queue up an event that will be logged next time GC runs.\n     */\n    inactiveNodeUsed(usageType, nodeId, nodeStateTracker, fromNodeId, packagePath, currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs(), requestHeaders) {\n        // If there is no reference timestamp to work with, no ops have been processed after creation. If so, skip\n        // logging as nothing interesting would have happened worth logging.\n        // If the node is active, skip logging.\n        if (currentReferenceTimestampMs === undefined || nodeStateTracker.state === UnreferencedState.Active) {\n            return;\n        }\n        // For non-summarizer clients, only log \"Loaded\" type events since these objects may not be loaded in the\n        // summarizer clients if they are based off of user actions (such as scrolling to content for these objects).\n        if (!this.isSummarizerClient && usageType !== \"Loaded\") {\n            return;\n        }\n        // We only care about data stores and attachment blobs for this telemetry since GC only marks these objects\n        // as unreferenced. Also, if an inactive DDS is used, the corresponding data store store will also be used.\n        const nodeType = this.runtime.getNodeType(nodeId);\n        if (nodeType !== GCNodeType.DataStore && nodeType !== GCNodeType.Blob) {\n            return;\n        }\n        const state = nodeStateTracker.state;\n        const uniqueEventId = `${state}-${nodeId}-${usageType}`;\n        if (this.loggedUnreferencedEvents.has(uniqueEventId)) {\n            return;\n        }\n        this.loggedUnreferencedEvents.add(uniqueEventId);\n        const propsToLog = {\n            id: nodeId,\n            type: nodeType,\n            unrefTime: nodeStateTracker.unreferencedTimestampMs,\n            age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,\n            timeout: nodeStateTracker.state === UnreferencedState.Inactive\n                ? this.inactiveTimeoutMs\n                : this.sweepTimeoutMs,\n            completedGCRuns: this.completedRuns,\n            lastSummaryTime: this.getLastSummaryTimestampMs(),\n            externalRequest: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[_containerRuntime__WEBPACK_IMPORTED_MODULE_13__.RuntimeHeaders.externalRequest],\n            viaHandle: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[_containerRuntime__WEBPACK_IMPORTED_MODULE_13__.RuntimeHeaders.viaHandle],\n            fromId: fromNodeId,\n        };\n        // For summarizer client, queue the event so it is logged the next time GC runs if the event is still valid.\n        // For non-summarizer client, log the event now since GC won't run on it. This may result in false positives\n        // but it's a good signal nonetheless and we can consume it with a grain of salt.\n        if (this.isSummarizerClient) {\n            this.pendingEventsQueue.push(Object.assign(Object.assign({}, propsToLog), { usageType, state }));\n        }\n        else {\n            this.mc.logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), { eventName: `${state}Object_${usageType}`, pkg: packagePath ? { value: packagePath.join(\"/\"), tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.CodeArtifact } : undefined }));\n        }\n    }\n    async logUnreferencedEvents(logger) {\n        for (const eventProps of this.pendingEventsQueue) {\n            const { usageType, state } = eventProps, propsToLog = __rest(eventProps, [\"usageType\", \"state\"]);\n            /**\n             * Revived event is logged only if the node is active. If the node is not active, the reference to it was\n             * from another unreferenced node and this scenario is not interesting to log.\n             * Loaded and Changed events are logged only if the node is not active. If the node is active, it was\n             * revived and a Revived event will be logged for it.\n             */\n            const nodeStateTracker = this.unreferencedNodesState.get(eventProps.id);\n            const active = nodeStateTracker === undefined || nodeStateTracker.state === UnreferencedState.Active;\n            if ((usageType === \"Revived\") === active) {\n                const pkg = await this.getNodePackagePath(eventProps.id);\n                const fromPkg = eventProps.fromId ? await this.getNodePackagePath(eventProps.fromId) : undefined;\n                logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), { eventName: `${state}Object_${usageType}`, pkg: pkg ? { value: pkg.join(\"/\"), tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.CodeArtifact } : undefined, fromPkg: fromPkg ? { value: fromPkg.join(\"/\"), tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.CodeArtifact } : undefined }));\n            }\n        }\n        this.pendingEventsQueue = [];\n    }\n}\n/**\n * Gets the garbage collection state from the given snapshot tree. The GC state may be written into multiple blobs.\n * Merge the GC state from all such blobs and return the merged GC state.\n */\nasync function getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob) {\n    let rootGCState = { gcNodes: {} };\n    for (const key of Object.keys(gcSnapshotTree.blobs)) {\n        // Skip blobs that do not start with the GC prefix.\n        if (!key.startsWith(gcBlobPrefix)) {\n            continue;\n        }\n        const blobId = gcSnapshotTree.blobs[key];\n        if (blobId === undefined) {\n            continue;\n        }\n        const gcState = await readAndParseBlob(blobId);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(gcState !== undefined, 0x2ad /* \"GC blob missing from snapshot\" */);\n        // Merge the GC state of this blob into the root GC state.\n        rootGCState = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.concatGarbageCollectionStates)(rootGCState, gcState);\n    }\n    return rootGCState;\n}\nfunction generateSortedGCState(gcState) {\n    const sortableArray = Object.entries(gcState.gcNodes);\n    sortableArray.sort(([a], [b]) => a.localeCompare(b));\n    const sortedGCState = { gcNodes: {} };\n    for (const [nodeId, nodeData] of sortableArray) {\n        nodeData.outboundRoutes.sort();\n        sortedGCState.gcNodes[nodeId] = nodeData;\n    }\n    return sortedGCState;\n}\n/**\n * setLongTimeout is used for timeouts longer than setTimeout's ~24.8 day max\n * @param timeoutMs - the total time the timeout needs to last in ms\n * @param timeoutFn - the function to execute when the timer ends\n * @param setTimerFn - the function used to update your timer variable\n */\nfunction setLongTimeout(timeoutMs, timeoutFn, setTimerFn) {\n    // The setTimeout max is 24.8 days before looping occurs.\n    const maxTimeout = 2147483647;\n    let timer;\n    if (timeoutMs > maxTimeout) {\n        const newTimeoutMs = timeoutMs - maxTimeout;\n        timer = setTimeout(() => setLongTimeout(newTimeoutMs, timeoutFn, setTimerFn), maxTimeout);\n    }\n    else {\n        timer = setTimeout(() => timeoutFn(), timeoutMs);\n    }\n    setTimerFn(timer);\n}\n//# sourceMappingURL=garbageCollection.js.map\n\n/***/ }),\n/* 74 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PromiseTimer\": () => (/* binding */ PromiseTimer),\n/* harmony export */   \"Timer\": () => (/* binding */ Timer)\n/* harmony export */ });\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);\n/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * This class is a thin wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the same\n * or similar handlers and timeouts.\n */\nclass Timer {\n    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {\n        this.defaultTimeout = defaultTimeout;\n        this.defaultHandler = defaultHandler;\n        this.getCurrentTick = getCurrentTick;\n    }\n    /**\n     * Returns true if the timer is running.\n     */\n    get hasTimer() {\n        return !!this.runningState;\n    }\n    /**\n     * Calls setTimeout and tracks the resulting timeout.\n     * @param ms - overrides default timeout in ms\n     * @param handler - overrides default handler\n     */\n    start(ms = this.defaultTimeout, handler = this.defaultHandler) {\n        this.startCore(ms, handler, ms);\n    }\n    /**\n     * Calls clearTimeout on the underlying timeout if running.\n     */\n    clear() {\n        if (!this.runningState) {\n            return;\n        }\n        clearTimeout(this.runningState.timeout);\n        this.runningState = undefined;\n    }\n    /**\n     * Restarts the timer with the new handler and duration.\n     * If a new handler is passed, the original handler may\n     * never execute.\n     * This is a potentially more efficient way to clear and start\n     * a new timer.\n     * @param ms - overrides previous or default timeout in ms\n     * @param handler - overrides previous or default handler\n     */\n    restart(ms, handler) {\n        var _a, _b;\n        if (!this.runningState) {\n            // If restart is called first, it behaves as a call to start\n            this.start(ms, handler);\n        }\n        else {\n            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;\n            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;\n            const remainingTime = this.calculateRemainingTime(this.runningState);\n            if (duration < remainingTime) {\n                // If remaining time exceeds restart duration, do a hard restart.\n                // The existing timeout time is too long.\n                this.start(duration, handlerToUse);\n            }\n            else if (duration === remainingTime) {\n                // The existing timeout time is perfect, just update handler and data.\n                this.runningState.handler = handlerToUse;\n                this.runningState.restart = undefined;\n                this.runningState.intendedDuration = duration;\n            }\n            else {\n                // If restart duration exceeds remaining time, set restart info.\n                // Existing timeout will start a new timeout for remaining time.\n                this.runningState.restart = {\n                    startTick: this.getCurrentTick(),\n                    duration,\n                    handler: handlerToUse,\n                };\n            }\n        }\n    }\n    startCore(duration, handler, intendedDuration) {\n        this.clear();\n        this.runningState = {\n            startTick: this.getCurrentTick(),\n            duration,\n            intendedDuration,\n            handler,\n            timeout: setTimeout(() => this.handler(), duration),\n        };\n    }\n    handler() {\n        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.runningState, 0x00a /* \"Running timer missing handler\" */);\n        const restart = this.runningState.restart;\n        if (restart !== undefined) {\n            // Restart with remaining time\n            const remainingTime = this.calculateRemainingTime(restart);\n            this.startCore(remainingTime, () => restart.handler(), restart.duration);\n        }\n        else {\n            // Run clear first, in case the handler decides to start again\n            const handler = this.runningState.handler;\n            this.clear();\n            handler();\n        }\n    }\n    calculateRemainingTime(runningTimeout) {\n        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;\n        return runningTimeout.duration - elapsedTime;\n    }\n}\n/**\n * This class is a wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the\n * same handlers and timeouts, while also providing a promise that\n * resolves when it times out.\n */\nclass PromiseTimer {\n    constructor(defaultTimeout, defaultHandler) {\n        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));\n    }\n    get hasTimer() {\n        return this.timer.hasTimer;\n    }\n    async start(ms, handler) {\n        this.clear();\n        this.deferred = new _promises__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);\n        return this.deferred.promise;\n    }\n    clear() {\n        this.timer.clear();\n        if (this.deferred) {\n            this.deferred.resolve({ timerResult: \"cancel\" });\n            this.deferred = undefined;\n        }\n    }\n    wrapHandler(handler) {\n        handler();\n        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.deferred, 0x00b /* \"Handler executed without deferred\" */);\n        this.deferred.resolve({ timerResult: \"timeout\" });\n        this.deferred = undefined;\n    }\n}\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n/* 75 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"LazyPromise\": () => (/* binding */ LazyPromise)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nclass Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nclass LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map\n\n/***/ }),\n/* 76 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"aliasBlobName\": () => (/* binding */ aliasBlobName),\n/* harmony export */   \"blobsTreeName\": () => (/* binding */ blobsTreeName),\n/* harmony export */   \"chunksBlobName\": () => (/* binding */ chunksBlobName),\n/* harmony export */   \"dataStoreAttributesBlobName\": () => (/* binding */ dataStoreAttributesBlobName),\n/* harmony export */   \"electedSummarizerBlobName\": () => (/* binding */ electedSummarizerBlobName),\n/* harmony export */   \"extractSummaryMetadataMessage\": () => (/* binding */ extractSummaryMetadataMessage),\n/* harmony export */   \"getAttributesFormatVersion\": () => (/* binding */ getAttributesFormatVersion),\n/* harmony export */   \"getFluidDataStoreAttributes\": () => (/* binding */ getFluidDataStoreAttributes),\n/* harmony export */   \"getGCVersion\": () => (/* binding */ getGCVersion),\n/* harmony export */   \"getMetadataFormatVersion\": () => (/* binding */ getMetadataFormatVersion),\n/* harmony export */   \"hasIsolatedChannels\": () => (/* binding */ hasIsolatedChannels),\n/* harmony export */   \"metadataBlobName\": () => (/* binding */ metadataBlobName),\n/* harmony export */   \"nonDataStorePaths\": () => (/* binding */ nonDataStorePaths),\n/* harmony export */   \"protocolTreeName\": () => (/* binding */ protocolTreeName),\n/* harmony export */   \"rootHasIsolatedChannels\": () => (/* binding */ rootHasIsolatedChannels),\n/* harmony export */   \"wrapSummaryInChannelsTree\": () => (/* binding */ wrapSummaryInChannelsTree)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _garbageCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\nfunction getAttributesFormatVersion(attributes) {\n    if (attributes.summaryFormatVersion) {\n        /**\n         * Version 2+: Introduces .channels trees for isolation of\n         * channel trees from data store objects.\n         */\n        return attributes.summaryFormatVersion;\n    }\n    else if (attributes.snapshotFormatVersion === \"0.1\") {\n        /**\n         * Version 1: from this version the pkg within the data store\n         * attributes blob is a JSON array rather than a string.\n         */\n        return 1;\n    }\n    /**\n     * Version 0: format version is missing from summary.\n     * This indicates it is an older version.\n     */\n    return 0;\n}\nfunction hasIsolatedChannels(attributes) {\n    return !!attributes.summaryFormatVersion && !attributes.disableIsolatedChannels;\n}\n/**\n * Extracts the properties from an ISequencedDocumentMessage as defined by ISummaryMetadataMessage. This message is\n * added to the metadata blob in summary.\n */\nconst extractSummaryMetadataMessage = (message) => message === undefined ? undefined : {\n    clientId: message.clientId,\n    clientSequenceNumber: message.clientSequenceNumber,\n    minimumSequenceNumber: message.minimumSequenceNumber,\n    referenceSequenceNumber: message.referenceSequenceNumber,\n    sequenceNumber: message.sequenceNumber,\n    timestamp: message.timestamp,\n    type: message.type,\n};\nfunction getMetadataFormatVersion(metadata) {\n    var _a;\n    /**\n     * Version 2+: Introduces runtime sequence number for data verification.\n     *\n     * Version 1+: Introduces .metadata blob and .channels trees for isolation of\n     * data store trees from container-level objects.\n     * Also introduces enableGC option stored in the summary.\n     *\n     * Version 0: metadata blob missing; format version is missing from summary.\n     * This indicates it is an older version.\n     */\n    return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion) !== null && _a !== void 0 ? _a : 0;\n}\nconst aliasBlobName = \".aliases\";\nconst metadataBlobName = \".metadata\";\nconst chunksBlobName = \".chunks\";\nconst electedSummarizerBlobName = \".electedSummarizer\";\nconst blobsTreeName = \".blobs\";\nfunction rootHasIsolatedChannels(metadata) {\n    return !!metadata && !metadata.disableIsolatedChannels;\n}\nfunction getGCVersion(metadata) {\n    var _a;\n    if (!metadata) {\n        // Force to 0/disallowed in prior versions\n        return 0;\n    }\n    return (_a = metadata.gcFeature) !== null && _a !== void 0 ? _a : 0;\n}\nconst protocolTreeName = \".protocol\";\n/**\n * List of tree IDs at the container level which are reserved.\n * This is for older versions of summaries that do not yet have an\n * isolated data stores namespace. Without the namespace, this must\n * be used to prevent name collisions with data store IDs.\n */\nconst nonDataStorePaths = [protocolTreeName, \".logTail\", \".serviceProtocol\", blobsTreeName, _garbageCollection__WEBPACK_IMPORTED_MODULE_0__.gcTreeKey];\nconst dataStoreAttributesBlobName = \".component\";\n/**\n * Modifies summary tree and stats to put tree under .channels tree.\n *\n * @param summarizeResult - Summary tree and stats to modify\n *\n * @example\n * Converts from:\n * ```typescript\n * {\n *     type: SummaryType.Tree,\n *     tree: { a: {...}, b: {...}, c: {...} },\n * }\n * ```\n *\n * to:\n *\n * ```typescript\n * {\n *     type: SummaryType.Tree,\n *     tree: {\n *         \".channels\": {\n *             type: SummaryType.Tree,\n *             tree: { a: {...}, b: {...}, c: {...} }\n *         },\n *     },\n * }\n * ```\n * And adds +1 to treeNodeCount in stats.\n */\nfunction wrapSummaryInChannelsTree(summarizeResult) {\n    summarizeResult.summary = {\n        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Tree,\n        tree: { [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__.channelsTreeName]: summarizeResult.summary },\n    };\n    summarizeResult.stats.treeNodeCount++;\n}\nasync function getFluidDataStoreAttributes(storage, snapshot) {\n    const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.readAndParse)(storage, snapshot.blobs[dataStoreAttributesBlobName]);\n    // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n    // For snapshotFormatVersion = \"0.1\" (1) or above, pkg is jsonified, otherwise it is just a string.\n    // However the feature of loading a detached container from snapshot, is added when the\n    // snapshotFormatVersion is at least \"0.1\" (1), so we don't expect it to be anything else.\n    const formatVersion = getAttributesFormatVersion(attributes);\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(formatVersion > 0, 0x1d5 /* Invalid snapshot format version */);\n    return attributes;\n}\n//# sourceMappingURL=summaryFormat.js.map\n\n/***/ }),\n/* 77 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 78 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"readAndParse\": () => (/* binding */ readAndParse)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Read a blob from IDocumentStorageService and JSON.parse it into object of type T\n *\n * @param storage - the IDocumentStorageService to read from\n * @param id - the id of the blob to read and parse\n * @returns the object that we decoded and JSON.parse\n */\nasync function readAndParse(storage, id) {\n    const blob = await storage.readBlob(id);\n    const decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, \"utf8\");\n    return JSON.parse(decoded);\n}\n//# sourceMappingURL=readAndParse.js.map\n\n/***/ }),\n/* 79 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 80 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 81 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 82 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataStores\": () => (/* binding */ DataStores),\n/* harmony export */   \"getSummaryForDatastores\": () => (/* binding */ getSummaryForDatastores)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(25);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(97);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(99);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(63);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(27);\n/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(103);\n/* harmony import */ var _dataStoreContexts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);\n/* harmony import */ var _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85);\n/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(76);\n/* harmony import */ var _dataStore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(101);\n/* harmony import */ var _garbageCollection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(73);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This class encapsulates data store handling. Currently it is only used by the container runtime,\n * but eventually could be hosted on any channel once we formalize the channel api boundary.\n */\nclass DataStores {\n    constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, deleteChildSummarizerNodeFn, baseLogger, getBaseGCDetails, gcNodeUpdated, aliasMap, writeGCDataAtRoot, contexts = new _dataStoreContexts__WEBPACK_IMPORTED_MODULE_0__.DataStoreContexts(baseLogger)) {\n        this.baseSnapshot = baseSnapshot;\n        this.runtime = runtime;\n        this.submitAttachFn = submitAttachFn;\n        this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;\n        this.deleteChildSummarizerNodeFn = deleteChildSummarizerNodeFn;\n        this.gcNodeUpdated = gcNodeUpdated;\n        this.aliasMap = aliasMap;\n        this.writeGCDataAtRoot = writeGCDataAtRoot;\n        this.contexts = contexts;\n        // Stores tracked by the Domain\n        this.pendingAttach = new Map();\n        // 0.24 back-compat attachingBeforeSummary\n        this.attachOpFiredForDataStore = new Set();\n        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => this.contexts.dispose());\n        // Stores the ids of new data stores between two GC runs. This is used to notify the garbage collector of new\n        // root data stores that are added.\n        this.dataStoresSinceLastGC = [];\n        this.dispose = () => this.disposeOnce.value;\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(baseLogger);\n        this.containerRuntimeHandle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__.FluidObjectHandle(this.runtime, \"/\", this.runtime.IFluidHandleContext);\n        const baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.LazyPromise(async () => {\n            return getBaseGCDetails();\n        });\n        // Returns the base GC details for the data store with the given id.\n        const dataStoreBaseGCDetails = async (dataStoreId) => {\n            const baseGCDetails = await baseGCDetailsP;\n            return baseGCDetails.get(dataStoreId);\n        };\n        // Extract stores stored inside the snapshot\n        const fluidDataStores = new Map();\n        if (baseSnapshot) {\n            for (const [key, value] of Object.entries(baseSnapshot.trees)) {\n                fluidDataStores.set(key, value);\n            }\n        }\n        let unreferencedDataStoreCount = 0;\n        // Create a context for each of them\n        for (const [key, value] of fluidDataStores) {\n            let dataStoreContext;\n            // counting number of unreferenced data stores\n            if (value.unreferenced) {\n                unreferencedDataStoreCount++;\n            }\n            // If we have a detached container, then create local data store contexts.\n            if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached) {\n                dataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.RemoteFluidDataStoreContext({\n                    id: key,\n                    snapshotTree: value,\n                    getBaseGCDetails: async () => dataStoreBaseGCDetails(key),\n                    runtime: this.runtime,\n                    storage: this.runtime.storage,\n                    scope: this.runtime.scope,\n                    createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.FromSummary }),\n                    writeGCDataAtRoot: this.writeGCDataAtRoot,\n                    disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n                });\n            }\n            else {\n                if (typeof value !== \"object\") {\n                    throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__.LoggingError(\"Snapshot should be there to load from!!\");\n                }\n                const snapshotTree = value;\n                dataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.LocalFluidDataStoreContext({\n                    id: key,\n                    pkg: undefined,\n                    runtime: this.runtime,\n                    storage: this.runtime.storage,\n                    scope: this.runtime.scope,\n                    createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.FromSummary }),\n                    makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(key),\n                    snapshotTree,\n                    isRootDataStore: undefined,\n                    writeGCDataAtRoot: this.writeGCDataAtRoot,\n                    disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n                });\n            }\n            this.contexts.addBoundOrRemoted(dataStoreContext);\n        }\n        this.containerLoadStats = {\n            containerLoadDataStoreCount: fluidDataStores.size,\n            referencedDataStoreCount: fluidDataStores.size - unreferencedDataStoreCount,\n        };\n    }\n    aliases() {\n        return this.aliasMap;\n    }\n    processAttachMessage(message, local) {\n        var _a, _b;\n        const attachMessage = message.contents;\n        this.dataStoresSinceLastGC.push(attachMessage.id);\n        // The local object has already been attached\n        if (local) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(this.pendingAttach.has(attachMessage.id), 0x15e /* \"Local object does not have matching attach message id\" */);\n            (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit(\"attached\");\n            this.pendingAttach.delete(attachMessage.id);\n            return;\n        }\n        // If a non-local operation then go and create the object, otherwise mark it as officially attached.\n        if (this.alreadyProcessed(attachMessage.id)) {\n            // TODO: dataStoreId may require a different tag from PackageData #7488\n            const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.DataCorruptionError(\n            // pre-0.58 error message: duplicateDataStoreCreatedWithExistingId\n            \"Duplicate DataStore created with existing id\", Object.assign(Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.extractSafePropertiesFromMessage)(message)), { dataStoreId: {\n                    value: attachMessage.id,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.PackageData,\n                } }));\n            throw error;\n        }\n        const flatBlobs = new Map();\n        let snapshotTree;\n        if (attachMessage.snapshot) {\n            snapshotTree = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);\n        }\n        // Include the type of attach message which is the pkg of the store to be\n        // used by RemoteFluidDataStoreContext in case it is not in the snapshot.\n        const pkg = [attachMessage.type];\n        const remoteFluidDataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.RemoteFluidDataStoreContext({\n            id: attachMessage.id,\n            snapshotTree,\n            // New data stores begin with empty GC details since GC hasn't run on them yet.\n            getBaseGCDetails: async () => { return {}; },\n            runtime: this.runtime,\n            storage: new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__.BlobCacheStorageService(this.runtime.storage, flatBlobs),\n            scope: this.runtime.scope,\n            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(attachMessage.id, {\n                type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.FromAttach,\n                sequenceNumber: message.sequenceNumber,\n                snapshot: (_b = attachMessage.snapshot) !== null && _b !== void 0 ? _b : {\n                    entries: [(0,_dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.createAttributesBlob)(pkg, true /* isRootDataStore */, this.runtime.disableIsolatedChannels)],\n                },\n            }),\n            writeGCDataAtRoot: this.writeGCDataAtRoot,\n            disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n            pkg,\n        });\n        this.contexts.addBoundOrRemoted(remoteFluidDataStoreContext);\n    }\n    processAliasMessage(message, localOpMetadata, local) {\n        const aliasMessage = message.contents;\n        if (!(0,_dataStore__WEBPACK_IMPORTED_MODULE_13__.isDataStoreAliasMessage)(aliasMessage)) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.DataCorruptionError(\"malformedDataStoreAliasMessage\", Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.extractSafePropertiesFromMessage)(message)));\n        }\n        const resolve = localOpMetadata;\n        const aliasResult = this.processAliasMessageCore(aliasMessage);\n        if (local) {\n            resolve(aliasResult);\n        }\n    }\n    processAliasMessageCore(aliasMessage) {\n        if (this.alreadyProcessed(aliasMessage.alias)) {\n            return false;\n        }\n        const context = this.contexts.get(aliasMessage.internalId);\n        if (context === undefined) {\n            this.logger.sendErrorEvent({\n                eventName: \"AliasFluidDataStoreNotFound\",\n                fluidDataStoreId: aliasMessage.internalId,\n            });\n            return false;\n        }\n        const handle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__.FluidObjectHandle(context, aliasMessage.internalId, this.runtime.IFluidHandleContext);\n        this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);\n        this.aliasMap.set(aliasMessage.alias, context.id);\n        context.setInMemoryRoot();\n        return true;\n    }\n    alreadyProcessed(id) {\n        return this.aliasMap.get(id) !== undefined || this.contexts.get(id) !== undefined;\n    }\n    /**\n     * Make the data stores locally visible in the container graph by moving the data store context from unbound to\n     * bound list. This data store can now be reached from the root.\n     * @param id - The id of the data store context to make visible.\n     */\n    makeDataStoreLocallyVisible(id) {\n        const localContext = this.contexts.getUnbound(id);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!localContext, 0x15f /* \"Could not find unbound context to bind\" */);\n        /**\n         * If the container is not detached, it is globally visible to all clients. This data store should also be\n         * globally visible. Move it to attaching state and send an \"attach\" op for it.\n         * If the container is detached, this data store will be part of the summary that makes the container attached.\n         */\n        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached) {\n            localContext.emit(\"attaching\");\n            const message = localContext.generateAttachMessage();\n            this.pendingAttach.set(id, message);\n            this.submitAttachFn(message);\n            this.attachOpFiredForDataStore.add(id);\n        }\n        this.contexts.bind(id);\n    }\n    createDetachedDataStoreCore(pkg, isRoot, id = (0,uuid__WEBPACK_IMPORTED_MODULE_14__[\"default\"])()) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!id.includes(\"/\"), 0x30c /* Id cannot contain slashes */);\n        const context = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.LocalDetachedFluidDataStoreContext({\n            id,\n            pkg,\n            runtime: this.runtime,\n            storage: this.runtime.storage,\n            scope: this.runtime.scope,\n            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.Local }),\n            makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),\n            snapshotTree: undefined,\n            isRootDataStore: isRoot,\n            writeGCDataAtRoot: this.writeGCDataAtRoot,\n            disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n        });\n        this.contexts.addUnbound(context);\n        return context;\n    }\n    _createFluidDataStoreContext(pkg, id, isRoot, props) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!id.includes(\"/\"), 0x30d /* Id cannot contain slashes */);\n        const context = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.LocalFluidDataStoreContext({\n            id,\n            pkg,\n            runtime: this.runtime,\n            storage: this.runtime.storage,\n            scope: this.runtime.scope,\n            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.Local }),\n            makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),\n            snapshotTree: undefined,\n            isRootDataStore: isRoot,\n            writeGCDataAtRoot: this.writeGCDataAtRoot,\n            disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n            createProps: props,\n        });\n        this.contexts.addUnbound(context);\n        return context;\n    }\n    get disposed() { return this.disposeOnce.evaluated; }\n    resubmitDataStoreOp(content, localOpMetadata) {\n        const envelope = content;\n        const context = this.contexts.get(envelope.address);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x160 /* \"There should be a store context for the op\" */);\n        context.reSubmit(envelope.contents, localOpMetadata);\n    }\n    rollbackDataStoreOp(content, localOpMetadata) {\n        const envelope = content;\n        const context = this.contexts.get(envelope.address);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x2e8 /* \"There should be a store context for the op\" */);\n        context.rollback(envelope.contents, localOpMetadata);\n    }\n    async applyStashedOp(content) {\n        const envelope = content;\n        const context = this.contexts.get(envelope.address);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x161 /* \"There should be a store context for the op\" */);\n        return context.applyStashedOp(envelope.contents);\n    }\n    async applyStashedAttachOp(message) {\n        this.pendingAttach.set(message.id, message);\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        this.processAttachMessage({ contents: message }, false);\n    }\n    processFluidDataStoreOp(message, local, localMessageMetadata) {\n        const envelope = message.contents;\n        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });\n        const context = this.contexts.get(envelope.address);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x162 /* \"There should be a store context for the op\" */);\n        context.process(transformed, local, localMessageMetadata);\n        // Notify that a GC node for the data store changed. This is used to detect if a deleted data store is\n        // being used.\n        this.gcNodeUpdated(`/${envelope.address}`, message.timestamp, context.isLoaded ? context.packagePath : undefined);\n    }\n    async getDataStore(id, wait) {\n        const context = await this.contexts.getBoundOrRemoted(id, wait);\n        if (context === undefined) {\n            // The requested data store does not exits. Throw a 404 response exception.\n            const request = { url: id };\n            throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__.responseToException)((0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__.create404Response)(request), request);\n        }\n        return context;\n    }\n    processSignal(address, message, local) {\n        const context = this.contexts.get(address);\n        if (!context) {\n            // Attach message may not have been processed yet\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!local, 0x163 /* \"Missing datastore for local signal\" */);\n            this.logger.sendTelemetryEvent({\n                eventName: \"SignalFluidDataStoreNotFound\",\n                fluidDataStoreId: {\n                    value: address,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.PackageData,\n                },\n            });\n            return;\n        }\n        context.processSignal(message, local);\n    }\n    setConnectionState(connected, clientId) {\n        for (const [fluidDataStore, context] of this.contexts) {\n            try {\n                context.setConnectionState(connected, clientId);\n            }\n            catch (error) {\n                this.logger.sendErrorEvent({\n                    eventName: \"SetConnectionStateError\",\n                    clientId,\n                    fluidDataStore,\n                }, error);\n            }\n        }\n    }\n    setAttachState(attachState) {\n        let eventName;\n        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attaching) {\n            eventName = \"attaching\";\n        }\n        else {\n            eventName = \"attached\";\n        }\n        for (const [, context] of this.contexts) {\n            // Fire only for bounded stores.\n            if (!this.contexts.isNotBound(context.id)) {\n                context.emit(eventName);\n            }\n        }\n    }\n    get size() {\n        return this.contexts.size;\n    }\n    async summarize(fullTree, trackState, telemetryContext) {\n        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();\n        // Iterate over each store and ask it to snapshot\n        await Promise.all(Array.from(this.contexts)\n            .filter(([_, context]) => {\n            // Summarizer works only with clients with no local changes!\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(context.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attaching, 0x165 /* \"Summarizer cannot work if client has local changes\" */);\n            return context.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached;\n        }).map(async ([contextId, context]) => {\n            const contextSummary = await context.summarize(fullTree, trackState, telemetryContext);\n            summaryBuilder.addWithStats(contextId, contextSummary);\n        }));\n        return summaryBuilder.getSummaryTree();\n    }\n    createSummary(telemetryContext) {\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();\n        // Attaching graph of some stores can cause other stores to get bound too.\n        // So keep taking summary until no new stores get bound.\n        let notBoundContextsLength;\n        do {\n            const builderTree = builder.summary.tree;\n            notBoundContextsLength = this.contexts.notBoundLength();\n            // Iterate over each data store and ask it to snapshot\n            Array.from(this.contexts)\n                .filter(([key, _]) => \n            // Take summary of bounded data stores only, make sure we haven't summarized them already\n            // and no attach op has been fired for that data store because for loader versions <= 0.24\n            // we set attach state as \"attaching\" before taking createNew summary.\n            !(this.contexts.isNotBound(key)\n                || builderTree[key]\n                || this.attachOpFiredForDataStore.has(key)))\n                .map(([key, value]) => {\n                let dataStoreSummary;\n                if (value.isLoaded) {\n                    const snapshot = value.generateAttachMessage().snapshot;\n                    dataStoreSummary = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertToSummaryTree)(snapshot, true);\n                }\n                else {\n                    // If this data store is not yet loaded, then there should be no changes in the snapshot from\n                    // which it was created as it is detached container. So just use the previous snapshot.\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!this.baseSnapshot, 0x166 /* \"BaseSnapshot should be there as detached container loaded from snapshot\" */);\n                    dataStoreSummary = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertSnapshotTreeToSummaryTree)(this.baseSnapshot.trees[key]);\n                }\n                builder.addWithStats(key, dataStoreSummary);\n            });\n        } while (notBoundContextsLength !== this.contexts.notBoundLength());\n        return builder.getSummaryTree();\n    }\n    /**\n     * Before GC runs, called by the garbage collector to update any pending GC state.\n     * The garbage collector needs to know all outbound references that are added. Since root data stores are not\n     * explicitly marked as referenced, notify GC of new root data stores that were added since the last GC run.\n     */\n    async updateStateBeforeGC() {\n        for (const id of this.dataStoresSinceLastGC) {\n            const context = this.contexts.get(id);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(context !== undefined, 0x2b6 /* Missing data store context */);\n            if (await context.isRoot()) {\n                // A root data store is basically a reference from the container runtime to the data store.\n                const handle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__.FluidObjectHandle(context, id, this.runtime.IFluidHandleContext);\n                this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);\n            }\n        }\n        this.dataStoresSinceLastGC = [];\n    }\n    /**\n     * Generates data used for garbage collection. It does the following:\n     * 1. Calls into each child data store context to get its GC data.\n     * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be\n     *    identified as belonging to the child.\n     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent\n     *    the GC data of this channel.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_17__.GCDataBuilder();\n        // Iterate over each store and get their GC data.\n        await Promise.all(Array.from(this.contexts)\n            .filter(([_, context]) => {\n            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n            // graph so any references they might have won't be connected as well.\n            return context.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached;\n        }).map(async ([contextId, context]) => {\n            const contextGCData = await context.getGCData(fullGC);\n            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.\n            // This also gradually builds the id of each node to be a path from the root.\n            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        }));\n        // Get the outbound routes and add a GC node for this channel.\n        builder.addNode(\"/\", await this.getOutboundRoutes());\n        return builder.getGCData();\n    }\n    /**\n     * After GC has run, called to notify this Container's data stores of routes that are used in it.\n     * @param usedRoutes - The routes that are used in all data stores in this Container.\n     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes\n     * unreferenced as part of this GC run, this should be used to update the time when it happens.\n     */\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        var _a;\n        // Get a map of data store ids to routes used in it.\n        const usedDataStoreRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_17__.unpackChildNodesUsedRoutes)(usedRoutes);\n        // Verify that the used routes are correct.\n        for (const [id] of usedDataStoreRoutes) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(this.contexts.has(id), 0x167 /* \"Used route does not belong to any known data store\" */);\n        }\n        // Update the used routes in each data store. Used routes is empty for unused data stores.\n        for (const [contextId, context] of this.contexts) {\n            context.updateUsedRoutes((_a = usedDataStoreRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);\n        }\n    }\n    /**\n     * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing\n     * scenarios with accessing deleted content.\n     * @param unusedRoutes - The routes that are unused in all data stores in this Container.\n     */\n    deleteUnusedRoutes(unusedRoutes) {\n        for (const route of unusedRoutes) {\n            const pathParts = route.split(\"/\");\n            // Delete data store only if its route (/datastoreId) is in unusedRoutes. We don't want to delete a data\n            // store based on its DDS being unused.\n            if (pathParts.length > 2) {\n                continue;\n            }\n            const dataStoreId = pathParts[1];\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(this.contexts.has(dataStoreId), 0x2d7 /* No data store with specified id */);\n            // Delete the contexts of unused data stores.\n            this.contexts.delete(dataStoreId);\n            // Delete the summarizer node of the unused data stores.\n            this.deleteChildSummarizerNodeFn(dataStoreId);\n        }\n    }\n    /**\n     * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are\n     * part of outbound routes.\n     */\n    async getOutboundRoutes() {\n        const outboundRoutes = [];\n        for (const [contextId, context] of this.contexts) {\n            const isRootDataStore = await context.isRoot();\n            if (isRootDataStore) {\n                outboundRoutes.push(`/${contextId}`);\n            }\n        }\n        return outboundRoutes;\n    }\n    /**\n     * Called by GC to retrieve the package path of a data store node with the given path.\n     */\n    async getDataStorePackagePath(nodePath) {\n        var _a;\n        // If the node belongs to a data store, return its package path. For DDSes, we return the package path of the\n        // data store that contains it.\n        const context = this.contexts.get(nodePath.split(\"/\")[1]);\n        return (_a = (await (context === null || context === void 0 ? void 0 : context.getInitialSnapshotDetails()))) === null || _a === void 0 ? void 0 : _a.pkg;\n    }\n    /**\n     * Called by GC to determine if a node is for a data store or for an object within a data store (for e.g. DDS).\n     * @returns the GC node type if the node belongs to a data store or object within data store, undefined otherwise.\n     */\n    getGCNodeType(nodePath) {\n        const pathParts = nodePath.split(\"/\");\n        if (!this.contexts.has(pathParts[1])) {\n            return undefined;\n        }\n        // Data stores paths are of the format \"/dataStoreId\".\n        // Sub data store paths are of the format \"/dataStoreId/subPath/...\".\n        if (pathParts.length === 2) {\n            return _garbageCollection__WEBPACK_IMPORTED_MODULE_18__.GCNodeType.DataStore;\n        }\n        return _garbageCollection__WEBPACK_IMPORTED_MODULE_18__.GCNodeType.SubDataStore;\n    }\n}\nfunction getSummaryForDatastores(snapshot, metadata) {\n    if (!snapshot) {\n        return undefined;\n    }\n    if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_19__.rootHasIsolatedChannels)(metadata)) {\n        const datastoresSnapshot = snapshot.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.channelsTreeName];\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!datastoresSnapshot, 0x168 /* Expected tree in snapshot not found */);\n        return datastoresSnapshot;\n    }\n    else {\n        // back-compat: strip out all non-datastore paths before giving to DataStores object.\n        const datastoresTrees = {};\n        for (const [key, value] of Object.entries(snapshot.trees)) {\n            if (!_summaryFormat__WEBPACK_IMPORTED_MODULE_19__.nonDataStorePaths.includes(key)) {\n                datastoresTrees[key] = value;\n            }\n        }\n        return Object.assign(Object.assign({}, snapshot), { trees: datastoresTrees });\n    }\n}\n//# sourceMappingURL=dataStores.js.map\n\n/***/ }),\n/* 83 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataStoreContexts\": () => (/* binding */ DataStoreContexts)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass DataStoreContexts {\n    constructor(baseLogger) {\n        this.notBoundContexts = new Set();\n        /** Attached and loaded context proxies */\n        this._contexts = new Map();\n        /**\n         * List of pending context waiting either to be bound or to arrive from another client.\n         * This covers the case where a local context has been created but not yet bound,\n         * or the case where a client knows a store will exist and is waiting on its creation,\n         * so that a caller may await the deferred's promise until such a time as the context is fully ready.\n         * This is a superset of _contexts, since contexts remain here once the Deferred resolves.\n         */\n        this.deferredContexts = new Map();\n        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => {\n            // close/stop all store contexts\n            for (const [fluidDataStoreId, contextD] of this.deferredContexts) {\n                contextD.promise.then((context) => {\n                    context.dispose();\n                }).catch((contextError) => {\n                    this._logger.sendErrorEvent({\n                        eventName: \"FluidDataStoreContextDisposeError\",\n                        fluidDataStoreId,\n                    }, contextError);\n                });\n            }\n        });\n        this.dispose = () => this.disposeOnce.value;\n        this._logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger);\n    }\n    [Symbol.iterator]() {\n        return this._contexts.entries();\n    }\n    get size() {\n        return this._contexts.size;\n    }\n    get disposed() { return this.disposeOnce.evaluated; }\n    notBoundLength() {\n        return this.notBoundContexts.size;\n    }\n    isNotBound(id) {\n        return this.notBoundContexts.has(id);\n    }\n    has(id) {\n        return this._contexts.has(id);\n    }\n    get(id) {\n        return this._contexts.get(id);\n    }\n    delete(id) {\n        this.deferredContexts.delete(id);\n        this.notBoundContexts.delete(id);\n        return this._contexts.delete(id);\n    }\n    /**\n     * Return the unbound local context with the given id,\n     * or undefined if it's not found or not unbound.\n     */\n    getUnbound(id) {\n        const context = this._contexts.get(id);\n        if (context === undefined || !this.notBoundContexts.has(id)) {\n            return undefined;\n        }\n        return this._contexts.get(id);\n    }\n    /**\n     * Add the given context, marking it as to-be-bound\n     */\n    addUnbound(context) {\n        const id = context.id;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this._contexts.has(id), 0x158 /* \"Creating store with existing ID\" */);\n        this._contexts.set(id, context);\n        this.notBoundContexts.add(id);\n        this.ensureDeferred(id);\n    }\n    /**\n     * Get the context with the given id, once it exists locally and is attached.\n     * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.\n     * @param id - The id of the context to get\n     * @param wait - If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.\n     */\n    async getBoundOrRemoted(id, wait) {\n        const deferredContext = this.ensureDeferred(id);\n        if (!wait && !deferredContext.isCompleted) {\n            return undefined;\n        }\n        return deferredContext.promise;\n    }\n    ensureDeferred(id) {\n        const deferred = this.deferredContexts.get(id);\n        if (deferred) {\n            return deferred;\n        }\n        const newDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();\n        this.deferredContexts.set(id, newDeferred);\n        return newDeferred;\n    }\n    /**\n     * Update this context as bound\n     */\n    bind(id) {\n        const removed = this.notBoundContexts.delete(id);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(removed, 0x159 /* \"The given id was not found in notBoundContexts to delete\" */);\n        this.resolveDeferred(id);\n    }\n    /**\n     * Triggers the deferred to resolve, indicating the context is not local-only\n     * @param id - The id of the context to resolve to\n     */\n    resolveDeferred(id) {\n        const context = this._contexts.get(id);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!context, 0x15a /* \"Cannot find context to resolve to\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.notBoundContexts.has(id), 0x15b /* \"Expected this id to already be removed from notBoundContexts\" */);\n        const deferred = this.deferredContexts.get(id);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!deferred, 0x15c /* \"Cannot find deferred to resolve\" */);\n        deferred.resolve(context);\n    }\n    /**\n     * Add the given context, marking it as not local-only.\n     * This could be because it's a local context that's been bound, or because it's a remote context.\n     * @param context - The context to add\n     */\n    addBoundOrRemoted(context) {\n        const id = context.id;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this._contexts.has(id), 0x15d /* \"Creating store with existing ID\" */);\n        this._contexts.set(id, context);\n        // Resolve the deferred immediately since this context is not unbound\n        this.ensureDeferred(id);\n        this.resolveDeferred(id);\n    }\n}\n//# sourceMappingURL=dataStoreContexts.js.map\n\n/***/ }),\n/* 84 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lazy\": () => (/* binding */ Lazy)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable\n  */\nclass Lazy {\n    /**\n     * Instantiates an instance of Lazy<T>\n     * @param valueGenerator - the function that will generate the value when value is accessed the first time\n     */\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this._evaluated = false;\n    }\n    /**\n     * Return true if the value as been generated, otherwise false\n     */\n    get evaluated() {\n        return this._evaluated;\n    }\n    /**\n     * Get the value. If this is the first call the value will be generated\n     */\n    get value() {\n        if (!this._evaluated) {\n            this._evaluated = true;\n            this._value = this.valueGenerator();\n        }\n        return this._value;\n    }\n}\n//# sourceMappingURL=lazy.js.map\n\n/***/ }),\n/* 85 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FluidDataStoreContext\": () => (/* binding */ FluidDataStoreContext),\n/* harmony export */   \"LocalDetachedFluidDataStoreContext\": () => (/* binding */ LocalDetachedFluidDataStoreContext),\n/* harmony export */   \"LocalFluidDataStoreContext\": () => (/* binding */ LocalFluidDataStoreContext),\n/* harmony export */   \"LocalFluidDataStoreContextBase\": () => (/* binding */ LocalFluidDataStoreContextBase),\n/* harmony export */   \"RemoteFluidDataStoreContext\": () => (/* binding */ RemoteFluidDataStoreContext),\n/* harmony export */   \"createAttributesBlob\": () => (/* binding */ createAttributesBlob)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(90);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(51);\n/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\nfunction createAttributes(pkg, isRootDataStore, disableIsolatedChannels) {\n    const stringifiedPkg = JSON.stringify(pkg);\n    return disableIsolatedChannels ? {\n        pkg: stringifiedPkg,\n        snapshotFormatVersion: \"0.1\",\n        isRootDataStore,\n    } : {\n        pkg: stringifiedPkg,\n        summaryFormatVersion: 2,\n        isRootDataStore,\n    };\n}\nfunction createAttributesBlob(pkg, isRootDataStore, disableIsolatedChannels) {\n    const attributes = createAttributes(pkg, isRootDataStore, disableIsolatedChannels);\n    return new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.BlobTreeEntry(_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));\n}\n/**\n * Represents the context for the store. This context is passed to the store runtime.\n */\nclass FluidDataStoreContext extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    constructor(props, existing, bindState, isLocalDataStore, makeLocallyVisibleFn) {\n        super();\n        this.existing = existing;\n        this.bindState = bindState;\n        this.isLocalDataStore = isLocalDataStore;\n        this.makeLocallyVisibleFn = makeLocallyVisibleFn;\n        this._disposed = false;\n        this.detachedRuntimeCreation = false;\n        this.loaded = false;\n        this.pending = [];\n        this._isInMemoryRoot = false;\n        this._containerRuntime = props.runtime;\n        this.id = props.id;\n        this.storage = props.storage;\n        this.scope = props.scope;\n        this.writeGCDataAtRoot = props.writeGCDataAtRoot;\n        this.disableIsolatedChannels = props.disableIsolatedChannels;\n        this.pkg = props.pkg;\n        // URIs use slashes as delimiters. Handles use URIs.\n        // Thus having slashes in types almost guarantees trouble down the road!\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.id.includes(\"/\"), 0x13a /* Data store ID contains slash */);\n        this._attachState = this.containerRuntime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached && this.existing ?\n            this.containerRuntime.attachState : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached;\n        this.bindToContext = () => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.bindState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.NotBound, 0x13b /* \"datastore context is already in bound state\" */);\n            this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Binding;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x13c /* \"undefined channel on datastore context\" */);\n            this.makeLocallyVisible();\n            this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound;\n        };\n        const thisSummarizeInternal = async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext);\n        this.summarizerNode = props.createSummarizerNodeFn(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => this.getBaseGCDetails());\n        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(this.logger, \"FluidDataStoreContext\");\n        this.thresholdOpsCounter = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ThresholdCounter(FluidDataStoreContext.pendingOpsCountThreshold, this.subLogger);\n    }\n    get packagePath() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x139 /* \"Undefined package path\" */);\n        return this.pkg;\n    }\n    get options() {\n        return this._containerRuntime.options;\n    }\n    get clientId() {\n        return this._containerRuntime.clientId;\n    }\n    get clientDetails() {\n        return this._containerRuntime.clientDetails;\n    }\n    get logger() {\n        return this._containerRuntime.logger;\n    }\n    get deltaManager() {\n        return this._containerRuntime.deltaManager;\n    }\n    get connected() {\n        return this._containerRuntime.connected;\n    }\n    get IFluidHandleContext() {\n        return this._containerRuntime.IFluidHandleContext;\n    }\n    get containerRuntime() {\n        return this._containerRuntime;\n    }\n    get isLoaded() {\n        return this.loaded;\n    }\n    get baseSnapshot() {\n        return this._baseSnapshot;\n    }\n    get disposed() { return this._disposed; }\n    get attachState() {\n        return this._attachState;\n    }\n    get IFluidDataStoreRegistry() {\n        return this.registry;\n    }\n    /**\n     * A datastore is considered as root if it\n     * 1. is root in memory - see isInMemoryRoot\n     * 2. is root as part of the base snapshot that the datastore loaded from\n     * @returns whether a datastore is root\n     */\n    async isRoot() {\n        return this.isInMemoryRoot() || (await this.getInitialSnapshotDetails()).isRootDataStore;\n    }\n    /**\n     * There are 3 states where isInMemoryRoot needs to be true\n     * 1. when a datastore becomes aliased. This can happen for both remote and local datastores\n     * 2. when a datastore is created locally as root\n     * 3. when a datastore is created locally as root and is rehydrated\n     * @returns whether a datastore is root in memory\n     */\n    isInMemoryRoot() {\n        return this._isInMemoryRoot;\n    }\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        // Dispose any pending runtime after it gets fulfilled\n        // Errors are logged where this.channelDeferred is consumed/generated (realizeCore(), bindRuntime())\n        if (this.channelDeferred) {\n            this.channelDeferred.promise.then((runtime) => {\n                runtime.dispose();\n            }).catch((error) => { });\n        }\n    }\n    rejectDeferredRealize(reason, packageName) {\n        throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError(reason, { packageName: { value: packageName, tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.TelemetryDataTag.PackageData } });\n    }\n    async realize() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.detachedRuntimeCreation, 0x13d /* \"Detached runtime creation on realize()\" */);\n        if (!this.channelDeferred) {\n            this.channelDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.Deferred();\n            this.realizeCore(this.existing).catch((error) => {\n                var _a;\n                const errorWrapped = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__.DataProcessingError.wrapIfUnrecognized(error, \"realizeFluidDataStoreContext\");\n                errorWrapped.addTelemetryProperties({ fluidDataStoreId: { value: this.id, tag: \"PackageData\" } });\n                (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(errorWrapped);\n                this.logger.sendErrorEvent({ eventName: \"RealizeError\" }, errorWrapped);\n            });\n        }\n        return this.channelDeferred.promise;\n    }\n    async factoryFromPackagePath(packages) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg === packages, 0x13e /* \"Unexpected package path\" */);\n        if (packages === undefined) {\n            this.rejectDeferredRealize(\"packages is undefined\");\n        }\n        let entry;\n        let registry = this._containerRuntime.IFluidDataStoreRegistry;\n        let lastPkg;\n        for (const pkg of packages) {\n            if (!registry) {\n                this.rejectDeferredRealize(\"No registry for package\", lastPkg);\n            }\n            lastPkg = pkg;\n            entry = await registry.get(pkg);\n            if (!entry) {\n                this.rejectDeferredRealize(\"Registry does not contain entry for the package\", pkg);\n            }\n            registry = entry.IFluidDataStoreRegistry;\n        }\n        const factory = entry === null || entry === void 0 ? void 0 : entry.IFluidDataStoreFactory;\n        if (factory === undefined) {\n            this.rejectDeferredRealize(\"Can't find factory for package\", lastPkg);\n        }\n        return { factory, registry };\n    }\n    async realizeCore(existing) {\n        const details = await this.getInitialSnapshotDetails();\n        // Base snapshot is the baseline where pending ops are applied to.\n        // It is important that this be in sync with the pending ops, and also\n        // that it is set here, before bindRuntime is called.\n        this._baseSnapshot = details.snapshot;\n        const packages = details.pkg;\n        const { factory, registry } = await this.factoryFromPackagePath(packages);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.registry === undefined, 0x13f /* \"datastore context registry is already set\" */);\n        this.registry = registry;\n        const channel = await factory.instantiateDataStore(this, existing);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(channel !== undefined, 0x140 /* \"undefined channel on datastore context\" */);\n        this.bindRuntime(channel);\n    }\n    /**\n     * Notifies this object about changes in the connection state.\n     * @param value - New connection state.\n     * @param clientId - ID of the client. It's old ID when in disconnected state and\n     * it's new client ID when we are connecting or connected.\n     */\n    setConnectionState(connected, clientId) {\n        this.verifyNotClosed();\n        // Connection events are ignored if the store is not yet loaded\n        if (!this.loaded) {\n            return;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connected === connected, 0x141 /* \"Unexpected connected state\" */);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.channel.setConnectionState(connected, clientId);\n    }\n    process(messageArg, local, localOpMetadata) {\n        var _a;\n        this.verifyNotClosed();\n        const innerContents = messageArg.contents;\n        const message = Object.assign(Object.assign({}, messageArg), { type: innerContents.type, contents: innerContents.content });\n        this.summarizerNode.recordChange(message);\n        if (this.loaded) {\n            return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!local, 0x142 /* \"local store channel is not loaded\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pending !== undefined, 0x23d /* \"pending is undefined\" */);\n            this.pending.push(message);\n            this.thresholdOpsCounter.sendIfMultiple(\"StorePendingOps\", this.pending.length);\n        }\n    }\n    processSignal(message, local) {\n        var _a;\n        this.verifyNotClosed();\n        // Signals are ignored if the store is not yet loaded\n        if (!this.loaded) {\n            return;\n        }\n        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);\n    }\n    getQuorum() {\n        return this._containerRuntime.getQuorum();\n    }\n    getAudience() {\n        return this._containerRuntime.getAudience();\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n    async summarize(fullTree = false, trackState = true, telemetryContext) {\n        return this.summarizerNode.summarize(fullTree, trackState, telemetryContext);\n    }\n    async summarizeInternal(fullTree, trackState, telemetryContext) {\n        await this.realize();\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const summarizeResult = await this.channel.summarize(fullTree, trackState, telemetryContext);\n        let pathPartsForChildren;\n        if (!this.disableIsolatedChannels) {\n            // Wrap dds summaries in .channels subtree.\n            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.wrapSummaryInChannelsTree)(summarizeResult);\n            pathPartsForChildren = [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.channelsTreeName];\n        }\n        // Add data store's attributes to the summary.\n        const { pkg } = await this.getInitialSnapshotDetails();\n        const isRoot = await this.isRoot();\n        const attributes = createAttributes(pkg, isRoot, this.disableIsolatedChannels);\n        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.addBlobToSummary)(summarizeResult, _summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));\n        // Add GC data to the summary if it's not written at the root.\n        if (!this.writeGCDataAtRoot) {\n            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.addBlobToSummary)(summarizeResult, _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.gcBlobKey, JSON.stringify(this.summarizerNode.getGCSummaryDetails()));\n        }\n        // If we are not referenced, mark the summary tree as unreferenced. Also, update unreferenced blob\n        // size in the summary stats with the blobs size of this data store.\n        if (!this.summarizerNode.isReferenced()) {\n            summarizeResult.summary.unreferenced = true;\n            summarizeResult.stats.unreferencedBlobSize = summarizeResult.stats.totalBlobSize;\n        }\n        return Object.assign(Object.assign({}, summarizeResult), { id: this.id, pathPartsForChildren });\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this data store\n     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the\n     * document.\n     * If there is no new data in this data store since the last summary, previous GC data is used.\n     * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        return this.summarizerNode.getGCData(fullGC);\n    }\n    /**\n     * Generates data used for garbage collection. This is called when there is new data since last summary. It\n     * realizes the data store and calls into each channel context to get its GC data.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCDataInternal(fullGC = false) {\n        await this.realize();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x143 /* \"Channel should not be undefined when running GC\" */);\n        return this.channel.getGCData(fullGC);\n    }\n    /**\n     * After GC has run, called to notify the data store of routes used in it. These are used for the following:\n     * 1. To identify if this data store is being referenced in the document or not.\n     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.\n     * 3. These are added to the summary generated by the data store.\n     * 4. To notify child contexts of their used routes. This is done immediately if the data store is loaded. Else,\n     *    it is done when realizing the data store.\n     * 5. To update the timestamp when this data store or any children are marked as unreferenced.\n     * @param usedRoutes - The routes that are used in this data store.\n     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced\n     * as part of this GC run, this should be used to update the time when it happens.\n     */\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        // Update the used routes in this data store's summarizer node.\n        this.summarizerNode.updateUsedRoutes(usedRoutes, gcTimestamp);\n        /**\n         * If the data store has not been realized yet, we need this used state to update the used state of the channel\n         * when it realizes. It's safe to keep only the last used state because if something changes because of this GC\n         * run, the data store will be immediately realized as part of the summary that follows GC. For example, if a\n         * child's reference state changes, the gcTimestamp has to be used to update its unreferencedTimestamp. Since\n         * it will result in a change in this data store's used routes, it will be realized to regenerate its summary.\n         */\n        this.lastUsedState = { usedRoutes, gcTimestamp };\n        // If we are loaded, call the channel so it can update the used routes of the child contexts.\n        // If we are not loaded, we will update this when we are realized.\n        if (this.loaded) {\n            this.updateChannelUsedRoutes();\n        }\n    }\n    /**\n     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify\n     * all references added in the system.\n     * @param srcHandle - The handle of the node that added the reference.\n     * @param outboundHandle - The handle of the outbound node that is referenced.\n     */\n    addedGCOutboundReference(srcHandle, outboundHandle) {\n        this._containerRuntime.addedGCOutboundReference(srcHandle, outboundHandle);\n    }\n    /**\n     * Updates the used routes of the channel and its child contexts. The channel must be loaded before calling this.\n     * It is called in these two scenarios:\n     * 1. When the used routes of the data store is updated and the data store is loaded.\n     * 2. When the data store is realized. This updates the channel's used routes as per last GC run.\n     */\n    updateChannelUsedRoutes() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.loaded, 0x144 /* \"Channel should be loaded when updating used routes\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x145 /* \"Channel should be present when data store is loaded\" */);\n        // If there is no lastUsedState, GC has not run up until this point.\n        if (this.lastUsedState === undefined) {\n            return;\n        }\n        // Remove the route to this data store, if it exists.\n        const usedChannelRoutes = this.lastUsedState.usedRoutes.filter((id) => { return id !== \"/\" && id !== \"\"; });\n        this.channel.updateUsedRoutes(usedChannelRoutes, this.lastUsedState.gcTimestamp);\n    }\n    /**\n     * @deprecated 0.18.Should call request on the runtime directly\n     */\n    async request(request) {\n        const runtime = await this.realize();\n        return runtime.request(request);\n    }\n    submitMessage(type, content, localOpMetadata) {\n        this.verifyNotClosed();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x146 /* \"Channel must exist when submitting message\" */);\n        const fluidDataStoreContent = {\n            content,\n            type,\n        };\n        this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);\n    }\n    /**\n     * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.\n     * It indicates that there is data in the object that needs to be summarized.\n     * We will update the latestSequenceNumber of the summary tracker of this\n     * store and of the object's channel.\n     *\n     * @param address - The address of the channel that is dirty.\n     *\n     */\n    setChannelDirty(address) {\n        this.verifyNotClosed();\n        // Get the latest sequence number.\n        const latestSequenceNumber = this.deltaManager.lastSequenceNumber;\n        this.summarizerNode.invalidate(latestSequenceNumber);\n        const channelSummarizerNode = this.summarizerNode.getChild(address);\n        if (channelSummarizerNode) {\n            channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?\n        }\n    }\n    submitSignal(type, content) {\n        this.verifyNotClosed();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x147 /* \"Channel must exist on submitting signal\" */);\n        return this._containerRuntime.submitDataStoreSignal(this.id, type, content);\n    }\n    /**\n     * This is called by the data store channel when it becomes locally visible indicating that it is ready to become\n     * globally visible now.\n     */\n    makeLocallyVisible() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x2cf /* \"undefined channel on datastore context\" */);\n        this.makeLocallyVisibleFn();\n    }\n    bindRuntime(channel) {\n        var _a;\n        if (this.channel) {\n            throw new Error(\"Runtime already bound\");\n        }\n        try {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.detachedRuntimeCreation, 0x148 /* \"Detached runtime creation on runtime bind\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channelDeferred !== undefined, 0x149 /* \"Undefined channel deferral\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x14a /* \"Undefined package path\" */);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const pending = this.pending;\n            // Apply all pending ops\n            for (const op of pending) {\n                channel.process(op, false, undefined /* localOpMetadata */);\n            }\n            this.thresholdOpsCounter.send(\"ProcessPendingOps\", pending.length);\n            this.pending = undefined;\n            // And now mark the runtime active\n            this.loaded = true;\n            this.channel = channel;\n            // Freeze the package path to ensure that someone doesn't modify it when it is\n            // returned in packagePath().\n            Object.freeze(this.pkg);\n            /**\n             * Update the used routes of the channel. If GC has run before this data store was realized, we will have\n             * the used routes saved. So, this will ensure that all the child contexts have up-to-date used routes as\n             * per the last time GC was run.\n             * Also, this data store may have been realized during summarize. In that case, the child contexts need to\n             * have their used routes updated to determine if its needs to summarize again and to add it to the summary.\n             */\n            this.updateChannelUsedRoutes();\n            // And notify the pending promise it is now available\n            this.channelDeferred.resolve(this.channel);\n        }\n        catch (error) {\n            (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);\n            this.logger.sendErrorEvent({ eventName: \"BindRuntimeError\", fluidDataStoreId: { value: this.id, tag: \"PackageData\" } }, error);\n        }\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attached) {\n            return undefined;\n        }\n        return this._containerRuntime.getAbsoluteUrl(relativeUrl);\n    }\n    /**\n     * @deprecated - Sets the datastore as root, for aliasing purposes: #7948\n     * This method should not be used outside of the aliasing context.\n     * It will be removed, as the source of truth for this flag will be the aliasing blob.\n     */\n    setInMemoryRoot() {\n        this._isInMemoryRoot = true;\n    }\n    reSubmit(contents, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x14b /* \"Channel must exist when resubmitting ops\" */);\n        const innerContents = contents;\n        this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);\n    }\n    rollback(contents, localOpMetadata) {\n        if (!this.channel) {\n            throw new Error(\"Channel must exist when rolling back ops\");\n        }\n        if (!this.channel.rollback) {\n            throw new Error(\"Channel doesn't support rollback\");\n        }\n        const innerContents = contents;\n        this.channel.rollback(innerContents.type, innerContents.content, localOpMetadata);\n    }\n    async applyStashedOp(contents) {\n        if (!this.channel) {\n            await this.realize();\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x14c /* \"Channel must exist when rebasing ops\" */);\n        const innerContents = contents;\n        return this.channel.applyStashedOp(innerContents.content);\n    }\n    verifyNotClosed() {\n        if (this._disposed) {\n            throw new Error(\"Context is closed\");\n        }\n    }\n    getCreateChildSummarizerNodeFn(id, createParam) {\n        return (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, \n        // DDS will not create failure summaries\n        { throwOnFailure: true }, getGCDataFn, getBaseGCDetailsFn);\n    }\n    async uploadBlob(blob) {\n        return this.containerRuntime.uploadBlob(blob);\n    }\n}\nFluidDataStoreContext.pendingOpsCountThreshold = 1000;\nclass RemoteFluidDataStoreContext extends FluidDataStoreContext {\n    constructor(props) {\n        super(props, true /* existing */, _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound, false /* isLocalDataStore */, () => {\n            throw new Error(\"Already attached\");\n        });\n        this.initialSnapshotDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.LazyPromise(async () => {\n            var _a, _b;\n            let tree;\n            let isRootDataStore = true;\n            if (typeof this.initSnapshotValue === \"string\") {\n                const commit = (await this.storage.getVersions(this.initSnapshotValue, 1))[0];\n                tree = (_a = await this.storage.getSnapshotTree(commit)) !== null && _a !== void 0 ? _a : undefined;\n            }\n            else {\n                tree = this.initSnapshotValue;\n            }\n            const localReadAndParse = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__.readAndParse)(this.storage, id);\n            if (tree) {\n                const loadedSummary = await this.summarizerNode.loadBaseSummary(tree, localReadAndParse);\n                tree = loadedSummary.baseSummary;\n                // Prepend outstanding ops to pending queue of ops to process.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.pending = loadedSummary.outstandingOps.concat(this.pending);\n            }\n            if (!!tree && tree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName] !== undefined) {\n                // Need to get through snapshot and use that to populate extraBlobs\n                const attributes = await localReadAndParse(tree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName]);\n                let pkgFromSnapshot;\n                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n                // For snapshotFormatVersion = \"0.1\" (1) or above, pkg is jsonified, otherwise it is just a string.\n                const formatVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.getAttributesFormatVersion)(attributes);\n                if (formatVersion < 1) {\n                    if (attributes.pkg.startsWith(\"[\\\"\") && attributes.pkg.endsWith(\"\\\"]\")) {\n                        pkgFromSnapshot = JSON.parse(attributes.pkg);\n                    }\n                    else {\n                        pkgFromSnapshot = [attributes.pkg];\n                    }\n                }\n                else {\n                    pkgFromSnapshot = JSON.parse(attributes.pkg);\n                }\n                this.pkg = pkgFromSnapshot;\n                /**\n                 * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that\n                 * data stores in older documents are not garbage collected incorrectly. This may lead to additional\n                 * roots in the document but they won't break.\n                 */\n                isRootDataStore = (_b = attributes.isRootDataStore) !== null && _b !== void 0 ? _b : true;\n                if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.hasIsolatedChannels)(attributes)) {\n                    tree = tree.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.channelsTreeName];\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(tree !== undefined, 0x1fe /* \"isolated channels subtree should exist in remote datastore snapshot\" */);\n                }\n            }\n            return {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                pkg: this.pkg,\n                isRootDataStore,\n                snapshot: tree,\n            };\n        });\n        this.initSnapshotValue = props.snapshotTree;\n        this.baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.LazyPromise(async () => {\n            var _a;\n            return (_a = (await props.getBaseGCDetails())) !== null && _a !== void 0 ? _a : {};\n        });\n    }\n    async getInitialSnapshotDetails() {\n        return this.initialSnapshotDetailsP;\n    }\n    /**\n     * @deprecated - Renamed to getBaseGCDetails.\n     */\n    async getInitialGCSummaryDetails() {\n        return this.getBaseGCDetails();\n    }\n    async getBaseGCDetails() {\n        return this.baseGCDetailsP;\n    }\n    generateAttachMessage() {\n        throw new Error(\"Cannot attach remote store\");\n    }\n}\n/**\n * Base class for detached & attached context classes\n */\nclass LocalFluidDataStoreContextBase extends FluidDataStoreContext {\n    constructor(props) {\n        super(props, props.snapshotTree !== undefined ? true : false /* existing */, props.snapshotTree ? _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.NotBound, true /* isLocalDataStore */, props.makeLocallyVisibleFn);\n        this.snapshotTree = props.snapshotTree;\n        if (props.isRootDataStore === true) {\n            this.setInMemoryRoot();\n        }\n        this.createProps = props.createProps;\n        this.attachListeners();\n    }\n    attachListeners() {\n        this.once(\"attaching\", () => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached, 0x14d /* \"Should move from detached to attaching\" */);\n            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attaching;\n        });\n        this.once(\"attached\", () => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attaching, 0x14e /* \"Should move from attaching to attached\" */);\n            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attached;\n        });\n    }\n    generateAttachMessage() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x14f /* \"There should be a channel when generating attach message\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x150 /* \"pkg should be available in local data store context\" */);\n        const summarizeResult = this.channel.getAttachSummary();\n        if (!this.disableIsolatedChannels) {\n            // Wrap dds summaries in .channels subtree.\n            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.wrapSummaryInChannelsTree)(summarizeResult);\n        }\n        // Add data store's attributes to the summary.\n        const attributes = createAttributes(this.pkg, this.isInMemoryRoot(), this.disableIsolatedChannels);\n        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.addBlobToSummary)(summarizeResult, _summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));\n        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n        const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.convertSummaryTreeToITree)(summarizeResult.summary);\n        const message = {\n            id: this.id,\n            snapshot,\n            type: this.pkg[this.pkg.length - 1],\n        };\n        return message;\n    }\n    async getInitialSnapshotDetails() {\n        var _a;\n        let snapshot = this.snapshotTree;\n        let attributes;\n        let isRootDataStore = false;\n        if (snapshot !== undefined) {\n            // Get the dataStore attributes.\n            // Note: storage can be undefined in special case while detached.\n            attributes = await (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.getFluidDataStoreAttributes)(this.storage, snapshot);\n            if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.hasIsolatedChannels)(attributes)) {\n                snapshot = snapshot.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.channelsTreeName];\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(snapshot !== undefined, 0x1ff /* \"isolated channels subtree should exist in local datastore snapshot\" */);\n            }\n            if (this.pkg === undefined) {\n                this.pkg = JSON.parse(attributes.pkg);\n                // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data\n                // stores in older documents are not garbage collected incorrectly. This may lead to additional\n                // roots in the document but they won't break.\n                if ((_a = attributes.isRootDataStore) !== null && _a !== void 0 ? _a : true) {\n                    isRootDataStore = true;\n                    this.setInMemoryRoot();\n                }\n            }\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x152 /* \"pkg should be available in local data store\" */);\n        return {\n            pkg: this.pkg,\n            isRootDataStore,\n            snapshot,\n        };\n    }\n    /**\n     * @deprecated - Renamed to getBaseGCDetails.\n     */\n    async getInitialGCSummaryDetails() {\n        // Local data store does not have initial summary.\n        return {};\n    }\n    async getBaseGCDetails() {\n        // Local data store does not have initial summary.\n        return {};\n    }\n}\n/**\n * context implementation for \"attached\" data store runtime.\n * Various workflows (snapshot creation, requests) result in .realize() being called\n * on context, resulting in instantiation and attachment of runtime.\n * Runtime is created using data store factory that is associated with this context.\n */\nclass LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n    constructor(props) {\n        super(props);\n    }\n}\n/**\n * Detached context. Data Store runtime will be attached to it by attachRuntime() call\n * Before attachment happens, this context is not associated with particular type of runtime\n * or factory, i.e. it's package path is undefined.\n * Attachment process provides all missing parts - package path, data store runtime, and data store factory\n */\nclass LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n    constructor(props) {\n        super(props);\n        this.detachedRuntimeCreation = true;\n    }\n    async attachRuntime(registry, dataStoreChannel) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.detachedRuntimeCreation, 0x154 /* \"runtime creation is already attached\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channelDeferred === undefined, 0x155 /* \"channel deferral is already set\" */);\n        const factory = registry.IFluidDataStoreFactory;\n        const entry = await this.factoryFromPackagePath(this.pkg);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(entry.factory === factory, 0x156 /* \"Unexpected factory for package path\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.registry === undefined, 0x157 /* \"datastore registry already attached\" */);\n        this.registry = entry.registry;\n        this.detachedRuntimeCreation = false;\n        this.channelDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.Deferred();\n        super.bindRuntime(dataStoreChannel);\n        if (await this.isRoot()) {\n            // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.\n            // For older versions, we still have to call bindToContext.\n            if (dataStoreChannel.makeVisibleAndAttachGraph !== undefined) {\n                dataStoreChannel.makeVisibleAndAttachGraph();\n            }\n            else {\n                dataStoreChannel.bindToContext();\n            }\n        }\n    }\n    async getInitialSnapshotDetails() {\n        if (this.detachedRuntimeCreation) {\n            throw new Error(\"Detached Fluid Data Store context can't be realized! Please attach runtime first!\");\n        }\n        return super.getInitialSnapshotDetails();\n    }\n}\n//# sourceMappingURL=dataStoreContext.js.map\n\n/***/ }),\n/* 86 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AttachmentTreeEntry\": () => (/* binding */ AttachmentTreeEntry),\n/* harmony export */   \"BlobTreeEntry\": () => (/* binding */ BlobTreeEntry),\n/* harmony export */   \"TreeTreeEntry\": () => (/* binding */ TreeTreeEntry),\n/* harmony export */   \"addBlobToTree\": () => (/* binding */ addBlobToTree),\n/* harmony export */   \"buildHierarchy\": () => (/* binding */ buildHierarchy),\n/* harmony export */   \"getGitMode\": () => (/* binding */ getGitMode),\n/* harmony export */   \"getGitType\": () => (/* binding */ getGitType)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Take a summary object and returns its git mode.\n *\n * @param value - summary object\n * @returns the git mode of summary object\n */\nfunction getGitMode(value) {\n    const type = value.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle ? value.handleType : value.type;\n    switch (type) {\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment:\n            return _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File;\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree:\n            return _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.Directory;\n        default:\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(type, `Unknown type: ${type}`);\n    }\n}\n/**\n * Take a summary object and returns its type.\n *\n * @param value - summary object\n * @returns the type of summary object\n */\nfunction getGitType(value) {\n    const type = value.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle ? value.handleType : value.type;\n    switch (type) {\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment:\n            return \"blob\";\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree:\n            return \"tree\";\n        default:\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(type, `Unknown type: ${type}`);\n    }\n}\n/**\n * Build a tree hierarchy base on a flat tree\n *\n * @param flatTree - a flat tree\n * @param blobsShaToPathCache - Map with blobs sha as keys and values as path of the blob.\n * @param removeAppTreePrefix - Remove `.app/` from beginning of paths when present\n * @returns the hierarchical tree\n */\nfunction buildHierarchy(flatTree, blobsShaToPathCache = new Map(), removeAppTreePrefix = false) {\n    const lookup = {};\n    const root = { id: flatTree.sha, blobs: {}, trees: {} };\n    lookup[\"\"] = root;\n    for (const entry of flatTree.tree) {\n        const entryPath = removeAppTreePrefix ? entry.path.replace(/^\\.app\\//, \"\") : entry.path;\n        const lastIndex = entryPath.lastIndexOf(\"/\");\n        const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));\n        const entryPathBase = entryPath.slice(lastIndex + 1);\n        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents\n        const node = lookup[entryPathDir];\n        // Add in either the blob or tree\n        if (entry.type === \"tree\") {\n            const newTree = { id: entry.sha, blobs: {}, commits: {}, trees: {} };\n            node.trees[decodeURIComponent(entryPathBase)] = newTree;\n            lookup[entryPath] = newTree;\n        }\n        else if (entry.type === \"blob\") {\n            node.blobs[decodeURIComponent(entryPathBase)] = entry.sha;\n            blobsShaToPathCache.set(entry.sha, `/${entryPath}`);\n        }\n        else {\n            throw new Error(\"Unknown entry type!!\");\n        }\n    }\n    return root;\n}\n/**\n * Basic implementation of a blob ITreeEntry\n */\nclass BlobTreeEntry {\n    /**\n     * Creates a blob ITreeEntry\n     * @param path - path of entry\n     * @param contents - blob contents\n     * @param encoding - encoding of contents; defaults to utf-8\n     */\n    constructor(path, contents, encoding = \"utf-8\") {\n        this.path = path;\n        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File;\n        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob;\n        this.value = { contents, encoding };\n    }\n}\n/**\n * Basic implementation of a tree ITreeEntry\n */\nclass TreeTreeEntry {\n    /**\n     * Creates a tree ITreeEntry\n     * @param path - path of entry\n     * @param value - subtree\n     */\n    constructor(path, value) {\n        this.path = path;\n        this.value = value;\n        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.Directory;\n        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Tree;\n    }\n}\n/**\n * Basic implementation of an attachment ITreeEntry\n */\nclass AttachmentTreeEntry {\n    /**\n     * Creates an attachment ITreeEntry\n     * @param path - path of entry\n     * @param id - id of external blob attachment\n     */\n    constructor(path, id) {\n        this.path = path;\n        this.id = id;\n        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File;\n        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Attachment;\n        this.value = { id };\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction addBlobToTree(tree, blobName, content) {\n    tree.entries.push({\n        mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File,\n        path: blobName,\n        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob,\n        value: {\n            contents: JSON.stringify(content),\n            encoding: \"utf-8\",\n        },\n    });\n}\n//# sourceMappingURL=blobs.js.map\n\n/***/ }),\n/* 87 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 88 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FileMode\": () => (/* binding */ FileMode),\n/* harmony export */   \"TreeEntry\": () => (/* binding */ TreeEntry)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar FileMode;\n(function (FileMode) {\n    FileMode[\"File\"] = \"100644\";\n    FileMode[\"Executable\"] = \"100755\";\n    FileMode[\"Directory\"] = \"040000\";\n    FileMode[\"Symlink\"] = \"120000\";\n})(FileMode || (FileMode = {}));\n/**\n * Type of entries that can be stored in a tree\n */\nvar TreeEntry;\n(function (TreeEntry) {\n    TreeEntry[\"Blob\"] = \"Blob\";\n    TreeEntry[\"Tree\"] = \"Tree\";\n    TreeEntry[\"Attachment\"] = \"Attachment\";\n})(TreeEntry || (TreeEntry = {}));\n//# sourceMappingURL=storage.js.map\n\n/***/ }),\n/* 89 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 90 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThresholdCounter\": () => (/* binding */ ThresholdCounter)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Utility counter which will send event only if the provided value\n * is above a configured threshold\n */\nclass ThresholdCounter {\n    constructor(threshold, logger, thresholdMultiple = threshold) {\n        this.threshold = threshold;\n        this.logger = logger;\n        this.thresholdMultiple = thresholdMultiple;\n    }\n    /**\n     * Sends the value if it's above the treshold.\n     */\n    send(eventName, value) {\n        if (value < this.threshold) {\n            return;\n        }\n        this.logger.sendPerformanceEvent({\n            eventName,\n            value,\n        });\n    }\n    /**\n     * Sends the value if it's above the treshold\n     * and a multiple of the threshold.\n     *\n     * To be used in scenarios where we'd like to record a\n     * threshold violation while reducing telemetry noise.\n     */\n    sendIfMultiple(eventName, value) {\n        if (value === this.thresholdMultiple) {\n            this.logger.sendPerformanceEvent({\n                eventName,\n                value,\n            });\n            // reduce number of \"multiple\" events.\n            this.thresholdMultiple = this.thresholdMultiple * 2;\n        }\n    }\n}\n//# sourceMappingURL=thresholdCounter.js.map\n\n/***/ }),\n/* 91 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryTreeBuilder\": () => (/* binding */ SummaryTreeBuilder),\n/* harmony export */   \"TelemetryContext\": () => (/* binding */ TelemetryContext),\n/* harmony export */   \"addBlobToSummary\": () => (/* binding */ addBlobToSummary),\n/* harmony export */   \"addSummarizeResultToSummary\": () => (/* binding */ addSummarizeResultToSummary),\n/* harmony export */   \"addTreeToSummary\": () => (/* binding */ addTreeToSummary),\n/* harmony export */   \"calculateStats\": () => (/* binding */ calculateStats),\n/* harmony export */   \"convertSnapshotTreeToSummaryTree\": () => (/* binding */ convertSnapshotTreeToSummaryTree),\n/* harmony export */   \"convertSummaryTreeToITree\": () => (/* binding */ convertSummaryTreeToITree),\n/* harmony export */   \"convertToSummaryTree\": () => (/* binding */ convertToSummaryTree),\n/* harmony export */   \"convertToSummaryTreeWithStats\": () => (/* binding */ convertToSummaryTreeWithStats),\n/* harmony export */   \"getBlobSize\": () => (/* binding */ getBlobSize),\n/* harmony export */   \"mergeStats\": () => (/* binding */ mergeStats),\n/* harmony export */   \"utf8ByteLength\": () => (/* binding */ utf8ByteLength)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Combines summary stats by adding their totals together.\n * Returns empty stats if called without args.\n * @param stats - stats to merge\n */\nfunction mergeStats(...stats) {\n    const results = {\n        treeNodeCount: 0,\n        blobNodeCount: 0,\n        handleNodeCount: 0,\n        totalBlobSize: 0,\n        unreferencedBlobSize: 0,\n    };\n    for (const stat of stats) {\n        results.treeNodeCount += stat.treeNodeCount;\n        results.blobNodeCount += stat.blobNodeCount;\n        results.handleNodeCount += stat.handleNodeCount;\n        results.totalBlobSize += stat.totalBlobSize;\n        results.unreferencedBlobSize += stat.unreferencedBlobSize;\n    }\n    return results;\n}\nfunction utf8ByteLength(str) {\n    // returns the byte length of an utf8 string\n    let s = str.length;\n    for (let i = str.length - 1; i >= 0; i--) {\n        const code = str.charCodeAt(i);\n        if (code > 0x7f && code <= 0x7ff) {\n            s++;\n        }\n        else if (code > 0x7ff && code <= 0xffff) {\n            s += 2;\n        }\n        if (code >= 0xDC00 && code <= 0xDFFF) {\n            i--; // trail surrogate\n        }\n    }\n    return s;\n}\nfunction getBlobSize(content) {\n    if (typeof content === \"string\") {\n        return utf8ByteLength(content);\n    }\n    else {\n        return content.byteLength;\n    }\n}\nfunction calculateStatsCore(summaryObject, stats) {\n    switch (summaryObject.type) {\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {\n            stats.treeNodeCount++;\n            for (const value of Object.values(summaryObject.tree)) {\n                calculateStatsCore(value, stats);\n            }\n            return;\n        }\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {\n            stats.handleNodeCount++;\n            return;\n        }\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {\n            stats.blobNodeCount++;\n            stats.totalBlobSize += getBlobSize(summaryObject.content);\n            return;\n        }\n        default: return;\n    }\n}\nfunction calculateStats(summary) {\n    const stats = mergeStats();\n    calculateStatsCore(summary, stats);\n    return stats;\n}\nfunction addBlobToSummary(summary, key, content) {\n    const blob = {\n        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob,\n        content,\n    };\n    summary.summary.tree[key] = blob;\n    summary.stats.blobNodeCount++;\n    summary.stats.totalBlobSize += getBlobSize(content);\n}\nfunction addTreeToSummary(summary, key, summarizeResult) {\n    summary.summary.tree[key] = summarizeResult.summary;\n    summary.stats = mergeStats(summary.stats, summarizeResult.stats);\n}\nfunction addSummarizeResultToSummary(summary, key, summarizeResult) {\n    summary.summary.tree[key] = summarizeResult.summary;\n    summary.stats = mergeStats(summary.stats, summarizeResult.stats);\n}\nclass SummaryTreeBuilder {\n    constructor() {\n        this.attachmentCounter = 0;\n        this.summaryTree = {};\n        this.summaryStats = mergeStats();\n        this.summaryStats.treeNodeCount++;\n    }\n    get summary() {\n        return {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,\n            tree: Object.assign({}, this.summaryTree),\n        };\n    }\n    get stats() {\n        return Object.assign({}, this.summaryStats);\n    }\n    addBlob(key, content) {\n        // Prevent cloning by directly referencing underlying private properties\n        addBlobToSummary({\n            summary: {\n                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,\n                tree: this.summaryTree,\n            },\n            stats: this.summaryStats,\n        }, key, content);\n    }\n    addHandle(key, handleType, handle) {\n        this.summaryTree[key] = {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle,\n            handleType,\n            handle,\n        };\n        this.summaryStats.handleNodeCount++;\n    }\n    addWithStats(key, summarizeResult) {\n        this.summaryTree[key] = summarizeResult.summary;\n        this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);\n    }\n    addAttachment(id) {\n        this.summaryTree[this.attachmentCounter++] = { id, type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment };\n    }\n    getSummaryTree() {\n        return { summary: this.summary, stats: this.stats };\n    }\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\nfunction convertToSummaryTreeWithStats(snapshot, fullTree = false) {\n    const builder = new SummaryTreeBuilder();\n    for (const entry of snapshot.entries) {\n        switch (entry.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob: {\n                const blob = entry.value;\n                let content;\n                if (blob.encoding === \"base64\") {\n                    content = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.IsoBuffer.from(blob.contents, \"base64\");\n                }\n                else {\n                    content = blob.contents;\n                }\n                builder.addBlob(entry.path, content);\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Tree: {\n                const subtree = convertToSummaryTree(entry.value, fullTree);\n                builder.addWithStats(entry.path, subtree);\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Attachment: {\n                const id = entry.value.id;\n                builder.addAttachment(id);\n                break;\n            }\n            default:\n                throw new Error(\"Unexpected TreeEntry type\");\n        }\n    }\n    const summaryTree = builder.getSummaryTree();\n    summaryTree.summary.unreferenced = snapshot.unreferenced;\n    return summaryTree;\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\nfunction convertToSummaryTree(snapshot, fullTree = false) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (snapshot.id && !fullTree) {\n        const stats = mergeStats();\n        stats.handleNodeCount++;\n        return {\n            summary: {\n                handle: snapshot.id,\n                handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,\n                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle,\n            },\n            stats,\n        };\n    }\n    else {\n        return convertToSummaryTreeWithStats(snapshot, fullTree);\n    }\n}\n/**\n * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was\n * was taken by serialize api in detached container.\n * @param snapshot - snapshot in ISnapshotTree format\n */\nfunction convertSnapshotTreeToSummaryTree(snapshot) {\n    const builder = new SummaryTreeBuilder();\n    for (const [path, id] of Object.entries(snapshot.blobs)) {\n        let decoded;\n        if (snapshot.blobsContents !== undefined) {\n            const content = snapshot.blobsContents[id];\n            if (content !== undefined) {\n                decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.bufferToString)(content, \"utf-8\");\n            }\n            // 0.44 back-compat We still put contents in same blob for back-compat so need to add blob\n            // only for blobPath -> blobId mapping and not for blobId -> blob value contents.\n        }\n        else if (snapshot.blobs[id] !== undefined) {\n            decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.fromBase64ToUtf8)(snapshot.blobs[id]);\n        }\n        if (decoded !== undefined) {\n            builder.addBlob(path, decoded);\n        }\n    }\n    for (const [key, tree] of Object.entries(snapshot.trees)) {\n        const subtree = convertSnapshotTreeToSummaryTree(tree);\n        builder.addWithStats(key, subtree);\n    }\n    const summaryTree = builder.getSummaryTree();\n    summaryTree.summary.unreferenced = snapshot.unreferenced;\n    return summaryTree;\n}\n/**\n * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.\n * @param summaryTree - summary tree in ISummaryTree format\n */\nfunction convertSummaryTreeToITree(summaryTree) {\n    const entries = [];\n    for (const [key, value] of Object.entries(summaryTree.tree)) {\n        switch (value.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {\n                let parsedContent;\n                let encoding = \"utf-8\";\n                if (typeof value.content === \"string\") {\n                    parsedContent = value.content;\n                }\n                else {\n                    parsedContent = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Uint8ArrayToString)(value.content, \"base64\");\n                    encoding = \"base64\";\n                }\n                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.BlobTreeEntry(key, parsedContent, encoding));\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {\n                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.TreeTreeEntry(key, convertSummaryTreeToITree(value)));\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment: {\n                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.AttachmentTreeEntry(key, value.id));\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {\n                throw new Error(\"Should not have Handle type in summary tree\");\n            }\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.unreachableCase)(value, \"Unexpected summary tree type\");\n        }\n    }\n    return {\n        entries,\n        unreferenced: summaryTree.unreferenced,\n    };\n}\nclass TelemetryContext {\n    constructor() {\n        this.telemetry = new Map();\n    }\n    /**\n     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.set}\n     */\n    set(prefix, property, value) {\n        this.telemetry.set(`${prefix}${property}`, value);\n    }\n    /**\n     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.get}\n     */\n    get(prefix, property) {\n        return this.telemetry.get(`${prefix}${property}`);\n    }\n    /**\n     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.serialize}\n     */\n    serialize() {\n        const jsonObject = {};\n        this.telemetry.forEach((value, key) => {\n            jsonObject[key] = value;\n        });\n        return JSON.stringify(jsonObject);\n    }\n}\n//# sourceMappingURL=summaryUtils.js.map\n\n/***/ }),\n/* 92 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 93 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FileMode\": () => (/* binding */ FileMode),\n/* harmony export */   \"TreeEntry\": () => (/* binding */ TreeEntry)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar FileMode;\n(function (FileMode) {\n    FileMode[\"File\"] = \"100644\";\n    FileMode[\"Executable\"] = \"100755\";\n    FileMode[\"Directory\"] = \"040000\";\n    FileMode[\"Symlink\"] = \"120000\";\n})(FileMode || (FileMode = {}));\n/**\n * Type of entries that can be stored in a tree\n */\nvar TreeEntry;\n(function (TreeEntry) {\n    TreeEntry[\"Blob\"] = \"Blob\";\n    TreeEntry[\"Tree\"] = \"Tree\";\n    TreeEntry[\"Attachment\"] = \"Attachment\";\n})(TreeEntry || (TreeEntry = {}));\n//# sourceMappingURL=storage.js.map\n\n/***/ }),\n/* 94 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 95 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromBase64ToUtf8\": () => (/* binding */ fromBase64ToUtf8),\n/* harmony export */   \"fromUtf8ToBase64\": () => (/* binding */ fromUtf8ToBase64),\n/* harmony export */   \"toUtf8\": () => (/* binding */ toUtf8)\n/* harmony export */ });\n/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nconst fromBase64ToUtf8 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, \"base64\").toString(\"utf-8\");\nconst fromUtf8ToBase64 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, \"utf8\").toString(\"base64\");\n/**\n * Convenience function to convert unknown encoding to utf8 that avoids\n * buffer copies/encode ops when no conversion is needed\n * @param input - The source string to convert\n * @param encoding - The source string's encoding\n */\nconst toUtf8 = (input, encoding) => {\n    switch (encoding) {\n        case \"utf8\":\n        case \"utf-8\":\n            return input;\n        default:\n            return _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, encoding).toString();\n    }\n};\n//# sourceMappingURL=base64Encoding.js.map\n\n/***/ }),\n/* 96 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 97 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildSnapshotTree\": () => (/* binding */ buildSnapshotTree)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\nfunction flattenCore(path, treeEntries, blobMap) {\n    const entries = [];\n    for (const treeEntry of treeEntries) {\n        const subPath = `${path}${treeEntry.path}`;\n        if (treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Blob) {\n            const blob = treeEntry.value;\n            const buffer = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.stringToBuffer)(blob.contents, blob.encoding);\n            const id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n            blobMap.set(id, buffer);\n            const entry = {\n                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],\n                path: subPath,\n                sha: id,\n                size: 0,\n                type: \"blob\",\n                url: \"\",\n            };\n            entries.push(entry);\n        }\n        else if (treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Tree) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Tree, 0x101 /* \"Unexpected tree entry type on flatten!\" */);\n            const t = treeEntry.value;\n            const entry = {\n                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],\n                path: subPath,\n                sha: \"\",\n                size: -1,\n                type: \"tree\",\n                url: \"\",\n            };\n            entries.push(entry);\n            const subTreeEntries = flattenCore(`${subPath}/`, t.entries, blobMap);\n            entries.push(...subTreeEntries);\n        }\n    }\n    return entries;\n}\n/**\n * Create a flatten view of an array of ITreeEntry\n *\n * @param tree - an array of ITreeEntry to flatten\n * @param blobMap - a map of blob's sha1 to content\n * @returns A flatten with of the ITreeEntry\n */\nfunction flatten(tree, blobMap) {\n    const entries = flattenCore(\"\", tree, blobMap);\n    return {\n        sha: \"\",\n        tree: entries,\n        url: \"\",\n    };\n}\n/**\n * Build a tree hierarchy base on an array of ITreeEntry\n *\n * @param entries - an array of ITreeEntry to flatten\n * @param blobMap - a map of blob's sha1 to content that gets filled with content from entries\n * NOTE: blobMap's validity is contingent on the returned promise's resolution\n * @returns the hierarchical tree\n */\nfunction buildSnapshotTree(entries, blobMap) {\n    const flattened = flatten(entries, blobMap);\n    return (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.buildHierarchy)(flattened);\n}\n//# sourceMappingURL=buildSnapshotTree.js.map\n\n/***/ }),\n/* 98 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FileMode\": () => (/* binding */ FileMode),\n/* harmony export */   \"TreeEntry\": () => (/* binding */ TreeEntry)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar FileMode;\n(function (FileMode) {\n    FileMode[\"File\"] = \"100644\";\n    FileMode[\"Executable\"] = \"100755\";\n    FileMode[\"Directory\"] = \"040000\";\n    FileMode[\"Symlink\"] = \"120000\";\n})(FileMode || (FileMode = {}));\n/**\n * Type of entries that can be stored in a tree\n */\nvar TreeEntry;\n(function (TreeEntry) {\n    TreeEntry[\"Blob\"] = \"Blob\";\n    TreeEntry[\"Tree\"] = \"Tree\";\n    TreeEntry[\"Attachment\"] = \"Attachment\";\n})(TreeEntry || (TreeEntry = {}));\n//# sourceMappingURL=storage.js.map\n\n/***/ }),\n/* 99 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlobCacheStorageService\": () => (/* binding */ BlobCacheStorageService)\n/* harmony export */ });\n/* harmony import */ var _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * IDocumentStorageService adapter with pre-cached blobs.\n */\nclass BlobCacheStorageService extends _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {\n    constructor(internalStorageService, blobs) {\n        super(internalStorageService);\n        this.blobs = blobs;\n    }\n    get policies() {\n        return this.internalStorageService.policies;\n    }\n    async readBlob(id) {\n        const blob = this.blobs.get(id);\n        if (blob !== undefined) {\n            return blob;\n        }\n        return this.internalStorageService.readBlob(id);\n    }\n}\n//# sourceMappingURL=blobCacheStorageService.js.map\n\n/***/ }),\n/* 100 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DocumentStorageServiceProxy\": () => (/* binding */ DocumentStorageServiceProxy)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nclass DocumentStorageServiceProxy {\n    constructor(internalStorageService) {\n        this.internalStorageService = internalStorageService;\n    }\n    set policies(policies) {\n        this._policies = policies;\n    }\n    get policies() {\n        var _a;\n        return (_a = this._policies) !== null && _a !== void 0 ? _a : this.internalStorageService.policies;\n    }\n    get repositoryUrl() {\n        return this.internalStorageService.repositoryUrl;\n    }\n    async getSnapshotTree(version, scenarioName) {\n        return this.internalStorageService.getSnapshotTree(version, scenarioName);\n    }\n    async getVersions(versionId, count, scenarioName) {\n        return this.internalStorageService.getVersions(versionId, count, scenarioName);\n    }\n    async uploadSummaryWithContext(summary, context) {\n        return this.internalStorageService.uploadSummaryWithContext(summary, context);\n    }\n    async downloadSummary(handle) {\n        return this.internalStorageService.downloadSummary(handle);\n    }\n    async createBlob(file) {\n        return this.internalStorageService.createBlob(file);\n    }\n    async readBlob(blobId) {\n        return this.internalStorageService.readBlob(blobId);\n    }\n}\n//# sourceMappingURL=documentStorageServiceProxy.js.map\n\n/***/ }),\n/* 101 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"channelToDataStore\": () => (/* binding */ channelToDataStore),\n/* harmony export */   \"isDataStoreAliasMessage\": () => (/* binding */ isDataStoreAliasMessage)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n/**\n * Type guard that returns true if the given alias message is actually an instance of\n * a class which implements {@link IDataStoreAliasMessage}\n * @param maybeDataStoreAliasMessage - message object to be validated\n * @returns True if the {@link IDataStoreAliasMessage} is fully implemented, false otherwise\n */\nconst isDataStoreAliasMessage = (maybeDataStoreAliasMessage) => {\n    return typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.internalId) === \"string\"\n        && typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.alias) === \"string\";\n};\nconst channelToDataStore = (fluidDataStoreChannel, internalId, runtime, datastores, logger) => new DataStore(fluidDataStoreChannel, internalId, runtime, datastores, logger);\nvar AliasState;\n(function (AliasState) {\n    AliasState[\"Aliased\"] = \"Aliased\";\n    AliasState[\"Aliasing\"] = \"Aliasing\";\n    AliasState[\"None\"] = \"None\";\n})(AliasState || (AliasState = {}));\nclass DataStore {\n    constructor(fluidDataStoreChannel, internalId, runtime, datastores, logger) {\n        this.fluidDataStoreChannel = fluidDataStoreChannel;\n        this.internalId = internalId;\n        this.runtime = runtime;\n        this.datastores = datastores;\n        this.logger = logger;\n        this.aliasState = AliasState.None;\n    }\n    async trySetAlias(alias) {\n        if (alias.includes(\"/\")) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__.UsageError(`The alias cannot contain slashes: '${alias}'`);\n        }\n        switch (this.aliasState) {\n            // If we're already aliasing, check if it's for the same value and return\n            // the stored promise, otherwise return 'AlreadyAliased'\n            case AliasState.Aliasing:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.aliasResult !== undefined, 0x316 /* There should be a cached promise of in-progress aliasing */);\n                await this.aliasResult;\n                return this.alias === alias ? \"Success\" : \"AlreadyAliased\";\n            // If this datastore is already aliased, return true only if this\n            // is a repeated call for the same alias\n            case AliasState.Aliased:\n                return this.alias === alias ? \"Success\" : \"AlreadyAliased\";\n            // There is no current or past alias operation for this datastore,\n            // it is safe to continue execution\n            case AliasState.None: break;\n            default: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(this.aliasState);\n        }\n        this.aliasState = AliasState.Aliasing;\n        this.aliasResult = this.trySetAliasInternal(alias);\n        return this.aliasResult;\n    }\n    async trySetAliasInternal(alias) {\n        const message = {\n            internalId: this.internalId,\n            alias,\n        };\n        // back-compat 0.58.2000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For\n        // older versions, we still have to call bindToContext.\n        if (this.fluidDataStoreChannel.makeVisibleAndAttachGraph !== undefined) {\n            this.fluidDataStoreChannel.makeVisibleAndAttachGraph();\n        }\n        else {\n            this.fluidDataStoreChannel.bindToContext();\n        }\n        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached) {\n            const localResult = this.datastores.processAliasMessageCore(message);\n            // Explicitly lock-out future attempts of aliasing,\n            // regardless of result\n            this.aliasState = AliasState.Aliased;\n            return localResult ? \"Success\" : \"Conflict\";\n        }\n        const aliased = await this.ackBasedPromise((resolve) => {\n            this.runtime.submitDataStoreAliasOp(message, resolve);\n        }).then((succeeded) => {\n            // Explicitly Lock-out future attempts of aliasing,\n            // regardless of result\n            this.aliasState = AliasState.Aliased;\n            if (succeeded) {\n                this.alias = alias;\n            }\n            return succeeded;\n        }).catch((error) => {\n            this.logger.sendErrorEvent({\n                eventName: \"AliasingException\",\n                alias: {\n                    value: alias,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.TelemetryDataTag.UserData,\n                },\n                internalId: {\n                    value: this.internalId,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.TelemetryDataTag.PackageData,\n                },\n            }, error);\n            this.aliasState = AliasState.None;\n            return false;\n        });\n        return aliased ? \"Success\" : \"Conflict\";\n    }\n    async request(request) {\n        return this.fluidDataStoreChannel.request(request);\n    }\n    get IFluidRouter() { return this.fluidDataStoreChannel; }\n    async ackBasedPromise(executor) {\n        let rejectBecauseDispose;\n        return new Promise((resolve, reject) => {\n            rejectBecauseDispose =\n                () => reject(new Error(\"ContainerRuntime disposed while this ack-based Promise was pending\"));\n            if (this.runtime.disposed) {\n                rejectBecauseDispose();\n                return;\n            }\n            this.runtime.on(\"dispose\", rejectBecauseDispose);\n            executor(resolve, reject);\n        }).finally(() => {\n            this.runtime.off(\"dispose\", rejectBecauseDispose);\n        });\n    }\n}\n//# sourceMappingURL=dataStore.js.map\n\n/***/ }),\n/* 102 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 103 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GCDataBuilder\": () => (/* binding */ GCDataBuilder),\n/* harmony export */   \"cloneGCData\": () => (/* binding */ cloneGCData),\n/* harmony export */   \"concatGarbageCollectionData\": () => (/* binding */ concatGarbageCollectionData),\n/* harmony export */   \"concatGarbageCollectionStates\": () => (/* binding */ concatGarbageCollectionStates),\n/* harmony export */   \"removeRouteFromAllNodes\": () => (/* binding */ removeRouteFromAllNodes),\n/* harmony export */   \"trimLeadingAndTrailingSlashes\": () => (/* binding */ trimLeadingAndTrailingSlashes),\n/* harmony export */   \"trimLeadingSlashes\": () => (/* binding */ trimLeadingSlashes),\n/* harmony export */   \"trimTrailingSlashes\": () => (/* binding */ trimTrailingSlashes),\n/* harmony export */   \"unpackChildNodesGCDetails\": () => (/* binding */ unpackChildNodesGCDetails),\n/* harmony export */   \"unpackChildNodesUsedRoutes\": () => (/* binding */ unpackChildNodesUsedRoutes)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Trims the leading and trailing slashes from the given string.\n * @param str - A string that may contain leading and / or trailing slashes.\n * @returns A new string without leading and trailing slashes.\n */\nfunction trimLeadingAndTrailingSlashes(str) {\n    return str.replace(/^\\/+|\\/+$/g, \"\");\n}\n/**\n * Trims the leading slashes from the given string.\n * @param str - A string that may contain leading slashes.\n * @returns A new string without leading slashes.\n */\nfunction trimLeadingSlashes(str) {\n    return str.replace(/^\\/+/g, \"\");\n}\n/**\n * Trims the trailing slashes from the given string.\n * @param str - A string that may contain trailing slashes.\n * @returns A new string without trailing slashes.\n */\nfunction trimTrailingSlashes(str) {\n    return str.replace(/\\/+$/g, \"\");\n}\n/**\n * Helper function that clones the GC data.\n * @param gcData - The GC data to clone.\n * @returns a clone of the given GC data.\n */\nfunction cloneGCData(gcData) {\n    const clonedGCNodes = {};\n    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {\n        clonedGCNodes[id] = Array.from(outboundRoutes);\n    }\n    return {\n        gcNodes: clonedGCNodes,\n    };\n}\n/**\n * Helper function that unpacks the GC details of the children from a given node's GC details.\n * @param gcDetails - The GC details of a node.\n * @returns A map of GC details of each children of the the given node.\n */\nfunction unpackChildNodesGCDetails(gcDetails) {\n    const childGCDetailsMap = new Map();\n    // If GC data is not available, bail out.\n    if (gcDetails.gcData === undefined) {\n        return childGCDetailsMap;\n    }\n    // Remove the node's self GC nodes, if any, and generate the children GC nodes.\n    const gcNodes = gcDetails.gcData.gcNodes;\n    delete gcNodes[\"/\"];\n    for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(id.startsWith(\"/\"), 0x2ae /* \"node id should always be an absolute route\" */);\n        const childId = id.split(\"/\")[1];\n        let childGCNodeId = id.slice(childId.length + 1);\n        // GC node id always begins with \"/\". Handle the special case where a child's id in the parent's GC nodes is\n        // of format `/root`. In this case, the childId is root and childGCNodeId is \"\". Make childGCNodeId = \"/\".\n        if (childGCNodeId === \"\") {\n            childGCNodeId = \"/\";\n        }\n        let childGCDetails = childGCDetailsMap.get(childId);\n        if (childGCDetails === undefined) {\n            childGCDetails = { gcData: { gcNodes: {} }, usedRoutes: [] };\n        }\n        // gcData should not undefined as its always at least initialized as  empty above.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childGCDetails.gcData !== undefined, 0x2af /* \"Child GC data should have been initialized\" */);\n        childGCDetails.gcData.gcNodes[childGCNodeId] = [...new Set(outboundRoutes)];\n        childGCDetailsMap.set(childId, childGCDetails);\n    }\n    if (gcDetails.usedRoutes === undefined) {\n        return childGCDetailsMap;\n    }\n    // Remove the node's self used route, if any, and generate the children used routes.\n    const usedRoutes = gcDetails.usedRoutes.filter((route) => route !== \"\" && route !== \"/\");\n    for (const route of usedRoutes) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(route.startsWith(\"/\"), 0x2b0 /* \"Used route should always be an absolute route\" */);\n        const childId = route.split(\"/\")[1];\n        const childUsedRoute = route.slice(childId.length + 1);\n        const childGCDetails = childGCDetailsMap.get(childId);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((childGCDetails === null || childGCDetails === void 0 ? void 0 : childGCDetails.usedRoutes) !== undefined, 0x2b1 /* \"This should have be initiallized when generate GC nodes above\" */);\n        childGCDetails.usedRoutes.push(childUsedRoute);\n        childGCDetailsMap.set(childId, childGCDetails);\n    }\n    return childGCDetailsMap;\n}\n/**\n * Helper function that unpacks the used routes of children from a given node's used routes.\n * @param usedRoutes - The used routes of a node.\n * @returns A map of used routes of each children of the the given node.\n */\nfunction unpackChildNodesUsedRoutes(usedRoutes) {\n    // Remove the node's self used route, if any, and generate the children used routes.\n    const filteredUsedRoutes = usedRoutes.filter((route) => route !== \"\" && route !== \"/\");\n    const childUsedRoutesMap = new Map();\n    for (const route of filteredUsedRoutes) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(route.startsWith(\"/\"), 0x198 /* \"Used route should always be an absolute route\" */);\n        const childId = route.split(\"/\")[1];\n        const childUsedRoute = route.slice(childId.length + 1);\n        const childUsedRoutes = childUsedRoutesMap.get(childId);\n        if (childUsedRoutes !== undefined) {\n            childUsedRoutes.push(childUsedRoute);\n        }\n        else {\n            childUsedRoutesMap.set(childId, [childUsedRoute]);\n        }\n    }\n    return childUsedRoutesMap;\n}\n/**\n * Removes the given route from the outbound routes of all the given GC nodes, and any duplicates\n * @param gcNodes - The nodes from which the route is to be removed.\n * @param outboundRoute - The route to be removed.\n */\nfunction removeRouteFromAllNodes(gcNodes, outboundRoute) {\n    const channels = Object.entries(gcNodes);\n    for (const [nodeId, outboundRoutes] of channels) {\n        // Remove route from channel to parent for each channel\n        const outboundRoutesSet = new Set(outboundRoutes);\n        outboundRoutesSet.delete(outboundRoute);\n        gcNodes[nodeId] = [...outboundRoutesSet];\n    }\n}\n/**\n * Concatenates the given GC states and returns the concatenated GC state.\n */\nfunction concatGarbageCollectionStates(gcState1, gcState2) {\n    var _a;\n    const combinedGCNodes = {};\n    for (const [nodeId, nodeData] of Object.entries(gcState1.gcNodes)) {\n        combinedGCNodes[nodeId] = {\n            outboundRoutes: Array.from(nodeData.outboundRoutes),\n            unreferencedTimestampMs: nodeData.unreferencedTimestampMs,\n        };\n    }\n    for (const [nodeId, nodeData] of Object.entries(gcState2.gcNodes)) {\n        let combinedNodedata = combinedGCNodes[nodeId];\n        if (combinedNodedata === undefined) {\n            combinedNodedata = {\n                outboundRoutes: Array.from(nodeData.outboundRoutes),\n                unreferencedTimestampMs: nodeData.unreferencedTimestampMs,\n            };\n        }\n        else {\n            // Validate that same node doesn't have different unreferenced timestamp.\n            if (nodeData.unreferencedTimestampMs !== undefined\n                && combinedNodedata.unreferencedTimestampMs !== undefined) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(nodeData.unreferencedTimestampMs === combinedNodedata.unreferencedTimestampMs, 0x2b2 /* \"Two entries for the same GC node with different unreferenced timestamp\" */);\n            }\n            combinedNodedata = {\n                outboundRoutes: [...new Set([...nodeData.outboundRoutes, ...combinedNodedata.outboundRoutes])],\n                unreferencedTimestampMs: (_a = nodeData.unreferencedTimestampMs) !== null && _a !== void 0 ? _a : combinedNodedata.unreferencedTimestampMs,\n            };\n        }\n        combinedGCNodes[nodeId] = combinedNodedata;\n    }\n    return { gcNodes: combinedGCNodes };\n}\n/**\n * Concatenates the given GC datas and returns the concatenated GC data.\n */\nfunction concatGarbageCollectionData(gcData1, gcData2) {\n    const combinedGCData = cloneGCData(gcData1);\n    for (const [id, routes] of Object.entries(gcData2.gcNodes)) {\n        if (combinedGCData.gcNodes[id] === undefined) {\n            combinedGCData.gcNodes[id] = Array.from(routes);\n        }\n        else {\n            const combinedRoutes = [...routes, ...combinedGCData.gcNodes[id]];\n            combinedGCData.gcNodes[id] = [...new Set(combinedRoutes)];\n        }\n    }\n    return combinedGCData;\n}\nclass GCDataBuilder {\n    constructor() {\n        this.gcNodesSet = {};\n    }\n    get gcNodes() {\n        const gcNodes = {};\n        for (const [nodeId, outboundRoutes] of Object.entries(this.gcNodesSet)) {\n            gcNodes[nodeId] = [...outboundRoutes];\n        }\n        return gcNodes;\n    }\n    addNode(id, outboundRoutes) {\n        this.gcNodesSet[id] = new Set(outboundRoutes);\n    }\n    /**\n     * Adds the given GC nodes. It does the following:\n     * - Normalizes the ids of the given nodes.\n     * - Prefixes the given `prefixId` to the given nodes' ids.\n     * - Adds the outbound routes of the nodes against the normalized and prefixed id.\n     */\n    prefixAndAddNodes(prefixId, gcNodes) {\n        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n            // Remove any leading slashes from the id.\n            let normalizedId = trimLeadingSlashes(id);\n            // Prefix the given id to the normalized id.\n            normalizedId = `/${prefixId}/${normalizedId}`;\n            // Remove any trailing slashes from the normalized id. Note that the trailing slashes are removed after\n            // adding the prefix for handling the special case where id is \"/\".\n            normalizedId = trimTrailingSlashes(normalizedId);\n            // Add the outbound routes against the normalized and prefixed id without duplicates.\n            this.gcNodesSet[normalizedId] = new Set(outboundRoutes);\n        }\n    }\n    addNodes(gcNodes) {\n        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {\n            this.gcNodesSet[id] = new Set(outboundRoutes);\n        }\n    }\n    /**\n     * Adds the given outbound route to the outbound routes of all GC nodes.\n     */\n    addRouteToAllNodes(outboundRoute) {\n        for (const outboundRoutes of Object.values(this.gcNodesSet)) {\n            outboundRoutes.add(outboundRoute);\n        }\n    }\n    getGCData() {\n        return {\n            gcNodes: this.gcNodes,\n        };\n    }\n}\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 104 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 105 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"runGarbageCollection\": () => (/* binding */ runGarbageCollection)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Runs garbage collection on the given reference graph.\n * @param referenceGraph - The reference graph to run GC on. It's a list of nodes where each node has an id and set of\n * routes to other nodes in the graph.\n * @param rootIds - The ids of root nodes that are considered referenced.\n * @returns the ids of referenced nodes and the ids of deleted nodes in the referenced graph.\n */\nfunction runGarbageCollection(referenceGraph, rootIds) {\n    // This set keeps track of nodes that we have visited. It is used to detect cycles in the graph.\n    const visited = new Set();\n    // This tracks the ids of referenced nodes. The nodes corresponding to rootIds are always considered\n    // referenced so we start with those.\n    const referencedIds = [...rootIds];\n    for (const id of referencedIds) {\n        // If we have already seen this node, ignore and continue. Else, add it to visited list.\n        if (visited.has(id)) {\n            continue;\n        }\n        visited.add(id);\n        // Get the node for the referenced id and add its outbound routes to referencedIds since they are\n        // also referenced.\n        const routes = referenceGraph[id];\n        if (routes !== undefined) {\n            referencedIds.push(...routes);\n        }\n    }\n    const referencedNodeIds = [];\n    const deletedNodeIds = [];\n    for (const id of Object.keys(referenceGraph)) {\n        // The nodes from the reference graph whose ids are in the visited list are referenced.\n        // The rest of the nodes are deleted.\n        if (visited.has(id)) {\n            referencedNodeIds.push(id);\n        }\n        else {\n            deletedNodeIds.push(id);\n        }\n    }\n    return { referencedNodeIds, deletedNodeIds };\n}\n//# sourceMappingURL=garbageCollector.js.map\n\n/***/ }),\n/* 106 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarizerNodeWithGC\": () => (/* binding */ SummarizerNodeWithGC),\n/* harmony export */   \"createRootSummarizerNodeWithGC\": () => (/* binding */ createRootSummarizerNodeWithGC)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);\n/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _summarizerNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(108);\n/* harmony import */ var _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(107);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n// Extend SummaryNode to add used routes tracking to it.\nclass SummaryNodeWithGC extends _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__.SummaryNode {\n    constructor(serializedUsedRoutes, summary) {\n        super(summary);\n        this.serializedUsedRoutes = serializedUsedRoutes;\n    }\n}\n/**\n * Extends the functionality of SummarizerNode to manage this node's garbage collection data:\n * - Adds a new API `getGCData` to return GC data of this node.\n * - Caches the result of `getGCData` to be used if nothing changes between summaries.\n * - Manages the used routes of this node. These are used to identify if this node is referenced in the document\n *   and to determine if the node's used state changed since last summary.\n * - Adds trackState param to summarize. If trackState is false, it bypasses the SummarizerNode and calls\n *   directly into summarizeInternal method.\n */\nclass SummarizerNodeWithGC extends _summarizerNode__WEBPACK_IMPORTED_MODULE_1__.SummarizerNode {\n    /**\n     * Do not call constructor directly.\n     * Use createRootSummarizerNodeWithGC to create root node, or createChild to create child nodes.\n     */\n    constructor(logger, summarizeFn, config, changeSequenceNumber, \n    /** Undefined means created without summary */\n    latestSummary, initialSummary, wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn) {\n        super(logger, async (fullTree, _trackState, telemetryContext) => summarizeFn(fullTree, true /* trackState */, telemetryContext), config, changeSequenceNumber, latestSummary, initialSummary, wipSummaryLogger);\n        this.summarizeFn = summarizeFn;\n        this.getGCDataFn = getGCDataFn;\n        // Keeps track of whether we have loaded the base details to ensure that we on;y do it once.\n        this.baseGCDetailsLoaded = false;\n        // Set used routes to have self route by default. This makes the node referenced by default. This is done to ensure\n        // that this node is not marked as collected when running GC has been disabled. Once, the option to disable GC is\n        // removed (from runGC flag in IContainerRuntimeOptions), this should be changed to be have no routes by default.\n        this.usedRoutes = [\"\"];\n        this.gcDisabled = config.gcDisabled === true;\n        this.baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.LazyPromise(async () => {\n            var _a;\n            return (_a = (await (getBaseGCDetailsFn === null || getBaseGCDetailsFn === void 0 ? void 0 : getBaseGCDetailsFn()))) !== null && _a !== void 0 ? _a : { usedRoutes: [] };\n        });\n    }\n    /**\n     * @deprecated - Renamed to getBaseGCDetails.\n     */\n    getGCSummaryDetails() {\n        return this.getBaseGCDetails();\n    }\n    // Returns the GC details to be added to this node's summary and is used to initialize new nodes' GC state.\n    getBaseGCDetails() {\n        return {\n            gcData: this.gcData,\n            usedRoutes: this.usedRoutes,\n            unrefTimestamp: this.unreferencedTimestampMs,\n        };\n    }\n    /**\n     * Loads state from this node's initial GC summary details. This contains the following data from the last summary\n     * seen by the server for this client:\n     * - usedRoutes: This is used to figure out if the used state of this node changed since last summary.\n     * - gcData: The garbage collection data of this node that is required for running GC.\n     */\n    async loadBaseGCDetails() {\n        var _a;\n        const baseGCDetails = await this.baseGCDetailsP;\n        // Possible race - If there were parallel calls to loadBaseGCDetails, we want to make sure that we only update\n        // the state from the base details only once.\n        if (this.baseGCDetailsLoaded) {\n            return;\n        }\n        this.baseGCDetailsLoaded = true;\n        // If the GC details has GC data, initialize our GC data from it.\n        if (baseGCDetails.gcData !== undefined) {\n            this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(baseGCDetails.gcData);\n        }\n        // Sort the used routes because we compare them with the current used routes to check if they changed between\n        // summaries. Both are sorted so that the order of elements is the same.\n        this.referenceUsedRoutes = (_a = baseGCDetails.usedRoutes) === null || _a === void 0 ? void 0 : _a.sort();\n        this.unreferencedTimestampMs = baseGCDetails.unrefTimestamp;\n    }\n    async summarize(fullTree, trackState = true, telemetryContext) {\n        // If GC is not disabled and we are tracking a summary, GC should have run and updated the used routes for this\n        // summary by calling updateUsedRoutes which sets wipSerializedUsedRoutes.\n        if (!this.gcDisabled && this.isTrackingInProgress()) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.wipSerializedUsedRoutes !== undefined, 0x1b1 /* \"wip used routes should be set if tracking a summary\" */);\n        }\n        // If trackState is true, get summary from base summarizer node which tracks summary state.\n        // If trackState is false, get summary from summarizeInternal.\n        return trackState\n            ? super.summarize(fullTree, true /* trackState */, telemetryContext)\n            : this.summarizeFn(fullTree, trackState, telemetryContext);\n    }\n    /**\n     * Returns the GC data of this node. If nothing has changed since last summary, it tries to reuse the data from\n     * the previous summary. Else, it gets new GC data from the underlying Fluid object.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.gcDisabled, 0x1b2 /* \"Getting GC data should not be called when GC is disabled!\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.getGCDataFn !== undefined, 0x1b3 /* \"GC data cannot be retrieved without getGCDataFn\" */);\n        // Load GC details from the initial summary, if not already loaded. If this is the first time this function is\n        // called and the node's data has not changed since last summary, the GC data in initial details is returned.\n        await this.loadBaseGCDetails();\n        // If there is no new data since last summary and we have GC data from the previous run, return it. We may not\n        // have data from previous GC run for clients with older summary format before GC was added. They won't have\n        // GC details in their initial summary.\n        if (!fullGC && !this.hasDataChanged() && this.gcData !== undefined) {\n            return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(this.gcData);\n        }\n        const gcData = await this.getGCDataFn(fullGC);\n        this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(gcData);\n        return gcData;\n    }\n    /**\n     * Called during the start of a summary. Updates the work-in-progress used routes.\n     */\n    startSummary(referenceSequenceNumber, summaryLogger) {\n        // If GC is disabled, skip setting wip used routes since we should not track GC state.\n        if (!this.gcDisabled) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.wipSerializedUsedRoutes === undefined, 0x1b4 /* \"We should not already be tracking used routes when to track a new summary\" */);\n        }\n        super.startSummary(referenceSequenceNumber, summaryLogger);\n    }\n    /**\n     * Called after summary has been uploaded to the server. Add the work-in-progress state to the pending\n     * summary queue. We track this until we get an ack from the server for this summary.\n     */\n    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n        let wipSerializedUsedRoutes;\n        // If GC is disabled, don't set wip used routes.\n        if (!this.gcDisabled) {\n            wipSerializedUsedRoutes = this.wipSerializedUsedRoutes;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(wipSerializedUsedRoutes !== undefined, 0x1b5 /* \"We should have been tracking used routes\" */);\n        }\n        super.completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion);\n        // If GC is disabled, skip setting pending summary with GC state.\n        if (!this.gcDisabled) {\n            const summaryNode = this.pendingSummaries.get(proposalHandle);\n            if (summaryNode !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const summaryNodeWithGC = new SummaryNodeWithGC(wipSerializedUsedRoutes, summaryNode);\n                this.pendingSummaries.set(proposalHandle, summaryNodeWithGC);\n            }\n        }\n    }\n    /**\n     * Clears the work-in-progress state.\n     */\n    clearSummary() {\n        this.wipSerializedUsedRoutes = undefined;\n        super.clearSummary();\n    }\n    /**\n     * Called when we get an ack from the server for a summary we sent. Update the reference state of this node\n     * from the state in the pending summary queue.\n     */\n    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.\n        if (!this.gcDisabled) {\n            const summaryNode = this.pendingSummaries.get(proposalHandle);\n            if (summaryNode !== undefined) {\n                this.referenceUsedRoutes = JSON.parse(summaryNode.serializedUsedRoutes);\n            }\n        }\n        return super.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n    }\n    /**\n     * Called when we need to upload the reference state from the given summary. Read the GC blob and get the state\n     * to upload from it.\n     */\n    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.\n        if (!this.gcDisabled) {\n            const gcDetailsBlob = snapshotTree.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.gcBlobKey];\n            if (gcDetailsBlob !== undefined) {\n                const gcDetails = await readAndParseBlob(gcDetailsBlob);\n                // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n                if (this.referenceSequenceNumber >= referenceSequenceNumber) {\n                    return;\n                }\n                this.referenceUsedRoutes = gcDetails.usedRoutes;\n            }\n        }\n        return super.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob);\n    }\n    /**\n     * Override the createChild method to return an instance of SummarizerNodeWithGC.\n     */\n    createChild(\n    /** Summarize function */\n    summarizeInternalFn, \n    /** Initial id or path part of this node */\n    id, \n    /**\n     * Information needed to create the node.\n     * If it is from a base summary, it will assert that a summary has been seen.\n     * Attach information if it is created from an attach op.\n     */\n    createParam, config = {}, getGCDataFn, getBaseGCDetailsFn) {\n        var _a;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.children.has(id), 0x1b6 /* \"Create SummarizerNode child already exists\" */);\n        const createDetails = this.getCreateDetailsForChild(id, createParam);\n        const child = new SummarizerNodeWithGC(this.defaultLogger, summarizeInternalFn, Object.assign(Object.assign({}, config), { \n            // Propagate our gcDisabled state to the child if its not explicity specified in child's config.\n            gcDisabled: (_a = config.gcDisabled) !== null && _a !== void 0 ? _a : this.gcDisabled }), createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn);\n        // There may be additional state that has to be updated in this child. For example, if a summary is being\n        // tracked, the child's summary tracking state needs to be updated too.\n        this.maybeUpdateChildState(child);\n        this.children.set(id, child);\n        return child;\n    }\n    /**\n     * Deletes the child node with the given id.\n     */\n    deleteChild(id) {\n        this.children.delete(id);\n    }\n    /**\n     * Override the getChild method to return an instance of SummarizerNodeWithGC.\n     */\n    getChild(id) {\n        return this.children.get(id);\n    }\n    isReferenced() {\n        return this.usedRoutes.includes(\"\") || this.usedRoutes.includes(\"/\");\n    }\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        // Sort the given routes before updating. This will ensure that the routes compared in hasUsedStateChanged()\n        // are in the same order.\n        this.usedRoutes = usedRoutes.sort();\n        // If GC is not disabled and we are tracking a summary, update the work-in-progress used routes so that it can\n        // be tracked for this summary.\n        if (!this.gcDisabled && this.isTrackingInProgress()) {\n            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);\n        }\n        if (this.isReferenced()) {\n            this.unreferencedTimestampMs = undefined;\n            return;\n        }\n        // If this node just became unreferenced, update its unreferencedTimestampMs.\n        if (this.unreferencedTimestampMs === undefined) {\n            this.unreferencedTimestampMs = gcTimestamp;\n        }\n    }\n    /**\n     * Override the hasChanged method. If this node data or its used state changed, the node is considered changed.\n     */\n    hasChanged() {\n        return this.hasDataChanged() || this.hasUsedStateChanged();\n    }\n    /**\n     * This tells whether the data in this node has changed or not.\n     */\n    hasDataChanged() {\n        return super.hasChanged();\n    }\n    /**\n     * This tells whether the used state of this node has changed since last successful summary. If the used routes\n     * of this node changed, its used state is considered changed. Basically, if this node or any of its child nodes\n     * was previously used and became unused (or vice versa), its used state has changed.\n     */\n    hasUsedStateChanged() {\n        // If GC is disabled, we are not tracking used state, return false.\n        if (this.gcDisabled) {\n            return false;\n        }\n        return this.referenceUsedRoutes === undefined ||\n            JSON.stringify(this.usedRoutes) !== JSON.stringify(this.referenceUsedRoutes);\n    }\n}\n/**\n * Creates a root summarizer node with GC functionality built-in.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n * @param getGCDataFn - Function to get the GC data of this node\n * @param baseGCDetailsP - Function to get the initial GC details of this node\n */\nconst createRootSummarizerNodeWithGC = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}, getGCDataFn, getBaseGCDetailsFn) => new SummarizerNodeWithGC(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__.SummaryNode.createForRoot(referenceSequenceNumber), undefined /* initialSummary */, undefined /* wipSummaryLogger */, getGCDataFn, getBaseGCDetailsFn);\n//# sourceMappingURL=summarizerNodeWithGc.js.map\n\n/***/ }),\n/* 107 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EscapedPath\": () => (/* binding */ EscapedPath),\n/* harmony export */   \"SummaryNode\": () => (/* binding */ SummaryNode),\n/* harmony export */   \"decodeSummary\": () => (/* binding */ decodeSummary),\n/* harmony export */   \"encodeSummary\": () => (/* binding */ encodeSummary),\n/* harmony export */   \"parseSummaryForSubtrees\": () => (/* binding */ parseSummaryForSubtrees),\n/* harmony export */   \"parseSummaryTreeForSubtrees\": () => (/* binding */ parseSummaryTreeForSubtrees)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _summaryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\nconst baseSummaryTreeKey = \"_baseSummary\";\nconst outstandingOpsBlobKey = \"_outstandingOps\";\nconst maxDecodeDepth = 100;\n/** Path for nodes in a tree with escaped special characters */\nclass EscapedPath {\n    constructor(path) {\n        this.path = path;\n    }\n    static create(path) {\n        return new EscapedPath(encodeURIComponent(path));\n    }\n    static createAndConcat(pathParts) {\n        var _a;\n        let ret = EscapedPath.create((_a = pathParts[0]) !== null && _a !== void 0 ? _a : \"\");\n        for (let i = 1; i < pathParts.length; i++) {\n            ret = ret.concat(EscapedPath.create(pathParts[i]));\n        }\n        return ret;\n    }\n    toString() {\n        return this.path;\n    }\n    concat(path) {\n        return new EscapedPath(`${this.path}/${path.path}`);\n    }\n}\n/** Information about a summary relevant to a specific node in the tree */\nclass SummaryNode {\n    constructor(summary) {\n        this.summary = summary;\n    }\n    /** Creates an instance that is valid for the root with specific basePath and localPath */\n    static createForRoot(referenceSequenceNumber) {\n        return new SummaryNode({\n            referenceSequenceNumber,\n            basePath: undefined,\n            localPath: EscapedPath.create(\"\"), // root hard-coded to \"\"\n        });\n    }\n    /** Summary reference sequence number, i.e. last sequence number seen when it was created */\n    get referenceSequenceNumber() {\n        return this.summary.referenceSequenceNumber;\n    }\n    /** Full path to parent node, or undefined if this is the root */\n    get basePath() {\n        return this.summary.basePath;\n    }\n    /** Relative path to this node from its parent node */\n    get localPath() {\n        return this.summary.localPath;\n    }\n    /** Relative path from this node to its node innermost base summary */\n    get additionalPath() {\n        return this.summary.additionalPath;\n    }\n    set additionalPath(additionalPath) {\n        this.summary.additionalPath = additionalPath;\n    }\n    /** Gets the full path to this node, to be used when sending a handle */\n    get fullPath() {\n        var _a, _b;\n        return (_b = (_a = this.basePath) === null || _a === void 0 ? void 0 : _a.concat(this.localPath)) !== null && _b !== void 0 ? _b : this.localPath;\n    }\n    /**\n     * Gets the full path to this node's innermost base summary.\n     * The children nodes can use this as their basePath to determine their path.\n     */\n    get fullPathForChildren() {\n        return this.additionalPath !== undefined\n            ? this.fullPath.concat(this.additionalPath)\n            : this.fullPath;\n    }\n    /**\n     * Creates a new node within the same summary for a child of this node.\n     * @param id - id of the child node\n     */\n    createForChild(id) {\n        return new SummaryNode({\n            referenceSequenceNumber: this.referenceSequenceNumber,\n            basePath: this.fullPathForChildren,\n            localPath: EscapedPath.create(id),\n        });\n    }\n}\n/**\n * Checks if the snapshot is created by referencing a previous successful\n * summary plus outstanding ops. If so, it will recursively \"decode\" it until\n * it gets to the last successful summary (the base summary) and returns that\n * as well as a function for fetching the outstanding ops. Also returns the\n * full path to the previous base summary for child summarizer nodes to use as\n * their base path when necessary.\n * @param snapshot - snapshot tree to decode\n */\nfunction decodeSummary(snapshot, logger) {\n    let baseSummary = snapshot;\n    const pathParts = [];\n    const opsBlobs = [];\n    for (let i = 0;; i++) {\n        if (i > maxDecodeDepth) {\n            logger.sendTelemetryEvent({\n                eventName: \"DecodeSummaryMaxDepth\",\n                maxDecodeDepth,\n            });\n        }\n        const outstandingOpsBlob = baseSummary.blobs[outstandingOpsBlobKey];\n        const newBaseSummary = baseSummary.trees[baseSummaryTreeKey];\n        if (outstandingOpsBlob === undefined && newBaseSummary === undefined) {\n            return {\n                baseSummary,\n                pathParts,\n                async getOutstandingOps(readAndParseBlob) {\n                    let outstandingOps = [];\n                    for (const opsBlob of opsBlobs) {\n                        const newOutstandingOps = await readAndParseBlob(opsBlob);\n                        if (outstandingOps.length > 0 && newOutstandingOps.length > 0) {\n                            const latestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n                            const newEarliestSeq = newOutstandingOps[0].sequenceNumber;\n                            if (newEarliestSeq <= latestSeq) {\n                                logger.sendTelemetryEvent({\n                                    eventName: \"DuplicateOutstandingOps\",\n                                    // eslint-disable-next-line max-len\n                                    message: `newEarliestSeq <= latestSeq in decodeSummary: ${newEarliestSeq} <= ${latestSeq}`,\n                                });\n                                while (newOutstandingOps.length > 0\n                                    && newOutstandingOps[0].sequenceNumber <= latestSeq) {\n                                    newOutstandingOps.shift();\n                                }\n                            }\n                        }\n                        outstandingOps = outstandingOps.concat(newOutstandingOps);\n                    }\n                    return outstandingOps;\n                },\n            };\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!outstandingOpsBlob, 0x1af /* \"Outstanding ops blob missing, but base summary tree exists\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(newBaseSummary !== undefined, 0x1b0 /* \"Base summary tree missing, but outstanding ops blob exists\" */);\n        baseSummary = newBaseSummary;\n        pathParts.push(baseSummaryTreeKey);\n        opsBlobs.unshift(outstandingOpsBlob);\n    }\n}\n/**\n * Creates a summary tree which is a handle of the previous successfully acked summary\n * and a blob of the outstanding ops since that summary. If there is no acked summary yet,\n * it will create with the tree found in the initial attach op and the blob of outstanding ops.\n * @param summaryParam - information about last acked summary and paths to encode if from summary,\n * otherwise the initial summary from the attach op.\n * @param outstandingOps - outstanding ops since last acked summary\n */\nfunction encodeSummary(summaryParam, outstandingOps) {\n    let additionalPath = EscapedPath.create(baseSummaryTreeKey);\n    const builder = new _summaryUtils__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeBuilder();\n    builder.addBlob(outstandingOpsBlobKey, JSON.stringify(outstandingOps));\n    if (summaryParam.fromSummary) {\n        // Create using handle of latest acked summary\n        const summaryNode = summaryParam.summaryNode;\n        if (summaryNode.additionalPath !== undefined) {\n            additionalPath = additionalPath.concat(summaryNode.additionalPath);\n        }\n        builder.addHandle(baseSummaryTreeKey, _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree, summaryNode.fullPath.path);\n    }\n    else {\n        // Create using initial summary from attach op\n        builder.addWithStats(baseSummaryTreeKey, summaryParam.initialSummary);\n    }\n    const summary = builder.getSummaryTree();\n    return Object.assign(Object.assign({}, summary), { additionalPath });\n}\n/**\n * Checks if the summary contains .channels subtree where the children subtrees\n * would be located if exists.\n * @param baseSummary - summary to check\n */\nfunction parseSummaryForSubtrees(baseSummary) {\n    // New versions of snapshots have child nodes isolated in .channels subtree\n    const channelsSubtree = baseSummary.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName];\n    if (channelsSubtree !== undefined) {\n        return {\n            childrenTree: channelsSubtree,\n            childrenPathPart: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName,\n        };\n    }\n    return {\n        childrenTree: baseSummary,\n        childrenPathPart: undefined,\n    };\n}\n/**\n * Checks if the summary contains .channels subtree where the children subtrees\n * would be located if exists.\n * @param baseSummary - summary to check\n */\nfunction parseSummaryTreeForSubtrees(summary) {\n    // New versions of snapshots have child nodes isolated in .channels subtree\n    const channelsSubtree = summary.tree[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName];\n    if (channelsSubtree !== undefined) {\n        return {\n            childrenTree: channelsSubtree,\n            childrenPathPart: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName,\n        };\n    }\n    return {\n        childrenTree: summary,\n        childrenPathPart: undefined,\n    };\n}\n//# sourceMappingURL=summarizerNodeUtils.js.map\n\n/***/ }),\n/* 108 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarizerNode\": () => (/* binding */ SummarizerNode),\n/* harmony export */   \"createRootSummarizerNode\": () => (/* binding */ createRootSummarizerNode)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96);\n/* harmony import */ var _summaryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);\n/* harmony import */ var _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(107);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n/**\n * Encapsulates the summarizing work and state of an individual tree node in the\n * summary tree. It tracks changes and allows for optimizations when unchanged, or\n * can allow for fallback summaries to be generated when an error is encountered.\n * Usage is for the root node to call startSummary first to begin tracking a WIP\n * (work in progress) summary. Then all nodes will call summarize to summaries their\n * individual parts. Once completed and uploaded to storage, the root node will call\n * completeSummary or clearSummary to clear the WIP summary tracking state if something\n * went wrong. The SummarizerNodes will track all pending summaries that have been\n * recorded by the completeSummary call. When one of them is acked, the root node should\n * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline\n * latest successful summary.\n */\nclass SummarizerNode {\n    /**\n     * Do not call constructor directly.\n     * Use createRootSummarizerNode to create root node, or createChild to create child nodes.\n     */\n    constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber, \n    /** Undefined means created without summary */\n    _latestSummary, initialSummary, wipSummaryLogger) {\n        var _a;\n        this.defaultLogger = defaultLogger;\n        this.summarizeInternalFn = summarizeInternalFn;\n        this._changeSequenceNumber = _changeSequenceNumber;\n        this._latestSummary = _latestSummary;\n        this.initialSummary = initialSummary;\n        this.wipSummaryLogger = wipSummaryLogger;\n        this.children = new Map();\n        this.pendingSummaries = new Map();\n        this.outstandingOps = [];\n        this.wipSkipRecursion = false;\n        this.canReuseHandle = (_a = config.canReuseHandle) !== null && _a !== void 0 ? _a : true;\n        // BUGBUG: Seeing issues with differential summaries.\n        // this will disable them, and throw instead\n        // while we continue to investigate\n        this.throwOnError = true; // config.throwOnFailure ?? false;\n        this.trackingSequenceNumber = this._changeSequenceNumber;\n    }\n    /**\n     * The reference sequence number of the most recent acked summary.\n     * Returns 0 if there is not yet an acked summary.\n     */\n    get referenceSequenceNumber() {\n        var _a, _b;\n        return (_b = (_a = this._latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber) !== null && _b !== void 0 ? _b : 0;\n    }\n    startSummary(referenceSequenceNumber, summaryLogger) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger === undefined, 0x19f /* \"wipSummaryLogger should not be set yet in startSummary\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipReferenceSequenceNumber === undefined, 0x1a0 /* \"Already tracking a summary\" */);\n        this.wipSummaryLogger = summaryLogger;\n        for (const child of this.children.values()) {\n            child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);\n        }\n        this.wipReferenceSequenceNumber = referenceSequenceNumber;\n    }\n    async summarize(fullTree, trackState = true, telemetryContext) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isTrackingInProgress(), 0x1a1 /* \"summarize should not be called when not tracking the summary\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger !== undefined, 0x1a2 /* \"wipSummaryLogger should have been set in startSummary or ctor\" */);\n        // Try to reuse the tree if unchanged\n        if (this.canReuseHandle && !fullTree && !this.hasChanged()) {\n            const latestSummary = this._latestSummary;\n            if (latestSummary !== undefined) {\n                this.wipLocalPaths = {\n                    localPath: latestSummary.localPath,\n                    additionalPath: latestSummary.additionalPath,\n                };\n                this.wipSkipRecursion = true;\n                const stats = (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.mergeStats)();\n                stats.handleNodeCount++;\n                return {\n                    summary: {\n                        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Handle,\n                        handle: latestSummary.fullPath.path,\n                        handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree,\n                    },\n                    stats,\n                };\n            }\n        }\n        try {\n            const result = await this.summarizeInternalFn(fullTree, true, telemetryContext);\n            this.wipLocalPaths = { localPath: _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(result.id) };\n            if (result.pathPartsForChildren !== undefined) {\n                this.wipLocalPaths.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.createAndConcat(result.pathPartsForChildren);\n            }\n            return { summary: result.summary, stats: result.stats };\n        }\n        catch (error) {\n            if (this.throwOnError || this.trackingSequenceNumber < this._changeSequenceNumber) {\n                throw error;\n            }\n            const latestSummary = this._latestSummary;\n            const initialSummary = this.initialSummary;\n            let encodeParam;\n            let localPath;\n            if (latestSummary !== undefined) {\n                // Create using handle of latest acked summary\n                encodeParam = {\n                    fromSummary: true,\n                    summaryNode: latestSummary,\n                };\n                localPath = latestSummary.localPath;\n            }\n            else if ((initialSummary === null || initialSummary === void 0 ? void 0 : initialSummary.summary) !== undefined) {\n                // Create using initial summary from attach op\n                encodeParam = {\n                    fromSummary: false,\n                    initialSummary: initialSummary.summary,\n                };\n                localPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(initialSummary.id);\n            }\n            else {\n                // No base summary to reference\n                throw error;\n            }\n            this.wipSummaryLogger.sendErrorEvent({\n                eventName: \"SummarizingWithBasePlusOps\",\n            }, error);\n            const summary = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.encodeSummary)(encodeParam, this.outstandingOps);\n            this.wipLocalPaths = {\n                localPath,\n                additionalPath: summary.additionalPath,\n            };\n            this.wipSkipRecursion = true;\n            return { summary: summary.summary, stats: summary.stats };\n        }\n    }\n    /**\n     * Complete the WIP summary for the given proposalHandle\n     */\n    completeSummary(proposalHandle) {\n        this.completeSummaryCore(proposalHandle, undefined, false);\n    }\n    /**\n     * Recursive implementation for completeSummary, with additional internal-only parameters\n     */\n    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger !== undefined, 0x1a3 /* \"wipSummaryLogger should have been set in startSummary or ctor\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipReferenceSequenceNumber !== undefined, 0x1a4 /* \"Not tracking a summary\" */);\n        let localPathsToUse = this.wipLocalPaths;\n        if (parentSkipRecursion) {\n            const latestSummary = this._latestSummary;\n            if (latestSummary !== undefined) {\n                // This case the parent node created a failure summary or was reused.\n                // This node and all children should only try to reference their path\n                // by its last known good state in the actual summary tree.\n                // If parent fails or is reused, the child summarize is not called so\n                // it did not get a chance to change its paths.\n                // In this case, essentially only propagate the new summary ref seq num.\n                localPathsToUse = {\n                    localPath: latestSummary.localPath,\n                    additionalPath: latestSummary.additionalPath,\n                };\n            }\n            else {\n                // This case the child is added after the latest non-failure summary.\n                // This node and all children should consider themselves as still not\n                // having a successful summary yet.\n                // We cannot \"reuse\" this node if unchanged since that summary, because\n                // handles will be unable to point to that node. It never made it to the\n                // tree itself, and only exists as an attach op in the _outstandingOps.\n                this.clearSummary();\n                return;\n            }\n        }\n        // This should come from wipLocalPaths in normal cases, or from the latestSummary\n        // if parentIsFailure or parentIsReused is true.\n        // If there is no latestSummary, clearSummary and return before reaching this code.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!localPathsToUse, 0x1a5 /* \"Tracked summary local paths not set\" */);\n        const summary = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode(Object.assign(Object.assign({}, localPathsToUse), { referenceSequenceNumber: this.wipReferenceSequenceNumber, basePath: parentPath }));\n        const fullPathForChildren = summary.fullPathForChildren;\n        for (const child of this.children.values()) {\n            child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);\n        }\n        // Note that this overwrites existing pending summary with\n        // the same proposalHandle. If proposalHandle is something like\n        // a hash or unique identifier, this should be fine. If storage\n        // can return the same proposalHandle for a different summary,\n        // this should still be okay, because we should be proposing the\n        // newer one later which would have to overwrite the previous one.\n        this.pendingSummaries.set(proposalHandle, summary);\n        this.clearSummary();\n    }\n    clearSummary() {\n        this.wipReferenceSequenceNumber = undefined;\n        this.wipLocalPaths = undefined;\n        this.wipSkipRecursion = false;\n        this.wipSummaryLogger = undefined;\n        for (const child of this.children.values()) {\n            child.clearSummary();\n        }\n    }\n    /**\n     * Refreshes the latest summary tracked by this node. If we have a pending summary for the given proposal handle,\n     * it becomes the latest summary. If the current summary is already ahead (e.g., loaded from a service summary),\n     * we skip the update. Otherwise, we get the snapshot by calling `getSnapshot` and update latest\n     * summary based off of that.\n     * @returns A RefreshSummaryResult type which returns information based on the following three scenarios:\n     *          1. The latest summary was not udpated.\n     *          2. The latest summary was updated and the summary corresponding to the params was being tracked.\n     *          3. The latest summary was updated but the summary corresponding to the params was not tracked. In this\n     *             case, the latest summary is updated based on the downloaded snapshot which is also returned.\n     */\n    async refreshLatestSummary(proposalHandle, summaryRefSeq, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {\n        if (proposalHandle !== undefined) {\n            const maybeSummaryNode = this.pendingSummaries.get(proposalHandle);\n            if (maybeSummaryNode !== undefined) {\n                this.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);\n                return { latestSummaryUpdated: true, wasSummaryTracked: true };\n            }\n        }\n        // If we have seen a summary same or later as the current one, ignore it.\n        if (this.referenceSequenceNumber >= summaryRefSeq) {\n            return { latestSummaryUpdated: false };\n        }\n        const snapshotTree = await getSnapshot();\n        await this.refreshLatestSummaryFromSnapshot(summaryRefSeq, snapshotTree, undefined, _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(\"\"), correlatedSummaryLogger, readAndParseBlob);\n        return { latestSummaryUpdated: true, wasSummaryTracked: false, snapshot: snapshotTree };\n    }\n    /**\n     * Called when we get an ack from the server for a summary we've just sent. Updates the reference state of this node\n     * from the state in the pending summary queue.\n     * @param proposalHandle - Handle for the current proposal.\n     * @param referenceSequenceNumber -  reference sequence number of sent summary.\n     */\n    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n        const summaryNode = this.pendingSummaries.get(proposalHandle);\n        if (summaryNode === undefined) {\n            // This should only happen if parent skipped recursion AND no prior summary existed.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this._latestSummary === undefined, 0x1a6 /* \"Not found pending summary, but this node has previously completed a summary\" */);\n            return;\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(referenceSequenceNumber === summaryNode.referenceSequenceNumber, 0x1a7 /* Pending summary reference sequence number should be consistent */);\n            // Clear earlier pending summaries\n            this.pendingSummaries.delete(proposalHandle);\n        }\n        this.refreshLatestSummaryCore(referenceSequenceNumber);\n        this._latestSummary = summaryNode;\n        // Propagate update to all child nodes\n        for (const child of this.children.values()) {\n            child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n        }\n    }\n    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n        // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n        if (this.referenceSequenceNumber >= referenceSequenceNumber) {\n            return;\n        }\n        this.refreshLatestSummaryCore(referenceSequenceNumber);\n        const { baseSummary, pathParts } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.decodeSummary)(snapshotTree, correlatedSummaryLogger);\n        this._latestSummary = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode({\n            referenceSequenceNumber,\n            basePath,\n            localPath,\n        });\n        const { childrenTree, childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryForSubtrees)(baseSummary);\n        if (childrenPathPart !== undefined) {\n            pathParts.push(childrenPathPart);\n        }\n        if (pathParts.length > 0) {\n            this._latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.createAndConcat(pathParts);\n        }\n        // Propagate update to all child nodes\n        const pathForChildren = this._latestSummary.fullPathForChildren;\n        await Promise.all(Array.from(this.children)\n            .filter(([id]) => {\n            // Assuming subtrees missing from snapshot are newer than the snapshot,\n            // but might be nice to assert this using earliest seq for node.\n            return childrenTree.trees[id] !== undefined;\n        }).map(async ([id, child]) => {\n            return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);\n        }));\n    }\n    refreshLatestSummaryCore(referenceSequenceNumber) {\n        for (const [key, value] of this.pendingSummaries) {\n            if (value.referenceSequenceNumber < referenceSequenceNumber) {\n                this.pendingSummaries.delete(key);\n            }\n        }\n        // Clear earlier outstanding ops\n        while (this.outstandingOps.length > 0\n            && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {\n            this.outstandingOps.shift();\n        }\n    }\n    loadBaseSummaryWithoutDifferential(snapshot) {\n        // Check base summary to see if it has any additional path parts\n        // separating child SummarizerNodes. Checks for .channels subtrees.\n        const { childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryForSubtrees)(snapshot);\n        if (childrenPathPart !== undefined && this._latestSummary !== undefined) {\n            this._latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(childrenPathPart);\n        }\n    }\n    async loadBaseSummary(snapshot, readAndParseBlob) {\n        const decodedSummary = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.decodeSummary)(snapshot, this.defaultLogger);\n        const outstandingOps = await decodedSummary.getOutstandingOps(readAndParseBlob);\n        const { childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryForSubtrees)(decodedSummary.baseSummary);\n        if (childrenPathPart !== undefined) {\n            decodedSummary.pathParts.push(childrenPathPart);\n        }\n        if (decodedSummary.pathParts.length > 0 && this._latestSummary !== undefined) {\n            this._latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.createAndConcat(decodedSummary.pathParts);\n        }\n        // Defensive assertion: tracking number should already exceed this number.\n        // This is probably a little excessive; can remove when stable.\n        if (outstandingOps.length > 0) {\n            const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(newOpsLatestSeq <= this.trackingSequenceNumber, 0x1a9 /* \"When loading base summary, expected outstanding ops <= tracking sequence number\" */);\n        }\n        return {\n            baseSummary: decodedSummary.baseSummary,\n            outstandingOps,\n        };\n    }\n    recordChange(op) {\n        const lastOp = this.outstandingOps[this.outstandingOps.length - 1];\n        if (lastOp !== undefined) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(lastOp.sequenceNumber < op.sequenceNumber, 0x1aa /* Out of order change recorded */);\n        }\n        this.invalidate(op.sequenceNumber);\n        this.trackingSequenceNumber = op.sequenceNumber;\n        this.outstandingOps.push(op);\n    }\n    invalidate(sequenceNumber) {\n        if (sequenceNumber > this._changeSequenceNumber) {\n            this._changeSequenceNumber = sequenceNumber;\n        }\n    }\n    /**\n     * True if a change has been recorded with sequence number exceeding\n     * the latest successfully acked summary reference sequence number.\n     * False implies that the previous summary can be reused.\n     */\n    hasChanged() {\n        return this._changeSequenceNumber > this.referenceSequenceNumber;\n    }\n    get latestSummary() {\n        return this._latestSummary;\n    }\n    createChild(\n    /** Summarize function */\n    summarizeInternalFn, \n    /** Initial id or path part of this node */\n    id, \n    /**\n     * Information needed to create the node.\n     * If it is from a base summary, it will assert that a summary has been seen.\n     * Attach information if it is created from an attach op.\n     */\n    createParam, config = {}) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.children.has(id), 0x1ab /* \"Create SummarizerNode child already exists\" */);\n        const createDetails = this.getCreateDetailsForChild(id, createParam);\n        const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger);\n        // There may be additional state that has to be updated in this child. For example, if a summary is being\n        // tracked, the child's summary tracking state needs to be updated too. Same goes for pendingSummaries we might\n        // have outstanding on the parent in case we realize nodes in between Summary Op and Summary Ack.\n        this.maybeUpdateChildState(child);\n        this.children.set(id, child);\n        return child;\n    }\n    getChild(id) {\n        return this.children.get(id);\n    }\n    /**\n     * Returns the details needed to create a child node.\n     * @param id - Initial id or path part of the child node.\n     * @param createParam - Information needed to create the node.\n     * @returns the details needed to create the child node.\n     */\n    getCreateDetailsForChild(id, createParam) {\n        var _a;\n        let initialSummary;\n        let latestSummary;\n        let changeSequenceNumber;\n        const parentLatestSummary = this._latestSummary;\n        switch (createParam.type) {\n            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.FromAttach: {\n                if (parentLatestSummary !== undefined\n                    && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {\n                    // Prioritize latest summary if it was after this node was attached.\n                    latestSummary = parentLatestSummary.createForChild(id);\n                }\n                else {\n                    const summary = (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.convertToSummaryTree)(createParam.snapshot);\n                    initialSummary = {\n                        sequenceNumber: createParam.sequenceNumber,\n                        id,\n                        summary,\n                    };\n                }\n                changeSequenceNumber = createParam.sequenceNumber;\n                break;\n            }\n            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.FromSummary: {\n                if (this.initialSummary === undefined) {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!parentLatestSummary, 0x1ac /* \"Cannot create child from summary if parent does not have latest summary\" */);\n                }\n                // fallthrough to local\n            }\n            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.Local: {\n                const parentInitialSummary = this.initialSummary;\n                if (parentInitialSummary !== undefined) {\n                    let childSummary;\n                    if (parentInitialSummary.summary !== undefined) {\n                        const { childrenTree } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryTreeForSubtrees)(parentInitialSummary.summary.summary);\n                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childrenTree.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree, 0x1d6 /* \"Parent summary object is not a tree\" */);\n                        childSummary = childrenTree.tree[id];\n                    }\n                    if (createParam.type === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.FromSummary) {\n                        // Locally created would not have differential subtree.\n                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!childSummary, 0x1ad /* \"Missing child summary tree\" */);\n                    }\n                    let childSummaryWithStats;\n                    if (childSummary !== undefined) {\n                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childSummary.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree, 0x1ae /* \"Child summary object is not a tree\" */);\n                        childSummaryWithStats = {\n                            summary: childSummary,\n                            stats: (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.calculateStats)(childSummary),\n                        };\n                    }\n                    initialSummary = {\n                        sequenceNumber: parentInitialSummary.sequenceNumber,\n                        id,\n                        summary: childSummaryWithStats,\n                    };\n                }\n                latestSummary = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.createForChild(id);\n                changeSequenceNumber = (_a = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.referenceSequenceNumber) !== null && _a !== void 0 ? _a : -1;\n                break;\n            }\n            default: {\n                const type = createParam.type;\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.unreachableCase)(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);\n            }\n        }\n        return {\n            initialSummary,\n            latestSummary,\n            changeSequenceNumber,\n        };\n    }\n    /**\n     * Updates the state of the child if required. For example, if a summary is currently being  tracked, the child's\n     * summary tracking state needs to be updated too.\n     * Also, in case a child node gets realized in between Summary Op and Summary Ack, let's initialize the child's\n     * pending summary as well.\n     * @param child - The child node whose state is to be updated.\n     */\n    maybeUpdateChildState(child) {\n        // If we are tracking a summary, this child was created after the tracking started. So, we need to update the\n        // child's tracking state as well.\n        if (this.isTrackingInProgress()) {\n            child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;\n        }\n        // In case we have pending summaries on the parent, let's initialize it on the child.\n        if (child._latestSummary !== undefined) {\n            for (const [key, value] of this.pendingSummaries.entries()) {\n                const newLatestSummaryNode = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode({\n                    referenceSequenceNumber: value.referenceSequenceNumber,\n                    basePath: child._latestSummary.basePath,\n                    localPath: child._latestSummary.localPath,\n                });\n                child.addPendingSummary(key, newLatestSummaryNode);\n            }\n        }\n    }\n    addPendingSummary(key, summary) {\n        this.pendingSummaries.set(key, summary);\n    }\n    /**\n     * Tells whether summary tracking is in progress. True if \"startSummary\" API is called before summarize.\n     */\n    isTrackingInProgress() {\n        return this.wipReferenceSequenceNumber !== undefined;\n    }\n}\n/**\n * Creates a root summarizer node.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n */\nconst createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode.createForRoot(referenceSequenceNumber));\n//# sourceMappingURL=summarizerNode.js.map\n\n/***/ }),\n/* 109 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"LazyPromise\": () => (/* binding */ LazyPromise)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nclass Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nclass LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map\n\n/***/ }),\n/* 110 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlobHandle\": () => (/* binding */ BlobHandle),\n/* harmony export */   \"BlobManager\": () => (/* binding */ BlobManager)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n/**\n * This class represents blob (long string)\n * This object is used only when creating (writing) new blob and serialization purposes.\n * De-serialization process goes through FluidObjectHandle and request flow:\n * DataObject.request() recognizes requests in the form of `/blobs/<id>`\n * and loads blob.\n */\nclass BlobHandle {\n    constructor(path, routeContext, get) {\n        this.path = path;\n        this.routeContext = routeContext;\n        this.get = get;\n        this.attached = false;\n        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);\n    }\n    get IFluidHandle() { return this; }\n    get isAttached() {\n        return this.attached;\n    }\n    attachGraph() {\n        this.attached = true;\n    }\n    bind(handle) {\n        throw new Error(\"Cannot bind to blob handle\");\n    }\n}\nclass BlobManager {\n    constructor(routeContext, snapshot, getStorage, attachBlobCallback, \n    // To be called when a blob node is requested. blobPath is the path of the blob's node in GC's graph. It's\n    // of the format `/<BlobManager.basePath>/<blobId>`.\n    gcNodeUpdated, runtime, logger) {\n        this.routeContext = routeContext;\n        this.getStorage = getStorage;\n        this.attachBlobCallback = attachBlobCallback;\n        this.gcNodeUpdated = gcNodeUpdated;\n        this.runtime = runtime;\n        this.logger = logger;\n        // uploaded blob IDs\n        this.blobIds = new Set();\n        // blobs for which upload is pending. maps to a promise that will resolve once the blob has been uploaded and a\n        // BlobAttach op has round-tripped.\n        this.pendingBlobIds = new Map();\n        // blobs uploaded while detached; cleared upon attach\n        this.detachedBlobIds = new Set();\n        this.runtime.once(\"dispose\", () => {\n            for (const promise of this.pendingBlobIds.values()) {\n                promise.reject(new Error(\"runtime disposed while blobAttach op in flight\"));\n            }\n        });\n        this.load(snapshot);\n    }\n    hasBlob(id) {\n        return this.blobIds.has(id) || this.detachedBlobIds.has(id);\n    }\n    /**\n     * For a blobId, returns its path in GC's graph. The node path is of the format `/<BlobManager.basePath>/<blobId>`\n     * This path must match the path of the blob handle returned by the createBlob API because blobs are marked\n     * referenced by storing these handles in a referenced DDS.\n     */\n    getBlobGCNodePath(blobId) {\n        return `/${BlobManager.basePath}/${blobId}`;\n    }\n    async getBlob(blobId) {\n        var _a, _b;\n        const storageId = (_b = (_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.get(blobId)) !== null && _b !== void 0 ? _b : blobId;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.hasBlob(storageId), 0x11f /* \"requesting unknown blobs\" */);\n        // When this blob is retrieved, let the container runtime know that the corresponding GC node got updated.\n        this.gcNodeUpdated(this.getBlobGCNodePath(blobId));\n        return new BlobHandle(`${BlobManager.basePath}/${storageId}`, this.routeContext, async () => _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, { eventName: \"AttachmentReadBlob\", id: storageId }, async () => {\n            return this.getStorage().readBlob(storageId);\n        }, { end: true, cancel: \"error\" }));\n    }\n    async createBlob(blob) {\n        var _a, _b;\n        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching) {\n            // blob upload is not supported in \"Attaching\" state\n            this.logger.sendTelemetryEvent({ eventName: \"CreateBlobWhileAttaching\" });\n            await new Promise((resolve) => this.runtime.once(\"attached\", resolve));\n        }\n        if (!this.runtime.connected && this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached) {\n            // see https://github.com/microsoft/FluidFramework/issues/8246\n            // Avoid getting storage if we are offline since it might be undefined. In the future we will return\n            // handles immediately while offline\n            await new Promise((resolve) => this.runtime.once(\"connected\", resolve));\n        }\n        const response = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, { eventName: \"createBlob\" }, async () => this.getStorage().createBlob(blob), { end: true, cancel: \"error\" });\n        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, this.routeContext, \n        // get() should go through BlobManager.getBlob() so handles created while detached can be redirected\n        // to the correct storage id after they are uploaded\n        async () => this.getBlob(response.id).then(async (h) => h.get()));\n        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached) {\n            this.detachedBlobIds.add(response.id);\n            return handle;\n        }\n        // Note - server will de-dup blobs, so we might get existing blobId!\n        if (this.pendingBlobIds.has(response.id)) {\n            await ((_a = this.pendingBlobIds.get(response.id)) === null || _a === void 0 ? void 0 : _a.promise);\n        }\n        else if (!this.blobIds.has(response.id)) {\n            this.pendingBlobIds.set(response.id, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Deferred());\n            // send blob attach op and wait until we see it to return the handle\n            this.attachBlobCallback(response.id);\n            await ((_b = this.pendingBlobIds.get(response.id)) === null || _b === void 0 ? void 0 : _b.promise);\n        }\n        return handle;\n    }\n    processBlobAttachOp(blobId, local) {\n        if (local) {\n            const pendingBlobP = this.pendingBlobIds.get(blobId);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(pendingBlobP !== undefined, 0x1f8 /* \"local BlobAttach op with no pending blob\" */);\n            pendingBlobP.resolve();\n            this.pendingBlobIds.delete(blobId);\n        }\n        this.blobIds.add(blobId);\n    }\n    /**\n     * Reads blobs needed to load BlobManager from storage.\n     */\n    static async load(blobsTree, tryFetchBlob) {\n        if (!blobsTree) {\n            return {};\n        }\n        let redirectTable;\n        const tableId = blobsTree.blobs[this.redirectTableBlobName];\n        if (tableId) {\n            redirectTable = await tryFetchBlob(tableId);\n        }\n        const ids = Object.entries(blobsTree.blobs)\n            .filter(([k, _]) => k !== this.redirectTableBlobName).map(([_, v]) => v);\n        return { ids, redirectTable };\n    }\n    /**\n     * Load a set of previously attached blob IDs from a previous snapshot. Note\n     * that BlobManager tracking and reporting attached blobs is a temporary\n     * solution since storage expects attached blobs to be reported and any that\n     * are not reported as attached may be GCed. In the future attached blob\n     * IDs will be collected at summarization time, and runtime will not care\n     * about the existence or specific formatting of this tree in returned\n     * snapshots.\n     *\n     * @param blobsTree - Tree containing IDs of previously attached blobs. This\n     * corresponds to snapshot() below. We look for the IDs in the blob entries\n     * of the tree since the both the r11s and SPO drivers replace the\n     * attachment types returned in snapshot() with blobs.\n     */\n    load(snapshot) {\n        var _a, _b, _c;\n        if (snapshot.ids) {\n            const detached = this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached;\n            snapshot.ids.map((entry) => detached ? this.detachedBlobIds.add(entry) : this.blobIds.add(entry));\n        }\n        if (snapshot.redirectTable) {\n            this.redirectTable = new Map(snapshot.redirectTable);\n        }\n        this.logger.sendTelemetryEvent({\n            eventName: \"AttachmentBlobsLoaded\",\n            count: (_b = (_a = snapshot.ids) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,\n            redirectTable: (_c = snapshot.redirectTable) === null || _c === void 0 ? void 0 : _c.length,\n        });\n    }\n    /**\n     * Generates data used for garbage collection. Each blob uploaded represents a node in the GC graph as it can be\n     * individually referenced by storing its handle in a referenced DDS. Returns the list of blob ids as GC nodes.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data. BlobManager doesn't care\n     * about this for now because the data is a simple list of blob ids.\n     */\n    getGCData(fullGC = false) {\n        const gcData = { gcNodes: {} };\n        this.blobIds.forEach((blobId) => {\n            gcData.gcNodes[this.getBlobGCNodePath(blobId)] = [];\n        });\n        /**\n         * For all blobs in the redirect table, the handle returned on creation is based off of the localId. So, these\n         * nodes can be referenced by storing the localId handle. When that happens, the corresponding storageId node\n         * must also be marked referenced. So, we add a route from the localId node to the storageId node.\n         * Note that because of de-duping, there can be multiple localIds that all redirect to the same storageId or\n         * a blob may be referenced via its storageId handle.\n         */\n        if (this.redirectTable !== undefined) {\n            for (const [localId, storageId] of this.redirectTable) {\n                // Add node for the localId and add a route to the storageId node. The storageId node will have been\n                // added above when adding nodes for this.blobIds.\n                gcData.gcNodes[this.getBlobGCNodePath(localId)] = [this.getBlobGCNodePath(storageId)];\n            }\n        }\n        return gcData;\n    }\n    /**\n     * When running GC in test mode, this is called to delete blobs that are unused.\n     * @param unusedRoutes - These are the blob node ids that are unused and should be deleted.\n     */\n    deleteUnusedRoutes(unusedRoutes) {\n        var _a;\n        // The routes or blob node paths are in the same format as returned in getGCData -\n        // `/<BlobManager.basePath>/<blobId>`.\n        for (const route of unusedRoutes) {\n            const pathParts = route.split(\"/\");\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(pathParts.length === 3 && pathParts[1] === BlobManager.basePath, 0x2d5 /* \"Invalid blob node id in unused routes.\" */);\n            const blobId = pathParts[2];\n            // The unused blobId could be a localId. If so, remove it from the redirect table and continue. The\n            // corresponding storageId may still be used either directly or via other localIds.\n            if ((_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.has(blobId)) {\n                this.redirectTable.delete(blobId);\n                continue;\n            }\n            this.blobIds.delete(blobId);\n        }\n    }\n    summarize(telemetryContext) {\n        // If we have a redirect table it means the container is about to transition to \"Attaching\" state, so we need\n        // to return an actual snapshot containing all the real storage IDs we know about.\n        const attachingOrAttached = !!this.redirectTable || this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached;\n        const blobIds = attachingOrAttached ? this.blobIds : this.detachedBlobIds;\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_5__.SummaryTreeBuilder();\n        blobIds.forEach((blobId) => {\n            builder.addAttachment(blobId);\n        });\n        if (this.redirectTable && this.redirectTable.size > 0) {\n            builder.addBlob(BlobManager.redirectTableBlobName, JSON.stringify(Array.from(this.redirectTable.entries())));\n        }\n        return builder.getSummaryTree();\n    }\n    setRedirectTable(table) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached, 0x252 /* \"redirect table can only be set in detached container\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.redirectTable, 0x253 /* \"redirect table already exists\" */);\n        for (const [localId, storageId] of table) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.detachedBlobIds.delete(localId), 0x254 /* \"unrecognized id in redirect table\" */);\n            this.blobIds.add(storageId);\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.detachedBlobIds.size === 0, 0x255 /* \"detached blob id absent in redirect table\" */);\n        this.redirectTable = table;\n    }\n}\nBlobManager.basePath = \"_blobs\";\nBlobManager.redirectTableBlobName = \".redirectTable\";\n//# sourceMappingURL=blobManager.js.map\n\n/***/ }),\n/* 111 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PendingStateManager\": () => (/* binding */ PendingStateManager)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);\n/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);\n/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(double_ended_queue__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n/**\n * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been\n * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed\n * batches along with the messages.\n * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing\n * of messages and triggering resubmission of unacked ops.\n *\n * It verifies that all the ops are acked, are received in the right order and batch information is correct.\n */\nclass PendingStateManager {\n    constructor(stateHandler, initialFlushMode, initialLocalState) {\n        var _a;\n        this.stateHandler = stateHandler;\n        this.pendingStates = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())();\n        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => {\n            this.initialStates.clear();\n            this.pendingStates.clear();\n        });\n        // Maintains the count of messages that are currently unacked.\n        this._pendingMessagesCount = 0;\n        // Indicates whether we are processing a batch.\n        this.isProcessingBatch = false;\n        this.dispose = () => this.disposeOnce.value;\n        this.initialStates = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())((_a = initialLocalState === null || initialLocalState === void 0 ? void 0 : initialLocalState.pendingStates) !== null && _a !== void 0 ? _a : []);\n        this.flushModeForNextMessage = initialFlushMode;\n        this.onFlushModeUpdated(initialFlushMode);\n    }\n    get pendingMessagesCount() {\n        return this._pendingMessagesCount;\n    }\n    /**\n     * Called to check if there are any pending messages in the pending state queue.\n     * @returns A boolean indicating whether there are messages or not.\n     */\n    hasPendingMessages() {\n        return this._pendingMessagesCount !== 0 || !this.initialStates.isEmpty();\n    }\n    getLocalState() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.initialStates.isEmpty(), 0x2e9 /* \"Must call getLocalState() after applying initial states\" */);\n        if (this.hasPendingMessages()) {\n            return {\n                pendingStates: this.pendingStates.toArray().map(\n                // delete localOpMetadata since it may not be serializable\n                // and will be regenerated by applyStashedOp()\n                (state) => state.type === \"message\" ? Object.assign(Object.assign({}, state), { localOpMetadata: undefined }) : state),\n            };\n        }\n    }\n    get disposed() { return this.disposeOnce.evaluated; }\n    /**\n     * Called when a message is submitted locally. Adds the message and the associated details to the pending state\n     * queue.\n     * @param type - The container message type.\n     * @param clientSequenceNumber - The clientSequenceNumber associated with the message.\n     * @param content - The message content.\n     * @param localOpMetadata - The local metadata associated with the message.\n     */\n    onSubmitMessage(type, clientSequenceNumber, referenceSequenceNumber, content, localOpMetadata, opMetadata) {\n        const pendingMessage = {\n            type: \"message\",\n            messageType: type,\n            clientSequenceNumber,\n            referenceSequenceNumber,\n            content,\n            localOpMetadata,\n            opMetadata,\n        };\n        this.pendingStates.push(pendingMessage);\n        this._pendingMessagesCount++;\n    }\n    /**\n     * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.\n     * @param flushMode - The flushMode that was updated.\n     */\n    onFlushModeUpdated(flushMode) {\n        this.pendingStates.push({ type: \"flushMode\", flushMode });\n    }\n    /**\n     * Called when flush() is called on the ContainerRuntime to manually flush messages.\n     */\n    onFlush() {\n        // If the FlushMode is Immediate, we don't need to track an explicit flush call because every message is\n        // automatically flushed. So, flush is a no-op.\n        if (this.stateHandler.flushMode() === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.FlushMode.Immediate) {\n            return;\n        }\n        // If the previous state is not a message, flush is a no-op.\n        const previousState = this.pendingStates.peekBack();\n        if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) !== \"message\") {\n            return;\n        }\n        // An explicit flush is interesting and is tracked only if there are messages sent in TurnBased mode.\n        this.pendingStates.push({ type: \"flush\" });\n    }\n    /**\n     * Applies stashed ops at their reference sequence number so they are ready to be ACKed or resubmitted\n     * @param seqNum - Sequence number at which to apply ops. Will apply all ops if seqNum is undefined.\n     */\n    async applyStashedOpsAt(seqNum) {\n        // apply stashed ops at sequence number\n        while (!this.initialStates.isEmpty()) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const nextState = this.initialStates.peekFront();\n            if (nextState.type === \"message\") {\n                if (seqNum !== undefined) {\n                    if (nextState.referenceSequenceNumber > seqNum) {\n                        break; // nothing left to do at this sequence number\n                    }\n                    else if (nextState.referenceSequenceNumber < seqNum) {\n                        throw new Error(\"loaded from snapshot too recent to apply stashed ops\");\n                    }\n                }\n                // applyStashedOp will cause the DDS to behave as if it has sent the op but not actually send it\n                const localOpMetadata = await this.stateHandler.applyStashedOp(nextState.messageType, nextState.content);\n                nextState.localOpMetadata = localOpMetadata;\n            }\n            // then we push onto pendingStates which will cause PendingStateManager to resubmit when we connect\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.pendingStates.push(this.initialStates.shift());\n        }\n    }\n    /**\n     * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that\n     * the batch information was preserved for batch messages.\n     * @param message - The message that got ack'd and needs to be processed.\n     */\n    processPendingLocalMessage(message) {\n        // Pre-processing part - This may be the start of a batch.\n        this.maybeProcessBatchBegin(message);\n        // Get the next state from the pending queue and verify that it is of type \"message\".\n        const pendingState = this.peekNextPendingState();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingState.type === \"message\", 0x169 /* \"No pending message found for this remote message\" */);\n        this.pendingStates.shift();\n        // Processing part - Verify that there has been no data corruption.\n        // The clientSequenceNumber of the incoming message must match that of the pending message.\n        if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {\n            // Close the container because this could indicate data corruption.\n            const error = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.create(\"pending local message clientSequenceNumber mismatch\", \"unexpectedAckReceived\", message, { expectedClientSequenceNumber: pendingState.clientSequenceNumber });\n            this.stateHandler.close(error);\n            return;\n        }\n        this._pendingMessagesCount--;\n        // Post-processing part - If we are processing a batch then this could be the last message in the batch.\n        this.maybeProcessBatchEnd(message);\n        return pendingState.localOpMetadata;\n    }\n    /**\n     * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.\n     * @param message - The message that is being processed.\n     */\n    maybeProcessBatchBegin(message) {\n        // Tracks the last FlushMode that was set before this message was sent.\n        let pendingFlushMode;\n        // Tracks whether a flush was called before this message was sent.\n        let pendingFlush = false;\n        /**\n         * We are checking if the next message is the start of a batch. It can happen in the following scenarios:\n         * 1. The FlushMode was set to TurnBased before this message was sent.\n         * 2. The FlushMode was already TurnBased and a flush was called before this message was sent. This essentially\n         *    means that the flush marked the end of a previous batch and beginning of a new batch.\n         *\n         * Keep reading pending states from the queue until we encounter a message. It's possible that the FlushMode was\n         * updated a bunch of times without sending any messages.\n         */\n        let nextPendingState = this.peekNextPendingState();\n        while (nextPendingState.type !== \"message\") {\n            if (nextPendingState.type === \"flushMode\") {\n                pendingFlushMode = nextPendingState.flushMode;\n            }\n            if (nextPendingState.type === \"flush\") {\n                pendingFlush = true;\n            }\n            this.pendingStates.shift();\n            nextPendingState = this.peekNextPendingState();\n        }\n        if (pendingFlushMode !== undefined) {\n            this.flushModeForNextMessage = pendingFlushMode;\n        }\n        // If the FlushMode was set to Immediate before this message was sent, this message won't be a batch message\n        // because in Immediate mode, every message is flushed individually.\n        if (pendingFlushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.FlushMode.Immediate) {\n            return;\n        }\n        /**\n         * This message is the first in a batch if before it was sent either the FlushMode was set to TurnBased or there\n         * was an explicit flush call. Note that a flush call is tracked only in TurnBased mode and it indicates the end\n         * of one batch and beginning of another.\n         */\n        if (pendingFlushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.FlushMode.TurnBased || pendingFlush) {\n            // We should not already be processing a batch and there should be no pending batch begin message.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, 0x16b /* \"The pending batch state indicates we are already processing a batch\" */);\n            // Set the pending batch state indicating we have started processing a batch.\n            this.pendingBatchBeginMessage = message;\n            this.isProcessingBatch = true;\n        }\n    }\n    /**\n     * This message could be the last message in batch. If so, clear batch state since the batch is complete.\n     * @param message - The message that is being processed.\n     */\n    maybeProcessBatchEnd(message) {\n        var _a, _b;\n        if (!this.isProcessingBatch) {\n            return;\n        }\n        const nextPendingState = this.peekNextPendingState();\n        if (nextPendingState.type === \"message\") {\n            return;\n        }\n        /**\n         * We are in the middle of processing a batch. The batch ends when we see an explicit flush. We should never see\n         * a FlushMode before flush. This is true because we track batches only when FlushMode is TurnBased and in this\n         * mode, a batch ends either by calling flush or by changing the mode to Immediate which also triggers a flush.\n         */\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(nextPendingState.type !== \"flushMode\", 0x2bd /* \"We should not see a pending FlushMode until we see a flush when processing a batch\" */);\n        // There should be a pending batch begin message.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pendingBatchBeginMessage !== undefined, 0x16d /* \"There is no pending batch begin message\" */);\n        // Get the batch begin metadata from the first message in the batch.\n        const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch;\n        // There could be just a single message in the batch. If so, it should not have any batch metadata. If there\n        // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.\n        if (this.pendingBatchBeginMessage === message) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchBeginMetadata === undefined, 0x16e /* \"Batch with single message should not have batch metadata\" */);\n        }\n        else {\n            // Get the batch metadata from the last message in the batch.\n            const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchBeginMetadata === true, 0x16f /* \"Did not receive batch begin metadata\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchEndMetadata === false, 0x170 /* \"Did not receive batch end metadata\" */);\n        }\n        // Clear the pending batch state now that we have processed the entire batch.\n        this.pendingBatchBeginMessage = undefined;\n        this.isProcessingBatch = false;\n    }\n    /**\n     * Capture the pending state at this point\n     */\n    checkpoint() {\n        const checkpointHead = this.pendingStates.peekBack();\n        return {\n            rollback: () => {\n                try {\n                    while (this.pendingStates.peekBack() !== checkpointHead) {\n                        this.rollbackNextPendingState();\n                    }\n                }\n                catch (err) {\n                    const error = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.wrapError)(err, (message) => {\n                        return _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.create(`RollbackError: ${message}`, \"checkpointRollback\", undefined);\n                    });\n                    this.stateHandler.close(error);\n                    throw error;\n                }\n            },\n        };\n    }\n    /**\n     * Returns the next pending state from the pending state queue.\n     */\n    peekNextPendingState() {\n        const nextPendingState = this.pendingStates.peekFront();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!nextPendingState, 0x171 /* \"No pending state found for the remote message\" */);\n        return nextPendingState;\n    }\n    /**\n     * Undo the last pending state\n     */\n    rollbackNextPendingState() {\n        const pendingStatesCount = this.pendingStates.length;\n        if (pendingStatesCount === 0) {\n            return;\n        }\n        this._pendingMessagesCount--;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const pendingState = this.pendingStates.pop();\n        switch (pendingState.type) {\n            case \"message\":\n                this.stateHandler.rollback(pendingState.messageType, pendingState.content, pendingState.localOpMetadata);\n                break;\n            default:\n                throw new Error(`Can't rollback state ${pendingState.type}`);\n        }\n    }\n    /**\n     * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending\n     * states in its queue. This includes setting the FlushMode and triggering resubmission of unacked ops.\n     */\n    replayPendingStates() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.stateHandler.connected(), 0x172 /* \"The connection state is not consistent with the runtime\" */);\n        // This assert suggests we are about to send same ops twice, which will result in data loss.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.clientId !== this.stateHandler.clientId(), 0x173 /* \"replayPendingStates called twice for same clientId!\" */);\n        this.clientId = this.stateHandler.clientId();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.initialStates.isEmpty(), 0x174 /* \"initial states should be empty before replaying pending\" */);\n        let pendingStatesCount = this.pendingStates.length;\n        if (pendingStatesCount === 0) {\n            return;\n        }\n        // Reset the pending message count because all these messages will be removed from the queue.\n        this._pendingMessagesCount = 0;\n        // Save the current FlushMode so that we can revert it back after replaying the states.\n        const savedFlushMode = this.stateHandler.flushMode();\n        // Set the flush mode for the next message. This step is important because the flush mode may have been changed\n        // after the next pending message was sent.\n        this.stateHandler.setFlushMode(this.flushModeForNextMessage);\n        // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were\n        // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue\n        // which must not be replayed.\n        while (pendingStatesCount > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const pendingState = this.pendingStates.shift();\n            switch (pendingState.type) {\n                case \"message\":\n                    this.stateHandler.reSubmit(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);\n                    break;\n                case \"flushMode\":\n                    this.stateHandler.setFlushMode(pendingState.flushMode);\n                    break;\n                case \"flush\":\n                    this.stateHandler.flush();\n                    break;\n                default:\n                    break;\n            }\n            pendingStatesCount--;\n        }\n        // Revert the FlushMode.\n        this.stateHandler.setFlushMode(savedFlushMode);\n    }\n}\n//# sourceMappingURL=pendingStateManager.js.map\n\n/***/ }),\n/* 112 */\n/***/ ((module) => {\n\n\"use strict\";\n/**\n * Copyright (c) 2013 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nfunction Deque(capacity) {\n    this._capacity = getCapacity(capacity);\n    this._length = 0;\n    this._front = 0;\n    if (isArray(capacity)) {\n        var len = capacity.length;\n        for (var i = 0; i < len; ++i) {\n            this[i] = capacity[i];\n        }\n        this._length = len;\n    }\n}\n\nDeque.prototype.toArray = function Deque$toArray() {\n    var len = this._length;\n    var ret = new Array(len);\n    var front = this._front;\n    var capacity = this._capacity;\n    for (var j = 0; j < len; ++j) {\n        ret[j] = this[(front + j) & (capacity - 1)];\n    }\n    return ret;\n};\n\nDeque.prototype.push = function Deque$push(item) {\n    var argsLength = arguments.length;\n    var length = this._length;\n    if (argsLength > 1) {\n        var capacity = this._capacity;\n        if (length + argsLength > capacity) {\n            for (var i = 0; i < argsLength; ++i) {\n                this._checkCapacity(length + 1);\n                var j = (this._front + length) & (this._capacity - 1);\n                this[j] = arguments[i];\n                length++;\n                this._length = length;\n            }\n            return length;\n        }\n        else {\n            var j = this._front;\n            for (var i = 0; i < argsLength; ++i) {\n                this[(j + length) & (capacity - 1)] = arguments[i];\n                j++;\n            }\n            this._length = length + argsLength;\n            return length + argsLength;\n        }\n\n    }\n\n    if (argsLength === 0) return length;\n\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = item;\n    this._length = length + 1;\n    return length + 1;\n};\n\nDeque.prototype.pop = function Deque$pop() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var i = (this._front + length - 1) & (this._capacity - 1);\n    var ret = this[i];\n    this[i] = void 0;\n    this._length = length - 1;\n    return ret;\n};\n\nDeque.prototype.shift = function Deque$shift() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var front = this._front;\n    var ret = this[front];\n    this[front] = void 0;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length = length - 1;\n    return ret;\n};\n\nDeque.prototype.unshift = function Deque$unshift(item) {\n    var length = this._length;\n    var argsLength = arguments.length;\n\n\n    if (argsLength > 1) {\n        var capacity = this._capacity;\n        if (length + argsLength > capacity) {\n            for (var i = argsLength - 1; i >= 0; i--) {\n                this._checkCapacity(length + 1);\n                var capacity = this._capacity;\n                var j = (((( this._front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n                this[j] = arguments[i];\n                length++;\n                this._length = length;\n                this._front = j;\n            }\n            return length;\n        }\n        else {\n            var front = this._front;\n            for (var i = argsLength - 1; i >= 0; i--) {\n                var j = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n                this[j] = arguments[i];\n                front = j;\n            }\n            this._front = front;\n            this._length = length + argsLength;\n            return length + argsLength;\n        }\n    }\n\n    if (argsLength === 0) return length;\n\n    this._checkCapacity(length + 1);\n    var capacity = this._capacity;\n    var i = (((( this._front - 1 ) &\n        ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = item;\n    this._length = length + 1;\n    this._front = i;\n    return length + 1;\n};\n\nDeque.prototype.peekBack = function Deque$peekBack() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var index = (this._front + length - 1) & (this._capacity - 1);\n    return this[index];\n};\n\nDeque.prototype.peekFront = function Deque$peekFront() {\n    if (this._length === 0) {\n        return void 0;\n    }\n    return this[this._front];\n};\n\nDeque.prototype.get = function Deque$get(index) {\n    var i = index;\n    if ((i !== (i | 0))) {\n        return void 0;\n    }\n    var len = this._length;\n    if (i < 0) {\n        i = i + len;\n    }\n    if (i < 0 || i >= len) {\n        return void 0;\n    }\n    return this[(this._front + i) & (this._capacity - 1)];\n};\n\nDeque.prototype.isEmpty = function Deque$isEmpty() {\n    return this._length === 0;\n};\n\nDeque.prototype.clear = function Deque$clear() {\n    var len = this._length;\n    var front = this._front;\n    var capacity = this._capacity;\n    for (var j = 0; j < len; ++j) {\n        this[(front + j) & (capacity - 1)] = void 0;\n    }\n    this._length = 0;\n    this._front = 0;\n};\n\nDeque.prototype.toString = function Deque$toString() {\n    return this.toArray().toString();\n};\n\nDeque.prototype.valueOf = Deque.prototype.toString;\nDeque.prototype.removeFront = Deque.prototype.shift;\nDeque.prototype.removeBack = Deque.prototype.pop;\nDeque.prototype.insertFront = Deque.prototype.unshift;\nDeque.prototype.insertBack = Deque.prototype.push;\nDeque.prototype.enqueue = Deque.prototype.push;\nDeque.prototype.dequeue = Deque.prototype.shift;\nDeque.prototype.toJSON = Deque.prototype.toArray;\n\nObject.defineProperty(Deque.prototype, \"length\", {\n    get: function() {\n        return this._length;\n    },\n    set: function() {\n        throw new RangeError(\"\");\n    }\n});\n\nDeque.prototype._checkCapacity = function Deque$_checkCapacity(size) {\n    if (this._capacity < size) {\n        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));\n    }\n};\n\nDeque.prototype._resizeTo = function Deque$_resizeTo(capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    if (front + length > oldCapacity) {\n        var moveItemsCount = (front + length) & (oldCapacity - 1);\n        arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n    }\n};\n\n\nvar isArray = Array.isArray;\n\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction pow2AtLeast(n) {\n    n = n >>> 0;\n    n = n - 1;\n    n = n | (n >> 1);\n    n = n | (n >> 2);\n    n = n | (n >> 4);\n    n = n | (n >> 8);\n    n = n | (n >> 16);\n    return n + 1;\n}\n\nfunction getCapacity(capacity) {\n    if (typeof capacity !== \"number\") {\n        if (isArray(capacity)) {\n            capacity = capacity.length;\n        }\n        else {\n            return 16;\n        }\n    }\n    return pow2AtLeast(\n        Math.min(\n            Math.max(16, capacity), 1073741824)\n    );\n}\n\nmodule.exports = Deque;\n\n\n/***/ }),\n/* 113 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryCollection\": () => (/* binding */ SummaryCollection)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar SummaryState;\n(function (SummaryState) {\n    SummaryState[SummaryState[\"Local\"] = 0] = \"Local\";\n    SummaryState[SummaryState[\"Broadcast\"] = 1] = \"Broadcast\";\n    SummaryState[SummaryState[\"Acked\"] = 2] = \"Acked\";\n    SummaryState[SummaryState[\"Nacked\"] = -1] = \"Nacked\";\n})(SummaryState || (SummaryState = {}));\nclass Summary {\n    constructor(clientId, clientSequenceNumber) {\n        this.clientId = clientId;\n        this.clientSequenceNumber = clientSequenceNumber;\n        this.state = SummaryState.Local;\n        this.defSummaryOp = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.defSummaryAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n    }\n    static createLocal(clientId, clientSequenceNumber) {\n        return new Summary(clientId, clientSequenceNumber);\n    }\n    static createFromOp(op) {\n        const summary = new Summary(op.clientId, op.clientSequenceNumber);\n        summary.broadcast(op);\n        return summary;\n    }\n    get summaryOp() { return this._summaryOp; }\n    get summaryAckNack() { return this._summaryAckNack; }\n    hasBeenAcked() {\n        return this.state === SummaryState.Acked;\n    }\n    broadcast(op) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryState.Local, 0x175 /* \"Can only broadcast if summarizer starts in local state\" */);\n        this._summaryOp = op;\n        this.defSummaryOp.resolve();\n        this.state = SummaryState.Broadcast;\n        return true;\n    }\n    ackNack(op) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryState.Broadcast, 0x176 /* \"Can only ack/nack if summarizer is in broadcasting state\" */);\n        this._summaryAckNack = op;\n        this.defSummaryAck.resolve();\n        this.state = op.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;\n        return true;\n    }\n    async waitBroadcast() {\n        await this.defSummaryOp.promise;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._summaryOp;\n    }\n    async waitAckNack() {\n        await this.defSummaryAck.promise;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._summaryAckNack;\n    }\n}\n/**\n * This class watches summaries created by a specific client.\n * It should be created and managed from a SummaryCollection.\n */\nclass ClientSummaryWatcher {\n    constructor(clientId, summaryCollection) {\n        this.clientId = clientId;\n        this.summaryCollection = summaryCollection;\n        // key: clientSeqNum\n        this.localSummaries = new Map();\n        this._disposed = false;\n    }\n    get disposed() { return this._disposed; }\n    /**\n     * Watches for a specific sent summary op.\n     * @param clientSequenceNumber - client sequence number of sent summary op\n     */\n    watchSummary(clientSequenceNumber) {\n        let summary = this.localSummaries.get(clientSequenceNumber);\n        if (!summary) {\n            summary = Summary.createLocal(this.clientId, clientSequenceNumber);\n            this.localSummaries.set(summary.clientSequenceNumber, summary);\n        }\n        return summary;\n    }\n    /**\n     * Waits until all of the pending summaries in the underlying SummaryCollection\n     * are acked/nacked.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    waitFlushed() {\n        return this.summaryCollection.waitFlushed();\n    }\n    /**\n     * Gets a watched summary or returns undefined if not watched.\n     * @param clientSequenceNumber - client sequence number of sent summary op\n     */\n    tryGetSummary(clientSequenceNumber) {\n        return this.localSummaries.get(clientSequenceNumber);\n    }\n    /**\n     * Starts watching a summary made by this client.\n     * @param summary - summary to start watching\n     */\n    setSummary(summary) {\n        this.localSummaries.set(summary.clientSequenceNumber, summary);\n    }\n    dispose() {\n        this.summaryCollection.removeWatcher(this.clientId);\n        this._disposed = true;\n    }\n}\n/**\n * Data structure that looks at the op stream to track summaries as they\n * are broadcast, acked and nacked.\n * It provides functionality for watching specific summaries.\n */\nclass SummaryCollection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.TypedEventEmitter {\n    constructor(deltaManager, logger) {\n        super();\n        this.deltaManager = deltaManager;\n        this.logger = logger;\n        // key: clientId\n        this.summaryWatchers = new Map();\n        // key: summarySeqNum\n        this.pendingSummaries = new Map();\n        this.refreshWaitNextAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.deltaManager.on(\"op\", (op) => this.handleOp(op));\n    }\n    get latestAck() { return this.lastAck; }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    get opsSinceLastAck() {\n        var _a, _b;\n        return this.deltaManager.lastSequenceNumber -\n            ((_b = (_a = this.lastAck) === null || _a === void 0 ? void 0 : _a.summaryAck.sequenceNumber) !== null && _b !== void 0 ? _b : this.deltaManager.initialSequenceNumber);\n    }\n    addOpListener(listener) {\n        this.deltaManager.on(\"op\", listener);\n    }\n    removeOpListener(listener) {\n        this.deltaManager.off(\"op\", listener);\n    }\n    /**\n     * Creates and returns a summary watcher for a specific client.\n     * This will allow for local sent summaries to be better tracked.\n     * @param clientId - client id for watcher\n     */\n    createWatcher(clientId) {\n        const watcher = new ClientSummaryWatcher(clientId, this);\n        this.summaryWatchers.set(clientId, watcher);\n        return watcher;\n    }\n    removeWatcher(clientId) {\n        this.summaryWatchers.delete(clientId);\n    }\n    setPendingAckTimerTimeoutCallback(maxAckWaitTime, timeoutCallback) {\n        this.maxAckWaitTime = maxAckWaitTime;\n        this.pendingAckTimerTimeoutCallback = timeoutCallback;\n    }\n    unsetPendingAckTimerTimeoutCallback() {\n        this.maxAckWaitTime = undefined;\n        this.pendingAckTimerTimeoutCallback = undefined;\n    }\n    /**\n     * Returns a promise that resolves once all pending summary ops\n     * have been acked or nacked.\n     */\n    async waitFlushed() {\n        while (this.pendingSummaries.size > 0) {\n            // eslint-disable-next-line @typescript-eslint/promise-function-async\n            const promises = Array.from(this.pendingSummaries, ([, summary]) => summary.waitAckNack());\n            await Promise.all(promises);\n        }\n        return this.lastAck;\n    }\n    /**\n     * Returns a promise that resolves once a summary is acked that has a reference\n     * sequence number greater than or equal to the passed in sequence number.\n     * @param referenceSequenceNumber - reference sequence number to wait for\n     * @returns The latest acked summary\n     */\n    async waitSummaryAck(referenceSequenceNumber) {\n        while (!this.lastAck || this.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {\n            await this.refreshWaitNextAck.promise;\n        }\n        return this.lastAck;\n    }\n    /**\n     * Handler for ops; only handles ops relating to summaries.\n     * @param op - op message to handle\n     */\n    handleOp(op) {\n        var _a;\n        switch (op.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Summarize: {\n                this.handleSummaryOp(op);\n                return;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck: {\n                this.handleSummaryAck(op);\n                return;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryNack: {\n                this.handleSummaryNack(op);\n                return;\n            }\n            default: {\n                // If the difference between timestamp of current op and last summary op is greater than\n                // the maxAckWaitTime, then we need to inform summarizer to not wait and summarize\n                // immediately as we have already waited for maxAckWaitTime.\n                const lastOpTimestamp = op.timestamp;\n                if (this.lastSummaryTimestamp !== undefined &&\n                    this.maxAckWaitTime !== undefined &&\n                    lastOpTimestamp - this.lastSummaryTimestamp >= this.maxAckWaitTime) {\n                    (_a = this.pendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n                }\n                this.emit(\"default\", op);\n                return;\n            }\n        }\n    }\n    handleSummaryOp(op) {\n        let summary;\n        // Check if summary already being watched, broadcast if so\n        const watcher = this.summaryWatchers.get(op.clientId);\n        if (watcher) {\n            summary = watcher.tryGetSummary(op.clientSequenceNumber);\n            if (summary) {\n                summary.broadcast(op);\n            }\n        }\n        // If not watched, create from op\n        if (!summary) {\n            summary = Summary.createFromOp(op);\n            if (watcher) {\n                watcher.setSummary(summary);\n            }\n        }\n        this.pendingSummaries.set(op.sequenceNumber, summary);\n        this.lastSummaryTimestamp = op.timestamp;\n        this.emit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Summarize, op);\n    }\n    handleSummaryAck(op) {\n        const seq = op.contents.summaryProposal.summarySequenceNumber;\n        const summary = this.pendingSummaries.get(seq);\n        if (!summary || summary.summaryOp === undefined) {\n            // Summary ack without an op should be rare. We could fetch the\n            // reference sequence number from the snapshot, but instead we\n            // will not emit this ack. It should be the case that the summary\n            // op that this ack is for is earlier than this file was loaded\n            // from. i.e. initialSequenceNumber > summarySequenceNumber.\n            // We really don't care about it for now, since it is older than\n            // the one we loaded from.\n            if (seq >= this.deltaManager.initialSequenceNumber) {\n                // Potential causes for it to be later than our initialSequenceNumber\n                // are that the summaryOp was nacked then acked, double-acked, or\n                // the summarySequenceNumber is incorrect.\n                this.logger.sendErrorEvent({\n                    eventName: \"SummaryAckWithoutOp\",\n                    sequenceNumber: op.sequenceNumber,\n                    summarySequenceNumber: seq,\n                    initialSequenceNumber: this.deltaManager.initialSequenceNumber,\n                });\n            }\n            return;\n        }\n        summary.ackNack(op);\n        this.pendingSummaries.delete(seq);\n        // Track latest ack\n        if (!this.lastAck || seq > this.lastAck.summaryAck.contents.summaryProposal.summarySequenceNumber) {\n            this.lastAck = {\n                summaryOp: summary.summaryOp,\n                summaryAck: op,\n            };\n            this.refreshWaitNextAck.resolve();\n            this.refreshWaitNextAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.emit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck, op);\n        }\n    }\n    handleSummaryNack(op) {\n        const seq = op.contents.summaryProposal.summarySequenceNumber;\n        const summary = this.pendingSummaries.get(seq);\n        if (summary) {\n            summary.ackNack(op);\n            this.pendingSummaries.delete(seq);\n            this.emit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryNack, op);\n        }\n    }\n}\n//# sourceMappingURL=summaryCollection.js.map\n\n/***/ }),\n/* 114 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OrderedClientCollection\": () => (/* binding */ OrderedClientCollection),\n/* harmony export */   \"OrderedClientElection\": () => (/* binding */ OrderedClientElection)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/* harmony import */ var _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71);\n\n\n\n\n/**\n * Tracks clients in the Quorum. It maintains their order using their join op\n * sequence numbers.\n * Internally, the collection of clients is maintained in a doubly-linked list,\n * with pointers to both the first and last nodes.\n * The first (root) node is a placeholder to simplify logic and reduce null checking.\n */\nclass OrderedClientCollection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(logger, deltaManager, quorum) {\n        super();\n        /** Collection of ALL clients currently in the quorum, with client ids as keys. */\n        this.clientMap = new Map();\n        /** Placeholder head node of linked list, for simplified null checking. */\n        this.rootNode = {\n            sequenceNumber: -1,\n            olderClient: undefined,\n            youngerClient: undefined,\n        };\n        /** Pointer to end of linked list, for optimized client adds. */\n        this._youngestClient = this.rootNode;\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, \"OrderedClientCollection\");\n        const members = quorum.getMembers();\n        for (const [clientId, client] of members) {\n            this.addClient(clientId, client);\n        }\n        quorum.on(\"addMember\", (clientId, client) => {\n            const newClient = this.addClient(clientId, client);\n            this.emit(\"addClient\", newClient, deltaManager.lastSequenceNumber);\n        });\n        quorum.on(\"removeMember\", (clientId) => {\n            const sequenceNumber = deltaManager.lastSequenceNumber;\n            const removeClient = this.removeClient(clientId);\n            if (removeClient === undefined) {\n                this.logger.sendErrorEvent({ eventName: \"ClientNotFound\", clientId, sequenceNumber });\n            }\n            else {\n                this.emit(\"removeClient\", removeClient, sequenceNumber);\n            }\n        });\n    }\n    get count() {\n        return this.clientMap.size;\n    }\n    get oldestClient() {\n        return this.rootNode.youngerClient;\n    }\n    addClient(clientId, client) {\n        // Normal case is adding the latest client, which will bypass loop.\n        // Find where it belongs otherwise (maybe possible during initial load?).\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(client.sequenceNumber > -1, 0x1f6 /* \"Negative client sequence number not allowed\" */);\n        let currClient = this._youngestClient;\n        while (currClient.sequenceNumber > client.sequenceNumber) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(currClient.olderClient !== undefined, 0x1f7 /* \"Previous client should always be defined\" */);\n            // Note: If adding a client older than the elected client, it will not be automatically elected.\n            currClient = currClient.olderClient;\n        }\n        // Now currClient is the node right before where the new client node should be.\n        const newClient = {\n            clientId,\n            sequenceNumber: client.sequenceNumber,\n            client: Object.assign({}, client.client),\n            olderClient: currClient,\n            youngerClient: currClient.youngerClient,\n        };\n        // Update prev node to point to this new node.\n        newClient.olderClient.youngerClient = newClient;\n        if (newClient.youngerClient === undefined) {\n            // Update linked list end pointer to youngest client.\n            this._youngestClient = newClient;\n        }\n        else {\n            // Update next node to point back to this new node.\n            newClient.youngerClient.olderClient = newClient;\n        }\n        this.clientMap.set(clientId, newClient);\n        return newClient;\n    }\n    removeClient(clientId) {\n        const removeClient = this.clientMap.get(clientId);\n        if (removeClient === undefined) {\n            return;\n        }\n        // Update prev node to point to next node.\n        removeClient.olderClient.youngerClient = removeClient.youngerClient;\n        if (removeClient.youngerClient === undefined) {\n            // Update linked list end pointer to youngest client.\n            this._youngestClient = removeClient.olderClient;\n        }\n        else {\n            // Update next node to point back to previous node.\n            removeClient.youngerClient.olderClient = removeClient.olderClient;\n        }\n        this.clientMap.delete(clientId);\n        return removeClient;\n    }\n    /** Returns an array of all clients being tracked in order from oldest to newest. */\n    getAllClients() {\n        const result = [];\n        let currClient = this.rootNode;\n        while (currClient.youngerClient !== undefined) {\n            result.push(currClient.youngerClient);\n            currClient = currClient.youngerClient;\n        }\n        return result;\n    }\n}\n/**\n * Adapter for OrderedClientCollection, with the purpose of deterministically maintaining\n * a currently elected client, excluding ineligible clients, in a distributed fashion.\n * This can be true as long as incrementElectedClient and resetElectedClient calls\n * are called under the same conditions for all clients.\n */\nclass OrderedClientElection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(logger, orderedClientCollection, \n    /** Serialized state from summary or current sequence number at time of load if new. */\n    initialState, isEligibleFn) {\n        super();\n        this.orderedClientCollection = orderedClientCollection;\n        this.isEligibleFn = isEligibleFn;\n        this._eligibleCount = 0;\n        let initialClient;\n        let initialParent;\n        for (const client of orderedClientCollection.getAllClients()) {\n            this.addClient(client, 0);\n            if (typeof initialState !== \"number\") {\n                if (client.clientId === initialState.electedClientId) {\n                    initialClient = client;\n                    if (initialState.electedParentId === undefined &&\n                        client.client.details.type !== _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType) {\n                        // If there was no elected parent in the serialized data, use this one.\n                        initialParent = client;\n                    }\n                }\n                if (client.clientId === initialState.electedParentId) {\n                    initialParent = client;\n                }\n            }\n        }\n        orderedClientCollection.on(\"addClient\", (client, seq) => this.addClient(client, seq));\n        orderedClientCollection.on(\"removeClient\", (client, seq) => this.removeClient(client, seq));\n        if (typeof initialState === \"number\") {\n            this._electionSequenceNumber = initialState;\n        }\n        else {\n            // Override the initially elected client with the initial state.\n            if ((initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId) !== initialState.electedClientId) {\n                // Cannot find initially elected client, so elect undefined.\n                logger.sendErrorEvent({\n                    eventName: \"InitialElectedClientNotFound\",\n                    electionSequenceNumber: initialState.electionSequenceNumber,\n                    expectedClientId: initialState.electedClientId,\n                    electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,\n                    clientCount: orderedClientCollection.count,\n                });\n            }\n            else if (initialClient !== undefined && !isEligibleFn(initialClient)) {\n                // Initially elected client is ineligible, so elect next eligible client.\n                initialClient = initialParent = this.findFirstEligibleParent(initialParent);\n                logger.sendErrorEvent({\n                    eventName: \"InitialElectedClientIneligible\",\n                    electionSequenceNumber: initialState.electionSequenceNumber,\n                    expectedClientId: initialState.electedClientId,\n                    electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,\n                });\n            }\n            this._electedParent = initialParent;\n            this._electedClient = initialClient;\n            this._electionSequenceNumber = initialState.electionSequenceNumber;\n        }\n    }\n    get eligibleCount() {\n        return this._eligibleCount;\n    }\n    get electionSequenceNumber() {\n        return this._electionSequenceNumber;\n    }\n    /**\n     * OrderedClientCollection tracks electedClient and electedParent separately. This allows us to handle the case\n     * where a new interactive parent client has been elected, but the summarizer is still doing work, so\n     * a new summarizer should not yet be spawned. In this case, changing electedParent will cause SummaryManager\n     * to stop the current summarizer, but a new summarizer will not be spawned until the old summarizer client has\n     * left the quorum.\n     *\n     * Details:\n     *\n     * electedParent is the interactive client that has been elected to spawn a summarizer. It is typically the oldest\n     * eligible interactive client in the quorum. Only the electedParent is permitted to spawn a summarizer.\n     * Once elected, this client will remain the electedParent until it leaves the quorum or the summarizer that\n     * it spawned stops producing summaries, at which point a new electedParent will be chosen.\n     *\n     * electedClient is the non-interactive summarizer client if one exists. If not, then electedClient is equal to\n     * electedParent. If electedParent === electedClient, this is the signal for electedParent to spawn a new\n     * electedClient. Once a summarizer client becomes electedClient, a new summarizer will not be spawned until\n     * electedClient leaves the quorum.\n     *\n     * A typical sequence looks like this:\n     * i. Begin by electing A. electedParent === A, electedClient === A.\n     * ii. SummaryManager running on A spawns a summarizer client, A'. electedParent === A, electedClient === A'\n     * iii. A' stops producing summaries. A new parent client, B, is elected. electedParent === B, electedClient === A'\n     * iv. SummaryManager running on A detects the change to electedParent and tells the summarizer to stop, but A'\n     *      is in mid-summarization. No new summarizer is spawned, as electedParent !== electedClient.\n     * v. A' completes its summary, and the summarizer and backing client are torn down.\n     * vi. A' leaves the quorum, and B takes its place as electedClient. electedParent === B, electedClient === B\n     * vii. SummaryManager running on B spawns a summarizer client, B'. electedParent === B, electedClient === B'\n     */\n    get electedClient() {\n        return this._electedClient;\n    }\n    get electedParent() {\n        return this._electedParent;\n    }\n    /** Tries changing the elected client, raising an event if it is different.\n     * Note that this function does no eligibility or suitability checks. If we get here, then\n     * we will set _electedClient, and we will set _electedParent if this is an interactive client.\n     */\n    tryElectingClient(client, sequenceNumber) {\n        let change = false;\n        const isSummarizerClient = (client === null || client === void 0 ? void 0 : client.client.details.type) === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType;\n        const prevClient = this._electedClient;\n        if (this._electedClient !== client) {\n            // Changing the elected client. Record the sequence number and note that we have to fire an event.\n            this._electionSequenceNumber = sequenceNumber;\n            this._electedClient = client;\n            change = true;\n        }\n        if (this._electedParent !== client && !isSummarizerClient) {\n            // Changing the elected parent as well.\n            this._electedParent = client;\n            change = true;\n        }\n        if (change) {\n            this.emit(\"election\", client, sequenceNumber, prevClient);\n        }\n    }\n    tryElectingParent(client, sequenceNumber) {\n        if (this._electedParent !== client) {\n            this._electedParent = client;\n            this.emit(\"election\", this._electedClient, sequenceNumber, this._electedClient);\n        }\n    }\n    /**\n     * Helper function to find the first eligible parent client starting with the passed in client,\n     * or undefined if none are eligible.\n     * @param client - client to start checking\n     * @returns oldest eligible client starting with passed in client or undefined if none.\n     */\n    findFirstEligibleParent(client) {\n        let candidateClient = client;\n        while (candidateClient !== undefined &&\n            (!this.isEligibleFn(candidateClient) || candidateClient.client.details.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType)) {\n            candidateClient = candidateClient.youngerClient;\n        }\n        return candidateClient;\n    }\n    /**\n     * Updates tracking for when a new client is added to the collection.\n     * Will automatically elect that new client if none is elected currently.\n     * @param client - client added to the collection\n     * @param sequenceNumber - sequence number when client was added\n     */\n    addClient(client, sequenceNumber) {\n        var _a;\n        if (this.isEligibleFn(client)) {\n            this._eligibleCount++;\n            const newClientIsSummarizer = client.client.details.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType;\n            const electedClientIsSummarizer = ((_a = this._electedClient) === null || _a === void 0 ? void 0 : _a.client.details.type) === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType;\n            // Note that we allow a summarizer client to supercede an interactive client as elected client.\n            if (this._electedClient === undefined || (!electedClientIsSummarizer && newClientIsSummarizer)) {\n                this.tryElectingClient(client, sequenceNumber);\n            }\n            else if (this._electedParent === undefined && !newClientIsSummarizer) {\n                // This is an odd case. If the _electedClient is set, the _electedParent should be as well.\n                this.tryElectingParent(client, sequenceNumber);\n            }\n        }\n    }\n    /**\n     * Updates tracking for when an existing client is removed from the collection.\n     * Will automatically elect next oldest client if currently elected is removed.\n     * @param client - client removed from the collection\n     * @param sequenceNumber - sequence number when client was removed\n     */\n    removeClient(client, sequenceNumber) {\n        var _a, _b, _c, _d, _e;\n        if (this.isEligibleFn(client)) {\n            this._eligibleCount--;\n            if (this._electedClient === client) {\n                // Removing the _electedClient. There are 2 possible cases:\n                if (this._electedParent !== client) {\n                    // 1. The _electedClient is a summarizer that we've been allowing to finish its work.\n                    // Let the _electedParent become the _electedClient so that it can start its own summarizer.\n                    if (this._electedClient.client.details.type !== _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType) {\n                        throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError(\"Elected client should be a summarizer client 1\");\n                    }\n                    this.tryElectingClient(this._electedParent, sequenceNumber);\n                }\n                else {\n                    // 2. The _electedClient is an interactive client that has left the quorum.\n                    // Automatically shift to next oldest client.\n                    const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n                    this.tryElectingClient(nextClient, sequenceNumber);\n                }\n            }\n            else if (this._electedParent === client) {\n                // Removing the _electedParent (but not _electedClient).\n                // Shift to the next oldest parent, but do not replace the _electedClient,\n                // which is a summarizer that is still doing work.\n                if (((_c = this._electedClient) === null || _c === void 0 ? void 0 : _c.client.details.type) !== _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType) {\n                    throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError(\"Elected client should be a summarizer client 2\");\n                }\n                const nextParent = (_e = this.findFirstEligibleParent((_d = this._electedParent) === null || _d === void 0 ? void 0 : _d.youngerClient)) !== null && _e !== void 0 ? _e : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n                this.tryElectingParent(nextParent, sequenceNumber);\n            }\n        }\n    }\n    getAllEligibleClients() {\n        return this.orderedClientCollection.getAllClients().filter(this.isEligibleFn);\n    }\n    /** Advance election to the next-oldest client. This is called if the current parent is leaving the quorum,\n     * or if the current summarizer is not responsive and we want to stop it and spawn a new one.\n     */\n    incrementElectedClient(sequenceNumber) {\n        var _a, _b;\n        const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n        if (this._electedClient === undefined || this._electedClient === this._electedParent) {\n            this.tryElectingClient(nextClient, sequenceNumber);\n        }\n        else {\n            // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.\n            // Changing the _electedParent will stop the summarizer.\n            this.tryElectingParent(nextClient, sequenceNumber);\n        }\n    }\n    /** (Re-)start election with the oldest client in the quorum. This is called if we need to summarize\n     * and no client has been elected.\n     */\n    resetElectedClient(sequenceNumber) {\n        const firstClient = this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n        if (this._electedClient === undefined || this._electedClient === this._electedParent) {\n            this.tryElectingClient(firstClient, sequenceNumber);\n        }\n        else {\n            // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.\n            // Changing the _electedParent will stop the summarizer.\n            this.tryElectingParent(firstClient, sequenceNumber);\n        }\n    }\n    peekNextElectedClient() {\n        var _a, _b;\n        return (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n    }\n    serialize() {\n        var _a, _b;\n        return {\n            electionSequenceNumber: this.electionSequenceNumber,\n            electedClientId: (_a = this.electedClient) === null || _a === void 0 ? void 0 : _a.clientId,\n            electedParentId: (_b = this.electedParent) === null || _b === void 0 ? void 0 : _b.clientId,\n        };\n    }\n}\n//# sourceMappingURL=orderedClientElection.js.map\n\n/***/ }),\n/* 115 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Summarizer\": () => (/* binding */ Summarizer),\n/* harmony export */   \"SummarizingWarning\": () => (/* binding */ SummarizingWarning),\n/* harmony export */   \"createSummarizingWarning\": () => (/* binding */ createSummarizingWarning)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(119);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(120);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(8);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(32);\n/* harmony import */ var _summarizerClientElection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(71);\n/* harmony import */ var _summarizerHandle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(118);\n/* harmony import */ var _runningSummarizer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(121);\n/* harmony import */ var _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(122);\n/* harmony import */ var _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst summarizingError = \"summarizingError\";\nclass SummarizingWarning extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError {\n    constructor(errorMessage, logged = false) {\n        super(errorMessage);\n        this.logged = logged;\n        this.errorType = summarizingError;\n        this.canRetry = true;\n    }\n    static wrap(error, logged = false, logger) {\n        const newErrorFn = (errMsg) => new SummarizingWarning(errMsg, logged);\n        return (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.wrapErrorAndLog)(error, newErrorFn, logger);\n    }\n}\nconst createSummarizingWarning = (errorMessage, logged) => new SummarizingWarning(errorMessage, logged);\n/**\n * Summarizer is responsible for coordinating when to generate and send summaries.\n * It is the main entry point for summary work.\n * It is created only by summarizing container (i.e. one with clientType === \"summarizer\")\n */\nclass Summarizer extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(url, \n    /** Reference to runtime that created this object.\n     * i.e. runtime with clientType === \"summarizer\"\n     */\n    runtime, configurationGetter, \n    /** Represents an object that can generate summary.\n     * In practical terms, it's same runtime (this.runtime) with clientType === \"summarizer\".\n    */\n    internalsProvider, handleContext, summaryCollection, runCoordinatorCreateFn) {\n        super();\n        this.runtime = runtime;\n        this.configurationGetter = configurationGetter;\n        this.internalsProvider = internalsProvider;\n        this.summaryCollection = summaryCollection;\n        this.runCoordinatorCreateFn = runCoordinatorCreateFn;\n        this._disposed = false;\n        this.starting = false;\n        this.stopDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Deferred();\n        this.summarizeOnDemand = (...args) => {\n            var _a;\n            try {\n                if (this._disposed || ((_a = this.runningSummarizer) === null || _a === void 0 ? void 0 : _a.disposed)) {\n                    throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"Summarizer is already disposed.\");\n                }\n                if (this.runtime.summarizerClientId !== undefined &&\n                    this.runtime.summarizerClientId !== this.runtime.clientId) {\n                    // If there is an elected summarizer, and it's not this one, don't allow on-demand summary.\n                    // This is to prevent the on-demand summary and heuristic-based summary from stepping on\n                    // each other.\n                    throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"On-demand summary attempted while an elected summarizer is present\");\n                }\n                const builder = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder();\n                if (this.runningSummarizer) {\n                    // Summarizer is already running. Go ahead and start.\n                    return this.runningSummarizer.summarizeOnDemand(builder, ...args);\n                }\n                // Summarizer isn't running, so we need to start it, which is an async operation.\n                // Manage the promise related to creating the cancellation token here.\n                // The promises related to starting, summarizing,\n                // and submitting are communicated to the caller through the results builder.\n                const coordinatorCreateP = this.runCoordinatorCreateFn(this.runtime);\n                coordinatorCreateP.then((runCoordinator) => {\n                    // Successully created the cancellation token. Start the summarizer.\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const startP = this.start(this.runtime.clientId, runCoordinator);\n                    startP.then(async (runningSummarizer) => {\n                        // Successfully started the summarizer. Run it.\n                        runningSummarizer.summarizeOnDemand(builder, ...args);\n                        // Wait for a command to stop or loss of connectivity before tearing down the summarizer and client.\n                        const stopReason = await Promise.race([this.stopDeferred.promise, runCoordinator.waitCancelled]);\n                        await runningSummarizer.waitStop(false);\n                        runCoordinator.stop(stopReason);\n                        this.close();\n                    }).catch((reason) => {\n                        builder.fail(\"Failed to start summarizer\", reason);\n                    });\n                }).catch((reason) => {\n                    builder.fail(\"Failed to create cancellation token\", reason);\n                });\n                return builder.build();\n            }\n            catch (error) {\n                throw SummarizingWarning.wrap(error, false /* logged */, this.logger);\n            }\n        };\n        this.enqueueSummarize = (...args) => {\n            if (this._disposed || this.runningSummarizer === undefined || this.runningSummarizer.disposed) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"Summarizer is not running or already disposed.\");\n            }\n            return this.runningSummarizer.enqueueSummarize(...args);\n        };\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(this.runtime.logger, \"Summarizer\");\n        this.innerHandle = new _summarizerHandle__WEBPACK_IMPORTED_MODULE_6__.SummarizerHandle(this, url, handleContext);\n    }\n    get IFluidLoadable() { return this; }\n    get ISummarizer() { return this; }\n    get handle() { return this.innerHandle; }\n    /**\n     * Creates a Summarizer and its underlying client.\n     * Note that different implementations of ILoader will handle the URL differently.\n     * ILoader provided by a ContainerRuntime is a RelativeLoader, which will treat URL's\n     * starting with \"/\" as relative to the Container. The general ILoader\n     * interface will expect an absolute URL and will not handle \"/\".\n     * @param loader - the loader that resolves the request\n     * @param url - the URL used to resolve the container\n     */\n    static async create(loader, url) {\n        const request = {\n            headers: {\n                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.LoaderHeader.cache]: false,\n                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.LoaderHeader.clientDetails]: {\n                    capabilities: { interactive: false },\n                    type: _summarizerClientElection__WEBPACK_IMPORTED_MODULE_8__.summarizerClientType,\n                },\n                [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_9__.DriverHeader.summarizingClient]: true,\n                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.LoaderHeader.reconnect]: false,\n            },\n            url,\n        };\n        const resolvedContainer = await loader.resolve(request);\n        const fluidObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__.requestFluidObject)(resolvedContainer, { url: \"_summarizer\" });\n        if (fluidObject.ISummarizer === undefined) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"Fluid object does not implement ISummarizer\");\n        }\n        return fluidObject.ISummarizer;\n    }\n    async run(onBehalfOf) {\n        try {\n            return await this.runCore(onBehalfOf);\n        }\n        catch (error) {\n            this.stop(\"summarizerException\");\n            throw SummarizingWarning.wrap(error, false /* logged */, this.logger);\n        }\n        finally {\n            this.close();\n        }\n    }\n    /**\n     * Stops the summarizer from running.  This will complete\n     * the run promise, and also close the container.\n     * @param reason - reason code for stopping\n     */\n    stop(reason) {\n        this.stopDeferred.resolve(reason);\n    }\n    close() {\n        // This will result in \"summarizerClientDisconnected\" stop reason recorded in telemetry,\n        // unless stop() was called earlier\n        this.dispose();\n        this.runtime.closeFn();\n    }\n    async runCore(onBehalfOf) {\n        const runCoordinator = await this.runCoordinatorCreateFn(this.runtime);\n        // Wait for either external signal to cancel, or loss of connectivity.\n        const stopP = Promise.race([runCoordinator.waitCancelled, this.stopDeferred.promise]);\n        void stopP.then((reason) => {\n            this.logger.sendTelemetryEvent({\n                eventName: \"StoppingSummarizer\",\n                onBehalfOf,\n                reason,\n            });\n        });\n        if (runCoordinator.cancelled) {\n            return runCoordinator.waitCancelled;\n        }\n        const runningSummarizer = await this.start(onBehalfOf, runCoordinator);\n        // Wait for either external signal to cancel, or loss of connectivity.\n        const stopReason = await stopP;\n        // There are two possible approaches here:\n        // 1. Propagate cancellation from this.stopDeferred to runCoordinator. This will ensure that we move to the exit\n        //    faster, including breaking out of the RunningSummarizer.trySummarize() faster.\n        //    We could create new coordinator and pass it to waitStop() -> trySummarizeOnce(\"lastSummary\") flow.\n        //    The con of this approach is that we might cancel active summary, and lastSummary will fail because it\n        //    did not wait for ack/nack from previous summary. Plus we disregard any 429 kind of info from service\n        //    that way (i.e. trySummarize() loop might have been waiting for 5 min because storage told us so).\n        //    In general, it's more wasted resources.\n        // 2. We can not do it and make waitStop() do last summary only if there was no active summary. This ensures\n        //    that client behaves properly (from server POV) and we do not waste resources. But, it may mean we wait\n        //    substantially longer for trySummarize() retries to play out and thus this summary loop may run into\n        //    conflict with new summarizer client starting on different client.\n        // As of now, #2 is implemented. It's more forward looking, as issue #7279 suggests changing design for new\n        // summarizer client to not be created until current summarizer fully moves to exit, and that would reduce\n        // cons of #2 substantially.\n        // Cleanup after running\n        await runningSummarizer.waitStop(!runCoordinator.cancelled && Summarizer.stopReasonCanRunLastSummary(stopReason));\n        // Propagate reason and ensure that if someone is waiting for cancellation token, they are moving to exit\n        runCoordinator.stop(stopReason);\n        return stopReason;\n    }\n    /**\n     * Should we try to run a last summary for the given stop reason?\n     * Currently only allows \"parentNotConnected\"\n     * @param stopReason - SummarizerStopReason\n     * @returns - true if the stop reason can run a last summary\n     */\n    static stopReasonCanRunLastSummary(stopReason) {\n        return stopReason === \"parentNotConnected\";\n    }\n    /**\n     * Put the summarizer in a started state, including creating and initializing the RunningSummarizer.\n     * The start request can come either from the SummaryManager (in the auto-summarize case) or from the user\n     * (in the on-demand case).\n     * @param onBehalfOf - ID of the client that requested that the summarizer start\n     * @param runCoordinator - cancellation token\n     * @param newConfig - Summary configuration to override the existing config when invoking the RunningSummarizer.\n     * @returns - Promise that is fulfilled when the RunningSummarizer is ready\n     */\n    async start(onBehalfOf, runCoordinator) {\n        if (this.runningSummarizer) {\n            if (this.runningSummarizer.disposed) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"Starting a disposed summarizer\");\n            }\n            return this.runningSummarizer;\n        }\n        if (this.starting) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"Attempting to start a summarizer that is already starting\");\n        }\n        this.starting = true;\n        // Initialize values and first ack (time is not exact)\n        this.logger.sendTelemetryEvent({\n            eventName: \"RunningSummarizer\",\n            onBehalfOf,\n            initSummarySeqNumber: this.runtime.deltaManager.initialSequenceNumber,\n            config: JSON.stringify(this.configurationGetter()),\n        });\n        // Summarizing container ID (with clientType === \"summarizer\")\n        const clientId = this.runtime.clientId;\n        if (clientId === undefined) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError(\"clientId should be defined if connected.\");\n        }\n        const runningSummarizer = await _runningSummarizer__WEBPACK_IMPORTED_MODULE_11__.RunningSummarizer.start(this.logger, this.summaryCollection.createWatcher(clientId), this.configurationGetter(), async (...args) => this.internalsProvider.submitSummary(...args), // submitSummaryCallback\n        new _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_12__.SummarizeHeuristicData(this.runtime.deltaManager.lastSequenceNumber, {\n            refSequenceNumber: this.runtime.deltaManager.initialSequenceNumber,\n            summaryTime: Date.now(),\n        }), (errorMessage) => {\n            if (!this._disposed) {\n                this.logger.sendErrorEvent({ eventName: \"summarizingError\" }, createSummarizingWarning(errorMessage, true));\n            }\n        }, this.summaryCollection, runCoordinator /* cancellationToken */, (reason) => runCoordinator.stop(reason));\n        this.runningSummarizer = runningSummarizer;\n        this.starting = false;\n        // Handle summary acks\n        // Note: no exceptions are thrown from handleSummaryAcks handler as it handles all exceptions\n        this.handleSummaryAcks().catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"HandleSummaryAckFatalError\" }, error);\n        });\n        // Listen for ops\n        this.systemOpListener = (op) => runningSummarizer.handleSystemOp(op);\n        this.runtime.deltaManager.inbound.on(\"op\", this.systemOpListener);\n        this.opListener = (error, op) => runningSummarizer.handleOp(error, op);\n        this.runtime.on(\"batchEnd\", this.opListener);\n        return runningSummarizer;\n    }\n    /**\n     * Disposes of resources after running.  This cleanup will\n     * clear any outstanding timers and reset some of the state\n     * properties.\n     * Called by ContainerRuntime when it is disposed, as well as at the end the run().\n     */\n    dispose() {\n        // Given that the call can come from own ContainerRuntime, ensure that we stop all the processes.\n        this.stop(\"summarizerClientDisconnected\");\n        this._disposed = true;\n        if (this.runningSummarizer) {\n            this.runningSummarizer.dispose();\n            this.runningSummarizer = undefined;\n        }\n        if (this.systemOpListener) {\n            this.runtime.deltaManager.inbound.off(\"op\", this.systemOpListener);\n        }\n        if (this.opListener) {\n            this.runtime.removeListener(\"batchEnd\", this.opListener);\n        }\n    }\n    async handleSummaryAcks() {\n        var _a, _b, _c, _d, _e;\n        let refSequenceNumber = this.runtime.deltaManager.initialSequenceNumber;\n        let ack;\n        while (this.runningSummarizer) {\n            const summaryLogger = (_a = this.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber)) !== null && _a !== void 0 ? _a : this.logger;\n            try {\n                // Initialize ack with undefined if exception happens inside of waitSummaryAck on second iteration,\n                // we record undefined, not previous handles.\n                ack = undefined;\n                ack = await this.summaryCollection.waitSummaryAck(refSequenceNumber);\n                refSequenceNumber = ack.summaryOp.referenceSequenceNumber;\n                const summaryOpHandle = ack.summaryOp.contents.handle;\n                const summaryAckHandle = ack.summaryAck.contents.handle;\n                // Make sure we block any summarizer from being executed/enqueued while\n                // executing the refreshLatestSummaryAck.\n                // https://dev.azure.com/fluidframework/internal/_workitems/edit/779\n                await this.runningSummarizer.lockedRefreshSummaryAckAction(async () => this.internalsProvider.refreshLatestSummaryAck(summaryOpHandle, summaryAckHandle, refSequenceNumber, summaryLogger).catch(async (error) => {\n                    // If the error is 404, so maybe the fetched version no longer exists on server. We just\n                    // ignore this error in that case, as that means we will have another summaryAck for the\n                    // latest version with which we will refresh the state. However in case of single commit\n                    // summary, we might me missing a summary ack, so in that case we are still fine as the\n                    // code in `submitSummary` function in container runtime, will refresh the latest state\n                    // by calling `refreshLatestSummaryAckFromServer` and we will be fine.\n                    if ((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__.isFluidError)(error)\n                        && error.errorType === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_14__.DriverErrorType.fileNotFoundOrAccessDeniedError) {\n                        summaryLogger.sendTelemetryEvent({\n                            eventName: \"HandleSummaryAckErrorIgnored\",\n                            referenceSequenceNumber: refSequenceNumber,\n                            proposalHandle: summaryOpHandle,\n                            ackHandle: summaryAckHandle,\n                        }, error);\n                    }\n                    else {\n                        throw error;\n                    }\n                }));\n            }\n            catch (error) {\n                summaryLogger.sendErrorEvent({\n                    eventName: \"HandleSummaryAckError\",\n                    referenceSequenceNumber: refSequenceNumber,\n                    handle: (_c = (_b = ack === null || ack === void 0 ? void 0 : ack.summaryOp) === null || _b === void 0 ? void 0 : _b.contents) === null || _c === void 0 ? void 0 : _c.handle,\n                    ackHandle: (_e = (_d = ack === null || ack === void 0 ? void 0 : ack.summaryAck) === null || _d === void 0 ? void 0 : _d.contents) === null || _e === void 0 ? void 0 : _e.handle,\n                }, error);\n            }\n            refSequenceNumber++;\n        }\n    }\n}\n//# sourceMappingURL=summarizer.js.map\n\n/***/ }),\n/* 116 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarizeResultBuilder\": () => (/* binding */ SummarizeResultBuilder),\n/* harmony export */   \"SummaryGenerator\": () => (/* binding */ SummaryGenerator),\n/* harmony export */   \"raceTimer\": () => (/* binding */ raceTimer)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n/** Helper function to wait for a promise or PromiseTimer to elapse. */\nasync function raceTimer(promise, timer, cancellationToken) {\n    const promises = [\n        promise.then((value) => ({ result: \"done\", value })),\n        timer.then(({ timerResult: result }) => ({ result })),\n    ];\n    if (cancellationToken !== undefined) {\n        promises.push(cancellationToken.waitCancelled.then(() => ({ result: \"cancelled\" })));\n    }\n    return Promise.race(promises);\n}\n// Send some telemetry if generate summary takes too long\nconst maxSummarizeTimeoutTime = 20000; // 20 sec\nconst maxSummarizeTimeoutCount = 5; // Double and resend 5 times\nconst summarizeErrors = {\n    /**\n     * Error encountered while generating the summary tree, uploading\n     * it to storage, or submitting the op. It could be a result of\n     * the client becoming disconnected while generating or an actual error.\n     */\n    submitSummaryFailure: \"Error while generating, uploading, or submitting summary\",\n    /**\n     * The summaryAckWaitTimeout time has elapsed before receiving the summarize op\n     * sent by this summarize attempt. It is expected to be broadcast quickly.\n     */\n    summaryOpWaitTimeout: \"Timeout while waiting for summarize op broadcast\",\n    /**\n     * The summaryAckWaitTimeout time has elapsed before receiving either a\n     * summaryAck or summaryNack op from the server in response to this\n     * summarize attempt. It is expected that the server should respond.\n     */\n    summaryAckWaitTimeout: \"Timeout while waiting for summaryAck/summaryNack op\",\n    /**\n     * The server responded with a summaryNack op, thus rejecting this\n     * summarize attempt.\n     */\n    summaryNack: \"Server rejected summary via summaryNack op\",\n    disconnect: \"Summary cancelled due to summarizer or main client disconnect\",\n};\nclass SummarizeResultBuilder {\n    constructor() {\n        this.summarySubmitted = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.summaryOpBroadcasted = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.receivedSummaryAckOrNack = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n    }\n    fail(message, error, nackSummaryResult, retryAfterSeconds) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.receivedSummaryAckOrNack.isCompleted, 0x25e /* \"no reason to call fail if all promises have been completed\" */);\n        const result = { success: false, message, data: undefined, error, retryAfterSeconds };\n        this.summarySubmitted.resolve(result);\n        this.summaryOpBroadcasted.resolve(result);\n        this.receivedSummaryAckOrNack.resolve(Object.assign(Object.assign({}, result), { data: nackSummaryResult }));\n    }\n    build() {\n        return {\n            summarySubmitted: this.summarySubmitted.promise,\n            summaryOpBroadcasted: this.summaryOpBroadcasted.promise,\n            receivedSummaryAckOrNack: this.receivedSummaryAckOrNack.promise,\n        };\n    }\n}\n/**\n * This class generates and tracks a summary attempt.\n */\nclass SummaryGenerator {\n    constructor(pendingAckTimer, heuristicData, submitSummaryCallback, raiseSummarizingError, successfulSummaryCallback, summaryWatcher, logger) {\n        this.pendingAckTimer = pendingAckTimer;\n        this.heuristicData = heuristicData;\n        this.submitSummaryCallback = submitSummaryCallback;\n        this.raiseSummarizingError = raiseSummarizingError;\n        this.successfulSummaryCallback = successfulSummaryCallback;\n        this.summaryWatcher = summaryWatcher;\n        this.logger = logger;\n        this.summarizeTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));\n    }\n    /**\n     * Generates summary and listens for broadcast and ack/nack.\n     * Returns true for ack, false for nack, and undefined for failure or timeout.\n     * @param reason - reason for summarizing\n     * @param options - refreshLatestAck to fetch summary ack info from server,\n     * fullTree to generate tree without any summary handles even if unchanged\n     */\n    summarize(summarizeProps, options, cancellationToken, resultsBuilder = new SummarizeResultBuilder()) {\n        this.summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken)\n            .catch((error) => {\n            const message = \"UnexpectedSummarizeError\";\n            this.logger.sendErrorEvent(Object.assign({ eventName: message }, summarizeProps), error);\n            resultsBuilder.fail(message, error);\n        });\n        return resultsBuilder.build();\n    }\n    async summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken) {\n        const { refreshLatestAck, fullTree } = options;\n        const logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, undefined, { all: summarizeProps });\n        // Note: timeSinceLastAttempt and timeSinceLastSummary for the\n        // first summary are basically the time since the summarizer was loaded.\n        const timeSinceLastAttempt = Date.now() - this.heuristicData.lastAttempt.summaryTime;\n        const timeSinceLastSummary = Date.now() - this.heuristicData.lastSuccessfulSummary.summaryTime;\n        let summarizeTelemetryProps = {\n            fullTree,\n            timeSinceLastAttempt,\n            timeSinceLastSummary,\n        };\n        const summarizeEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.start(logger, Object.assign({ eventName: \"Summarize\", refreshLatestAck }, summarizeTelemetryProps));\n        // Helper functions to report failures and return.\n        const getFailMessage = (errorCode) => `${errorCode}: ${summarizeErrors[errorCode]}`;\n        const fail = (errorCode, error, properties, nackSummaryResult) => {\n            this.raiseSummarizingError(summarizeErrors[errorCode]);\n            // UploadSummary may fail with 429 and retryAfter - respect that\n            // Summary Nack also can have retryAfter, it's parsed below and comes as a property.\n            const retryAfterSeconds = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getRetryDelaySecondsFromError)(error);\n            // Report any failure as an error unless it was due to cancellation (like \"disconnected\" error)\n            // If failure happened on upload, we may not yet realized that socket disconnected, so check\n            // offlineError too.\n            const category = cancellationToken.cancelled || (error === null || error === void 0 ? void 0 : error.errorType) === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_5__.DriverErrorType.offlineError ?\n                \"generic\" : \"error\";\n            summarizeEvent.cancel(Object.assign(Object.assign({}, properties), { reason: errorCode, category,\n                retryAfterSeconds }), error);\n            resultsBuilder.fail(getFailMessage(errorCode), error, nackSummaryResult, retryAfterSeconds);\n        };\n        // Wait to generate and send summary\n        this.summarizeTimer.start();\n        // Use record type to prevent unexpected value types\n        let summaryData;\n        try {\n            summaryData = await this.submitSummaryCallback({\n                fullTree,\n                refreshLatestAck,\n                summaryLogger: logger,\n                cancellationToken,\n            });\n            // Cumulatively add telemetry properties based on how far generateSummary went.\n            const referenceSequenceNumber = summaryData.referenceSequenceNumber;\n            const opsSinceLastSummary = referenceSequenceNumber - this.heuristicData.lastSuccessfulSummary.refSequenceNumber;\n            summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { referenceSequenceNumber, minimumSequenceNumber: summaryData.minimumSequenceNumber, opsSinceLastAttempt: referenceSequenceNumber - this.heuristicData.lastAttempt.refSequenceNumber, opsSinceLastSummary });\n            if (summaryData.stage !== \"base\") {\n                summarizeTelemetryProps = Object.assign(Object.assign(Object.assign({}, summarizeTelemetryProps), summaryData.summaryStats), { generateDuration: summaryData.generateDuration });\n                if (summaryData.stage !== \"generate\") {\n                    summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { handle: summaryData.handle, uploadDuration: summaryData.uploadDuration });\n                    if (summaryData.stage !== \"upload\") {\n                        summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { clientSequenceNumber: summaryData.clientSequenceNumber });\n                    }\n                }\n            }\n            if (summaryData.stage !== \"submit\") {\n                return fail(\"submitSummaryFailure\", summaryData.error, summarizeTelemetryProps);\n            }\n            /**\n             * With incremental summaries, if the full tree was not summarized, only data stores that changed should\n             * be summarized. A data store is considered changed if either or both of the following is true:\n             * - It has received an op.\n             * - Its reference state changed, i.e., it went from referenced to unreferenced or vice-versa.\n             *\n             * In the extreme case, every op can be for a different data store and each op can result in the reference\n             * state change of multiple data stores. So, the total number of data stores that are summarized should not\n             * exceed the number of ops since last summary + number of data store whose reference state changed.\n             */\n            if (!fullTree && !summaryData.forcedFullTree) {\n                const { summarizedDataStoreCount, gcStateUpdatedDataStoreCount = 0 } = summaryData.summaryStats;\n                if (summarizedDataStoreCount > gcStateUpdatedDataStoreCount + opsSinceLastSummary) {\n                    logger.sendErrorEvent({\n                        eventName: \"IncrementalSummaryViolation\",\n                        summarizedDataStoreCount,\n                        gcStateUpdatedDataStoreCount,\n                        opsSinceLastSummary,\n                    });\n                }\n            }\n            // Log event here on summary success only, as Summarize_cancel duplicates failure logging.\n            summarizeEvent.reportEvent(\"generate\", Object.assign({}, summarizeTelemetryProps));\n            resultsBuilder.summarySubmitted.resolve({ success: true, data: summaryData });\n        }\n        catch (error) {\n            return fail(\"submitSummaryFailure\", error);\n        }\n        finally {\n            this.heuristicData.recordAttempt(summaryData === null || summaryData === void 0 ? void 0 : summaryData.referenceSequenceNumber);\n            this.summarizeTimer.clear();\n        }\n        try {\n            const pendingTimeoutP = this.pendingAckTimer.start();\n            const summary = this.summaryWatcher.watchSummary(summaryData.clientSequenceNumber);\n            // Wait for broadcast\n            const waitBroadcastResult = await raceTimer(summary.waitBroadcast(), pendingTimeoutP, cancellationToken);\n            if (waitBroadcastResult.result === \"cancelled\") {\n                return fail(\"disconnect\");\n            }\n            if (waitBroadcastResult.result !== \"done\") {\n                return fail(\"summaryOpWaitTimeout\");\n            }\n            const summarizeOp = waitBroadcastResult.value;\n            const broadcastDuration = Date.now() - this.heuristicData.lastAttempt.summaryTime;\n            resultsBuilder.summaryOpBroadcasted.resolve({\n                success: true,\n                data: { summarizeOp, broadcastDuration },\n            });\n            this.heuristicData.lastAttempt.summarySequenceNumber = summarizeOp.sequenceNumber;\n            logger.sendTelemetryEvent({\n                eventName: \"Summarize_Op\",\n                duration: broadcastDuration,\n                referenceSequenceNumber: summarizeOp.referenceSequenceNumber,\n                summarySequenceNumber: summarizeOp.sequenceNumber,\n                handle: summarizeOp.contents.handle,\n            });\n            // Wait for ack/nack\n            const waitAckNackResult = await raceTimer(summary.waitAckNack(), pendingTimeoutP, cancellationToken);\n            if (waitAckNackResult.result === \"cancelled\") {\n                return fail(\"disconnect\");\n            }\n            if (waitAckNackResult.result !== \"done\") {\n                return fail(\"summaryAckWaitTimeout\");\n            }\n            const ackNackOp = waitAckNackResult.value;\n            this.pendingAckTimer.clear();\n            // Update for success/failure\n            const ackNackDuration = Date.now() - this.heuristicData.lastAttempt.summaryTime;\n            // adding new properties\n            summarizeTelemetryProps = Object.assign({ ackWaitDuration: ackNackDuration, ackNackSequenceNumber: ackNackOp.sequenceNumber, summarySequenceNumber: ackNackOp.contents.summaryProposal.summarySequenceNumber }, summarizeTelemetryProps);\n            if (ackNackOp.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.SummaryAck) {\n                this.heuristicData.markLastAttemptAsSuccessful();\n                this.successfulSummaryCallback();\n                summarizeEvent.end(Object.assign(Object.assign({}, summarizeTelemetryProps), { handle: ackNackOp.contents.handle }));\n                resultsBuilder.receivedSummaryAckOrNack.resolve({ success: true, data: {\n                        summaryAckOp: ackNackOp,\n                        ackNackDuration,\n                    } });\n            }\n            else {\n                // Check for retryDelay in summaryNack response.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(ackNackOp.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.SummaryNack, 0x274 /* \"type check\" */);\n                const summaryNack = ackNackOp.contents;\n                const message = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.message;\n                const retryAfterSeconds = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.retryAfter;\n                // pre-0.58 error message prefix: summaryNack\n                const error = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError(`Received summaryNack: ${message}`, { retryAfterSeconds });\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getRetryDelaySecondsFromError)(error) === retryAfterSeconds, 0x25f /* \"retryAfterSeconds\" */);\n                // This will only set resultsBuilder.receivedSummaryAckOrNack, as other promises are already set.\n                return fail(\"summaryNack\", error, Object.assign(Object.assign({}, summarizeTelemetryProps), { nackRetryAfter: retryAfterSeconds }), { summaryNackOp: ackNackOp, ackNackDuration });\n            }\n        }\n        finally {\n            this.pendingAckTimer.clear();\n        }\n    }\n    summarizeTimerHandler(time, count) {\n        this.logger.sendPerformanceEvent({\n            eventName: \"SummarizeTimeout\",\n            timeoutTime: time,\n            timeoutCount: count,\n        });\n        if (count < maxSummarizeTimeoutCount) {\n            // Double and start a new timer\n            const nextTime = time * 2;\n            this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));\n        }\n    }\n    dispose() {\n        this.summarizeTimer.clear();\n    }\n}\n//# sourceMappingURL=summaryGenerator.js.map\n\n/***/ }),\n/* 117 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AuthorizationError\": () => (/* binding */ AuthorizationError),\n/* harmony export */   \"DeltaStreamConnectionForbiddenError\": () => (/* binding */ DeltaStreamConnectionForbiddenError),\n/* harmony export */   \"GenericNetworkError\": () => (/* binding */ GenericNetworkError),\n/* harmony export */   \"NetworkErrorBasic\": () => (/* binding */ NetworkErrorBasic),\n/* harmony export */   \"NonRetryableError\": () => (/* binding */ NonRetryableError),\n/* harmony export */   \"OnlineStatus\": () => (/* binding */ OnlineStatus),\n/* harmony export */   \"RetryableError\": () => (/* binding */ RetryableError),\n/* harmony export */   \"ThrottlingError\": () => (/* binding */ ThrottlingError),\n/* harmony export */   \"canRetryOnError\": () => (/* binding */ canRetryOnError),\n/* harmony export */   \"createGenericNetworkError\": () => (/* binding */ createGenericNetworkError),\n/* harmony export */   \"createWriteError\": () => (/* binding */ createWriteError),\n/* harmony export */   \"getRetryDelayFromError\": () => (/* binding */ getRetryDelayFromError),\n/* harmony export */   \"getRetryDelaySecondsFromError\": () => (/* binding */ getRetryDelaySecondsFromError),\n/* harmony export */   \"isOnline\": () => (/* binding */ isOnline)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a;\n\n\nvar OnlineStatus;\n(function (OnlineStatus) {\n    OnlineStatus[OnlineStatus[\"Offline\"] = 0] = \"Offline\";\n    OnlineStatus[OnlineStatus[\"Online\"] = 1] = \"Online\";\n    OnlineStatus[OnlineStatus[\"Unknown\"] = 2] = \"Unknown\";\n})(OnlineStatus || (OnlineStatus = {}));\n// It tells if we have local connection only - we might not have connection to web.\n// No solution for node.js (other than resolve dns names / ping specific sites)\n// Can also use window.addEventListener(\"online\" / \"offline\")\nfunction isOnline() {\n    if (typeof navigator === \"object\" && navigator !== null && typeof navigator.onLine === \"boolean\") {\n        return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;\n    }\n    return OnlineStatus.Unknown;\n}\n/**\n * Generic network error class.\n */\nclass GenericNetworkError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, canRetry, props) {\n        super(message, props);\n        this.canRetry = canRetry;\n        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.genericNetworkError;\n    }\n}\n// Todo GH #6214: Remove after next drive def bump. This is necessary as there is no\n// compatible way to augment an enum, as it can't be optional. So for now\n// we need to duplicate the value here. We likely need to rethink our\n// DriverErrorType strategy so that it supports extension with optional\n// value.\nconst deltaStreamConnectionForbiddenStr = \"deltaStreamConnectionForbidden\";\nclass DeltaStreamConnectionForbiddenError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, props) {\n        super(message, Object.assign(Object.assign({}, props), { statusCode: 400 }));\n        this.errorType = DeltaStreamConnectionForbiddenError.errorType;\n        this.canRetry = false;\n    }\n}\nDeltaStreamConnectionForbiddenError.errorType = (_a = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType[deltaStreamConnectionForbiddenStr]) !== null && _a !== void 0 ? _a : deltaStreamConnectionForbiddenStr;\nclass AuthorizationError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, claims, tenantId, props) {\n        // don't log claims or tenantId\n        super(message, props, new Set([\"claims\", \"tenantId\"]));\n        this.claims = claims;\n        this.tenantId = tenantId;\n        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.authorizationError;\n        this.canRetry = false;\n    }\n}\nclass NetworkErrorBasic extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, errorType, canRetry, props) {\n        super(message, props);\n        this.errorType = errorType;\n        this.canRetry = canRetry;\n    }\n}\nclass NonRetryableError extends NetworkErrorBasic {\n    constructor(message, errorType, props) {\n        super(message, errorType, false, props);\n        this.errorType = errorType;\n    }\n}\nclass RetryableError extends NetworkErrorBasic {\n    constructor(message, errorType, props) {\n        super(message, errorType, true, props);\n        this.errorType = errorType;\n    }\n}\n/**\n * Throttling error class - used to communicate all throttling errors\n */\nclass ThrottlingError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {\n    constructor(message, retryAfterSeconds, props) {\n        super(message, props);\n        this.retryAfterSeconds = retryAfterSeconds;\n        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.throttlingError;\n        this.canRetry = true;\n    }\n}\nconst createWriteError = (message, props) => new NonRetryableError(message, _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.writeError, props);\nfunction createGenericNetworkError(message, retryInfo, props) {\n    if (retryInfo.retryAfterMs !== undefined && retryInfo.canRetry) {\n        return new ThrottlingError(message, retryInfo.retryAfterMs / 1000, props);\n    }\n    return new GenericNetworkError(message, retryInfo.canRetry, props);\n}\n/**\n * Check if a connection error can be retried.  Unless explicitly allowed, retry is disallowed.\n * I.e. asserts or unexpected exceptions in our code result in container failure.\n * @param error - The error to inspect for ability to retry\n */\nconst canRetryOnError = (error) => (error === null || error === void 0 ? void 0 : error.canRetry) === true;\n/** Check retryAfterSeconds property on error */\nconst getRetryDelaySecondsFromError = (error) => error === null || error === void 0 ? void 0 : error.retryAfterSeconds;\n/** Check retryAfterSeconds property on error and convert to ms */\nconst getRetryDelayFromError = (error) => (error === null || error === void 0 ? void 0 : error.retryAfterSeconds) !== undefined ?\n    error.retryAfterSeconds * 1000 : undefined;\n//# sourceMappingURL=network.js.map\n\n/***/ }),\n/* 118 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarizerHandle\": () => (/* binding */ SummarizerHandle)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// TODO #2425 Expose Summarizer handle as FluidObjectHandle w/ tests\nclass SummarizerHandle extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidObjectHandle {\n    async get() {\n        throw Error(\"Do not try to get a summarizer object from the handle. Reference it directly.\");\n    }\n    attach() {\n        return;\n    }\n    bind(handle) {\n        return;\n    }\n}\n//# sourceMappingURL=summarizerHandle.js.map\n\n/***/ }),\n/* 119 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoaderHeader\": () => (/* binding */ LoaderHeader)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Accepted header keys for requests coming to the Loader\n */\nvar LoaderHeader;\n(function (LoaderHeader) {\n    /**\n     * Override the Loader's default caching behavior for this container.\n     */\n    LoaderHeader[\"cache\"] = \"fluid-cache\";\n    LoaderHeader[\"clientDetails\"] = \"fluid-client-details\";\n    /**\n     * Start the container in a paused, unconnected state. Defaults to false\n     */\n    LoaderHeader[\"loadMode\"] = \"loadMode\";\n    LoaderHeader[\"reconnect\"] = \"fluid-reconnect\";\n    LoaderHeader[\"sequenceNumber\"] = \"fluid-sequence-number\";\n    /**\n     * One of the following:\n     * null or \"null\": use ops, no snapshots\n     * undefined: fetch latest snapshot\n     * otherwise, version sha to load snapshot\n     */\n    LoaderHeader[\"version\"] = \"version\";\n})(LoaderHeader || (LoaderHeader = {}));\n//# sourceMappingURL=loader.js.map\n\n/***/ }),\n/* 120 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DriverHeader\": () => (/* binding */ DriverHeader)\n/* harmony export */ });\n/**\n * Additional key in the loader request header\n */\nvar DriverHeader;\n(function (DriverHeader) {\n    // Key to indicate whether the request for summarizer\n    DriverHeader[\"summarizingClient\"] = \"fluid-client-summarizer\";\n    // createNew information, specific to each driver\n    DriverHeader[\"createNew\"] = \"createNew\";\n})(DriverHeader || (DriverHeader = {}));\n//# sourceMappingURL=urlResolver.js.map\n\n/***/ }),\n/* 121 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RunningSummarizer\": () => (/* binding */ RunningSummarizer)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(123);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);\n/* harmony import */ var _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);\n/* harmony import */ var _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\n\n\nconst maxSummarizeAckWaitTime = 10 * 60 * 1000; // 10 minutes\n/**\n * An instance of RunningSummarizer manages the heuristics for summarizing.\n * Until disposed, the instance of RunningSummarizer can assume that it is\n * in a state of running, meaning it is connected and initialized.  It keeps\n * track of summaries that it is generating as they are broadcast and acked/nacked.\n * This object is created and controlled by Summarizer object.\n */\nclass RunningSummarizer {\n    constructor(baseLogger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {\n        this.summaryWatcher = summaryWatcher;\n        this.configuration = configuration;\n        this.submitSummaryCallback = submitSummaryCallback;\n        this.heuristicData = heuristicData;\n        this.raiseSummarizingError = raiseSummarizingError;\n        this.summaryCollection = summaryCollection;\n        this.cancellationToken = cancellationToken;\n        this.stopSummarizerCallback = stopSummarizerCallback;\n        this.stopping = false;\n        this._disposed = false;\n        this.tryWhileSummarizing = false;\n        this.summarizeCount = 0;\n        this.totalSuccessfulAttempts = 0;\n        /**\n         * RunningSummarizer's logger includes the sequenced index of the current summary on each event.\n         * If some other Summarizer code wants that event on their logs they can get it here,\n         * but only if they're logging about that same summary.\n         * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct\n         */\n        this.tryGetCorrelatedLogger = (summaryOpRefSeq) => this.heuristicData.lastAttempt.refSequenceNumber === summaryOpRefSeq\n            ? this.logger\n            : undefined;\n        const telemetryProps = {\n            summarizeCount: () => this.summarizeCount,\n            summarizerSuccessfulAttempts: () => this.totalSuccessfulAttempts,\n        };\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(baseLogger, \"Running\", {\n            all: telemetryProps,\n        });\n        if (configuration.state !== \"disableHeuristics\") {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.configuration.state === \"enabled\", 0x2ea /* \"Configuration state should be enabled\" */);\n            this.heuristicRunner = new _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_2__.SummarizeHeuristicRunner(heuristicData, this.configuration, (reason) => this.trySummarize(reason), this.logger);\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.configuration.state !== \"disabled\", 0x2eb /* \"Summary not supported with configuration disabled\" */);\n        // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime\n        // configuration.maxAckWaitTime is composed from defaults, server values, and runtime overrides\n        const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);\n        this.pendingAckTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.PromiseTimer(maxAckWaitTime, () => {\n            // pre-0.58 error message: summaryAckWaitTimeout\n            this.raiseSummarizingError(\"Pending summary ack not received in time\");\n            // Note: summarizeCount (from ChildLogger definition) may be 0,\n            // since this code path is hit when RunningSummarizer first starts up,\n            // before this instance has kicked off a new summarize run.\n            this.logger.sendErrorEvent({\n                eventName: \"SummaryAckWaitTimeout\",\n                maxAckWaitTime,\n                referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,\n                summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,\n                timePending: Date.now() - this.heuristicData.lastAttempt.summaryTime,\n            });\n        });\n        // Set up pending ack timeout by op timestamp differences for previous summaries.\n        summaryCollection.setPendingAckTimerTimeoutCallback(maxAckWaitTime, () => {\n            if (this.pendingAckTimer.hasTimer) {\n                this.logger.sendTelemetryEvent({\n                    eventName: \"MissingSummaryAckFoundByOps\",\n                    referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,\n                    summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,\n                });\n                this.pendingAckTimer.clear();\n            }\n        });\n        this.generator = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummaryGenerator(this.pendingAckTimer, this.heuristicData, this.submitSummaryCallback, this.raiseSummarizingError, () => { this.totalSuccessfulAttempts++; }, this.summaryWatcher, this.logger);\n    }\n    static async start(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {\n        var _a;\n        const summarizer = new RunningSummarizer(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback);\n        await summarizer.waitStart();\n        // Run the heuristics after starting\n        (_a = summarizer.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();\n        return summarizer;\n    }\n    get disposed() { return this._disposed; }\n    dispose() {\n        var _a;\n        this.summaryWatcher.dispose();\n        (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.heuristicRunner = undefined;\n        this.generator.dispose();\n        this.pendingAckTimer.clear();\n        this.disposeEnqueuedSummary();\n        this._disposed = true;\n        this.stopping = true;\n    }\n    handleSystemOp(op) {\n        switch (op.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.ClientLeave:\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.ClientJoin:\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.Propose: {\n                // Synchronously handle quorum ops like regular ops\n                this.handleOp(undefined, op);\n                return;\n            }\n            default: {\n                return;\n            }\n        }\n    }\n    handleOp(error, { sequenceNumber, type, clientId, contents }) {\n        var _a;\n        if (error !== undefined) {\n            return;\n        }\n        this.heuristicData.lastOpSequenceNumber = sequenceNumber;\n        // Check for enqueued on-demand summaries; Intentionally do nothing otherwise\n        if (!this.tryRunEnqueuedSummary()) {\n            (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();\n        }\n    }\n    async waitStop(allowLastSummary) {\n        var _a;\n        if (this.stopping) {\n            return;\n        }\n        this.stopping = true;\n        this.disposeEnqueuedSummary();\n        // This will try to run lastSummary if needed.\n        if (allowLastSummary && ((_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.shouldRunLastSummary())) {\n            if (this.summarizingLock === undefined) {\n                this.trySummarizeOnce(\n                // summarizeProps\n                { reason: \"lastSummary\" }, \n                // ISummarizeOptions, using defaults: { refreshLatestAck: false, fullTree: false }\n                {});\n            }\n        }\n        // Note that trySummarizeOnce() call above returns right away, without waiting.\n        // So we need to wait for its completion, otherwise it would be destroyed right away.\n        // That said, if summary lock was taken upfront, this wait might wait on  multiple retries to\n        // submit summary. We should reconsider this flow and make summarizer move to exit faster.\n        // This resolves when the current pending summary gets an ack or fails.\n        await this.summarizingLock;\n    }\n    async waitStart() {\n        // Wait no longer than ack timeout for all pending\n        const waitStartResult = await (0,_summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.raceTimer)(this.summaryWatcher.waitFlushed(), this.pendingAckTimer.start());\n        this.pendingAckTimer.clear();\n        // Remove pending ack wait timeout by op timestamp comparison, because\n        // it has race conditions with summaries submitted by this same client.\n        this.summaryCollection.unsetPendingAckTimerTimeoutCallback();\n        if (waitStartResult.result === \"done\" && waitStartResult.value !== undefined) {\n            this.heuristicData.updateWithLastSummaryAckInfo({\n                refSequenceNumber: waitStartResult.value.summaryOp.referenceSequenceNumber,\n                // This will be the Summarizer starting point so only use timestamps from client's machine.\n                summaryTime: Date.now(),\n                summarySequenceNumber: waitStartResult.value.summaryOp.sequenceNumber,\n            });\n        }\n    }\n    /**\n     * Blocks a new summarizer from running in case RefreshSummaryAck is being processed.\n     * Assumes that caller checked upfront for lack of concurrent action (this.refreshSummaryAckLock)\n     * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.\n     * Note: The refreshSummaryAckLock makes sure no summarizer gets enqueued or processed\n     * until the refresh has completed. One can't rely uniquely on the summarizingLock as the\n     * refreshLatestSummaryAck also happens during the time summarizingLock !== undefined.\n     * Ex. Summarizer submits a summay + op and then waits for the Summary Ack to proceed\n     * with the refreshLatestSummaryAck and complete the summary.\n     * @param action - action to perform.\n     * @returns - result of action.\n     */\n    async lockedRefreshSummaryAckAction(action) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.refreshSummaryAckLock === undefined, \"Refresh Summary Ack - Caller is responsible for checking lock\");\n        const refreshSummaryAckLock = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.Deferred();\n        this.refreshSummaryAckLock = refreshSummaryAckLock.promise;\n        return action().finally(() => {\n            refreshSummaryAckLock.resolve();\n            this.refreshSummaryAckLock = undefined;\n        });\n    }\n    /**\n     * Runs single summary action that prevents any other concurrent actions.\n     * Assumes that caller checked upfront for lack of concurrent action (this.summarizingLock)\n     * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.\n     * @param action - action to perform.\n     * @returns - result of action.\n     */\n    async lockedSummaryAction(action) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.summarizingLock === undefined, 0x25b /* \"Caller is responsible for checking lock\" */);\n        const summarizingLock = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.Deferred();\n        this.summarizingLock = summarizingLock.promise;\n        this.summarizeCount++;\n        // Make sure the RefreshLatestSummaryAck is not being executed.\n        await this.refreshSummaryAckLock;\n        return action().finally(() => {\n            var _a;\n            summarizingLock.resolve();\n            this.summarizingLock = undefined;\n            const retry = this.tryWhileSummarizing;\n            this.tryWhileSummarizing = false;\n            // After summarizing, we should check to see if we need to summarize again.\n            // Rerun the heuristics and check for enqueued summaries.\n            if (!this.stopping && !this.tryRunEnqueuedSummary() && retry) {\n                (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();\n            }\n        });\n    }\n    /**\n     * Runs single summarize attempt\n     * @param summarizeProps - props to log with each telemetry event associated with this attempt\n     * @param options - summary options\n     * @param cancellationToken - cancellation token to use to be able to cancel this summary, if needed\n     * @param resultsBuilder - optional, result builder to use.\n     * @returns ISummarizeResult - result of running a summary.\n     */\n    trySummarizeOnce(summarizeProps, options, cancellationToken = this.cancellationToken, resultsBuilder = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder()) {\n        this.lockedSummaryAction(async () => {\n            const summarizeResult = this.generator.summarize(summarizeProps, options, cancellationToken, resultsBuilder);\n            // ensure we wait till the end of the process\n            return summarizeResult.receivedSummaryAckOrNack;\n        }).catch((error) => {\n            // SummaryGenerator.summarize() does not throw exceptions - it converts them to failed result\n            // on resultsBuilder\n            // We do not care about exceptions on receivedSummaryAckOrNack - caller should check results\n            // and take a appropriate action.\n        });\n        return resultsBuilder.build();\n    }\n    /** Heuristics summarize attempt. */\n    trySummarize(reason, cancellationToken = this.cancellationToken) {\n        if (this.summarizingLock !== undefined) {\n            // lockedSummaryAction() will retry heuristic-based summary at the end of current attempt\n            // if it's still needed\n            this.tryWhileSummarizing = true;\n            return;\n        }\n        this.lockedSummaryAction(async () => {\n            const attempts = [\n                { refreshLatestAck: false, fullTree: false },\n                { refreshLatestAck: true, fullTree: false },\n                { refreshLatestAck: true, fullTree: false, delaySeconds: 2 * 60 },\n                { refreshLatestAck: true, fullTree: true, delaySeconds: 10 * 60 },\n            ];\n            let overrideDelaySeconds;\n            let summaryAttempts = 0;\n            let summaryAttemptsPerPhase = 0;\n            let lastResult;\n            for (let summaryAttemptPhase = 0; summaryAttemptPhase < attempts.length;) {\n                if (this.cancellationToken.cancelled) {\n                    return;\n                }\n                // We only want to attempt 1 summary when reason is \"lastSummary\"\n                if (++summaryAttempts > 1 && reason === \"lastSummary\") {\n                    return;\n                }\n                summaryAttemptsPerPhase++;\n                const _a = attempts[summaryAttemptPhase], { delaySeconds: regularDelaySeconds = 0 } = _a, options = __rest(_a, [\"delaySeconds\"]);\n                const delaySeconds = overrideDelaySeconds !== null && overrideDelaySeconds !== void 0 ? overrideDelaySeconds : regularDelaySeconds;\n                const summarizeProps = Object.assign({ reason,\n                    summaryAttempts,\n                    summaryAttemptsPerPhase, summaryAttemptPhase: summaryAttemptPhase + 1 }, options);\n                if (delaySeconds > 0) {\n                    this.logger.sendPerformanceEvent(Object.assign({ eventName: \"SummarizeAttemptDelay\", duration: delaySeconds, summaryNackDelay: overrideDelaySeconds !== undefined }, summarizeProps));\n                    await (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.delay)(delaySeconds * 1000);\n                }\n                // Make sure the refresh Summary Ack is not being executed.\n                await this.refreshSummaryAckLock;\n                // Note: no need to account for cancellationToken.waitCancelled here, as\n                // this is accounted SummaryGenerator.summarizeCore that controls receivedSummaryAckOrNack.\n                const resultSummarize = this.generator.summarize(summarizeProps, options, cancellationToken);\n                const result = await resultSummarize.receivedSummaryAckOrNack;\n                if (result.success) {\n                    return;\n                }\n                // Check for retryDelay that can come from summaryNack or upload summary flow.\n                // Retry the same step only once per retryAfter response.\n                overrideDelaySeconds = result.retryAfterSeconds;\n                if (overrideDelaySeconds === undefined || summaryAttemptsPerPhase > 1) {\n                    summaryAttemptPhase++;\n                    summaryAttemptsPerPhase = 0;\n                }\n                lastResult = result;\n            }\n            // If all attempts failed, log error (with last attempt info) and close the summarizer container\n            this.logger.sendErrorEvent({\n                eventName: \"FailToSummarize\",\n                reason,\n                message: lastResult === null || lastResult === void 0 ? void 0 : lastResult.message,\n            }, lastResult === null || lastResult === void 0 ? void 0 : lastResult.error);\n            this.stopSummarizerCallback(\"failToSummarize\");\n        }).catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"UnexpectedSummarizeError\" }, error);\n        });\n    }\n    /** {@inheritdoc (ISummarizer:interface).summarizeOnDemand} */\n    summarizeOnDemand(resultsBuilder = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder(), _a) {\n        var { reason } = _a, options = __rest(_a, [\"reason\"]);\n        if (this.stopping) {\n            resultsBuilder.fail(\"RunningSummarizer stopped or disposed\", undefined);\n            return resultsBuilder.build();\n        }\n        // Check for concurrent summary attempts. If one is found,\n        // return a promise that caller can await before trying again.\n        if (this.summarizingLock !== undefined) {\n            // The heuristics are blocking concurrent summarize attempts.\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.UsageError(\"Attempted to run an already-running summarizer on demand\");\n        }\n        const result = this.trySummarizeOnce({ reason: `onDemand/${reason}` }, options, this.cancellationToken, resultsBuilder);\n        return result;\n    }\n    /** {@inheritdoc (ISummarizer:interface).enqueueSummarize} */\n    enqueueSummarize(_a) {\n        var { reason, afterSequenceNumber = 0, override = false } = _a, options = __rest(_a, [\"reason\", \"afterSequenceNumber\", \"override\"]);\n        const onDemandReason = `enqueue;${reason}`;\n        let overridden = false;\n        if (this.enqueuedSummary !== undefined) {\n            if (!override) {\n                return { alreadyEnqueued: true };\n            }\n            // Override existing enqueued summarize attempt.\n            this.enqueuedSummary.resultsBuilder.fail(\"Aborted; overridden by another enqueue summarize attempt\", undefined);\n            this.enqueuedSummary = undefined;\n            overridden = true;\n        }\n        this.enqueuedSummary = {\n            reason: onDemandReason,\n            afterSequenceNumber,\n            options,\n            resultsBuilder: new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder(),\n        };\n        const results = this.enqueuedSummary.resultsBuilder.build();\n        this.tryRunEnqueuedSummary();\n        return overridden ? Object.assign(Object.assign({}, results), { alreadyEnqueued: true, overridden: true }) : results;\n    }\n    tryRunEnqueuedSummary() {\n        if (this.stopping) {\n            this.disposeEnqueuedSummary();\n            return false;\n        }\n        if (this.enqueuedSummary === undefined\n            || this.heuristicData.lastOpSequenceNumber < this.enqueuedSummary.afterSequenceNumber\n            || this.summarizingLock !== undefined) {\n            // If no enqueued summary is ready or a summary is already in progress, take no action.\n            return false;\n        }\n        const { reason, resultsBuilder, options } = this.enqueuedSummary;\n        // Set to undefined first, so that subsequent enqueue attempt while summarize will occur later.\n        this.enqueuedSummary = undefined;\n        this.trySummarizeOnce({ reason: `enqueuedSummary/${reason}` }, options, this.cancellationToken, resultsBuilder);\n        return true;\n    }\n    disposeEnqueuedSummary() {\n        if (this.enqueuedSummary !== undefined) {\n            this.enqueuedSummary.resultsBuilder.fail(\"RunningSummarizer stopped or disposed\", undefined);\n            this.enqueuedSummary = undefined;\n        }\n    }\n}\n//# sourceMappingURL=runningSummarizer.js.map\n\n/***/ }),\n/* 122 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarizeHeuristicData\": () => (/* binding */ SummarizeHeuristicData),\n/* harmony export */   \"SummarizeHeuristicRunner\": () => (/* binding */ SummarizeHeuristicRunner)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/** Simple implementation of class for tracking summarize heuristic data. */\nclass SummarizeHeuristicData {\n    constructor(lastOpSequenceNumber, \n    /** Baseline attempt data used for comparisons with subsequent attempts/calculations. */\n    attemptBaseline) {\n        this.lastOpSequenceNumber = lastOpSequenceNumber;\n        this._lastAttempt = attemptBaseline;\n        this._lastSuccessfulSummary = Object.assign({}, attemptBaseline);\n    }\n    get lastAttempt() {\n        return this._lastAttempt;\n    }\n    get lastSuccessfulSummary() {\n        return this._lastSuccessfulSummary;\n    }\n    updateWithLastSummaryAckInfo(lastSummary) {\n        this._lastAttempt = lastSummary;\n        this._lastSuccessfulSummary = Object.assign({}, lastSummary);\n    }\n    recordAttempt(refSequenceNumber) {\n        this._lastAttempt = {\n            refSequenceNumber: refSequenceNumber !== null && refSequenceNumber !== void 0 ? refSequenceNumber : this.lastOpSequenceNumber,\n            summaryTime: Date.now(),\n        };\n    }\n    markLastAttemptAsSuccessful() {\n        this._lastSuccessfulSummary = Object.assign({}, this.lastAttempt);\n    }\n}\n/**\n * This class contains the heuristics for when to summarize.\n */\nclass SummarizeHeuristicRunner {\n    constructor(heuristicData, configuration, trySummarize, logger) {\n        this.heuristicData = heuristicData;\n        this.configuration = configuration;\n        this.trySummarize = trySummarize;\n        this.logger = logger;\n        this.idleTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Timer(this.configuration.idleTime, () => this.trySummarize(\"idle\"));\n        this.minOpsForLastSummaryAttempt = this.configuration.minOpsForLastSummaryAttempt;\n    }\n    get opsSinceLastAck() {\n        return this.heuristicData.lastOpSequenceNumber - this.heuristicData.lastSuccessfulSummary.refSequenceNumber;\n    }\n    run() {\n        const timeSinceLastSummary = Date.now() - this.heuristicData.lastSuccessfulSummary.summaryTime;\n        const opsSinceLastAck = this.opsSinceLastAck;\n        if (timeSinceLastSummary > this.configuration.maxTime) {\n            this.idleTimer.clear();\n            this.trySummarize(\"maxTime\");\n        }\n        else if (opsSinceLastAck > this.configuration.maxOps) {\n            this.idleTimer.clear();\n            this.trySummarize(\"maxOps\");\n        }\n        else {\n            this.idleTimer.restart();\n        }\n    }\n    shouldRunLastSummary() {\n        const opsSinceLastAck = this.opsSinceLastAck;\n        const minOpsForLastSummaryAttempt = this.minOpsForLastSummaryAttempt;\n        this.logger.sendTelemetryEvent({\n            eventName: \"ShouldRunLastSummary\",\n            opsSinceLastAck,\n            minOpsForLastSummaryAttempt,\n        });\n        return opsSinceLastAck >= minOpsForLastSummaryAttempt;\n    }\n    dispose() {\n        this.idleTimer.clear();\n    }\n}\n//# sourceMappingURL=summarizerHeuristics.js.map\n\n/***/ }),\n/* 123 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"delay\": () => (/* binding */ delay)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Returns a promise that resolves after timeMs\n * @param timeMs - time in milliseconds to wait\n */\nconst delay = async (timeMs) => new Promise((resolve) => setTimeout(() => resolve(), timeMs));\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n/* 124 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RunWhileConnectedCoordinator\": () => (/* binding */ RunWhileConnectedCoordinator),\n/* harmony export */   \"neverCancelledSummaryToken\": () => (/* binding */ neverCancelledSummaryToken)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Can be useful in testing as well as in places where caller does not use cancellation.\n * This object implements ISummaryCancellationToken interface but cancellation is never leveraged.\n */\nconst neverCancelledSummaryToken = {\n    cancelled: false,\n    waitCancelled: new Promise(() => { }),\n};\n/**\n * Helper class to coordinate something that needs to run only while connected.\n * This provides promises that resolve as it starts or stops.  Stopping happens\n * when disconnected or if stop() is called.\n */\nclass RunWhileConnectedCoordinator {\n    constructor(runtime) {\n        this.runtime = runtime;\n        this._cancelled = false;\n        this.stopDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n    }\n    get cancelled() {\n        if (!this._cancelled) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime.deltaManager.active, 0x25d /* \"We should never connect as 'read'\" */);\n            // This check can't be enabled in current design due to lastSummary flow, where\n            // summarizer for closed container stays around and can produce one more summary.\n            // Currently we solve the problem of overlapping summarizer by doing wait in\n            // SummaryManager.createSummarizer()\n            // Better solution would involve these steps:\n            // 1. Summarizer selection logic should chose summarizing client (with clientType === \"summarizer\")\n            // if such client exists.\n            // 2. Summarizer should be updated about such changes (to update onBehalfOfClientId)\n            //\n            // assert(this.runtime.summarizerClientId === this.onBehalfOfClientId ||\n            //    this.runtime.summarizerClientId === this.runtime.clientId, \"onBehalfOfClientId\");\n        }\n        return this._cancelled;\n    }\n    /**\n     * Returns a promise that resolves once stopped either externally or by disconnect.\n     */\n    get waitCancelled() {\n        return this.stopDeferred.promise;\n    }\n    static async create(runtime) {\n        const obj = new RunWhileConnectedCoordinator(runtime);\n        await obj.waitStart();\n        return obj;\n    }\n    /**\n     * Starts and waits for a promise which resolves when connected.\n     * The promise will also resolve if stopped either externally or by disconnect.\n     *\n     * We only listen on disconnected event for clientType === \"summarizer\" container!\n     * And only do it here - no other place should check it! That way we have only one place\n     * that controls policy and it's easy to change policy in the future if we want to!\n     * We do not listen for \"main\" (aka interactive) container disconnect here, as it's\n     * responsibility of SummaryManager to decide if that's material or not. There are cases\n     * like \"lastSummary\", or main client experiencing nacks / disconnects due to hitting limit\n     * of non-summarized ops, where can make determination to continue with summary even if main\n     * client is disconnected.\n     */\n    async waitStart() {\n        if (this.runtime.disposed) {\n            this.stop(\"summarizerClientDisconnected\");\n            return;\n        }\n        this.runtime.once(\"dispose\", () => this.stop(\"summarizerClientDisconnected\"));\n        if (!this.runtime.connected) {\n            const waitConnected = new Promise((resolve) => this.runtime.once(\"connected\", resolve));\n            await Promise.race([waitConnected, this.waitCancelled]);\n        }\n        this.runtime.once(\"disconnected\", () => this.stop(\"summarizerClientDisconnected\"));\n    }\n    /**\n     * Stops running.\n     */\n    stop(reason) {\n        if (!this._cancelled) {\n            this._cancelled = true;\n            this.stopDeferred.resolve(reason);\n        }\n    }\n}\n//# sourceMappingURL=runWhileConnectedCoordinator.js.map\n\n/***/ }),\n/* 125 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryManager\": () => (/* binding */ SummaryManager),\n/* harmony export */   \"SummaryManagerState\": () => (/* binding */ SummaryManagerState)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nconst defaultInitialDelayMs = 5000;\nconst defaultOpsToBypassInitialDelay = 4000;\nvar SummaryManagerState;\n(function (SummaryManagerState) {\n    SummaryManagerState[SummaryManagerState[\"Off\"] = 0] = \"Off\";\n    SummaryManagerState[SummaryManagerState[\"Starting\"] = 1] = \"Starting\";\n    SummaryManagerState[SummaryManagerState[\"Running\"] = 2] = \"Running\";\n    SummaryManagerState[SummaryManagerState[\"Stopping\"] = 3] = \"Stopping\";\n})(SummaryManagerState || (SummaryManagerState = {}));\n/**\n * SummaryManager is created by parent container (i.e. interactive container with clientType !== \"summarizer\") only.\n * It observes changes in calculated summarizer and reacts to changes by either creating summarizer client or\n * stopping existing summarizer client.\n */\nclass SummaryManager {\n    constructor(clientElection, connectedState, summaryCollection, parentLogger, \n    /** Creates summarizer by asking interactive container to spawn summarizing container and\n     * get back its Summarizer instance. */\n    requestSummarizerFn, startThrottler, { initialDelayMs = defaultInitialDelayMs, opsToBypassInitialDelay = defaultOpsToBypassInitialDelay, } = {}, disableHeuristics) {\n        this.clientElection = clientElection;\n        this.connectedState = connectedState;\n        this.summaryCollection = summaryCollection;\n        this.requestSummarizerFn = requestSummarizerFn;\n        this.startThrottler = startThrottler;\n        this.disableHeuristics = disableHeuristics;\n        this.state = SummaryManagerState.Off;\n        this._disposed = false;\n        this.handleConnected = (clientId) => {\n            this.latestClientId = clientId;\n            // If we have a summarizer, it should have been either cancelled on disconnected by now.\n            // But because of lastSummary process, it can still hang around, so there is not much we can\n            // check or assert.\n            this.refreshSummarizer();\n        };\n        this.handleDisconnected = () => {\n            this.refreshSummarizer();\n        };\n        this.refreshSummarizer = () => {\n            // Transition states depending on shouldSummarize, which is a calculated property\n            // that is only true if this client is connected and is the elected summarizer.\n            const shouldSummarizeState = this.getShouldSummarizeState();\n            switch (this.state) {\n                case SummaryManagerState.Off: {\n                    if (shouldSummarizeState.shouldSummarize) {\n                        this.startSummarization();\n                    }\n                    return;\n                }\n                case SummaryManagerState.Starting: {\n                    // Cannot take any action until summarizer is created\n                    // state transition will occur after creation\n                    return;\n                }\n                case SummaryManagerState.Running: {\n                    if (shouldSummarizeState.shouldSummarize === false) {\n                        this.stop(shouldSummarizeState.stopReason);\n                    }\n                    return;\n                }\n                case SummaryManagerState.Stopping: {\n                    // Cannot take any action until running summarizer finishes\n                    // state transition will occur after it stops\n                    return;\n                }\n                default: {\n                    return;\n                }\n            }\n        };\n        this.summarizeOnDemand = (...args) => {\n            if (this.summarizer === undefined) {\n                throw Error(\"No running summarizer client\");\n                // TODO: could spawn a summarizer client temporarily.\n            }\n            return this.summarizer.summarizeOnDemand(...args);\n        };\n        this.enqueueSummarize = (...args) => {\n            if (this.summarizer === undefined) {\n                throw Error(\"No running summarizer client\");\n                // TODO: could spawn a summarizer client temporarily.\n            }\n            return this.summarizer.enqueueSummarize(...args);\n        };\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(parentLogger, \"SummaryManager\", { all: { clientId: () => this.latestClientId } });\n        this.connectedState.on(\"connected\", this.handleConnected);\n        this.connectedState.on(\"disconnected\", this.handleDisconnected);\n        this.latestClientId = this.connectedState.clientId;\n        this.opsToBypassInitialDelay = opsToBypassInitialDelay;\n        this.initialDelayMs = initialDelayMs;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    get currentState() { return this.state; }\n    /**\n     * Until start is called, the SummaryManager won't begin attempting to start summarization.  This ensures there's\n     * a window between construction and starting where the caller can attach listeners.\n     */\n    start() {\n        this.clientElection.on(\"electedSummarizerChanged\", this.refreshSummarizer);\n        this.refreshSummarizer();\n    }\n    getShouldSummarizeState() {\n        // Note that if we're in the Running state, the electedClient may be a summarizer client, so we can't\n        // enforce connectedState.clientId === clientElection.electedClientId. But once we're Running, we should\n        // only transition to Stopping when the electedParentId changes. Stopping the summarizer without\n        // changing the electedParent will just cause us to transition to Starting again.\n        if (this.connectedState.clientId !== this.clientElection.electedParentId ||\n            (this.state !== SummaryManagerState.Running &&\n                this.connectedState.clientId !== this.clientElection.electedClientId)) {\n            return { shouldSummarize: false, stopReason: \"parentShouldNotSummarize\" };\n        }\n        else if (!this.connectedState.connected) {\n            return { shouldSummarize: false, stopReason: \"parentNotConnected\" };\n        }\n        else if (this.disposed) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(false, 0x260 /* \"Disposed should mean disconnected!\" */);\n        }\n        else {\n            return { shouldSummarize: true };\n        }\n    }\n    startSummarization() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryManagerState.Off, 0x261 /* \"Expected: off\" */);\n        this.state = SummaryManagerState.Starting;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.summarizer === undefined, 0x262 /* \"Old summarizer is still working!\" */);\n        this.delayBeforeCreatingSummarizer().then(async (startWithInitialDelay) => {\n            // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore\n            // but only if creation was delayed. If it was not, then we want to ensure we always create\n            // a summarizer to kick off lastSummary. Without that, we would not be able to summarize and get\n            // document out of broken state if it has too many ops and ordering service keeps nacking main\n            // container (and thus it goes into cycle of reconnects)\n            if (startWithInitialDelay && this.getShouldSummarizeState().shouldSummarize === false) {\n                return \"early exit\";\n            }\n            // We transition to Running before requesting the summarizer, because after requesting we can't predict\n            // when the electedClient will be replaced with the new summarizer client.\n            // The alternative would be to let connectedState.clientId !== clientElection.electedClientId when\n            // state === Starting || state === Running.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryManagerState.Starting, 0x263 /* \"Expected: starting\" */);\n            this.state = SummaryManagerState.Running;\n            const summarizer = await this.requestSummarizerFn();\n            this.summarizer = summarizer;\n            // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore\n            const shouldSummarizeState = this.getShouldSummarizeState();\n            if (shouldSummarizeState.shouldSummarize === false) {\n                this.state = SummaryManagerState.Starting;\n                summarizer.stop(shouldSummarizeState.stopReason);\n                return \"early exit after starting summarizer\";\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clientId = this.latestClientId;\n            return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.PerformanceEvent.timedExecAsync(this.logger, { eventName: \"RunningSummarizer\", attempt: this.startThrottler.numAttempts }, async () => summarizer.run(clientId, this.disableHeuristics));\n        }).then((reason) => {\n            this.logger.sendTelemetryEvent({\n                eventName: \"EndingSummarizer\",\n                reason,\n            });\n        }).catch((error) => {\n            this.logger.sendTelemetryEvent({\n                eventName: \"EndingSummarizer\",\n                reason: \"exception\",\n            }, error);\n            // Most of exceptions happen due to container being closed while loading it, due to\n            // summarizer container loosing connection while load.\n            // Not worth reporting such errors as errors. That said, we might miss some real errors if\n            // we ignore blindly, so try to narrow signature we are looking for - skip logging\n            // error only if this client should no longer be a summarizer (which in practice\n            // means it also lost connection), and error happened on load (we do not have summarizer).\n            // We could annotate the error raised in Container.load where the container closed during load with no error\n            // and check for that case here, but that does not seem to be necessary.\n            if (this.getShouldSummarizeState().shouldSummarize || this.summarizer !== undefined) {\n                // Report any failure as an error unless it was due to cancellation (like \"disconnected\" error)\n                // If failure happened on container load, we may not yet realized that socket disconnected, so check\n                // offlineError.\n                const category = (error === null || error === void 0 ? void 0 : error.errorType) === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__.DriverErrorType.offlineError ? \"generic\" : \"error\";\n                this.logger.sendTelemetryEvent({\n                    eventName: \"SummarizerException\",\n                    category,\n                }, error);\n            }\n        }).finally(() => {\n            var _a;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state !== SummaryManagerState.Off, 0x264 /* \"Expected: Not Off\" */);\n            this.state = SummaryManagerState.Off;\n            (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.close();\n            this.summarizer = undefined;\n            if (this.getShouldSummarizeState().shouldSummarize) {\n                this.startSummarization();\n            }\n        });\n    }\n    stop(reason) {\n        var _a;\n        if (!SummaryManager.isStartingOrRunning(this.state)) {\n            return;\n        }\n        this.state = SummaryManagerState.Stopping;\n        // Stopping the running summarizer client should trigger a change\n        // in states when the running summarizer closes\n        (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.stop(reason);\n    }\n    /**\n     * Implements initial delay before creating summarizer\n     * @returns true, if creation is delayed due to heuristics (not many ops to summarize).\n     *          False if summarizer should start immediately due to too many unsummarized ops.\n     */\n    async delayBeforeCreatingSummarizer() {\n        // throttle creation of new summarizer containers to prevent spamming the server with websocket connections\n        let delayMs = this.startThrottler.getDelay();\n        // We have been elected the summarizer. Some day we may be able to summarize with a live document but for\n        // now we play it safe and launch a second copy.\n        this.logger.sendTelemetryEvent({\n            eventName: \"CreatingSummarizer\",\n            throttlerDelay: delayMs,\n            initialDelay: this.initialDelayMs,\n            startThrottlerMaxDelayMs: this.startThrottler.maxDelayMs,\n            opsSinceLastAck: this.summaryCollection.opsSinceLastAck,\n            opsToBypassInitialDelay: this.opsToBypassInitialDelay,\n        });\n        // This delay helps ensure that last summarizer that might be left from previous client\n        // has enough time to complete its last summary and thus new summarizer not conflict with previous one.\n        // If, however, there are too many unsummarized ops, try to resolve it as quickly as possible, with\n        // understanding that we may see nacks because of such quick action.\n        // A better design would be for summarizer election logic to always select current summarizer as\n        // summarizing client (i.e. clientType === \"summarizer\" can be elected) to ensure that nobody else can\n        // summarizer while it finishes its work and moves to exit.\n        // It also helps with pure boot scenario (single client) to offset expensive work a bit out from\n        // critical boot sequence.\n        let startWithInitialDelay = false;\n        if (this.summaryCollection.opsSinceLastAck < this.opsToBypassInitialDelay) {\n            startWithInitialDelay = true;\n            delayMs = Math.max(delayMs, this.initialDelayMs);\n        }\n        if (delayMs > 0) {\n            let timer;\n            let resolveOpPromiseFn;\n            // Create a listener that will break the delay if we've exceeded the initial delay ops count.\n            const opsListenerFn = () => {\n                if (this.summaryCollection.opsSinceLastAck >= this.opsToBypassInitialDelay) {\n                    clearTimeout(timer);\n                    resolveOpPromiseFn();\n                }\n            };\n            // Create a Promise that will resolve when the delay expires.\n            const delayPromise = new Promise((resolve) => {\n                timer = setTimeout(() => resolve(), delayMs);\n            });\n            // Create a Promise that will resolve if the ops count passes the threshold.\n            const opPromise = new Promise((resolve) => { resolveOpPromiseFn = resolve; });\n            this.summaryCollection.addOpListener(opsListenerFn);\n            await Promise.race([delayPromise, opPromise]);\n            this.summaryCollection.removeOpListener(opsListenerFn);\n        }\n        return startWithInitialDelay;\n    }\n    dispose() {\n        this.clientElection.off(\"electedSummarizerChanged\", this.refreshSummarizer);\n        this.connectedState.off(\"connected\", this.handleConnected);\n        this.connectedState.off(\"disconnected\", this.handleDisconnected);\n        this._disposed = true;\n    }\n}\nSummaryManager.isStartingOrRunning = (state) => state === SummaryManagerState.Starting || state === SummaryManagerState.Running;\n//# sourceMappingURL=summaryManager.js.map\n\n/***/ }),\n/* 126 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Throttler\": () => (/* binding */ Throttler),\n/* harmony export */   \"formExponentialFn\": () => (/* binding */ formExponentialFn),\n/* harmony export */   \"formExponentialFnWithAttemptOffset\": () => (/* binding */ formExponentialFnWithAttemptOffset),\n/* harmony export */   \"formLinearFn\": () => (/* binding */ formLinearFn),\n/* harmony export */   \"formLinearFnWithAttemptOffset\": () => (/* binding */ formLinearFnWithAttemptOffset)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Used to give increasing delay times for throttling a single functionality.\n * Delay is based on previous attempts within specified time window, subtracting delay time.\n */\nclass Throttler {\n    constructor(\n    /** Width of sliding delay window in milliseconds. */\n    delayWindowMs, \n    /** Maximum delay allowed in milliseconds. */\n    maxDelayMs, \n    /**\n     * Delay function used to calculate what the delay should be.\n     * The input is the number of attempts that occurred within the sliding window.\n     * The result is the calculated delay in milliseconds.\n     */\n    delayFn) {\n        this.delayWindowMs = delayWindowMs;\n        this.maxDelayMs = maxDelayMs;\n        this.delayFn = delayFn;\n        this.startTimes = [];\n    }\n    get numAttempts() {\n        return this.startTimes.length;\n    }\n    /**\n     * Gets all attempt start times after compensating for the delay times\n     * by adding the delay times to the actual times.\n     */\n    getAttempts() {\n        return [...this.startTimes];\n    }\n    /**\n     * Latest attempt time after compensating for the delay time itself\n     * by adding the delay time to the actual time.\n     */\n    get latestAttemptTime() {\n        return this.startTimes.length > 0 ? this.startTimes[this.startTimes.length - 1] : undefined;\n    }\n    getDelay() {\n        const now = Date.now();\n        const latestAttemptTime = this.latestAttemptTime;\n        if (latestAttemptTime !== undefined) {\n            // If getDelay was called sooner than the most recent delay,\n            // subtract the remaining time, since we previously added it.\n            const earlyMs = latestAttemptTime - now;\n            if (earlyMs > 0) {\n                this.startTimes = this.startTimes.map((t) => t - earlyMs);\n            }\n        }\n        // Remove all attempts that have already fallen out of the window.\n        this.startTimes = this.startTimes.filter((t) => (now - t) < this.delayWindowMs);\n        // Compute delay, but do not exceed the specified max delay.\n        const delayMs = Math.min(this.delayFn(this.startTimes.length), this.maxDelayMs);\n        // Record this attempt start time.\n        this.startTimes.push(now);\n        // Account for the delay time, by effectively removing it from the delay window.\n        this.startTimes = this.startTimes.map((t) => t + delayMs);\n        if (delayMs === this.maxDelayMs) {\n            // We hit max delay, so adding more won't affect anything.\n            // Shift off oldest time to stop this array from growing forever.\n            this.startTimes.shift();\n        }\n        return delayMs;\n    }\n}\n/**\n * Helper function to generate simple exponential throttle functions.\n * f(n) = [coefficient] x ([multiplier]^n) + [flatOffset]\n * where n = number of attempts, and f(n) = delay time in milliseconds.\n * If not provided, coefficient will default to 1, multiplier to 2,\n * minimum delay to 0, and the offset to 0, yielding:\n * 0 ms, 2 ms, 4 ms, 8 ms, ..., 2^n ms\n * where M = multiplier; an exponential back-off.\n * Use initialDelay to decide what should happen when numAttempts is 0,\n * leave it undefined to not special case.\n */\nconst formExponentialFn = ({ multiplier = 2, coefficient = 1, offset = 0, initialDelay = undefined, } = {}) => (numAttempts) => Math.max(0, numAttempts <= 0 && initialDelay !== undefined\n    ? initialDelay\n    : coefficient * (Math.pow(multiplier, numAttempts)) + offset);\n/** f(n) = C x (B^(n+A)) + F = (C x B^A) x B^n + F */\nconst formExponentialFnWithAttemptOffset = (attemptOffset, { multiplier = 2, coefficient = 1, offset = 0, initialDelay = undefined, } = {}) => formExponentialFn({\n    multiplier,\n    coefficient: coefficient * Math.pow(multiplier, attemptOffset),\n    offset,\n    initialDelay,\n});\n/**\n * Helper function to generate simple linear throttle functions.\n * f(n) = [coefficient] x n + [flatOffset]\n * where n = number of attempts, and f(n) = delay time in milliseconds.\n * If not provided, coefficient will default to 1, and offset to 0, yielding:\n * 0 ms, 1 ms, 2 ms, 3 ms, ..., n ms delays; a linear back-off.\n */\nconst formLinearFn = ({ coefficient = 1, offset = 0, } = {}) => (numAttempts) => Math.max(0, coefficient * numAttempts + offset);\n/** f(n) = C x (n+A) + F = C x n + (C x A + F) */\nconst formLinearFnWithAttemptOffset = (attemptOffset, { coefficient = 1, offset = 0, } = {}) => formLinearFn({\n    coefficient,\n    offset: coefficient * attemptOffset + offset,\n});\n//# sourceMappingURL=throttler.js.map\n\n/***/ }),\n/* 127 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BatchTracker\": () => (/* binding */ BatchTracker),\n/* harmony export */   \"BindBatchTracker\": () => (/* binding */ BindBatchTracker)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass BatchTracker {\n    constructor(batchEventEmitter, logger, batchLengthThreshold, batchCountSamplingRate, dateTimeProvider = () => _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now()) {\n        this.batchEventEmitter = batchEventEmitter;\n        this.trackedBatchCount = 0;\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, \"Batching\");\n        this.batchEventEmitter.on(\"batchBegin\", (message) => {\n            this.startBatchSequenceNumber = message.sequenceNumber;\n            this.batchProcessingStartTimeStamp = dateTimeProvider();\n            this.trackedBatchCount++;\n        });\n        this.batchEventEmitter.on(\"batchEnd\", (error, message) => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startBatchSequenceNumber !== undefined && this.batchProcessingStartTimeStamp !== undefined, 0x2ba /* \"batchBegin must fire before batchEnd\" */);\n            const length = message.sequenceNumber - this.startBatchSequenceNumber + 1;\n            if (length >= batchLengthThreshold) {\n                this.logger.sendErrorEvent({\n                    eventName: \"LengthTooBig\",\n                    length,\n                    threshold: batchLengthThreshold,\n                    batchEndSequenceNumber: message.sequenceNumber,\n                    duration: dateTimeProvider() - this.batchProcessingStartTimeStamp,\n                    batchError: error !== undefined,\n                });\n            }\n            if (this.trackedBatchCount % batchCountSamplingRate === 0) {\n                this.logger.sendPerformanceEvent({\n                    eventName: \"Length\",\n                    length,\n                    samplingRate: batchCountSamplingRate,\n                    batchEndSequenceNumber: message.sequenceNumber,\n                    duration: dateTimeProvider() - this.batchProcessingStartTimeStamp,\n                });\n            }\n            this.startBatchSequenceNumber = undefined;\n            this.batchProcessingStartTimeStamp = undefined;\n        });\n    }\n}\n/**\n * Track batch sizes in terms of op counts and processing times\n *\n * @param batchEventEmitter - event emitter which tracks the lifecycle of batch operations\n * @param logger - logger\n * @param batchLengthThreshold - threshold for the length of a batch when to send an error event\n * @param batchCountSamplingRate - rate for batches for which to send an event with its characteristics\n * @returns\n */\nconst BindBatchTracker = (batchEventEmitter, logger, batchLengthThreshold = 1000, batchCountSamplingRate = 1000) => new BatchTracker(batchEventEmitter, logger, batchLengthThreshold, batchCountSamplingRate);\n//# sourceMappingURL=batchTracker.js.map\n\n/***/ }),\n/* 128 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OpTracker\": () => (/* binding */ OpTracker)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass OpTracker {\n    constructor(deltaManager, disabled) {\n        /**\n         * Used for storing the message content size when\n         * the message is pushed onto the inbound queue.\n         */\n        this.messageSize = new Map();\n        this._nonSystemOpCount = 0;\n        this._opsSizeAccumulator = 0;\n        if (disabled) {\n            return;\n        }\n        // Record the message content size when we receive it.\n        // We should not log this value, as summarization can happen between the time the message\n        // is received and until it is processed (the 'op' event).\n        deltaManager.inbound.on(\"push\", (message) => {\n            var _a;\n            // Some messages my already have string contents at this point,\n            // so stringifying them again will add inaccurate overhead.\n            const messageContent = typeof message.contents === \"string\" ?\n                message.contents :\n                (_a = JSON.stringify(message.contents)) !== null && _a !== void 0 ? _a : \"\";\n            const messageData = OpTracker.messageHasData(message) ? message.data : \"\";\n            this.messageSize[OpTracker.messageId(message)] = messageContent.length + messageData.length;\n        });\n        deltaManager.on(\"op\", (message) => {\n            var _a;\n            this._nonSystemOpCount += !(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.isRuntimeMessage)(message) ? 0 : 1;\n            const id = OpTracker.messageId(message);\n            this._opsSizeAccumulator += (_a = this.messageSize[id]) !== null && _a !== void 0 ? _a : 0;\n            this.messageSize.delete(id);\n        });\n    }\n    get nonSystemOpCount() {\n        return this._nonSystemOpCount;\n    }\n    get opsSizeAccumulator() {\n        return this._opsSizeAccumulator;\n    }\n    static messageId(message) {\n        return message.sequenceNumber;\n    }\n    static messageHasData(message) {\n        return message.data !== undefined;\n    }\n    reset() {\n        this._nonSystemOpCount = 0;\n        this._opsSizeAccumulator = 0;\n    }\n}\n//# sourceMappingURL=opTelemetry.js.map\n\n/***/ }),\n/* 129 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerializedSnapshotStorage\": () => (/* binding */ SerializedSnapshotStorage)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(130);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * A storage wrapper that can serialize blobs from a snapshot tree and then use them to rehydrate.\n * Used in offline load/attached dehydration to save snapshot blobs that are still needed but may have been deleted.\n */\nclass SerializedSnapshotStorage {\n    constructor(storageGetter, blobs) {\n        this.storageGetter = storageGetter;\n        this.blobs = blobs;\n    }\n    static async serializeTree(snapshot, storage) {\n        const blobs = {};\n        await this.serializeTreeCore(snapshot, blobs, storage);\n        return blobs;\n    }\n    static async serializeTreeCore(tree, blobs, storage) {\n        const treePs = [];\n        for (const subTree of Object.values(tree.trees)) {\n            treePs.push(this.serializeTreeCore(subTree, blobs, storage));\n        }\n        for (const id of Object.values(tree.blobs)) {\n            const blob = await storage.readBlob(id);\n            // ArrayBufferLike will not survive JSON.stringify()\n            blobs[id] = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, \"utf8\");\n        }\n        return Promise.all(treePs);\n    }\n    static serializeTreeWithBlobContents(snapshot) {\n        const blobs = {};\n        this.serializeTreeWithBlobContentsCore(snapshot, blobs);\n        return blobs;\n    }\n    static serializeTreeWithBlobContentsCore(tree, blobs) {\n        for (const subTree of Object.values(tree.trees)) {\n            this.serializeTreeWithBlobContentsCore(subTree, blobs);\n        }\n        for (const id of Object.values(tree.blobs)) {\n            const blob = tree.blobsContents[id];\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!blob, 0x2ec /* \"Blob must be present in blobsContents\" */);\n            // ArrayBufferLike will not survive JSON.stringify()\n            blobs[id] = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, \"utf8\");\n        }\n    }\n    get storage() {\n        // avoid calling it until we need it since it will be undefined if we're not connected\n        // and we shouldn't need it in this case anyway\n        if (this._storage) {\n            return this._storage;\n        }\n        this._storage = this.storageGetter();\n        return this._storage;\n    }\n    get repositoryUrl() { return this.storage.repositoryUrl; }\n    /**\n     * Reads the object with the given ID, returns content in arrayBufferLike\n     */\n    async readBlob(id) {\n        if (this.blobs[id] !== undefined) {\n            return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBuffer)(this.blobs[id], \"utf8\");\n        }\n        return this.storage.readBlob(id);\n    }\n    /**\n     * Returns the snapshot tree.\n     */\n    // eslint-disable-next-line @rushstack/no-new-null\n    async getSnapshotTree(version) {\n        return this.storage.getSnapshotTree(version);\n    }\n    /**\n     * Retrieves all versions of the document starting at the specified versionId - or null if from the head\n     */\n    // eslint-disable-next-line @rushstack/no-new-null\n    async getVersions(versionId, count) {\n        return this.storage.getVersions(versionId, count);\n    }\n    /**\n     * Creates a blob out of the given buffer\n     */\n    async createBlob(file) {\n        return this.storage.createBlob(file);\n    }\n    /**\n     * Uploads a summary tree to storage using the given context for reference of previous summary handle.\n     * The ISummaryHandles in the uploaded tree should have paths to indicate which summary object they are\n     * referencing from the previously acked summary.\n     * Returns the uploaded summary handle.\n     */\n    async uploadSummaryWithContext(summary, context) {\n        return this.storage.uploadSummaryWithContext(summary, context);\n    }\n    /**\n     * Retrieves the commit that matches the packfile handle. If the packfile has already been committed and the\n     * server has deleted it this call may result in a broken promise.\n     */\n    async downloadSummary(handle) {\n        return this.storage.downloadSummary(handle);\n    }\n}\n//# sourceMappingURL=serializedSnapshotStorage.js.map\n\n/***/ }),\n/* 130 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 131 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FluidDataStoreRegistry\": () => (/* binding */ FluidDataStoreRegistry)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass FluidDataStoreRegistry {\n    constructor(namedEntries) {\n        this.map = new Map();\n        for (const entry of namedEntries) {\n            if (this.map.has(entry[0])) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__.UsageError(\"Duplicate entry names exist\");\n            }\n            this.map.set(entry[0], entry[1]);\n        }\n    }\n    get IFluidDataStoreRegistry() { return this; }\n    async get(name) {\n        if (this.map.has(name)) {\n            return this.map.get(name);\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=dataStoreRegistry.js.map\n\n/***/ }),\n/* 132 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"connectedEventName\": () => (/* binding */ connectedEventName),\n/* harmony export */   \"disconnectedEventName\": () => (/* binding */ disconnectedEventName),\n/* harmony export */   \"raiseConnectedEvent\": () => (/* binding */ raiseConnectedEvent),\n/* harmony export */   \"safeRaiseEvent\": () => (/* binding */ safeRaiseEvent)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst connectedEventName = \"connected\";\nconst disconnectedEventName = \"disconnected\";\nfunction safeRaiseEvent(emitter, logger, event, ...args) {\n    try {\n        emitter.emit(event, ...args);\n    }\n    catch (error) {\n        logger.sendErrorEvent({ eventName: \"RaiseEventError\", event }, error);\n    }\n}\nfunction raiseConnectedEvent(logger, emitter, connected, clientId) {\n    try {\n        if (connected) {\n            emitter.emit(connectedEventName, clientId);\n        }\n        else {\n            emitter.emit(disconnectedEventName);\n        }\n    }\n    catch (error) {\n        logger.sendErrorEvent({ eventName: \"RaiseConnectedEventError\" }, error);\n    }\n}\n//# sourceMappingURL=events.js.map\n\n/***/ }),\n/* 133 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Trace\": () => (/* binding */ Trace)\n/* harmony export */ });\n/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Helper class for tracing performance of events\n * Time measurements are in milliseconds as a floating point with a decimal\n */\nclass Trace {\n    constructor(startTick) {\n        this.startTick = startTick;\n        this.lastTick = startTick;\n    }\n    static start() {\n        const startTick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        return new Trace(startTick);\n    }\n    trace() {\n        const tick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        const event = {\n            totalTimeElapsed: tick - this.startTick,\n            duration: tick - this.lastTick,\n            tick,\n        };\n        this.lastTick = tick;\n        return event;\n    }\n}\n//# sourceMappingURL=trace.js.map\n\n/***/ }),\n/* 134 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"seqFromTree\": () => (/* binding */ seqFromTree)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Fetches the sequence number of the snapshot tree by examining the protocol.\n * @param tree - snapshot tree to examine\n * @param readAndParseBlob - function to read blob contents from storage\n * and parse the result from JSON.\n */\nasync function seqFromTree(tree, readAndParseBlob) {\n    const attributesHash = tree.trees[\".protocol\"].blobs.attributes;\n    const attrib = await readAndParseBlob(attributesHash);\n    return attrib.sequenceNumber;\n}\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 135 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummarySerializer\": () => (/* binding */ SummarySerializer)\n/* harmony export */ });\n/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Serializer implementation for serializing handles during summary.\n */\nclass SummarySerializer extends _serializer__WEBPACK_IMPORTED_MODULE_0__.FluidSerializer {\n    constructor() {\n        super(...arguments);\n        this.serializedRoutes = new Set();\n    }\n    getSerializedRoutes() {\n        return Array.from(this.serializedRoutes);\n    }\n    serializeHandle(handle, bind) {\n        this.serializedRoutes.add(handle.absolutePath);\n        return super.serializeHandle(handle, bind);\n    }\n}\n//# sourceMappingURL=summarySerializer.js.map\n\n/***/ }),\n/* 136 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LocalValueMaker\": () => (/* binding */ LocalValueMaker),\n/* harmony export */   \"PlainLocalValue\": () => (/* binding */ PlainLocalValue),\n/* harmony export */   \"makeSerializable\": () => (/* binding */ makeSerializable)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(137);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nfunction makeSerializable(localValue, serializer, bind) {\n    const value = localValue.makeSerialized(serializer, bind);\n    return {\n        type: value.type,\n        value: value.value && JSON.parse(value.value),\n    };\n}\n/**\n * Manages a contained plain value.  May also contain shared object handles.\n */\nclass PlainLocalValue {\n    /**\n     * Create a new PlainLocalValue.\n     * @param value - The value to store, which may contain shared object handles\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * {@inheritDoc ILocalValue.\"type\"}\n     */\n    get type() {\n        return _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Plain];\n    }\n    /**\n     * {@inheritDoc ILocalValue.makeSerialized}\n     */\n    makeSerialized(serializer, bind) {\n        // Stringify to convert to the serialized handle values - and then parse in order to create\n        // a POJO for the op\n        const value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.serializeHandles)(this.value, serializer, bind);\n        return {\n            type: this.type,\n            value,\n        };\n    }\n}\n/**\n * A LocalValueMaker enables a container type DDS to produce and store local values with minimal awareness of how\n * those objects are stored, serialized, and deserialized.\n */\nclass LocalValueMaker {\n    /**\n     * Create a new LocalValueMaker.\n     * @param serializer - The serializer to serialize / parse handles.\n     */\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    /**\n     * Create a new local value from an incoming serialized value.\n     * @param serializable - The serializable value to make local\n     */\n    fromSerializable(serializable) {\n        // Migrate from old shared value to handles\n        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Shared]) {\n            serializable.type = _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Plain];\n            const handle = {\n                type: \"__fluid_handle__\",\n                url: serializable.value,\n            };\n            serializable.value = handle;\n        }\n        const translatedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.parseHandles)(serializable.value, this.serializer);\n        return new PlainLocalValue(translatedValue);\n    }\n    /**\n     * Create a new local value containing a given plain object.\n     * @param value - The value to store\n     * @returns An ILocalValue containing the value\n     */\n    fromInMemory(value) {\n        return new PlainLocalValue(value);\n    }\n}\n//# sourceMappingURL=localValues.js.map\n\n/***/ }),\n/* 137 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValueType\": () => (/* binding */ ValueType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * enum representing the possible types of a shared object\n */\nvar ValueType;\n(function (ValueType) {\n    /**\n     * The value is a shared object\n     * @deprecated Instead store the handle of the shared object, rather than the shared object itself.\n     */\n    ValueType[ValueType[\"Shared\"] = 0] = \"Shared\";\n    /**\n     * The value is a plain JavaScript object or handle.  If a plain object, it may contain handles deeper within.\n     */\n    ValueType[ValueType[\"Plain\"] = 1] = \"Plain\";\n})(ValueType || (ValueType = {}));\n//# sourceMappingURL=valueType.js.map\n\n/***/ }),\n/* 138 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createSingleBlobSummary\": () => (/* binding */ createSingleBlobSummary),\n/* harmony export */   \"makeHandlesSerializable\": () => (/* binding */ makeHandlesSerializable),\n/* harmony export */   \"parseHandles\": () => (/* binding */ parseHandles),\n/* harmony export */   \"serializeHandles\": () => (/* binding */ serializeHandles)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Given a mostly-plain object that may have handle objects embedded within, return a string representation of an object\n * where the handle objects have been replaced with a serializable form.\n * @param value - The mostly-plain object\n * @param serializer - The serializer that knows how to convert handles into serializable format\n * @param context - The handle context for the container\n * @param bind - Bind any other handles we find in the object against this given handle.\n * @returns Result of strigifying an object\n */\nfunction serializeHandles(value, serializer, bind) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value !== undefined\n        ? serializer.stringify(value, bind)\n        : value;\n}\n/**\n * Given a mostly-plain object that may have handle objects embedded within, will return a fully-plain object\n * where any embedded IFluidHandles have been replaced with a serializable form.\n *\n * The original `input` object is not mutated.  This method will shallowly clones all objects in the path from\n * the root to any replaced handles.  (If no handles are found, returns the original object.)\n *\n * @param input - The mostly-plain object\n * @param context - The handle context for the container\n * @param bind - Bind any other handles we find in the object against this given handle.\n * @returns The fully-plain object\n */\nfunction makeHandlesSerializable(value, serializer, bind) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return serializer.encode(value, bind);\n}\n/**\n * Given a fully-plain object that may have serializable-form handles within, will return the mostly-plain object\n * with handle objects created instead.\n * @param value - The fully-plain object\n * @param serializer - The serializer that knows how to convert serializable-form handles into handle objects\n * @param context - The handle context for the container\n * @returns The mostly-plain object with handle objects within\n */\nfunction parseHandles(value, serializer) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value !== undefined ? serializer.parse(JSON.stringify(value)) : value;\n}\n/**\n * Create a new summary containing one blob\n * @param key - the key for the blob in the summary\n * @param content - blob content\n * @returns The summary containing the blob\n */\nfunction createSingleBlobSummary(key, content) {\n    const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.SummaryTreeBuilder();\n    builder.addBlob(key, content);\n    return builder.getSummaryTree();\n}\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 139 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 140 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 141 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 142 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MapFactory\": () => (/* binding */ MapFactory),\n/* harmony export */   \"SharedMap\": () => (/* binding */ SharedMap)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(140);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);\n/* harmony import */ var _mapKernel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(143);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a;\n\n\n\n\n\n\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the map.\n * @sealed\n */\nclass MapFactory {\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n     */\n    get type() {\n        return MapFactory.Type;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n     */\n    get attributes() {\n        return MapFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const map = new SharedMap(id, runtime, attributes);\n        await map.load(services);\n        return map;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n     */\n    create(runtime, id) {\n        const map = new SharedMap(id, runtime, MapFactory.Attributes);\n        map.initializeLocal();\n        return map;\n    }\n}\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n */\nMapFactory.Type = \"https://graph.microsoft.com/types/map\";\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n */\nMapFactory.Attributes = {\n    type: MapFactory.Type,\n    snapshotFormatVersion: \"0.2\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion,\n};\n/**\n * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting\n * and retrieving values that JavaScript developers are accustomed to with the\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.\n * However, the keys of a SharedMap must be strings.\n */\nclass SharedMap extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.SharedObject {\n    /**\n     * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.\n     *\n     * @param id - String identifier.\n     * @param runtime - Data store runtime.\n     * @param attributes - The attributes for the map.\n     */\n    constructor(id, runtime, attributes) {\n        super(id, runtime, attributes, \"fluid_map_\");\n        /**\n         * String representation for the class.\n         */\n        this[_a] = \"SharedMap\";\n        this.kernel = new _mapKernel__WEBPACK_IMPORTED_MODULE_2__.MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), this);\n    }\n    /**\n     * Create a new shared map.\n     * @param runtime - The data store runtime that the new shared map belongs to.\n     * @param id - Optional name of the shared map.\n     * @returns Newly created shared map.\n     *\n     * @example\n     * To create a `SharedMap`, call the static create method:\n     *\n     * ```typescript\n     * const myMap = SharedMap.create(this.runtime, id);\n     * ```\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, MapFactory.Type);\n    }\n    /**\n     * Get a factory for SharedMap to register with the data store.\n     * @returns A factory that creates SharedMaps and loads them from storage.\n     */\n    static getFactory() {\n        return new MapFactory();\n    }\n    /**\n     * Get an iterator over the keys in this map.\n     * @returns The iterator\n     */\n    keys() {\n        return this.kernel.keys();\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    entries() {\n        return this.kernel.entries();\n    }\n    /**\n     * Get an iterator over the values in this map.\n     * @returns The iterator\n     */\n    values() {\n        return this.kernel.values();\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.kernel.entries();\n    }\n    /**\n     * The number of key/value pairs stored in the map.\n     */\n    get size() {\n        return this.kernel.size;\n    }\n    /**\n     * Executes the given callback on each entry in the map.\n     * @param callbackFn - Callback function\n     */\n    forEach(callbackFn) {\n        this.kernel.forEach(callbackFn);\n    }\n    /**\n     * {@inheritDoc ISharedMap.get}\n     */\n    get(key) {\n        return this.kernel.get(key);\n    }\n    /**\n     * Check if a key exists in the map.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this.kernel.has(key);\n    }\n    /**\n     * {@inheritDoc ISharedMap.set}\n     */\n    set(key, value) {\n        this.kernel.set(key, value);\n        return this;\n    }\n    /**\n     * Delete a key from the map.\n     * @param key - Key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        return this.kernel.delete(key);\n    }\n    /**\n     * Clear all data from the map.\n     */\n    clear() {\n        this.kernel.clear();\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}\n     * @internal\n     */\n    summarizeCore(serializer, telemetryContext) {\n        let currentSize = 0;\n        let counter = 0;\n        let headerBlob = {};\n        const blobs = [];\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__.SummaryTreeBuilder();\n        const data = this.kernel.getSerializedStorage(serializer);\n        // If single property exceeds this size, it goes into its own blob\n        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n        // Maximum blob size for multiple map properties\n        // Should be bigger than MinValueSizeSeparateSnapshotBlob\n        const MaxSnapshotBlobSize = 16 * 1024;\n        // Partitioning algorithm:\n        // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.\n        //    Naming (across snapshots) of such blob does not have to be stable across snapshots,\n        //    As de-duping process (in driver) should not care about paths, only content.\n        // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.\n        //    This process does not produce stable partitioning. This means\n        //    modification (including addition / deletion) of property can shift properties across blobs\n        //    and result in non-incremental snapshot.\n        //    This can be improved in the future, without being format breaking change, as loading sequence\n        //    loads all blobs at once and partitioning schema has no impact on that process.\n        for (const key of Object.keys(data)) {\n            const value = data[key];\n            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n                const blobName = `blob${counter}`;\n                counter++;\n                blobs.push(blobName);\n                const content = {\n                    [key]: {\n                        type: value.type,\n                        value: JSON.parse(value.value),\n                    },\n                };\n                builder.addBlob(blobName, JSON.stringify(content));\n            }\n            else {\n                currentSize += value.type.length + 21; // Approximation cost of property header\n                if (value.value) {\n                    currentSize += value.value.length;\n                }\n                if (currentSize > MaxSnapshotBlobSize) {\n                    const blobName = `blob${counter}`;\n                    counter++;\n                    blobs.push(blobName);\n                    builder.addBlob(blobName, JSON.stringify(headerBlob));\n                    headerBlob = {};\n                    currentSize = 0;\n                }\n                headerBlob[key] = {\n                    type: value.type,\n                    value: value.value === undefined ? undefined : JSON.parse(value.value),\n                };\n            }\n        }\n        const header = {\n            blobs,\n            content: headerBlob,\n        };\n        builder.addBlob(snapshotFileName, JSON.stringify(header));\n        return builder.getSummaryTree();\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     * @internal\n     */\n    async loadCore(storage) {\n        const json = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(storage, snapshotFileName);\n        const newFormat = json;\n        if (Array.isArray(newFormat.blobs)) {\n            this.kernel.populateFromSerializable(newFormat.content);\n            await Promise.all(newFormat.blobs.map(async (value) => {\n                const content = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(storage, value);\n                this.kernel.populateFromSerializable(content);\n            }));\n        }\n        else {\n            this.kernel.populateFromSerializable(json);\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n     * @internal\n     */\n    onDisconnect() { }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n     * @internal\n     */\n    reSubmitCore(content, localOpMetadata) {\n        this.kernel.trySubmitMessage(content, localOpMetadata);\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}\n     * @internal\n     */\n    applyStashedOp(content) {\n        this.kernel.tryProcessMessage(content, false, undefined);\n        return this.kernel.tryGetStashedOpLocalMetadata(content);\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n     * @internal\n     */\n    processCore(message, local, localOpMetadata) {\n        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.Operation) {\n            this.kernel.tryProcessMessage(message.contents, local, localOpMetadata);\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}\n     * @internal\n    */\n    rollback(content, localOpMetadata) {\n        this.kernel.rollback(content, localOpMetadata);\n    }\n}\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n/* 143 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MapKernel\": () => (/* binding */ MapKernel)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(137);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);\n/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nfunction isMapKeyLocalOpMetadata(metadata) {\n    return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" &&\n        (metadata.type === \"add\" || metadata.type === \"edit\");\n}\nfunction isClearLocalOpMetadata(metadata) {\n    return metadata !== undefined && metadata.type === \"clear\" && typeof metadata.pendingMessageId === \"number\";\n}\nfunction isMapLocalOpMetadata(metadata) {\n    return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" &&\n        (metadata.type === \"add\" || metadata.type === \"edit\" || metadata.type === \"clear\");\n}\n/**\n * A SharedMap is a map-like distributed data structure.\n */\nclass MapKernel {\n    /**\n     * Create a new shared map kernel.\n     * @param serializer - The serializer to serialize / parse handles\n     * @param handle - The handle of the shared object using the kernel\n     * @param submitMessage - A callback to submit a message through the shared object\n     * @param isAttached - To query whether the shared object should generate ops\n     * @param valueTypes - The value types to register\n     * @param eventEmitter - The object that will emit map events\n     */\n    constructor(serializer, handle, submitMessage, isAttached, eventEmitter) {\n        this.serializer = serializer;\n        this.handle = handle;\n        this.submitMessage = submitMessage;\n        this.isAttached = isAttached;\n        this.eventEmitter = eventEmitter;\n        /**\n         * Mapping of op types to message handlers.\n         */\n        this.messageHandlers = new Map();\n        /**\n         * The in-memory data the map is storing.\n         */\n        this.data = new Map();\n        /**\n         * Keys that have been modified locally but not yet ack'd from the server.\n         */\n        this.pendingKeys = new Map();\n        /**\n         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n         */\n        this.pendingMessageId = -1;\n        /**\n         * The pending ids of any clears that have been performed locally but not yet ack'd from the server\n         */\n        this.pendingClearMessageIds = [];\n        this.localValueMaker = new _localValues__WEBPACK_IMPORTED_MODULE_0__.LocalValueMaker(serializer);\n        this.messageHandlers = this.getMessageHandlers();\n    }\n    /**\n     * The number of key/value pairs stored in the map.\n     */\n    get size() {\n        return this.data.size;\n    }\n    /**\n     * Get an iterator over the keys in this map.\n     * @returns The iterator\n     */\n    keys() {\n        return this.data.keys();\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    entries() {\n        const localEntriesIterator = this.data.entries();\n        const iterator = {\n            next() {\n                const nextVal = localEntriesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the values in this map.\n     * @returns The iterator\n     */\n    values() {\n        const localValuesIterator = this.data.values();\n        const iterator = {\n            next() {\n                const nextVal = localValuesIterator.next();\n                if (nextVal.done) {\n                    return { value: undefined, done: true };\n                }\n                else {\n                    // Unpack the stored value\n                    return { value: nextVal.value.value, done: false };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Executes the given callback on each entry in the map.\n     * @param callbackFn - Callback function\n     */\n    forEach(callbackFn) {\n        this.data.forEach((localValue, key, m) => {\n            callbackFn(localValue.value, key, m);\n        });\n    }\n    /**\n     * {@inheritDoc ISharedMap.get}\n     */\n    get(key) {\n        const localValue = this.data.get(key);\n        return localValue === undefined ? undefined : localValue.value;\n    }\n    /**\n     * Check if a key exists in the map.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this.data.has(key);\n    }\n    /**\n     * {@inheritDoc ISharedMap.set}\n     */\n    set(key, value) {\n        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n        if (key === undefined || key === null) {\n            throw new Error(\"Undefined and null keys are not supported\");\n        }\n        // Create a local value and serialize it.\n        const localValue = this.localValueMaker.fromInMemory(value);\n        const serializableValue = (0,_localValues__WEBPACK_IMPORTED_MODULE_0__.makeSerializable)(localValue, this.serializer, this.handle);\n        // Set the value locally.\n        const previousValue = this.setCore(key, localValue, true);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return;\n        }\n        const op = {\n            key,\n            type: \"set\",\n            value: serializableValue,\n        };\n        this.submitMapKeyMessage(op, previousValue);\n    }\n    /**\n     * Delete a key from the map.\n     * @param key - Key to delete\n     * @returns True if the key existed and was deleted, false if it did not exist\n     */\n    delete(key) {\n        // Delete the key locally first.\n        const previousValue = this.deleteCore(key, true);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return previousValue !== undefined;\n        }\n        const op = {\n            key,\n            type: \"delete\",\n        };\n        this.submitMapKeyMessage(op, previousValue);\n        return previousValue !== undefined;\n    }\n    /**\n     * Clear all data from the map.\n     */\n    clear() {\n        const copy = this.isAttached() ? new Map(this.data) : undefined;\n        // Clear the data locally first.\n        this.clearCore(true);\n        // If we are not attached, don't submit the op.\n        if (!this.isAttached()) {\n            return;\n        }\n        const op = {\n            type: \"clear\",\n        };\n        this.submitMapClearMessage(op, copy);\n    }\n    /**\n     * Serializes the data stored in the shared map to a JSON string\n     * @param serializer - The serializer to use to serialize handles in its values.\n     * @returns A JSON string containing serialized map data\n     */\n    getSerializedStorage(serializer) {\n        const serializableMapData = {};\n        this.data.forEach((localValue, key) => {\n            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);\n        });\n        return serializableMapData;\n    }\n    getSerializableStorage(serializer) {\n        const serializableMapData = {};\n        this.data.forEach((localValue, key) => {\n            serializableMapData[key] = (0,_localValues__WEBPACK_IMPORTED_MODULE_0__.makeSerializable)(localValue, serializer, this.handle);\n        });\n        return serializableMapData;\n    }\n    serialize(serializer) {\n        return JSON.stringify(this.getSerializableStorage(serializer));\n    }\n    /**\n     * Populate the kernel with the given map data.\n     * @param data - A JSON string containing serialized map data\n     */\n    populateFromSerializable(json) {\n        for (const [key, serializable] of Object.entries(json)) {\n            const localValue = {\n                key,\n                value: this.makeLocal(key, serializable),\n            };\n            this.data.set(localValue.key, localValue.value);\n        }\n    }\n    populate(json) {\n        this.populateFromSerializable(JSON.parse(json));\n    }\n    /**\n     * Submit the given op if a handler is registered.\n     * @param op - The operation to attempt to submit\n     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime\n     * and not sent to the server. This will be sent back when this message is received back from the server. This is\n     * also sent if we are asked to resubmit the message.\n     * @returns True if the operation was submitted, false otherwise.\n     */\n    trySubmitMessage(op, localOpMetadata) {\n        const handler = this.messageHandlers.get(op.type);\n        if (handler === undefined) {\n            return false;\n        }\n        handler.submit(op, localOpMetadata);\n        return true;\n    }\n    tryGetStashedOpLocalMetadata(op) {\n        const handler = this.messageHandlers.get(op.type);\n        if (handler === undefined) {\n            throw new Error(\"no apply stashed op handler\");\n        }\n        return handler.getStashedOpLocalMetadata(op);\n    }\n    /**\n     * Process the given op if a handler is registered.\n     * @param op - The message to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation was processed, false otherwise.\n     */\n    tryProcessMessage(op, local, localOpMetadata) {\n        const handler = this.messageHandlers.get(op.type);\n        if (handler === undefined) {\n            return false;\n        }\n        handler.process(op, local, localOpMetadata);\n        return true;\n    }\n    /**\n     * Rollback a local op\n     * @param op - The operation to rollback\n     * @param localOpMetadata - The local metadata associated with the op.\n     */\n    rollback(op, localOpMetadata) {\n        if (!isMapLocalOpMetadata(localOpMetadata)) {\n            throw new Error(\"Invalid localOpMetadata\");\n        }\n        if (op.type === \"clear\" && localOpMetadata.type === \"clear\") {\n            if (localOpMetadata.previousMap === undefined) {\n                throw new Error(\"Cannot rollback without previous map\");\n            }\n            localOpMetadata.previousMap.forEach((localValue, key) => {\n                this.setCore(key, localValue, true);\n            });\n            const lastPendingClearId = this.pendingClearMessageIds.pop();\n            if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {\n                throw new Error(\"Rollback op does match last clear\");\n            }\n        }\n        else if (op.type === \"delete\" || op.type === \"set\") {\n            if (localOpMetadata.type === \"add\") {\n                this.deleteCore(op.key, true);\n            }\n            else if (localOpMetadata.type === \"edit\" && localOpMetadata.previousValue !== undefined) {\n                this.setCore(op.key, localOpMetadata.previousValue, true);\n            }\n            else {\n                throw new Error(\"Cannot rollback without previous value\");\n            }\n            const pendingMessageIds = this.pendingKeys.get(op.key);\n            const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();\n            if (!pendingMessageIds || lastPendingMessageId !== localOpMetadata.pendingMessageId) {\n                throw new Error(\"Rollback op does not match last pending\");\n            }\n            if (pendingMessageIds.length === 0) {\n                this.pendingKeys.delete(op.key);\n            }\n        }\n        else {\n            throw new Error(\"Unsupported op for rollback\");\n        }\n    }\n    /**\n     * Set implementation used for both locally sourced sets as well as incoming remote sets.\n     * @param key - The key being set\n     * @param value - The value being set\n     * @param local - Whether the message originated from the local client\n     * @returns Previous local value of the key, if any\n     */\n    setCore(key, value, local) {\n        const previousLocalValue = this.data.get(key);\n        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n        this.data.set(key, value);\n        this.eventEmitter.emit(\"valueChanged\", { key, previousValue }, local, this.eventEmitter);\n        return previousLocalValue;\n    }\n    /**\n     * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n     * @param local - Whether the message originated from the local client\n     */\n    clearCore(local) {\n        this.data.clear();\n        this.eventEmitter.emit(\"clear\", local, this.eventEmitter);\n    }\n    /**\n     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n     * @param key - The key being deleted\n     * @param local - Whether the message originated from the local client\n     * @returns Previous local value of the key if it existed, undefined if it did not exist\n     */\n    deleteCore(key, local) {\n        const previousLocalValue = this.data.get(key);\n        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n        const successfullyRemoved = this.data.delete(key);\n        if (successfullyRemoved) {\n            this.eventEmitter.emit(\"valueChanged\", { key, previousValue }, local, this.eventEmitter);\n        }\n        return previousLocalValue;\n    }\n    /**\n     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n     */\n    clearExceptPendingKeys() {\n        // Assuming the pendingKeys is small and the map is large\n        // we will get the value for the pendingKeys and clear the map\n        const temp = new Map();\n        this.pendingKeys.forEach((value, key) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            temp.set(key, this.data.get(key));\n        });\n        this.clearCore(false);\n        temp.forEach((value, key) => {\n            this.setCore(key, value, true);\n        });\n    }\n    /**\n     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will\n     * have the information we need to create a real object, but will not be the real object yet.  For example,\n     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's\n     * job is to convert that information into a real object for local usage.\n     * @param key - The key that the caller intends to store the local value into (used for ops later).  But\n     * doesn't actually store the local value into that key.  So better not lie!\n     * @param serializable - The remote information that we can convert into a real object\n     * @returns The local value that was produced\n     */\n    makeLocal(key, serializable) {\n        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType.Plain] || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType.Shared]) {\n            return this.localValueMaker.fromSerializable(serializable);\n        }\n        else {\n            throw new Error(\"Unknown local value type\");\n        }\n    }\n    /**\n     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n     * not process the incoming operation.\n     * @param op - Operation to check\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation should be processed, false otherwise\n     */\n    needProcessKeyOperation(op, local, localOpMetadata) {\n        if (this.pendingClearMessageIds.length > 0) {\n            if (local) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata) &&\n                    localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x013 /* \"Received out of order op when there is an unackd clear message\" */);\n            }\n            // If we have an unack'd clear, we can ignore all ops.\n            return false;\n        }\n        const pendingKeyMessageId = this.pendingKeys.get(op.key);\n        if (pendingKeyMessageId !== undefined) {\n            // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's\n            // and don't process the op.\n            if (local) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata), 0x014 /* pendingMessageId is missing from the local client's operation */);\n                const pendingMessageIds = this.pendingKeys.get(op.key);\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2fa /* Unexpected pending message received */);\n                pendingMessageIds.shift();\n                if (pendingMessageIds.length === 0) {\n                    this.pendingKeys.delete(op.key);\n                }\n            }\n            return false;\n        }\n        // If we don't have a NACK op on the key, we need to process the remote ops.\n        return !local;\n    }\n    /**\n     * Get the message handlers for the map.\n     * @returns A map of string op names to IMapMessageHandlers for those ops\n     */\n    getMessageHandlers() {\n        const messageHandlers = new Map();\n        messageHandlers.set(\"clear\", {\n            process: (op, local, localOpMetadata) => {\n                if (local) {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x015 /* \"pendingMessageId is missing from the local client's clear operation\" */);\n                    const pendingClearMessageId = this.pendingClearMessageIds.shift();\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fb /* pendingMessageId does not match */);\n                    return;\n                }\n                if (this.pendingKeys.size !== 0) {\n                    this.clearExceptPendingKeys();\n                    return;\n                }\n                this.clearCore(local);\n            },\n            submit: (op, localOpMetadata) => {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x2fc /* Invalid localOpMetadata for clear */);\n                // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n                const pendingClearMessageId = this.pendingClearMessageIds.shift();\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fd /* pendingMessageId does not match */);\n                this.submitMapClearMessage(op, localOpMetadata.previousMap);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n                return { type: \"clear\", pendingMessageId: this.getMapClearMessageId() };\n            },\n        });\n        messageHandlers.set(\"delete\", {\n            process: (op, local, localOpMetadata) => {\n                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {\n                    return;\n                }\n                this.deleteCore(op.key, local);\n            },\n            submit: (op, localOpMetadata) => {\n                this.resubmitMapKeyMessage(op, localOpMetadata);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n                return { type: \"edit\", pendingMessageId: this.getMapKeyMessageId(op) };\n            },\n        });\n        messageHandlers.set(\"set\", {\n            process: (op, local, localOpMetadata) => {\n                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {\n                    return;\n                }\n                // needProcessKeyOperation should have returned false if local is true\n                const context = this.makeLocal(op.key, op.value);\n                this.setCore(op.key, context, local);\n            },\n            submit: (op, localOpMetadata) => {\n                this.resubmitMapKeyMessage(op, localOpMetadata);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n                return { type: \"edit\", pendingMessageId: this.getMapKeyMessageId(op) };\n            },\n        });\n        return messageHandlers;\n    }\n    getMapClearMessageId() {\n        const pendingMessageId = ++this.pendingMessageId;\n        this.pendingClearMessageIds.push(pendingMessageId);\n        return pendingMessageId;\n    }\n    /**\n     * Submit a clear message to remote clients.\n     * @param op - The clear message\n     */\n    submitMapClearMessage(op, previousMap) {\n        const metadata = { type: \"clear\", pendingMessageId: this.getMapClearMessageId(), previousMap };\n        this.submitMessage(op, metadata);\n    }\n    getMapKeyMessageId(op) {\n        const pendingMessageId = ++this.pendingMessageId;\n        const pendingMessageIds = this.pendingKeys.get(op.key);\n        if (pendingMessageIds !== undefined) {\n            pendingMessageIds.push(pendingMessageId);\n        }\n        else {\n            this.pendingKeys.set(op.key, [pendingMessageId]);\n        }\n        return pendingMessageId;\n    }\n    /**\n     * Submit a map key message to remote clients.\n     * @param op - The map key message\n     * @param previousValue - The value of the key before this op\n     */\n    submitMapKeyMessage(op, previousValue) {\n        const pendingMessageId = this.getMapKeyMessageId(op);\n        const localMetadata = previousValue ?\n            { type: \"edit\", pendingMessageId, previousValue } :\n            { type: \"add\", pendingMessageId };\n        this.submitMessage(op, localMetadata);\n    }\n    /**\n     * Submit a map key message to remote clients based on a previous submit.\n     * @param op - The map key message\n     * @param localOpMetadata - Metadata from the previous submit\n     */\n    resubmitMapKeyMessage(op, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isMapKeyLocalOpMetadata(localOpMetadata), 0x2fe /* Invalid localOpMetadata in submit */);\n        // clear the old pending message id\n        const pendingMessageIds = this.pendingKeys.get(op.key);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2ff /* Unexpected pending message received */);\n        pendingMessageIds.shift();\n        if (pendingMessageIds.length === 0) {\n            this.pendingKeys.delete(op.key);\n        }\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        const pendingMessageId = this.getMapKeyMessageId(op);\n        const localMetadata = localOpMetadata.type === \"edit\" ?\n            { type: \"edit\", pendingMessageId, previousValue: localOpMetadata.previousValue } :\n            { type: \"add\", pendingMessageId };\n        this.submitMessage(op, localMetadata);\n    }\n}\n//# sourceMappingURL=mapKernel.js.map\n\n/***/ }),\n/* 144 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isDataObjectClass\": () => (/* binding */ isDataObjectClass),\n/* harmony export */   \"isSharedObjectClass\": () => (/* binding */ isSharedObjectClass),\n/* harmony export */   \"parseDataObjectsFromSharedObjects\": () => (/* binding */ parseDataObjectsFromSharedObjects)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Runtime check to determine if a class is a DataObject type\n */\nconst isDataObjectClass = (obj) => {\n    return (obj === null || obj === void 0 ? void 0 : obj.factory) !== undefined;\n};\n/**\n * Runtime check to determine if a class is a SharedObject type\n */\nconst isSharedObjectClass = (obj) => {\n    return (obj === null || obj === void 0 ? void 0 : obj.getFactory) !== undefined;\n};\n/**\n * The ContainerSchema consists of initialObjects and dynamicObjectTypes. These types can be\n * of both SharedObject or DataObject. This function seperates the two and returns a registery\n * of DataObject types and an array of SharedObjects.\n */\nconst parseDataObjectsFromSharedObjects = (schema) => {\n    var _a;\n    const registryEntries = new Set();\n    const sharedObjects = new Set();\n    const tryAddObject = (obj) => {\n        if (isSharedObjectClass(obj)) {\n            sharedObjects.add(obj.getFactory());\n        }\n        else if (isDataObjectClass(obj)) {\n            registryEntries.add([\n                obj.factory.type,\n                Promise.resolve(obj.factory),\n            ]);\n        }\n        else {\n            throw new Error(`Entry is neither a DataObject or a SharedObject`);\n        }\n    };\n    // Add the object types that will be initialized\n    const dedupedObjects = new Set([\n        ...Object.values(schema.initialObjects),\n        ...((_a = schema.dynamicObjectTypes) !== null && _a !== void 0 ? _a : []),\n    ]);\n    dedupedObjects.forEach(tryAddObject);\n    if (registryEntries.size === 0 && sharedObjects.size === 0) {\n        throw new Error(\"Container cannot be initialized without any DataTypes\");\n    }\n    return [Array.from(registryEntries), Array.from(sharedObjects)];\n};\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 145 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseContainerRuntimeFactory\": () => (/* binding */ BaseContainerRuntimeFactory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(131);\n/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);\n/* harmony import */ var _fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(149);\n/* harmony import */ var _fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);\n/* harmony import */ var _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(146);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n/**\n * BaseContainerRuntimeFactory produces container runtimes with a given data store and service registry, as well as\n * given request handlers.  It can be subclassed to implement a first-time initialization procedure for the containers\n * it creates.\n */\nclass BaseContainerRuntimeFactory extends _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RuntimeFactoryHelper {\n    /**\n     * @param registryEntries - The data store registry for containers produced\n     * @param serviceRegistry - The service registry for containers produced\n     * @param requestHandlers - Request handlers for containers produced\n     * @param runtimeOptions - The runtime options passed to the ContainerRuntime when instantiating it\n     */\n    constructor(registryEntries, dependencyContainer, requestHandlers = [], runtimeOptions) {\n        super();\n        this.registryEntries = registryEntries;\n        this.dependencyContainer = dependencyContainer;\n        this.requestHandlers = requestHandlers;\n        this.runtimeOptions = runtimeOptions;\n        this.registry = new _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__.FluidDataStoreRegistry(registryEntries);\n    }\n    get IFluidDataStoreRegistry() { return this.registry; }\n    async instantiateFirstTime(runtime) {\n        await this.containerInitializingFirstTime(runtime);\n        await this.containerHasInitialized(runtime);\n    }\n    async instantiateFromExisting(runtime) {\n        await this.containerHasInitialized(runtime);\n    }\n    async preInitialize(context, existing) {\n        const scope = context.scope;\n        const dc = new _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__.DependencyContainer(this.dependencyContainer, scope.IFluidDependencySynthesizer);\n        scope.IFluidDependencySynthesizer = dc;\n        const runtime = await _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__.ContainerRuntime.load(context, this.registryEntries, (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.buildRuntimeRequestHandler)(...this.requestHandlers), this.runtimeOptions, scope, existing);\n        // we register the runtime so developers of providers can use it in the factory pattern.\n        dc.register(_fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.IContainerRuntime, runtime);\n        return runtime;\n    }\n    /**\n     * Subclasses may override containerInitializingFirstTime to perform any setup steps at the time the container\n     * is created. This likely includes creating any initial data stores that are expected to be there at the outset.\n     * @param runtime - The container runtime for the container being initialized\n     */\n    async containerInitializingFirstTime(runtime) { }\n    /**\n     * Subclasses may override containerHasInitialized to perform any steps after the container has initialized.\n     * This likely includes loading any data stores that are expected to be there at the outset.\n     * @param runtime - The container runtime for the container being initialized\n     */\n    async containerHasInitialized(runtime) { }\n}\n//# sourceMappingURL=baseContainerRuntimeFactory.js.map\n\n/***/ }),\n/* 146 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RuntimeFactoryHelper\": () => (/* binding */ RuntimeFactoryHelper)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RuntimeFactoryHelper {\n    get IRuntimeFactory() { return this; }\n    async instantiateRuntime(context, existing) {\n        const fromExisting = existing === undefined\n            ? context.existing === true\n            : existing;\n        const runtime = await this.preInitialize(context, fromExisting);\n        if (fromExisting) {\n            await this.instantiateFromExisting(runtime);\n        }\n        else {\n            await this.instantiateFirstTime(runtime);\n        }\n        await this.hasInitialized(runtime);\n        return runtime;\n    }\n    async instantiateFirstTime(_runtime) { }\n    async instantiateFromExisting(_runtime) { }\n    async hasInitialized(_runtime) { }\n}\n//# sourceMappingURL=runtimeFactoryHelper.js.map\n\n/***/ }),\n/* 147 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DependencyContainer\": () => (/* binding */ DependencyContainer)\n/* harmony export */ });\n/* harmony import */ var _IFluidDependencySynthesizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(148);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * DependencyContainer is similar to a IoC Container. It takes providers and will\n * synthesize an object based on them when requested.\n */\nclass DependencyContainer {\n    constructor(...parents) {\n        this.providers = new Map();\n        this.parents = parents.filter((v) => v !== undefined);\n    }\n    get IFluidDependencySynthesizer() { return this; }\n    /**\n     * Add a new provider\n     * @param type - Name of the Type T being provided\n     * @param provider - A provider that will resolve the T correctly when asked\n     * @throws - If passing a type that's already registered\n     */\n    register(type, provider) {\n        if (this.providers.has(type)) {\n            throw new Error(`Attempting to register a provider of type ${type} that already exists`);\n        }\n        this.providers.set(type, provider);\n    }\n    /**\n     * Remove a provider\n     * @param type - Name of the provider to remove\n     */\n    unregister(type) {\n        if (this.providers.has(type)) {\n            this.providers.delete(type);\n        }\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}\n     */\n    synthesize(optionalTypes, requiredTypes) {\n        const base = {};\n        this.generateRequired(base, requiredTypes);\n        this.generateOptional(base, optionalTypes);\n        Object.defineProperty(base, _IFluidDependencySynthesizer__WEBPACK_IMPORTED_MODULE_0__.IFluidDependencySynthesizer, { get: () => this });\n        return base;\n    }\n    /**\n     * {@inheritDoc (IFluidDependencySynthesizer:interface).has}\n     * @param excludeParents - If true, exclude checking parent registries\n     */\n    has(type, excludeParents) {\n        if (this.providers.has(type)) {\n            return true;\n        }\n        if (excludeParents !== true) {\n            return this.parents.some((p) => p.has(type));\n        }\n        return false;\n    }\n    /**\n     * @deprecated - Needed for back compat\n     */\n    getProvider(provider) {\n        // this was removed, but some partners have trouble with back compat where they\n        // use invalid patterns with FluidObject and IFluidDependencySynthesizer\n        // this is just for back compat until those are removed\n        if (this.has(provider)) {\n            if (this.providers.has(provider)) {\n                return this.providers.get(provider);\n            }\n            for (const parent of this.parents) {\n                if (parent instanceof DependencyContainer) {\n                    return parent.getProvider(provider);\n                }\n                else {\n                    // older implementations of the IFluidDependencySynthesizer exposed getProvider\n                    const maybeGetProvider = parent;\n                    if ((maybeGetProvider === null || maybeGetProvider === void 0 ? void 0 : maybeGetProvider.getProvider) !== undefined) {\n                        return maybeGetProvider.getProvider(provider);\n                    }\n                }\n            }\n        }\n    }\n    generateRequired(base, types) {\n        if (types === undefined) {\n            return;\n        }\n        for (const key of Object.keys(types)) {\n            const provider = this.resolveProvider(key);\n            if (provider === undefined) {\n                throw new Error(`Object attempted to be created without registered required provider ${key}`);\n            }\n            Object.defineProperty(base, key, provider);\n        }\n    }\n    generateOptional(base, types) {\n        var _a;\n        if (types === undefined) {\n            return;\n        }\n        for (const key of Object.keys(types)) {\n            // back-compat: in 0.56 we allow undefined in the types, but we didn't before\n            // this will keep runtime back compat, eventually we should support undefined properties\n            // rather than properties that return promises that resolve to undefined\n            const provider = (_a = this.resolveProvider(key)) !== null && _a !== void 0 ? _a : { get: async () => undefined };\n            Object.defineProperty(base, key, provider);\n        }\n    }\n    resolveProvider(t) {\n        // If we have the provider return it\n        const provider = this.providers.get(t);\n        if (provider === undefined) {\n            for (const parent of this.parents) {\n                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n                const sp = { [t]: t };\n                const syn = parent.synthesize(sp, {});\n                const descriptor = Object.getOwnPropertyDescriptor(syn, t);\n                if (descriptor !== undefined) {\n                    return descriptor;\n                }\n            }\n            return undefined;\n        }\n        // The double nested gets are required for lazy loading the provider resolution\n        if (typeof provider === \"function\") {\n            return {\n                get() {\n                    if (provider && typeof provider === \"function\") {\n                        return Promise.resolve(this[_IFluidDependencySynthesizer__WEBPACK_IMPORTED_MODULE_0__.IFluidDependencySynthesizer])\n                            .then(async (fds) => provider(fds))\n                            .then((p) => p === null || p === void 0 ? void 0 : p[t]);\n                    }\n                },\n            };\n        }\n        return {\n            get() {\n                if (provider) {\n                    return Promise.resolve(provider).then((p) => {\n                        if (p) {\n                            return p[t];\n                        }\n                    });\n                }\n            },\n        };\n    }\n}\n//# sourceMappingURL=dependencyContainer.js.map\n\n/***/ }),\n/* 148 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IFluidDependencySynthesizer\": () => (/* binding */ IFluidDependencySynthesizer)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst IFluidDependencySynthesizer = \"IFluidDependencySynthesizer\";\n//# sourceMappingURL=IFluidDependencySynthesizer.js.map\n\n/***/ }),\n/* 149 */\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(150), exports);\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 150 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IContainerRuntime = void 0;\n/**\n * @deprecated - This will be removed in a later release.\n */\nexports.IContainerRuntime = \"IContainerRuntime\";\n//# sourceMappingURL=containerRuntime.js.map\n\n/***/ }),\n/* 151 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataObjectFactory\": () => (/* binding */ DataObjectFactory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);\n/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(142);\n/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(153);\n/* harmony import */ var _pureDataObjectFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(152);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * DataObjectFactory is the IFluidDataStoreFactory for use with DataObjects.\n * It facilitates DataObject's features (such as its shared directory) by\n * ensuring relevant shared objects etc are available to the factory.\n *\n * @typeParam TObj - DataObject (concrete type)\n * @typeParam I - The input types for the DataObject\n */\nclass DataObjectFactory extends _pureDataObjectFactory__WEBPACK_IMPORTED_MODULE_0__.PureDataObjectFactory {\n    constructor(type, ctor, sharedObjects = [], optionalProviders, registryEntries, runtimeFactory = _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_1__.FluidDataStoreRuntime) {\n        const mergedObjects = [...sharedObjects];\n        if (!sharedObjects.find((factory) => factory.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.DirectoryFactory.Type)) {\n            // User did not register for directory\n            mergedObjects.push(_fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.SharedDirectory.getFactory());\n        }\n        // TODO: Remove SharedMap factory when compatibility with SharedMap DataObject is no longer needed in 0.10\n        if (!sharedObjects.find((factory) => factory.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.MapFactory.Type)) {\n            // User did not register for map\n            mergedObjects.push(_fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedMap.getFactory());\n        }\n        super(type, ctor, mergedObjects, optionalProviders, registryEntries, runtimeFactory);\n    }\n}\n//# sourceMappingURL=dataObjectFactory.js.map\n\n/***/ }),\n/* 152 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PureDataObjectFactory\": () => (/* binding */ PureDataObjectFactory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(153);\n/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(131);\n/* harmony import */ var _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);\n/* harmony import */ var _data_objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n/**\n * Proxy over PureDataObject\n * Does delayed creation & initialization of PureDataObject\n*/\nasync function createDataObject(ctor, context, sharedObjectRegistry, optionalProviders, runtimeClassArg, existing, initProps) {\n    // base\n    let runtimeClass = runtimeClassArg;\n    // request mixin in\n    runtimeClass = (0,_fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.mixinRequestHandler)(async (request, runtimeArg) => (await _data_objects__WEBPACK_IMPORTED_MODULE_1__.PureDataObject.getDataObject(runtimeArg)).request(request), runtimeClass);\n    // Create a new runtime for our data store\n    // The runtime is what Fluid uses to create DDS' and route to your data store\n    const runtime = new runtimeClass(context, sharedObjectRegistry, existing);\n    // Create object right away.\n    // This allows object to register various callbacks with runtime before runtime\n    // becomes globally available. But it's not full initialization - constructor can't\n    // access DDSes or other services of runtime as objects are not fully initialized.\n    // In order to use object, we need to go through full initialization by calling finishInitialization().\n    const scope = context.scope;\n    const dependencyContainer = new _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__.DependencyContainer(scope.IFluidDependencySynthesizer);\n    const providers = dependencyContainer.synthesize(optionalProviders, {});\n    const instance = new ctor({ runtime, context, providers, initProps });\n    // if it's a newly created object, we need to wait for it to finish initialization\n    // as that results in creation of DDSes, before it gets attached, providing atomic\n    // guarantee of creation.\n    // WARNING: we can't do the same (yet) for already existing PureDataObject!\n    // This will result in deadlock, as it tries to resolve internal handles, but any\n    // handle resolution goes through root (container runtime), which can't route it back\n    // to this data store, as it's still not initialized and not known to container runtime yet.\n    // In the future, we should address it by using relative paths for handles and be able to resolve\n    // local DDSes while data store is not fully initialized.\n    if (!existing) {\n        await instance.finishInitialization(existing);\n    }\n    return { instance, runtime };\n}\n/**\n * PureDataObjectFactory is a barebones IFluidDataStoreFactory for use with PureDataObject.\n * Consumers should typically use DataObjectFactory instead unless creating\n * another base data store factory.\n *\n * @typeParam TObj - DataObject (concrete type)\n * @typeParam I - The input types for the DataObject\n */\nclass PureDataObjectFactory {\n    constructor(type, ctor, sharedObjects, optionalProviders, registryEntries, runtimeClass = _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidDataStoreRuntime) {\n        this.type = type;\n        this.ctor = ctor;\n        this.optionalProviders = optionalProviders;\n        this.runtimeClass = runtimeClass;\n        if (this.type === \"\") {\n            throw new Error(\"undefined type member\");\n        }\n        if (registryEntries !== undefined) {\n            this.registry = new _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__.FluidDataStoreRegistry(registryEntries);\n        }\n        this.sharedObjectRegistry = new Map(sharedObjects.map((ext) => [ext.type, ext]));\n    }\n    get IFluidDataStoreFactory() { return this; }\n    get IFluidDataStoreRegistry() {\n        return this.registry;\n    }\n    /**\n     * Convenience helper to get the data store's/factory's data store registry entry.\n     * The return type hides the factory's generics, easing grouping of registry\n     * entries that differ only in this way into the same array.\n     * @returns The NamedFluidDataStoreRegistryEntry\n     */\n    get registryEntry() {\n        return [this.type, Promise.resolve(this)];\n    }\n    /**\n     * This is where we do data store setup.\n     *\n     * @param context - data store context used to load a data store runtime\n     */\n    async instantiateDataStore(context, existing) {\n        const { runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, existing);\n        return runtime;\n    }\n    /**\n     * Creates a new instance of the object. Uses parent context's registry to build package path to this factory.\n     * In other words, registry of context passed in has to contain this factory, with the name that matches\n     * this factory's type.\n     * It is intended to be used by data store objects that create sub-objects.\n     * @param context - The context being used to create the runtime\n     * (the created object will have its own new context created as well)\n     * @param initialState - The initial state to provide to the created data store.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createChildInstance(parentContext, initialState) {\n        return this.createNonRootInstanceCore(parentContext.containerRuntime, [...parentContext.packagePath, this.type], initialState);\n    }\n    /**\n     * Creates a new instance of the object. Uses peer context's registry and its package path to identify this factory.\n     * In other words, registry of context passed in has to have this factory.\n     * Intended to be used by data store objects that need to create peers (similar) instances of existing objects.\n     * @param context - The component context being used to create the object\n     * (the created object will have its own new context created as well)\n     * @param initialState - The initial state to provide to the created component.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createPeerInstance(peerContext, initialState) {\n        return this.createNonRootInstanceCore(peerContext.containerRuntime, peerContext.packagePath, initialState);\n    }\n    /**\n     * Creates a new instance of the object. Uses container's registry to find this factory.\n     * It's expected that only container owners would use this functionality, as only such developers\n     * have knowledge of entries in container registry.\n     * The name in this registry for such record should match type of this factory.\n     * @param runtime - container runtime. It's registry is used to create an object.\n     * @param initialState - The initial state to provide to the created component.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createInstance(runtime, initialState) {\n        return this.createNonRootInstanceCore(runtime, [this.type], initialState);\n    }\n    /**\n     * Creates a new root instance of the object. Uses container's registry to find this factory.\n     * It's expected that only container owners would use this functionality, as only such developers\n     * have knowledge of entries in container registry.\n     * The name in this registry for such record should match type of this factory.\n     * @param runtime - container runtime. It's registry is used to create an object.\n     * @param initialState - The initial state to provide to the created component.\n     * @returns an object created by this factory. Data store and objects created are not attached to container.\n     * They get attached only when a handle to one of them is attached to already attached objects.\n     */\n    async createRootInstance(rootDataStoreId, runtime, initialState) {\n        const context = runtime.createDetachedRootDataStore([this.type], rootDataStoreId);\n        return this.createInstanceCore(context, initialState);\n    }\n    async createNonRootInstanceCore(containerRuntime, packagePath, initialState) {\n        const context = containerRuntime.createDetachedDataStore(packagePath);\n        return this.createInstanceCore(context, initialState);\n    }\n    async createInstanceCore(context, initialState) {\n        const { instance, runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, false, // existing\n        initialState);\n        await context.attachRuntime(this, runtime);\n        return instance;\n    }\n}\n//# sourceMappingURL=pureDataObjectFactory.js.map\n\n/***/ }),\n/* 153 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataStoreMessageType\": () => (/* binding */ DataStoreMessageType),\n/* harmony export */   \"FluidDataStoreRuntime\": () => (/* binding */ FluidDataStoreRuntime),\n/* harmony export */   \"mixinRequestHandler\": () => (/* binding */ mixinRequestHandler),\n/* harmony export */   \"mixinSummaryHandler\": () => (/* binding */ mixinSummaryHandler)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(154);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(155);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(273);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(132);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(97);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(272);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(55);\n/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(21);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(24);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(25);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(103);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);\n/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(266);\n/* harmony import */ var _localChannelContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(157);\n/* harmony import */ var _remoteChannelContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(271);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DataStoreMessageType;\n(function (DataStoreMessageType) {\n    // Creates a new channel\n    DataStoreMessageType[\"Attach\"] = \"attach\";\n    DataStoreMessageType[\"ChannelOp\"] = \"op\";\n})(DataStoreMessageType || (DataStoreMessageType = {}));\n/**\n * Base data store class\n */\nclass FluidDataStoreRuntime extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(dataStoreContext, sharedObjectRegistry, existing) {\n        super();\n        this.dataStoreContext = dataStoreContext;\n        this.sharedObjectRegistry = sharedObjectRegistry;\n        this._disposed = false;\n        this.contexts = new Map();\n        this.contextsDeferred = new Map();\n        this.pendingAttach = new Map();\n        this.deferredAttached = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        this.localChannelContextQueue = new Map();\n        this.notBoundedChannelContextSet = new Set();\n        // A list of handles that are bound when the data store is not visible. We have to make them visible when the data\n        // store becomes visible.\n        this.pendingHandlesToMakeVisible = new Set();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!dataStoreContext.id.includes(\"/\"), 0x30e /* Id cannot contain slashes. DataStoreContext should have validated this. */);\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(dataStoreContext.logger, \"FluidDataStoreRuntime\", { all: { dataStoreId: (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])() } });\n        this.id = dataStoreContext.id;\n        this.options = dataStoreContext.options;\n        this.deltaManager = dataStoreContext.deltaManager;\n        this.quorum = dataStoreContext.getQuorum();\n        this.audience = dataStoreContext.getAudience();\n        const tree = dataStoreContext.baseSnapshot;\n        this.channelsBaseGCDetails = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.LazyPromise(async () => {\n            var _a, _b, _c;\n            const baseGCDetails = await ((_c = (_b = (_a = this.dataStoreContext).getBaseGCDetails) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : this.dataStoreContext.getInitialGCSummaryDetails());\n            return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.unpackChildNodesGCDetails)(baseGCDetails);\n        });\n        // Must always receive the data store type inside of the attributes\n        if ((tree === null || tree === void 0 ? void 0 : tree.trees) !== undefined) {\n            Object.keys(tree.trees).forEach((path) => {\n                // Issue #4414\n                if (path === \"_search\") {\n                    return;\n                }\n                let channelContext;\n                // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a\n                // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be\n                // true. In this case create a RehydratedLocalChannelContext.\n                if (dataStoreContext.isLocalDataStore) {\n                    channelContext = new _localChannelContext__WEBPACK_IMPORTED_MODULE_6__.RehydratedLocalChannelContext(path, this.sharedObjectRegistry, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), tree.trees[path]);\n                    // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of\n                    // data store, if the data store is loaded after the container is attached, then we missed making\n                    // the channel visible. So do it now. Otherwise, add it to local channel context queue, so\n                    // that it can be make it visible later with the data store.\n                    if (dataStoreContext.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached) {\n                        channelContext.makeVisible();\n                    }\n                    else {\n                        this.localChannelContextQueue.set(path, channelContext);\n                    }\n                }\n                else {\n                    channelContext = new _remoteChannelContext__WEBPACK_IMPORTED_MODULE_8__.RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), path, tree.trees[path], this.sharedObjectRegistry, undefined /* extraBlobs */, this.dataStoreContext.getCreateChildSummarizerNodeFn(path, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.CreateSummarizerNodeSource.FromSummary }), async () => this.getChannelBaseGCDetails(path));\n                }\n                const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n                deferred.resolve(channelContext);\n                this.contexts.set(path, channelContext);\n                this.contextsDeferred.set(path, deferred);\n            });\n        }\n        this.attachListener();\n        // If exists on storage or loaded from a snapshot, it should already be bound.\n        this.bindState = existing ? _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.Bound : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.NotBound;\n        this._attachState = dataStoreContext.attachState;\n        /**\n         * If existing flag is false, this is a new data store and is not visible. The existing flag can be true in two\n         * conditions:\n         * 1. It's a local data store that is created when a detached container is rehydrated. In this case, the data\n         *    store is locally visible because the snapshot it is loaded from contains locally visible data stores only.\n         * 2. It's a remote data store that is created when an attached container is loaded is loaded from snapshot or\n         *    when an attach op comes in. In both these cases, the data store is already globally visible.\n         */\n        if (existing) {\n            this.visibilityState = dataStoreContext.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached\n                ? _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.LocallyVisible : _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible;\n        }\n        else {\n            this.visibilityState = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.NotVisible;\n        }\n        // If it's existing we know it has been attached.\n        if (existing) {\n            this.deferredAttached.resolve();\n        }\n    }\n    /**\n     * Loads the data store runtime\n     * @param context - The data store context\n     * @param sharedObjectRegistry - The registry of shared objects used by this data store\n     * @param existing - If loading from an existing file.\n     */\n    static load(context, sharedObjectRegistry, existing) {\n        return new FluidDataStoreRuntime(context, sharedObjectRegistry, existing);\n    }\n    get IFluidRouter() { return this; }\n    get connected() {\n        return this.dataStoreContext.connected;\n    }\n    get clientId() {\n        return this.dataStoreContext.clientId;\n    }\n    get clientDetails() {\n        return this.dataStoreContext.clientDetails;\n    }\n    get isAttached() {\n        return this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached;\n    }\n    get attachState() {\n        return this._attachState;\n    }\n    get absolutePath() {\n        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__.generateHandleContextPath)(this.id, this.routeContext);\n    }\n    get routeContext() {\n        return this.dataStoreContext.IFluidHandleContext;\n    }\n    get IFluidHandleContext() { return this; }\n    get rootRoutingContext() { return this; }\n    get channelsRoutingContext() { return this; }\n    get objectsRoutingContext() { return this; }\n    get disposed() { return this._disposed; }\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this.emit(\"dispose\");\n        this.removeAllListeners();\n    }\n    async resolveHandle(request) {\n        return this.request(request);\n    }\n    async request(request) {\n        try {\n            const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.RequestParser.create(request);\n            const id = parser.pathParts[0];\n            if (id === \"_channels\" || id === \"_custom\") {\n                return this.request(parser.createSubRequest(1));\n            }\n            // Check for a data type reference first\n            if (this.contextsDeferred.has(id) && parser.isLeaf(1)) {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const value = await this.contextsDeferred.get(id).promise;\n                    const channel = await value.getChannel();\n                    return { mimeType: \"fluid/object\", status: 200, value: channel };\n                }\n                catch (error) {\n                    this.logger.sendErrorEvent({ eventName: \"GetChannelFailedInRequest\" }, error);\n                    return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.createResponseError)(500, `Failed to get Channel: ${error}`, request);\n                }\n            }\n            // Otherwise defer to an attached request handler\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.create404Response)(request);\n        }\n        catch (error) {\n            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.exceptionToResponse)(error);\n        }\n    }\n    async getChannel(id) {\n        this.verifyNotClosed();\n        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist\n        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if\n        // it doesn't exist\n        if (!this.contextsDeferred.has(id)) {\n            this.contextsDeferred.set(id, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred());\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const context = await this.contextsDeferred.get(id).promise;\n        const channel = await context.getChannel();\n        return channel;\n    }\n    createChannel(id = (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(), type) {\n        if (id.includes(\"/\")) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.UsageError(`Id cannot contain slashes: ${id}`);\n        }\n        this.verifyNotClosed();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.contexts.has(id), 0x179 /* \"createChannel() with existing ID\" */);\n        this.notBoundedChannelContextSet.add(id);\n        const context = new _localChannelContext__WEBPACK_IMPORTED_MODULE_6__.LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle));\n        this.contexts.set(id, context);\n        if (this.contextsDeferred.has(id)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.contextsDeferred.get(id).resolve(context);\n        }\n        else {\n            const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n            deferred.resolve(context);\n            this.contextsDeferred.set(id, deferred);\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!context.channel, 0x17a /* \"Channel should be loaded when created!!\" */);\n        return context.channel;\n    }\n    /**\n     * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.\n     * If the runtime is not attached we will defer the attach until the runtime attaches.\n     * @param channel - channel to be registered.\n     */\n    bindChannel(channel) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.notBoundedChannelContextSet.has(channel.id), 0x17b /* \"Channel to be binded should be in not bounded set\" */);\n        this.notBoundedChannelContextSet.delete(channel.id);\n        // If our data store is attached, then attach the channel.\n        if (this.isAttached) {\n            this.attachChannel(channel);\n            return;\n        }\n        /**\n         * If this channel is already waiting to be made visible, do nothing. This can happen during attachGraph() when\n         * a channel's graph is attached. It calls bindToContext on the shared object which will end up back here.\n         */\n        if (this.pendingHandlesToMakeVisible.has(channel.handle)) {\n            return;\n        }\n        this.bind(channel.handle);\n        // If our data store is local then add the channel to the queue\n        if (!this.localChannelContextQueue.has(channel.id)) {\n            this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));\n        }\n    }\n    /**\n     * This function is called when a data store becomes root. It does the following:\n     * 1. Marks the data store locally visible in the container.\n     * 2. Attaches the graph of all the handles bound to it.\n     * 3. Calls into the data store context to mark it visible in the container too. If the container is globally\n     *    visible, it will mark us globally visible. Otherwise, it will mark us globally visible when it becomes\n     *    globally visible.\n     */\n    makeVisibleAndAttachGraph() {\n        if (this.visibilityState !== _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.NotVisible) {\n            return;\n        }\n        this.visibilityState = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.LocallyVisible;\n        this.pendingHandlesToMakeVisible.forEach((handle) => {\n            handle.attachGraph();\n        });\n        this.pendingHandlesToMakeVisible.clear();\n        this.bindToContext();\n    }\n    /**\n     * This function is called when a handle to this data store is added to a visible DDS.\n     */\n    attachGraph() {\n        this.makeVisibleAndAttachGraph();\n    }\n    /**\n     * Binds this runtime to the container\n     * This includes the following:\n     * 1. Sending an Attach op that includes all existing state\n     * 2. Attaching the graph if the data store becomes attached.\n     */\n    bindToContext() {\n        if (this.bindState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.NotBound) {\n            return;\n        }\n        this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.Binding;\n        this.dataStoreContext.bindToContext();\n        this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.Bound;\n    }\n    bind(handle) {\n        // If visible, attach the incoming handle's graph. Else, this will be done when we become visible.\n        if (this.visibilityState !== _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.NotVisible) {\n            handle.attachGraph();\n            return;\n        }\n        this.pendingHandlesToMakeVisible.add(handle);\n    }\n    setConnectionState(connected, clientId) {\n        this.verifyNotClosed();\n        for (const [, object] of this.contexts) {\n            object.setConnectionState(connected, clientId);\n        }\n        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__.raiseConnectedEvent)(this.logger, this, connected, clientId);\n    }\n    getQuorum() {\n        return this.quorum;\n    }\n    getAudience() {\n        return this.audience;\n    }\n    async uploadBlob(blob) {\n        this.verifyNotClosed();\n        return this.dataStoreContext.uploadBlob(blob);\n    }\n    process(message, local, localOpMetadata) {\n        this.verifyNotClosed();\n        try {\n            // catches as data processing error whether or not they come from async pending queues\n            switch (message.type) {\n                case DataStoreMessageType.Attach: {\n                    const attachMessage = message.contents;\n                    const id = attachMessage.id;\n                    // If a non-local operation then go and create the object\n                    // Otherwise mark it as officially attached.\n                    if (local) {\n                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pendingAttach.has(id), 0x17c /* \"Unexpected attach (local) channel OP\" */);\n                        this.pendingAttach.delete(id);\n                    }\n                    else {\n                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.contexts.has(id), 0x17d);\n                        const flatBlobs = new Map();\n                        const snapshotTree = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);\n                        const remoteChannelContext = new _remoteChannelContext__WEBPACK_IMPORTED_MODULE_8__.RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {\n                            type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.CreateSummarizerNodeSource.FromAttach,\n                            sequenceNumber: message.sequenceNumber,\n                            snapshot: attachMessage.snapshot,\n                        }), async () => this.getChannelBaseGCDetails(id), attachMessage.type);\n                        this.contexts.set(id, remoteChannelContext);\n                        if (this.contextsDeferred.has(id)) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            this.contextsDeferred.get(id).resolve(remoteChannelContext);\n                        }\n                        else {\n                            const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n                            deferred.resolve(remoteChannelContext);\n                            this.contextsDeferred.set(id, deferred);\n                        }\n                    }\n                    break;\n                }\n                case DataStoreMessageType.ChannelOp:\n                    this.processChannelOp(message, local, localOpMetadata);\n                    break;\n                default:\n            }\n            this.emit(\"op\", message);\n        }\n        catch (error) {\n            throw _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.DataProcessingError.wrapIfUnrecognized(error, \"fluidDataStoreRuntimeFailedToProcessMessage\", message);\n        }\n    }\n    processSignal(message, local) {\n        this.emit(\"signal\", message, local);\n    }\n    isChannelAttached(id) {\n        return (\n        // Added in createChannel\n        // Removed when bindChannel is called\n        !this.notBoundedChannelContextSet.has(id)\n            // Added in bindChannel only if this is not attached yet\n            // Removed when this is attached by calling attachGraph\n            && !this.localChannelContextQueue.has(id)\n            // Added in attachChannel called by bindChannel\n            // Removed when attach op is broadcast\n            && !this.pendingAttach.has(id));\n    }\n    /**\n     * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered\n     * referenced and are hence outbound. This will change when we have root and non-root channel contexts.\n     * The only root contexts will be considered as referenced.\n     */\n    getOutboundRoutes() {\n        const outboundRoutes = [];\n        for (const [contextId] of this.contexts) {\n            outboundRoutes.push(`${this.absolutePath}/${contextId}`);\n        }\n        return outboundRoutes;\n    }\n    /**\n     * Updates the GC nodes of this channel. It does the following:\n     * - Adds a back route to self to all its child GC nodes.\n     * - Adds a node for this channel.\n     * @param builder - The builder that contains the GC nodes for this channel's children.\n     */\n    updateGCNodes(builder) {\n        // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should\n        // be considered referenced as well.\n        builder.addRouteToAllNodes(this.absolutePath);\n        // Get the outbound routes and add a GC node for this channel.\n        builder.addNode(\"/\", this.getOutboundRoutes());\n    }\n    /**\n     * Generates data used for garbage collection. This includes a list of GC nodes that represent this channel\n     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the\n     * document. It does the following:\n     * 1. Calls into each child context to get its GC data.\n     * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be\n     *    identified as belonging to the child.\n     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent\n     *    the GC data of this channel.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.GCDataBuilder();\n        // Iterate over each channel context and get their GC data.\n        await Promise.all(Array.from(this.contexts)\n            .filter(([contextId, _]) => {\n            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n            // graph so any references they might have won't be connected as well.\n            return this.isChannelAttached(contextId);\n        }).map(async ([contextId, context]) => {\n            const contextGCData = await context.getGCData(fullGC);\n            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.\n            // This also gradually builds the id of each node to be a path from the root.\n            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        }));\n        this.updateGCNodes(builder);\n        return builder.getGCData();\n    }\n    /**\n     * After GC has run, called to notify this channel of routes that are used in it. It calls the child contexts to\n     * update their used routes.\n     * @param usedRoutes - The routes that are used in all contexts in this channel.\n     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced\n     * as part of this GC run, this should be used to update the time when it happens.\n     */\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        var _a;\n        // Get a map of channel ids to routes used in it.\n        const usedContextRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.unpackChildNodesUsedRoutes)(usedRoutes);\n        // Verify that the used routes are correct.\n        for (const [id] of usedContextRoutes) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.contexts.has(id), 0x17e /* \"Used route does not belong to any known context\" */);\n        }\n        // Update the used routes in each context. Used routes is empty for unused context.\n        for (const [contextId, context] of this.contexts) {\n            context.updateUsedRoutes((_a = usedContextRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);\n        }\n    }\n    /**\n     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify\n     * all references added in the system.\n     * @param srcHandle - The handle of the node that added the reference.\n     * @param outboundHandle - The handle of the outbound node that is referenced.\n     */\n    addedGCOutboundReference(srcHandle, outboundHandle) {\n        var _a, _b;\n        (_b = (_a = this.dataStoreContext).addedGCOutboundReference) === null || _b === void 0 ? void 0 : _b.call(_a, srcHandle, outboundHandle);\n    }\n    /**\n     * Returns the base GC details for the channel with the given id. This is used to initialize its GC state.\n     * @param channelId - The id of the channel context that is asked for the initial GC details.\n     * @returns the requested channel's base GC details.\n     */\n    async getChannelBaseGCDetails(channelId) {\n        var _a;\n        let channelBaseGCDetails = (await this.channelsBaseGCDetails).get(channelId);\n        if (channelBaseGCDetails === undefined) {\n            channelBaseGCDetails = {};\n        }\n        else if (((_a = channelBaseGCDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) !== undefined) {\n            // Note: if the child channel has an explicit handle route to its parent, it will be removed here and\n            // expected to be added back by the parent when getGCData is called.\n            (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.removeRouteFromAllNodes)(channelBaseGCDetails.gcData.gcNodes, this.absolutePath);\n        }\n        // Currently, channel context's are always considered used. So, it there are no used routes for it, we still\n        // need to mark it as used. Add self-route (empty string) to the channel context's used routes.\n        if (channelBaseGCDetails.usedRoutes === undefined || channelBaseGCDetails.usedRoutes.length === 0) {\n            channelBaseGCDetails.usedRoutes = [\"\"];\n        }\n        return channelBaseGCDetails;\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n    async summarize(fullTree = false, trackState = true, telemetryContext) {\n        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();\n        // Iterate over each data store and ask it to summarize\n        await Promise.all(Array.from(this.contexts)\n            .filter(([contextId, _]) => {\n            const isAttached = this.isChannelAttached(contextId);\n            // We are not expecting local dds! Summary may not capture local state.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isAttached, 0x17f /* \"Not expecting detached channels during summarize\" */);\n            // If the object is registered - and we have received the sequenced op creating the object\n            // (i.e. it has a base mapping) - then we go ahead and summarize\n            return isAttached;\n        }).map(async ([contextId, context]) => {\n            const contextSummary = await context.summarize(fullTree, trackState, telemetryContext);\n            summaryBuilder.addWithStats(contextId, contextSummary);\n        }));\n        return summaryBuilder.getSummaryTree();\n    }\n    getAttachSummary(telemetryContext) {\n        /**\n         * back-compat 0.59.1000 - getAttachSummary() is called when making a data store globally visible (previously\n         * attaching state). Ideally, attachGraph() should have already be called making it locally visible. However,\n         * before visibility state was added, this may not have been the case and getAttachSummary() could be called:\n         * 1) Before attaching the data store - When a detached container is attached.\n         * 2) After attaching the data store - When a data store is created and bound in an attached container.\n         *\n         * The basic idea is that all local object should become locally visible before they are globally visible.\n         */\n        this.attachGraph();\n        /**\n         * This assert cannot be added now due to back-compat. To be uncommented when the following issue is fixed -\n         * https://github.com/microsoft/FluidFramework/issues/9688.\n         *\n         * assert(this.visibilityState === VisibilityState.LocallyVisible,\n         *   \"The data store should be locally visible when generating attach summary\",\n         * );\n         */\n        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();\n        // Craft the .attributes file for each shared object\n        for (const [contextId, context] of this.contexts) {\n            if (!(context instanceof _localChannelContext__WEBPACK_IMPORTED_MODULE_6__.LocalChannelContextBase)) {\n                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError(\"Should only be called with local channel handles\");\n            }\n            if (!this.notBoundedChannelContextSet.has(contextId)) {\n                let summaryTree;\n                if (context.isLoaded) {\n                    const contextSummary = context.getAttachSummary(telemetryContext);\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(contextSummary.summary.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.SummaryType.Tree, 0x180 /* \"getAttachSummary should always return a tree\" */);\n                    summaryTree = { stats: contextSummary.stats, summary: contextSummary.summary };\n                }\n                else {\n                    // If this channel is not yet loaded, then there should be no changes in the snapshot from which\n                    // it was created as it is detached container. So just use the previous snapshot.\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.dataStoreContext.baseSnapshot, 0x181 /* \"BaseSnapshot should be there as detached container loaded from snapshot\" */);\n                    summaryTree = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertSnapshotTreeToSummaryTree)(this.dataStoreContext.baseSnapshot.trees[contextId]);\n                }\n                summaryBuilder.addWithStats(contextId, summaryTree);\n            }\n        }\n        return summaryBuilder.getSummaryTree();\n    }\n    submitMessage(type, content, localOpMetadata) {\n        this.submit(type, content, localOpMetadata);\n    }\n    submitSignal(type, content) {\n        this.verifyNotClosed();\n        return this.dataStoreContext.submitSignal(type, content);\n    }\n    /**\n     * Will return when the data store is attached.\n     */\n    async waitAttached() {\n        return this.deferredAttached.promise;\n    }\n    /**\n     * Attach channel should only be called after the data store has been attached\n     */\n    attachChannel(channel) {\n        this.verifyNotClosed();\n        // If this handle is already attached no need to attach again.\n        if (channel.handle.isAttached) {\n            return;\n        }\n        channel.handle.attachGraph();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.isAttached, 0x182 /* \"Data store should be attached to attach the channel.\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.visibilityState === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible, 0x2d0 /* \"Data store should be globally visible to attach channels.\" */);\n        const summarizeResult = (0,_channelContext__WEBPACK_IMPORTED_MODULE_19__.summarizeChannel)(channel, true /* fullTree */, false /* trackState */);\n        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n        const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertSummaryTreeToITree)(summarizeResult.summary);\n        const message = {\n            id: channel.id,\n            snapshot,\n            type: channel.attributes.type,\n        };\n        this.pendingAttach.set(channel.id, message);\n        this.submit(DataStoreMessageType.Attach, message);\n        const context = this.contexts.get(channel.id);\n        context.makeVisible();\n    }\n    submitChannelOp(address, contents, localOpMetadata) {\n        const envelope = { address, contents };\n        this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);\n    }\n    submit(type, content, localOpMetadata = undefined) {\n        this.verifyNotClosed();\n        this.dataStoreContext.submitMessage(type, content, localOpMetadata);\n    }\n    /**\n     * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.\n     * For all other messages, just submit it again.\n     * This typically happens when we reconnect and there are unacked messages.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    reSubmit(type, content, localOpMetadata) {\n        this.verifyNotClosed();\n        switch (type) {\n            case DataStoreMessageType.ChannelOp:\n                {\n                    // For Operations, find the right channel and trigger resubmission on it.\n                    const envelope = content;\n                    const channelContext = this.contexts.get(envelope.address);\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x183 /* \"There should be a channel context for the op\" */);\n                    channelContext.reSubmit(envelope.contents, localOpMetadata);\n                    break;\n                }\n            case DataStoreMessageType.Attach:\n                // For Attach messages, just submit them again.\n                this.submit(type, content, localOpMetadata);\n                break;\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_20__.unreachableCase)(type);\n        }\n    }\n    /**\n     * Revert a local op.\n     * @param content - The content of the original message.\n     * @param localOpMetadata - The local metadata associated with the original message.\n     */\n    rollback(type, content, localOpMetadata) {\n        this.verifyNotClosed();\n        switch (type) {\n            case DataStoreMessageType.ChannelOp:\n                {\n                    // For Operations, find the right channel and trigger resubmission on it.\n                    const envelope = content;\n                    const channelContext = this.contexts.get(envelope.address);\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x2ed /* \"There should be a channel context for the op\" */);\n                    channelContext.rollback(envelope.contents, localOpMetadata);\n                    break;\n                }\n            default:\n                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError(`Can't rollback ${type} message`);\n        }\n    }\n    async applyStashedOp(content) {\n        const envelope = content;\n        const channelContext = this.contexts.get(envelope.address);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x184 /* \"There should be a channel context for the op\" */);\n        await channelContext.getChannel();\n        return channelContext.applyStashedOp(envelope.contents);\n    }\n    setChannelDirty(address) {\n        this.verifyNotClosed();\n        this.dataStoreContext.setChannelDirty(address);\n    }\n    processChannelOp(message, local, localOpMetadata) {\n        this.verifyNotClosed();\n        const envelope = message.contents;\n        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });\n        const channelContext = this.contexts.get(envelope.address);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x185 /* \"Channel not found\" */);\n        channelContext.processOp(transformed, local, localOpMetadata);\n        return channelContext;\n    }\n    attachListener() {\n        this.setMaxListeners(Number.MAX_SAFE_INTEGER);\n        this.dataStoreContext.once(\"attaching\", () => {\n            /**\n             * back-compat 0.59.1000 - Ideally, attachGraph() should have already been called making the data store\n             * locally visible. However, before visibility state was added, this may not have been the case and data\n             * store can move to \"attaching\" state in 2 scenarios:\n             * 1) Before attachGraph() is called - When a data store is created and bound in an attached container.\n             * 2) After attachGraph() is called - When a detached container is attached.\n             *\n             * The basic idea is that all local object should become locally visible before they are globally visible.\n             */\n            this.attachGraph();\n            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Attaching;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.visibilityState === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.LocallyVisible, 0x2d1 /* \"Data store should be locally visible before it can become globally visible.\" */);\n            // Mark the data store globally visible and make its child channels visible as well.\n            this.visibilityState = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible;\n            this.localChannelContextQueue.forEach((channel) => {\n                channel.makeVisible();\n            });\n            this.localChannelContextQueue.clear();\n            // This promise resolution will be moved to attached event once we fix the scheduler.\n            this.deferredAttached.resolve();\n            this.emit(\"attaching\");\n        });\n        this.dataStoreContext.once(\"attached\", () => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.visibilityState === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible, 0x2d2 /* \"Data store should be globally visible when its attached.\" */);\n            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Attached;\n            this.emit(\"attached\");\n        });\n    }\n    verifyNotClosed() {\n        if (this._disposed) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError(\"Runtime is closed\");\n        }\n    }\n}\n/**\n * Mixin class that adds request handler to FluidDataStoreRuntime\n * Request handler is only called when data store can't resolve request, i.e. for custom requests.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n * @param requestHandler - request handler to mix in\n */\nconst mixinRequestHandler = (requestHandler, Base = FluidDataStoreRuntime) => class RuntimeWithRequestHandler extends Base {\n    async request(request) {\n        const response = await super.request(request);\n        if (response.status === 404) {\n            return requestHandler(request, this);\n        }\n        return response;\n    }\n};\n/**\n * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.\n * @param handler - handler that returns info about blob to be added to summary.\n * Or undefined not to add anything to summary.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n */\nconst mixinSummaryHandler = (handler, Base = FluidDataStoreRuntime) => class RuntimeWithSummarizerHandler extends Base {\n    addBlob(summary, path, content) {\n        const firstName = path.shift();\n        if (firstName === undefined) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError(\"Path can't be empty\");\n        }\n        let blob = {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.SummaryType.Blob,\n            content,\n        };\n        summary.stats.blobNodeCount++;\n        summary.stats.totalBlobSize += content.length;\n        for (const name of path.reverse()) {\n            blob = {\n                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.SummaryType.Tree,\n                tree: { [name]: blob },\n            };\n            summary.stats.treeNodeCount++;\n        }\n        summary.summary.tree[firstName] = blob;\n    }\n    async summarize(...args) {\n        const summary = await super.summarize(...args);\n        const content = await handler(this);\n        if (content !== undefined) {\n            this.addBlob(summary, content.path, content.content);\n        }\n        return summary;\n    }\n};\n//# sourceMappingURL=dataStoreRuntime.js.map\n\n/***/ }),\n/* 154 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 155 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"LazyPromise\": () => (/* binding */ LazyPromise)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nclass Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nclass LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map\n\n/***/ }),\n/* 156 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 157 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LocalChannelContext\": () => (/* binding */ LocalChannelContext),\n/* harmony export */   \"LocalChannelContextBase\": () => (/* binding */ LocalChannelContextBase),\n/* harmony export */   \"RehydratedLocalChannelContext\": () => (/* binding */ RehydratedLocalChannelContext)\n/* harmony export */ });\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(158);\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(270);\n/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(266);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\n\n\n\n\n\n/**\n * Channel context for a locally created channel\n */\nclass LocalChannelContextBase {\n    constructor(id, registry, runtime, servicesGetter) {\n        this.id = id;\n        this.registry = registry;\n        this.runtime = runtime;\n        this.servicesGetter = servicesGetter;\n        this.globallyVisible = false;\n        this.pending = [];\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.id.includes(\"/\"), 0x30f /* Channel context ID cannot contain slashes */);\n    }\n    async getChannel() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.channel !== undefined, 0x207 /* \"Channel should be defined\" */);\n        return this.channel;\n    }\n    get isLoaded() {\n        return this.channel !== undefined;\n    }\n    setConnectionState(connected, clientId) {\n        // Connection events are ignored if the data store is not yet globallyVisible or loaded\n        if (this.globallyVisible && this.isLoaded) {\n            this.servicesGetter().value.deltaConnection.setConnectionState(connected);\n        }\n    }\n    processOp(message, local, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.globallyVisible, 0x2d3 /* \"Local channel must be globally visible when processing op\" */);\n        // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of\n        // delay loading. So after the container is attached and some other client joins which start generating\n        // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.\n        if (this.isLoaded) {\n            this.servicesGetter().value.deltaConnection.process(message, local, localOpMetadata);\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(local === false, 0x189 /* \"Should always be remote because a local dds shouldn't generate ops before loading\" */);\n            this.pending.push(message);\n        }\n    }\n    reSubmit(content, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded, 0x18a /* \"Channel should be loaded to resubmit ops\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.globallyVisible, 0x2d4 /* \"Local channel must be globally visible when resubmitting op\" */);\n        this.servicesGetter().value.deltaConnection.reSubmit(content, localOpMetadata);\n    }\n    rollback(content, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded, 0x2ee /* \"Channel should be loaded to rollback ops\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.globallyVisible, 0x2ef /* \"Local channel must be globally visible when rolling back op\" */);\n        this.servicesGetter().value.deltaConnection.rollback(content, localOpMetadata);\n    }\n    applyStashedOp() {\n        throw new Error(\"no stashed ops on local channel\");\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n    async summarize(fullTree = false, trackState = false, telemetryContext) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded && this.channel !== undefined, 0x18c /* \"Channel should be loaded to summarize\" */);\n        return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannelAsync)(this.channel, fullTree, trackState, telemetryContext);\n    }\n    getAttachSummary(telemetryContext) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded && this.channel !== undefined, 0x18d /* \"Channel should be loaded to take snapshot\" */);\n        return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannel)(this.channel, true /* fullTree */, false /* trackState */, telemetryContext);\n    }\n    makeVisible() {\n        if (this.globallyVisible) {\n            throw new Error(\"Channel is already globally visible\");\n        }\n        if (this.isLoaded) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!this.channel, 0x192 /* \"Channel should be there if loaded!!\" */);\n            this.channel.connect(this.servicesGetter().value);\n        }\n        this.globallyVisible = true;\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n     * Each node has a set of outbound routes to other GC nodes in the document. This should be called only after\n     * the context has loaded.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded && this.channel !== undefined, 0x193 /* \"Channel should be loaded to run GC\" */);\n        return this.channel.getGCData(fullGC);\n    }\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        /**\n         * Currently, DDSes are always considered referenced and are not garbage collected.\n         * Once we have GC at DDS level, this channel context's used routes will be updated as per the passed\n         * value. See - https://github.com/microsoft/FluidFramework/issues/4611\n         */\n    }\n}\nclass RehydratedLocalChannelContext extends LocalChannelContextBase {\n    constructor(id, registry, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn, snapshotTree) {\n        super(id, registry, runtime, () => this.services);\n        this.snapshotTree = snapshotTree;\n        const blobMap = new Map();\n        const clonedSnapshotTree = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(this.snapshotTree);\n        // 0.47 back-compat Need to sanitize if snapshotTree.blobs still contains blob contents too.\n        // This is for older snapshot which is generated by loader <=0.47 version which still contains\n        // the contents within blobs. After a couple of revisions we can remove it.\n        if (this.isSnapshotInOldFormatAndCollectBlobs(clonedSnapshotTree, blobMap)) {\n            this.sanitizeSnapshot(clonedSnapshotTree);\n        }\n        this.services = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Lazy(() => {\n            return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger, clonedSnapshotTree, blobMap);\n        });\n        this.dirtyFn = () => { dirtyFn(id); };\n    }\n    async getChannel() {\n        if (this.channel === undefined) {\n            this.channel = await this.loadChannel()\n                .catch((err) => {\n                throw _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.wrapIfUnrecognized(err, \"rehydratedLocalChannelContextFailedToLoadChannel\", undefined);\n            });\n        }\n        return this.channel;\n    }\n    async loadChannel() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.isLoaded, 0x18e /* \"Channel must not already be loaded when loading\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(await this.services.value.objectStorage.contains(\".attributes\"), 0x190 /* \".attributes blob should be present\" */);\n        const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.readAndParse)(this.services.value.objectStorage, \".attributes\");\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.factory === undefined, 0x208 /* \"Factory should be undefined before loading\" */);\n        this.factory = this.registry.get(attributes.type);\n        if (this.factory === undefined) {\n            throw new Error(`Channel Factory ${attributes.type} not registered`);\n        }\n        // Services will be assigned during this load.\n        const channel = await this.factory.load(this.runtime, this.id, this.services.value, attributes);\n        // Commit changes.\n        this.channel = channel;\n        // Send all pending messages to the channel\n        for (const message of this.pending) {\n            this.services.value.deltaConnection.process(message, false, undefined /* localOpMetadata */);\n        }\n        return this.channel;\n    }\n    isSnapshotInOldFormatAndCollectBlobs(snapshotTree, blobMap) {\n        let sanitize = false;\n        const blobsContents = snapshotTree.blobsContents;\n        Object.entries(blobsContents).forEach(([key, value]) => {\n            blobMap.set(key, value);\n            if (snapshotTree.blobs[key] !== undefined) {\n                sanitize = true;\n            }\n        });\n        for (const value of Object.values(snapshotTree.trees)) {\n            sanitize = sanitize || this.isSnapshotInOldFormatAndCollectBlobs(value, blobMap);\n        }\n        return sanitize;\n    }\n    sanitizeSnapshot(snapshotTree) {\n        const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));\n        for (const [blobName, blobId] of blobMapInitial.entries()) {\n            const blobValue = blobMapInitial.get(blobId);\n            if (blobValue === undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete snapshotTree.blobs[blobName];\n            }\n        }\n        for (const value of Object.values(snapshotTree.trees)) {\n            this.sanitizeSnapshot(value);\n        }\n    }\n}\nclass LocalChannelContext extends LocalChannelContextBase {\n    constructor(id, registry, type, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn) {\n        super(id, registry, runtime, () => this.services);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(type !== undefined, 0x209 /* \"Factory Type should be defined\" */);\n        this.factory = registry.get(type);\n        if (this.factory === undefined) {\n            throw new Error(`Channel Factory ${type} not registered`);\n        }\n        this.channel = this.factory.create(runtime, id);\n        this.services = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Lazy(() => {\n            return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger);\n        });\n        this.dirtyFn = () => { dirtyFn(id); };\n    }\n}\n//# sourceMappingURL=localChannelContext.js.map\n\n/***/ }),\n/* 158 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseClone = __webpack_require__(159);\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n\n\n/***/ }),\n/* 159 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Stack = __webpack_require__(160),\n    arrayEach = __webpack_require__(204),\n    assignValue = __webpack_require__(205),\n    baseAssign = __webpack_require__(208),\n    baseAssignIn = __webpack_require__(230),\n    cloneBuffer = __webpack_require__(234),\n    copyArray = __webpack_require__(235),\n    copySymbols = __webpack_require__(236),\n    copySymbolsIn = __webpack_require__(240),\n    getAllKeys = __webpack_require__(244),\n    getAllKeysIn = __webpack_require__(246),\n    getTag = __webpack_require__(247),\n    initCloneArray = __webpack_require__(252),\n    initCloneByTag = __webpack_require__(253),\n    initCloneObject = __webpack_require__(260),\n    isArray = __webpack_require__(216),\n    isBuffer = __webpack_require__(217),\n    isMap = __webpack_require__(262),\n    isObject = __webpack_require__(184),\n    isSet = __webpack_require__(264),\n    keys = __webpack_require__(210),\n    keysIn = __webpack_require__(231);\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n/***/ }),\n/* 160 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar ListCache = __webpack_require__(161),\n    stackClear = __webpack_require__(169),\n    stackDelete = __webpack_require__(170),\n    stackGet = __webpack_require__(171),\n    stackHas = __webpack_require__(172),\n    stackSet = __webpack_require__(173);\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n/***/ }),\n/* 161 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar listCacheClear = __webpack_require__(162),\n    listCacheDelete = __webpack_require__(163),\n    listCacheGet = __webpack_require__(166),\n    listCacheHas = __webpack_require__(167),\n    listCacheSet = __webpack_require__(168);\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/***/ }),\n/* 162 */\n/***/ ((module) => {\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n/***/ }),\n/* 163 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(164);\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/***/ }),\n/* 164 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar eq = __webpack_require__(165);\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/***/ }),\n/* 165 */\n/***/ ((module) => {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n/* 166 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(164);\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/***/ }),\n/* 167 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(164);\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/***/ }),\n/* 168 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(164);\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/***/ }),\n/* 169 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar ListCache = __webpack_require__(161);\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n/***/ }),\n/* 170 */\n/***/ ((module) => {\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n/***/ }),\n/* 171 */\n/***/ ((module) => {\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n/***/ }),\n/* 172 */\n/***/ ((module) => {\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n/***/ }),\n/* 173 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar ListCache = __webpack_require__(161),\n    Map = __webpack_require__(174),\n    MapCache = __webpack_require__(189);\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n/***/ }),\n/* 174 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175),\n    root = __webpack_require__(180);\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/***/ }),\n/* 175 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseIsNative = __webpack_require__(176),\n    getValue = __webpack_require__(188);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n/* 176 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isFunction = __webpack_require__(177),\n    isMasked = __webpack_require__(185),\n    isObject = __webpack_require__(184),\n    toSource = __webpack_require__(187);\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n/* 177 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetTag = __webpack_require__(178),\n    isObject = __webpack_require__(184);\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n/* 178 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Symbol = __webpack_require__(179),\n    getRawTag = __webpack_require__(182),\n    objectToString = __webpack_require__(183);\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n/* 179 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar root = __webpack_require__(180);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n/* 180 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar freeGlobal = __webpack_require__(181);\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n/* 181 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n\n\n/***/ }),\n/* 182 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Symbol = __webpack_require__(179);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n/* 183 */\n/***/ ((module) => {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n/* 184 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n/* 185 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar coreJsData = __webpack_require__(186);\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n/* 186 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar root = __webpack_require__(180);\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n/* 187 */\n/***/ ((module) => {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n/* 188 */\n/***/ ((module) => {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n/* 189 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar mapCacheClear = __webpack_require__(190),\n    mapCacheDelete = __webpack_require__(198),\n    mapCacheGet = __webpack_require__(201),\n    mapCacheHas = __webpack_require__(202),\n    mapCacheSet = __webpack_require__(203);\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/***/ }),\n/* 190 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Hash = __webpack_require__(191),\n    ListCache = __webpack_require__(161),\n    Map = __webpack_require__(174);\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/***/ }),\n/* 191 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar hashClear = __webpack_require__(192),\n    hashDelete = __webpack_require__(194),\n    hashGet = __webpack_require__(195),\n    hashHas = __webpack_require__(196),\n    hashSet = __webpack_require__(197);\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/***/ }),\n/* 192 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(193);\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n/***/ }),\n/* 193 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175);\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/***/ }),\n/* 194 */\n/***/ ((module) => {\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n/***/ }),\n/* 195 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(193);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/***/ }),\n/* 196 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(193);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/***/ }),\n/* 197 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(193);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/***/ }),\n/* 198 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(199);\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n/* 199 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isKeyable = __webpack_require__(200);\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/***/ }),\n/* 200 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/***/ }),\n/* 201 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(199);\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/***/ }),\n/* 202 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(199);\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/***/ }),\n/* 203 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(199);\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/***/ }),\n/* 204 */\n/***/ ((module) => {\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n/***/ }),\n/* 205 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseAssignValue = __webpack_require__(206),\n    eq = __webpack_require__(165);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n/***/ }),\n/* 206 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar defineProperty = __webpack_require__(207);\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n/***/ }),\n/* 207 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175);\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n/***/ }),\n/* 208 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar copyObject = __webpack_require__(209),\n    keys = __webpack_require__(210);\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n/***/ }),\n/* 209 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assignValue = __webpack_require__(205),\n    baseAssignValue = __webpack_require__(206);\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n/***/ }),\n/* 210 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar arrayLikeKeys = __webpack_require__(211),\n    baseKeys = __webpack_require__(225),\n    isArrayLike = __webpack_require__(229);\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n/***/ }),\n/* 211 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseTimes = __webpack_require__(212),\n    isArguments = __webpack_require__(213),\n    isArray = __webpack_require__(216),\n    isBuffer = __webpack_require__(217),\n    isIndex = __webpack_require__(219),\n    isTypedArray = __webpack_require__(220);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n/* 212 */\n/***/ ((module) => {\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n/***/ }),\n/* 213 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseIsArguments = __webpack_require__(214),\n    isObjectLike = __webpack_require__(215);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n/***/ }),\n/* 214 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetTag = __webpack_require__(178),\n    isObjectLike = __webpack_require__(215);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n/***/ }),\n/* 215 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n/* 216 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n/* 217 */\n/***/ ((module, exports, __webpack_require__) => {\n\n/* module decorator */ module = __webpack_require__.nmd(module);\nvar root = __webpack_require__(180),\n    stubFalse = __webpack_require__(218);\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n\n/***/ }),\n/* 218 */\n/***/ ((module) => {\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n/***/ }),\n/* 219 */\n/***/ ((module) => {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n/***/ }),\n/* 220 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseIsTypedArray = __webpack_require__(221),\n    baseUnary = __webpack_require__(223),\n    nodeUtil = __webpack_require__(224);\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n/***/ }),\n/* 221 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetTag = __webpack_require__(178),\n    isLength = __webpack_require__(222),\n    isObjectLike = __webpack_require__(215);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n/* 222 */\n/***/ ((module) => {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/***/ }),\n/* 223 */\n/***/ ((module) => {\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n/***/ }),\n/* 224 */\n/***/ ((module, exports, __webpack_require__) => {\n\n/* module decorator */ module = __webpack_require__.nmd(module);\nvar freeGlobal = __webpack_require__(181);\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n\n/***/ }),\n/* 225 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isPrototype = __webpack_require__(226),\n    nativeKeys = __webpack_require__(227);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n/***/ }),\n/* 226 */\n/***/ ((module) => {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n/***/ }),\n/* 227 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar overArg = __webpack_require__(228);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n/***/ }),\n/* 228 */\n/***/ ((module) => {\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n/***/ }),\n/* 229 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isFunction = __webpack_require__(177),\n    isLength = __webpack_require__(222);\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n/***/ }),\n/* 230 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar copyObject = __webpack_require__(209),\n    keysIn = __webpack_require__(231);\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n\n\n/***/ }),\n/* 231 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar arrayLikeKeys = __webpack_require__(211),\n    baseKeysIn = __webpack_require__(232),\n    isArrayLike = __webpack_require__(229);\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n/***/ }),\n/* 232 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isObject = __webpack_require__(184),\n    isPrototype = __webpack_require__(226),\n    nativeKeysIn = __webpack_require__(233);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n/***/ }),\n/* 233 */\n/***/ ((module) => {\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n/***/ }),\n/* 234 */\n/***/ ((module, exports, __webpack_require__) => {\n\n/* module decorator */ module = __webpack_require__.nmd(module);\nvar root = __webpack_require__(180);\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n\n\n/***/ }),\n/* 235 */\n/***/ ((module) => {\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n/***/ }),\n/* 236 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar copyObject = __webpack_require__(209),\n    getSymbols = __webpack_require__(237);\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n\n\n/***/ }),\n/* 237 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar arrayFilter = __webpack_require__(238),\n    stubArray = __webpack_require__(239);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n/***/ }),\n/* 238 */\n/***/ ((module) => {\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n/***/ }),\n/* 239 */\n/***/ ((module) => {\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n/***/ }),\n/* 240 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar copyObject = __webpack_require__(209),\n    getSymbolsIn = __webpack_require__(241);\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n\n\n/***/ }),\n/* 241 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar arrayPush = __webpack_require__(242),\n    getPrototype = __webpack_require__(243),\n    getSymbols = __webpack_require__(237),\n    stubArray = __webpack_require__(239);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n\n\n/***/ }),\n/* 242 */\n/***/ ((module) => {\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n/***/ }),\n/* 243 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar overArg = __webpack_require__(228);\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n/***/ }),\n/* 244 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetAllKeys = __webpack_require__(245),\n    getSymbols = __webpack_require__(237),\n    keys = __webpack_require__(210);\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n/***/ }),\n/* 245 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar arrayPush = __webpack_require__(242),\n    isArray = __webpack_require__(216);\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n/***/ }),\n/* 246 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetAllKeys = __webpack_require__(245),\n    getSymbolsIn = __webpack_require__(241),\n    keysIn = __webpack_require__(231);\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n\n\n/***/ }),\n/* 247 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar DataView = __webpack_require__(248),\n    Map = __webpack_require__(174),\n    Promise = __webpack_require__(249),\n    Set = __webpack_require__(250),\n    WeakMap = __webpack_require__(251),\n    baseGetTag = __webpack_require__(178),\n    toSource = __webpack_require__(187);\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n/***/ }),\n/* 248 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175),\n    root = __webpack_require__(180);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n/***/ }),\n/* 249 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175),\n    root = __webpack_require__(180);\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n/***/ }),\n/* 250 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175),\n    root = __webpack_require__(180);\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n/***/ }),\n/* 251 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(175),\n    root = __webpack_require__(180);\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n/***/ }),\n/* 252 */\n/***/ ((module) => {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n/***/ }),\n/* 253 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar cloneArrayBuffer = __webpack_require__(254),\n    cloneDataView = __webpack_require__(256),\n    cloneRegExp = __webpack_require__(257),\n    cloneSymbol = __webpack_require__(258),\n    cloneTypedArray = __webpack_require__(259);\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n\n\n/***/ }),\n/* 254 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Uint8Array = __webpack_require__(255);\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n\n\n/***/ }),\n/* 255 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar root = __webpack_require__(180);\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n/***/ }),\n/* 256 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar cloneArrayBuffer = __webpack_require__(254);\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n\n\n/***/ }),\n/* 257 */\n/***/ ((module) => {\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n\n\n/***/ }),\n/* 258 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Symbol = __webpack_require__(179);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n\n\n/***/ }),\n/* 259 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar cloneArrayBuffer = __webpack_require__(254);\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n\n\n/***/ }),\n/* 260 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseCreate = __webpack_require__(261),\n    getPrototype = __webpack_require__(243),\n    isPrototype = __webpack_require__(226);\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n\n\n/***/ }),\n/* 261 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isObject = __webpack_require__(184);\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n/***/ }),\n/* 262 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseIsMap = __webpack_require__(263),\n    baseUnary = __webpack_require__(223),\n    nodeUtil = __webpack_require__(224);\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n\n\n/***/ }),\n/* 263 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getTag = __webpack_require__(247),\n    isObjectLike = __webpack_require__(215);\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n\n\n/***/ }),\n/* 264 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseIsSet = __webpack_require__(265),\n    baseUnary = __webpack_require__(223),\n    nodeUtil = __webpack_require__(224);\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n\n\n/***/ }),\n/* 265 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getTag = __webpack_require__(247),\n    isObjectLike = __webpack_require__(215);\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n\n\n/***/ }),\n/* 266 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attributesBlobKey\": () => (/* binding */ attributesBlobKey),\n/* harmony export */   \"createServiceEndpoints\": () => (/* binding */ createServiceEndpoints),\n/* harmony export */   \"summarizeChannel\": () => (/* binding */ summarizeChannel),\n/* harmony export */   \"summarizeChannelAsync\": () => (/* binding */ summarizeChannelAsync)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);\n/* harmony import */ var _channelDeltaConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(267);\n/* harmony import */ var _channelStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nconst attributesBlobKey = \".attributes\";\nfunction createServiceEndpoints(id, connected, submitFn, dirtyFn, addedGCOutboundReferenceFn, storageService, logger, tree, extraBlobs) {\n    const deltaConnection = new _channelDeltaConnection__WEBPACK_IMPORTED_MODULE_0__.ChannelDeltaConnection(id, connected, (message, localOpMetadata) => submitFn(message, localOpMetadata), dirtyFn, addedGCOutboundReferenceFn);\n    const objectStorage = new _channelStorageService__WEBPACK_IMPORTED_MODULE_1__.ChannelStorageService(tree, storageService, logger, extraBlobs);\n    return {\n        deltaConnection,\n        objectStorage,\n    };\n}\nfunction summarizeChannel(channel, fullTree = false, trackState = false, telemetryContext) {\n    const summarizeResult = channel.getAttachSummary(fullTree, trackState, telemetryContext);\n    // Add the channel attributes to the returned result.\n    (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.addBlobToSummary)(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));\n    return summarizeResult;\n}\nasync function summarizeChannelAsync(channel, fullTree = false, trackState = false, telemetryContext) {\n    const summarizeResult = await channel.summarize(fullTree, trackState, telemetryContext);\n    // Add the channel attributes to the returned result.\n    (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.addBlobToSummary)(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));\n    return summarizeResult;\n}\n//# sourceMappingURL=channelContext.js.map\n\n/***/ }),\n/* 267 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChannelDeltaConnection\": () => (/* binding */ ChannelDeltaConnection)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(156);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass ChannelDeltaConnection {\n    constructor(objectId, _connected, submit, dirty, addedGCOutboundReference) {\n        this.objectId = objectId;\n        this._connected = _connected;\n        this.submit = submit;\n        this.dirty = dirty;\n        this.addedGCOutboundReference = addedGCOutboundReference;\n    }\n    get handler() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this._handler, 0x177 /* \"Missing delta handler\" */);\n        return this._handler;\n    }\n    get connected() {\n        return this._connected;\n    }\n    attach(handler) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this._handler === undefined, 0x178 /* \"Missing delta handler on attach\" */);\n        this._handler = handler;\n    }\n    setConnectionState(connected) {\n        this._connected = connected;\n        this.handler.setConnectionState(connected);\n    }\n    process(message, local, localOpMetadata) {\n        try {\n            // catches as data processing error whether or not they come from async pending queues\n            this.handler.process(message, local, localOpMetadata);\n        }\n        catch (error) {\n            throw _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataProcessingError.wrapIfUnrecognized(error, \"channelDeltaConnectionFailedToProcessMessage\", message);\n        }\n    }\n    reSubmit(content, localOpMetadata) {\n        this.handler.reSubmit(content, localOpMetadata);\n    }\n    rollback(content, localOpMetadata) {\n        if (this.handler.rollback === undefined) {\n            throw new Error(\"Handler doesn't support rollback\");\n        }\n        this.handler.rollback(content, localOpMetadata);\n    }\n    applyStashedOp(message) {\n        return this.handler.applyStashedOp(message);\n    }\n}\n//# sourceMappingURL=channelDeltaConnection.js.map\n\n/***/ }),\n/* 268 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChannelStorageService\": () => (/* binding */ ChannelStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass ChannelStorageService {\n    constructor(tree, storage, logger, extraBlobs) {\n        this.tree = tree;\n        this.storage = storage;\n        this.logger = logger;\n        this.extraBlobs = extraBlobs;\n        this.flattenedTree = {};\n        // Create a map from paths to blobs\n        if (tree !== undefined) {\n            ChannelStorageService.flattenTree(\"\", tree, this.flattenedTree);\n        }\n    }\n    static flattenTree(base, tree, results) {\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const path in tree.trees) {\n            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);\n        }\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const blob in tree.blobs) {\n            results[`${base}${blob}`] = tree.blobs[blob];\n        }\n    }\n    async contains(path) {\n        return this.flattenedTree[path] !== undefined;\n    }\n    async readBlob(path) {\n        const id = await this.getIdForPath(path);\n        const blob = this.extraBlobs !== undefined\n            ? this.extraBlobs.get(id)\n            : undefined;\n        if (blob !== undefined) {\n            return blob;\n        }\n        const blobP = this.storage.readBlob(id);\n        blobP.catch((error) => this.logger.sendErrorEvent({ eventName: \"ChannelStorageBlobError\" }, error));\n        return blobP;\n    }\n    async list(path) {\n        var _a;\n        let tree = this.tree;\n        const pathParts = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.getNormalizedObjectStoragePathParts)(path);\n        while (tree !== undefined && pathParts.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const part = pathParts.shift();\n            tree = tree.trees[part];\n        }\n        if (tree === undefined || pathParts.length !== 0) {\n            throw new Error(\"path does not exist\");\n        }\n        return Object.keys((_a = tree === null || tree === void 0 ? void 0 : tree.blobs) !== null && _a !== void 0 ? _a : {});\n    }\n    async getIdForPath(path) {\n        return this.flattenedTree[path];\n    }\n}\n//# sourceMappingURL=channelStorageService.js.map\n\n/***/ }),\n/* 269 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getNormalizedObjectStoragePathParts\": () => (/* binding */ getNormalizedObjectStoragePathParts),\n/* harmony export */   \"listBlobsAtTreePath\": () => (/* binding */ listBlobsAtTreePath)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getNormalizedObjectStoragePathParts(path) {\n    let normalizePath = path;\n    if (normalizePath.startsWith(\"/\")) {\n        normalizePath = normalizePath.substr(1);\n    }\n    if (normalizePath.endsWith(\"/\")) {\n        normalizePath = normalizePath.substr(0, normalizePath.length - 1);\n    }\n    if (normalizePath.length > 0) {\n        return normalizePath.split(\"/\");\n    }\n    return [];\n}\nasync function listBlobsAtTreePath(inputTree, path) {\n    const pathParts = getNormalizedObjectStoragePathParts(path);\n    let tree = inputTree;\n    while ((tree === null || tree === void 0 ? void 0 : tree.entries) !== undefined && pathParts.length > 0) {\n        const part = pathParts.shift();\n        const treeEntry = tree.entries.find((value) => {\n            if (value.type === \"Tree\" && value.path === part) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        });\n        // this check is largely superfluous due to the same check being done\n        // immediately above. the type system, however, is not aware of this.\n        // so we must redundantly determine that the entry's type is \"Tree\"\n        if ((treeEntry === null || treeEntry === void 0 ? void 0 : treeEntry.type) === \"Tree\") {\n            tree = treeEntry.value;\n        }\n        else {\n            tree = undefined;\n        }\n    }\n    if ((tree === null || tree === void 0 ? void 0 : tree.entries) === undefined || pathParts.length !== 0) {\n        throw new Error(\"path does not exist\");\n    }\n    return tree.entries.filter((e) => e.type === \"Blob\").map((e) => e.path);\n}\n//# sourceMappingURL=objectstorageutils.js.map\n\n/***/ }),\n/* 270 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lazy\": () => (/* binding */ Lazy)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable\n  */\nclass Lazy {\n    /**\n     * Instantiates an instance of Lazy<T>\n     * @param valueGenerator - the function that will generate the value when value is accessed the first time\n     */\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this._evaluated = false;\n    }\n    /**\n     * Return true if the value as been generated, otherwise false\n     */\n    get evaluated() {\n        return this._evaluated;\n    }\n    /**\n     * Get the value. If this is the first call the value will be generated\n     */\n    get value() {\n        if (!this._evaluated) {\n            this._evaluated = true;\n            this._value = this.valueGenerator();\n        }\n        return this._value;\n    }\n}\n//# sourceMappingURL=lazy.js.map\n\n/***/ }),\n/* 271 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RemoteChannelContext\": () => (/* binding */ RemoteChannelContext)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(156);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);\n/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(266);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\nclass RemoteChannelContext {\n    constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, addedGCOutboundReferenceFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, getBaseGCDetails, attachMessageType) {\n        this.runtime = runtime;\n        this.dataStoreContext = dataStoreContext;\n        this.id = id;\n        this.registry = registry;\n        this.attachMessageType = attachMessageType;\n        this.isLoaded = false;\n        this.pending = [];\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.id.includes(\"/\"), 0x310 /* Channel context ID cannot contain slashes */);\n        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(this.runtime.logger, \"RemoteChannelContext\");\n        this.services = (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), addedGCOutboundReferenceFn, storageService, this.subLogger, baseSnapshot, extraBlobs);\n        const thisSummarizeInternal = async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext);\n        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => getBaseGCDetails());\n        this.thresholdOpsCounter = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ThresholdCounter(RemoteChannelContext.pendingOpsCountThreshold, this.subLogger);\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    getChannel() {\n        if (this.channelP === undefined) {\n            this.channelP = this.loadChannel();\n        }\n        return this.channelP;\n    }\n    setConnectionState(connected, clientId) {\n        // Connection events are ignored if the data store is not yet loaded\n        if (!this.isLoaded) {\n            return;\n        }\n        this.services.deltaConnection.setConnectionState(connected);\n    }\n    applyStashedOp(message) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLoaded, 0x194 /* \"Remote channel must be loaded when rebasing op\" */);\n        return this.services.deltaConnection.applyStashedOp(message);\n    }\n    processOp(message, local, localOpMetadata) {\n        this.summarizerNode.invalidate(message.sequenceNumber);\n        if (this.isLoaded) {\n            this.services.deltaConnection.process(message, local, localOpMetadata);\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!local, 0x195 /* \"Remote channel must not be local when processing op\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pending !== undefined, 0x23e /* \"pending is undefined\" */);\n            this.pending.push(message);\n            this.thresholdOpsCounter.sendIfMultiple(\"StorePendingOps\", this.pending.length);\n        }\n    }\n    reSubmit(content, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLoaded, 0x196 /* \"Remote channel must be loaded when resubmitting op\" */);\n        this.services.deltaConnection.reSubmit(content, localOpMetadata);\n    }\n    rollback(content, localOpMetadata) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLoaded, 0x2f0 /* \"Remote channel must be loaded when rolling back op\" */);\n        this.services.deltaConnection.rollback(content, localOpMetadata);\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n    async summarize(fullTree = false, trackState = true, telemetryContext) {\n        return this.summarizerNode.summarize(fullTree, trackState, telemetryContext);\n    }\n    async summarizeInternal(fullTree, trackState, telemetryContext) {\n        const channel = await this.getChannel();\n        const summarizeResult = await (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannelAsync)(channel, fullTree, trackState, telemetryContext);\n        return Object.assign(Object.assign({}, summarizeResult), { id: this.id });\n    }\n    async loadChannel() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.isLoaded, 0x197 /* \"Remote channel must not already be loaded when loading\" */);\n        let attributes;\n        if (await this.services.objectStorage.contains(_channelContext__WEBPACK_IMPORTED_MODULE_2__.attributesBlobKey)) {\n            attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(this.services.objectStorage, _channelContext__WEBPACK_IMPORTED_MODULE_2__.attributesBlobKey);\n        }\n        let factory;\n        // this is a backward compatibility case where\n        // the attach message doesn't include\n        // the attributes. Since old attach messages\n        // will not have attributes we need to keep\n        // this as long as we support old attach messages\n        if (attributes === undefined) {\n            if (this.attachMessageType === undefined) {\n                // TODO: dataStoreId may require a different tag from PackageData #7488\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.DataCorruptionError(\"channelTypeNotAvailable\", {\n                    channelId: {\n                        value: this.id,\n                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                    },\n                    dataStoreId: {\n                        value: this.dataStoreContext.id,\n                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                    },\n                    dataStorePackagePath: this.dataStoreContext.packagePath.join(\"/\"),\n                });\n            }\n            factory = this.registry.get(this.attachMessageType);\n            if (factory === undefined) {\n                // TODO: dataStoreId may require a different tag from PackageData #7488\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.DataCorruptionError(\"channelFactoryNotRegisteredForAttachMessageType\", {\n                    channelId: {\n                        value: this.id,\n                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                    },\n                    dataStoreId: {\n                        value: this.dataStoreContext.id,\n                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                    },\n                    dataStorePackagePath: this.dataStoreContext.packagePath.join(\"/\"),\n                    channelFactoryType: this.attachMessageType,\n                });\n            }\n            attributes = factory.attributes;\n        }\n        else {\n            factory = this.registry.get(attributes.type);\n            if (factory === undefined) {\n                // TODO: dataStoreId may require a different tag from PackageData #7488\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.DataCorruptionError(\"channelFactoryNotRegisteredForGivenType\", {\n                    channelId: {\n                        value: this.id,\n                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                    },\n                    dataStoreId: {\n                        value: this.dataStoreContext.id,\n                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                    },\n                    dataStorePackagePath: this.dataStoreContext.packagePath.join(\"/\"),\n                    channelFactoryType: attributes.type,\n                });\n            }\n        }\n        // Compare snapshot version to collaborative object version\n        if (attributes.snapshotFormatVersion !== undefined\n            && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {\n            this.subLogger.sendTelemetryEvent({\n                eventName: \"ChannelAttributesVersionMismatch\",\n                channelType: { value: attributes.type, tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData },\n                channelSnapshotVersion: {\n                    value: `${attributes.snapshotFormatVersion}@${attributes.packageVersion}`,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                },\n                channelCodeVersion: {\n                    value: `${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`,\n                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,\n                },\n            });\n        }\n        const channel = await factory.load(this.runtime, this.id, this.services, attributes);\n        // Send all pending messages to the channel\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pending !== undefined, 0x23f /* \"pending undefined\" */);\n        for (const message of this.pending) {\n            this.services.deltaConnection.process(message, false, undefined /* localOpMetadata */);\n        }\n        this.thresholdOpsCounter.send(\"ProcessPendingOps\", this.pending.length);\n        // Commit changes.\n        this.channel = channel;\n        this.pending = undefined;\n        this.isLoaded = true;\n        // Because have some await between we created the service and here, the connection state might have changed\n        // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.\n        this.services.deltaConnection.setConnectionState(this.dataStoreContext.connected);\n        return this.channel;\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n     * Each node has a set of outbound routes to other GC nodes in the document.\n     * If there is no new data in this context since the last summary, previous GC data is used.\n     * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCData(fullGC = false) {\n        return this.summarizerNode.getGCData(fullGC);\n    }\n    /**\n     * Generates the data used for garbage collection. This is called when there is new data since last summary. It\n     * loads the context and calls into the channel to get its GC data.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n    async getGCDataInternal(fullGC = false) {\n        const channel = await this.getChannel();\n        return channel.getGCData(fullGC);\n    }\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n        /**\n         * Currently, DDSes are always considered referenced and are not garbage collected. Update the summarizer node's\n         * used routes to contain a route to this channel context.\n         * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -\n         * https://github.com/microsoft/FluidFramework/issues/4611\n         */\n        this.summarizerNode.updateUsedRoutes([\"\"]);\n    }\n}\nRemoteChannelContext.pendingOpsCountThreshold = 1000;\n//# sourceMappingURL=remoteChannelContext.js.map\n\n/***/ }),\n/* 272 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 273 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 274 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ServiceAudience\": () => (/* binding */ ServiceAudience)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Base class for providing audience information for sessions interacting with FluidContainer\n * This can be extended by different service-specific client packages to additional parameters to\n * the user and client details returned in IMember\n * @typeParam M - A service-specific member type.\n */\nclass ServiceAudience extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(\n    /**\n     * Fluid Container to read the audience from.\n     */\n    container) {\n        super();\n        this.container = container;\n        /**\n         * Retain the most recent member list.  This is so we have more information about a member\n         * leaving the audience in the removeMember event.  It allows us to match the behavior of the\n         * addMember event where it only fires on a change to the members this class exposes (and would\n         * actually produce a change in what getMembers returns).  It also allows us to provide the\n         * client details in the event which makes it easier to find that client connection in a map\n         * keyed on the userId and not clientId.\n         * This map will always be up-to-date in a removeMember event because it is set once at\n         * construction and in every addMember event.\n         * It is mapped clientId to M to be better work with what the IAudience event provides\n         */\n        this.lastMembers = new Map();\n        this.audience = container.audience;\n        // getMembers will assign lastMembers so the removeMember event has what it needs\n        // in case it would fire before getMembers otherwise gets called the first time\n        this.getMembers();\n        this.audience.on(\"addMember\", (clientId, details) => {\n            if (this.shouldIncludeAsMember(details)) {\n                const member = this.getMember(clientId);\n                this.emit(\"memberAdded\", clientId, member);\n                this.emit(\"membersChanged\");\n            }\n        });\n        this.audience.on(\"removeMember\", (clientId) => {\n            if (this.lastMembers.has(clientId)) {\n                this.emit(\"memberRemoved\", clientId, this.lastMembers.get(clientId));\n                this.emit(\"membersChanged\");\n            }\n        });\n        this.container.on(\"connected\", () => this.emit(\"membersChanged\"));\n    }\n    /**\n     * {@inheritDoc IServiceAudience.getMembers}\n     */\n    getMembers() {\n        const users = new Map();\n        const clientMemberMap = new Map();\n        // Iterate through the members and get the user specifics.\n        this.audience.getMembers().forEach((member, clientId) => {\n            if (this.shouldIncludeAsMember(member)) {\n                const userId = member.user.id;\n                // Ensure we're tracking the user\n                let user = users.get(userId);\n                if (user === undefined) {\n                    user = this.createServiceMember(member);\n                    users.set(userId, user);\n                }\n                // Add this connection to their collection\n                user.connections.push({ id: clientId, mode: member.mode });\n                clientMemberMap.set(clientId, user);\n            }\n        });\n        this.lastMembers = clientMemberMap;\n        return users;\n    }\n    /**\n     * {@inheritDoc IServiceAudience.getMyself}\n     */\n    getMyself() {\n        const clientId = this.container.clientId;\n        if (clientId === undefined) {\n            return undefined;\n        }\n        return this.getMember(clientId);\n    }\n    getMember(clientId) {\n        // Fetch the user ID assoicated with this client ID from the runtime\n        const internalAudienceMember = this.audience.getMember(clientId);\n        if (internalAudienceMember === undefined) {\n            return undefined;\n        }\n        // Return the member object with any other clients associated for this user\n        const allMembers = this.getMembers();\n        const member = allMembers.get(internalAudienceMember === null || internalAudienceMember === void 0 ? void 0 : internalAudienceMember.user.id);\n        if (member === undefined) {\n            throw Error(`Attempted to fetch client ${clientId} that is not part of the current member list`);\n        }\n        return member;\n    }\n    /**\n     * Provides ability for the inheriting class to include/omit specific members.\n     * An example use case is omitting the summarizer client.\n     * @param member - Member to be included/omitted.\n     */\n    shouldIncludeAsMember(member) {\n        // Include only human members\n        return member.details.capabilities.interactive;\n    }\n}\n//# sourceMappingURL=serviceAudience.js.map\n\n/***/ }),\n/* 275 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirectoryFactory\": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.DirectoryFactory),\n/* harmony export */   \"LocalValueMaker\": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.LocalValueMaker),\n/* harmony export */   \"MapFactory\": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.MapFactory),\n/* harmony export */   \"SharedDirectory\": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.SharedDirectory),\n/* harmony export */   \"SharedMap\": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.SharedMap)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(276);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n/* 276 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirectoryFactory\": () => (/* reexport safe */ _directory__WEBPACK_IMPORTED_MODULE_1__.DirectoryFactory),\n/* harmony export */   \"LocalValueMaker\": () => (/* reexport safe */ _localValues__WEBPACK_IMPORTED_MODULE_2__.LocalValueMaker),\n/* harmony export */   \"MapFactory\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_0__.MapFactory),\n/* harmony export */   \"SharedDirectory\": () => (/* reexport safe */ _directory__WEBPACK_IMPORTED_MODULE_1__.SharedDirectory),\n/* harmony export */   \"SharedMap\": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_0__.SharedMap)\n/* harmony export */ });\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(142);\n/* harmony import */ var _directory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);\n/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * The `map` package provides interfaces and implementing classes for map-like distributed data structures.\n *\n * @remarks The following distributed data structures are defined in this package:\n *\n * - {@link SharedMap}\n *\n * - {@link SharedDirectory}\n *\n * @packageDocumentation\n */\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 277 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Interval\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.Interval),\n/* harmony export */   \"IntervalCollection\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.IntervalCollection),\n/* harmony export */   \"IntervalCollectionIterator\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.IntervalCollectionIterator),\n/* harmony export */   \"IntervalType\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.IntervalType),\n/* harmony export */   \"PaddingSegment\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.PaddingSegment),\n/* harmony export */   \"RunSegment\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.RunSegment),\n/* harmony export */   \"SequenceDeltaEvent\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceDeltaEvent),\n/* harmony export */   \"SequenceEvent\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceEvent),\n/* harmony export */   \"SequenceInterval\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceInterval),\n/* harmony export */   \"SequenceMaintenanceEvent\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceMaintenanceEvent),\n/* harmony export */   \"SharedIntervalCollection\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedIntervalCollection),\n/* harmony export */   \"SharedIntervalCollectionFactory\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedIntervalCollectionFactory),\n/* harmony export */   \"SharedNumberSequence\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedNumberSequence),\n/* harmony export */   \"SharedNumberSequenceFactory\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedNumberSequenceFactory),\n/* harmony export */   \"SharedObjectSequence\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedObjectSequence),\n/* harmony export */   \"SharedObjectSequenceFactory\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedObjectSequenceFactory),\n/* harmony export */   \"SharedSegmentSequence\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSegmentSequence),\n/* harmony export */   \"SharedSequence\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence),\n/* harmony export */   \"SharedString\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedString),\n/* harmony export */   \"SharedStringFactory\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedStringFactory),\n/* harmony export */   \"SparseMatrix\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SparseMatrix),\n/* harmony export */   \"SparseMatrixFactory\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SparseMatrixFactory),\n/* harmony export */   \"SubSequence\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SubSequence),\n/* harmony export */   \"maxCellPosition\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxCellPosition),\n/* harmony export */   \"maxCol\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxCol),\n/* harmony export */   \"maxCols\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxCols),\n/* harmony export */   \"maxRow\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxRow),\n/* harmony export */   \"maxRows\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxRows),\n/* harmony export */   \"positionToRowCol\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.positionToRowCol),\n/* harmony export */   \"rowColToPosition\": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.rowColToPosition)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(278);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n//# sourceMappingURL=sequence.js.map\n\n/***/ }),\n/* 278 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Interval\": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.Interval),\n/* harmony export */   \"IntervalCollection\": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.IntervalCollection),\n/* harmony export */   \"IntervalCollectionIterator\": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.IntervalCollectionIterator),\n/* harmony export */   \"IntervalType\": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.IntervalType),\n/* harmony export */   \"PaddingSegment\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.PaddingSegment),\n/* harmony export */   \"RunSegment\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.RunSegment),\n/* harmony export */   \"SequenceDeltaEvent\": () => (/* reexport safe */ _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceDeltaEvent),\n/* harmony export */   \"SequenceEvent\": () => (/* reexport safe */ _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceEvent),\n/* harmony export */   \"SequenceInterval\": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.SequenceInterval),\n/* harmony export */   \"SequenceMaintenanceEvent\": () => (/* reexport safe */ _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceMaintenanceEvent),\n/* harmony export */   \"SharedIntervalCollection\": () => (/* reexport safe */ _sharedIntervalCollection__WEBPACK_IMPORTED_MODULE_9__.SharedIntervalCollection),\n/* harmony export */   \"SharedIntervalCollectionFactory\": () => (/* reexport safe */ _sharedIntervalCollection__WEBPACK_IMPORTED_MODULE_9__.SharedIntervalCollectionFactory),\n/* harmony export */   \"SharedNumberSequence\": () => (/* reexport safe */ _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_7__.SharedNumberSequence),\n/* harmony export */   \"SharedNumberSequenceFactory\": () => (/* reexport safe */ _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__.SharedNumberSequenceFactory),\n/* harmony export */   \"SharedObjectSequence\": () => (/* reexport safe */ _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_6__.SharedObjectSequence),\n/* harmony export */   \"SharedObjectSequenceFactory\": () => (/* reexport safe */ _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__.SharedObjectSequenceFactory),\n/* harmony export */   \"SharedSegmentSequence\": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_2__.SharedSegmentSequence),\n/* harmony export */   \"SharedSequence\": () => (/* reexport safe */ _sharedSequence__WEBPACK_IMPORTED_MODULE_5__.SharedSequence),\n/* harmony export */   \"SharedString\": () => (/* reexport safe */ _sharedString__WEBPACK_IMPORTED_MODULE_1__.SharedString),\n/* harmony export */   \"SharedStringFactory\": () => (/* reexport safe */ _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__.SharedStringFactory),\n/* harmony export */   \"SparseMatrix\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.SparseMatrix),\n/* harmony export */   \"SparseMatrixFactory\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.SparseMatrixFactory),\n/* harmony export */   \"SubSequence\": () => (/* reexport safe */ _sharedSequence__WEBPACK_IMPORTED_MODULE_5__.SubSequence),\n/* harmony export */   \"maxCellPosition\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxCellPosition),\n/* harmony export */   \"maxCol\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxCol),\n/* harmony export */   \"maxCols\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxCols),\n/* harmony export */   \"maxRow\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxRow),\n/* harmony export */   \"maxRows\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxRows),\n/* harmony export */   \"positionToRowCol\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.positionToRowCol),\n/* harmony export */   \"rowColToPosition\": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.rowColToPosition)\n/* harmony export */ });\n/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(279);\n/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(290);\n/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);\n/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(317);\n/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(311);\n/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(319);\n/* harmony import */ var _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(320);\n/* harmony import */ var _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(321);\n/* harmony import */ var _sparsematrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(322);\n/* harmony import */ var _sharedIntervalCollection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(323);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Supports distributed data structures which are list-like.\n *\n * This package's main export is {@link SharedSequence}, a DDS for storing and simultaneously editing a sequence of\n * text.\n *\n * @remarks Note that SharedString is a sequence DDS but it has additional specialized features and behaviors for\n * working with text.\n *\n * @packageDocumentation\n */\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 279 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Interval\": () => (/* binding */ Interval),\n/* harmony export */   \"IntervalCollection\": () => (/* binding */ IntervalCollection),\n/* harmony export */   \"IntervalCollectionIterator\": () => (/* binding */ IntervalCollectionIterator),\n/* harmony export */   \"IntervalCollectionValueType\": () => (/* binding */ IntervalCollectionValueType),\n/* harmony export */   \"IntervalType\": () => (/* binding */ IntervalType),\n/* harmony export */   \"LocalIntervalCollection\": () => (/* binding */ LocalIntervalCollection),\n/* harmony export */   \"SequenceInterval\": () => (/* binding */ SequenceInterval),\n/* harmony export */   \"SequenceIntervalCollectionValueType\": () => (/* binding */ SequenceIntervalCollectionValueType),\n/* harmony export */   \"createIntervalIndex\": () => (/* binding */ createIntervalIndex),\n/* harmony export */   \"defaultIntervalConflictResolver\": () => (/* binding */ defaultIntervalConflictResolver)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(288);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(289);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(280);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(282);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(284);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(281);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(286);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(287);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(285);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(26);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(27);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/* eslint-disable no-bitwise */\n\n\n\n\n\nconst reservedIntervalIdKey = \"intervalId\";\nvar IntervalType;\n(function (IntervalType) {\n    IntervalType[IntervalType[\"Simple\"] = 0] = \"Simple\";\n    IntervalType[IntervalType[\"Nest\"] = 1] = \"Nest\";\n    /**\n     * SlideOnRemove indicates that the ends of the interval will slide if the segment\n     * they reference is removed and acked.\n     * See `packages\\dds\\merge-tree\\REFERENCEPOSITIONS.md` for details\n     * SlideOnRemove is the default interval behavior and does not need to be specified.\n     */\n    IntervalType[IntervalType[\"SlideOnRemove\"] = 2] = \"SlideOnRemove\";\n    /**\n     * @internal\n     * A temporary interval, used internally\n     */\n    IntervalType[IntervalType[\"Transient\"] = 4] = \"Transient\";\n})(IntervalType || (IntervalType = {}));\n/**\n * Decompress an interval after loading a summary from JSON. The exact format\n * of this compression is unspecified and subject to change\n */\nfunction decompressInterval(interval, label) {\n    return {\n        start: interval[0],\n        end: interval[1],\n        sequenceNumber: interval[2],\n        intervalType: interval[3],\n        properties: Object.assign(Object.assign({}, interval[4]), { [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey]: label }),\n    };\n}\n/**\n * Compress an interval prior to serialization as JSON. The exact format of this\n * compression is unspecified and subject to change\n */\nfunction compressInterval(interval) {\n    const { start, end, sequenceNumber, intervalType, properties } = interval;\n    return [\n        start,\n        end,\n        sequenceNumber,\n        intervalType,\n        Object.assign(Object.assign({}, properties), { [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey]: undefined }),\n    ];\n}\nclass Interval {\n    constructor(start, end, props) {\n        this.start = start;\n        this.end = end;\n        this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();\n        this.properties = {};\n        if (props) {\n            this.addProperties(props);\n        }\n    }\n    getIntervalId() {\n        var _a;\n        const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n        if (id === undefined) {\n            return undefined;\n        }\n        return `${id}`;\n    }\n    getAdditionalPropertySets() {\n        return this.auxProps;\n    }\n    addPropertySet(props) {\n        if (this.auxProps === undefined) {\n            this.auxProps = [];\n        }\n        this.auxProps.push(props);\n    }\n    serialize(client) {\n        let seq = 0;\n        if (client) {\n            seq = client.getCurrentSeq();\n        }\n        const serializedInterval = {\n            end: this.end,\n            intervalType: 0,\n            sequenceNumber: seq,\n            start: this.start,\n        };\n        if (this.properties) {\n            serializedInterval.properties = this.properties;\n        }\n        return serializedInterval;\n    }\n    clone() {\n        return new Interval(this.start, this.end, this.properties);\n    }\n    compare(b) {\n        const startResult = this.compareStart(b);\n        if (startResult === 0) {\n            const endResult = this.compareEnd(b);\n            if (endResult === 0) {\n                const thisId = this.getIntervalId();\n                if (thisId) {\n                    const bId = b.getIntervalId();\n                    if (bId) {\n                        return thisId > bId ? 1 : thisId < bId ? -1 : 0;\n                    }\n                    return 0;\n                }\n                return 0;\n            }\n            else {\n                return endResult;\n            }\n        }\n        else {\n            return startResult;\n        }\n    }\n    compareStart(b) {\n        return this.start - b.start;\n    }\n    compareEnd(b) {\n        return this.end - b.end;\n    }\n    overlaps(b) {\n        const result = (this.start <= b.end) &&\n            (this.end >= b.start);\n        return result;\n    }\n    union(b) {\n        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);\n    }\n    getProperties() {\n        return this.properties;\n    }\n    addProperties(newProps, collaborating = false, seq, op) {\n        if (newProps) {\n            this.initializeProperties();\n            return this.propertyManager.addProperties(this.properties, newProps, op, seq, collaborating);\n        }\n    }\n    modify(label, start, end, op) {\n        const startPos = start !== null && start !== void 0 ? start : this.start;\n        const endPos = end !== null && end !== void 0 ? end : this.end;\n        if (this.start === startPos && this.end === endPos) {\n            // Return undefined to indicate that no change is necessary.\n            return;\n        }\n        const newInterval = new Interval(startPos, endPos);\n        if (this.properties) {\n            newInterval.initializeProperties();\n            this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);\n        }\n        return newInterval;\n    }\n    initializeProperties() {\n        if (!this.propertyManager) {\n            this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();\n        }\n        if (!this.properties) {\n            this.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.createMap)();\n        }\n    }\n}\nclass SequenceInterval {\n    constructor(start, end, intervalType, props) {\n        this.start = start;\n        this.end = end;\n        this.intervalType = intervalType;\n        this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();\n        this.properties = {};\n        if (props) {\n            this.addProperties(props);\n        }\n    }\n    /**\n     * @internal\n     * Subscribes to position change events on this interval if there are no current listeners.\n     */\n    addPositionChangeListeners(beforePositionChange, afterPositionChange) {\n        var _a, _b;\n        var _c, _d;\n        if (this.callbacks === undefined) {\n            this.callbacks = {\n                beforePositionChange,\n                afterPositionChange,\n            };\n            const startCbs = (_a = (_c = this.start).callbacks) !== null && _a !== void 0 ? _a : (_c.callbacks = {});\n            const endCbs = (_b = (_d = this.end).callbacks) !== null && _b !== void 0 ? _b : (_d.callbacks = {});\n            startCbs.beforeSlide = endCbs.beforeSlide = beforePositionChange;\n            startCbs.afterSlide = endCbs.afterSlide = afterPositionChange;\n        }\n    }\n    /**\n     * @internal\n     * Removes the currently subscribed position change listeners.\n     */\n    removePositionChangeListeners() {\n        if (this.callbacks) {\n            this.callbacks = undefined;\n            this.start.callbacks = undefined;\n            this.end.callbacks = undefined;\n        }\n    }\n    serialize(client) {\n        const startPosition = this.start.toPosition();\n        const endPosition = this.end.toPosition();\n        const serializedInterval = {\n            end: endPosition,\n            intervalType: this.intervalType,\n            sequenceNumber: client.getCurrentSeq(),\n            start: startPosition,\n        };\n        if (this.properties) {\n            serializedInterval.properties = this.properties;\n        }\n        return serializedInterval;\n    }\n    clone() {\n        return new SequenceInterval(this.start, this.end, this.intervalType, this.properties);\n    }\n    compare(b) {\n        const startResult = this.compareStart(b);\n        if (startResult === 0) {\n            const endResult = this.compareEnd(b);\n            if (endResult === 0) {\n                const thisId = this.getIntervalId();\n                if (thisId) {\n                    const bId = b.getIntervalId();\n                    if (bId) {\n                        return thisId > bId ? 1 : thisId < bId ? -1 : 0;\n                    }\n                    return 0;\n                }\n                return 0;\n            }\n            else {\n                return endResult;\n            }\n        }\n        else {\n            return startResult;\n        }\n    }\n    compareStart(b) {\n        return this.start.compare(b.start);\n    }\n    compareEnd(b) {\n        return this.end.compare(b.end);\n    }\n    overlaps(b) {\n        const result = (this.start.compare(b.end) <= 0) &&\n            (this.end.compare(b.start) >= 0);\n        return result;\n    }\n    getIntervalId() {\n        var _a;\n        const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n        if (id === undefined) {\n            return undefined;\n        }\n        return `${id}`;\n    }\n    union(b) {\n        return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);\n    }\n    addProperties(newProps, collab = false, seq, op) {\n        this.initializeProperties();\n        return this.propertyManager.addProperties(this.properties, newProps, op, seq, collab);\n    }\n    overlapsPos(bstart, bend) {\n        const startPos = this.start.toPosition();\n        const endPos = this.start.toPosition();\n        return (endPos > bstart) && (startPos < bend);\n    }\n    modify(label, start, end, op) {\n        const getRefType = (baseType) => {\n            let refType = baseType;\n            if (op === undefined) {\n                refType &= ~_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;\n                refType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;\n            }\n            return refType;\n        };\n        let startRef = this.start;\n        if (start !== undefined) {\n            startRef = createPositionReference(this.start.getClient(), start, getRefType(this.start.refType), op);\n            startRef.addProperties(this.start.properties);\n        }\n        let endRef = this.end;\n        if (end !== undefined) {\n            endRef = createPositionReference(this.end.getClient(), end, getRefType(this.end.refType), op);\n            endRef.addProperties(this.end.properties);\n        }\n        startRef.pairedRef = endRef;\n        endRef.pairedRef = startRef;\n        const newInterval = new SequenceInterval(startRef, endRef, this.intervalType);\n        if (this.properties) {\n            newInterval.initializeProperties();\n            this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);\n        }\n        return newInterval;\n    }\n    initializeProperties() {\n        if (!this.propertyManager) {\n            this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();\n        }\n        if (!this.properties) {\n            this.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.createMap)();\n        }\n    }\n}\nfunction createPositionReferenceFromSegoff(client, segoff, refType, op) {\n    if (segoff.segment) {\n        const ref = client.createLocalReferencePosition(segoff.segment, segoff.offset, refType, undefined);\n        return ref;\n    }\n    else {\n        if (!op && !(0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.Transient)) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError(\"Non-transient references need segment\");\n        }\n        return new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__.LocalReference(client, undefined, 0, refType);\n    }\n}\nfunction createPositionReference(client, pos, refType, op) {\n    let segoff;\n    if (op) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)((refType & _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove) !== 0, 0x2f5 /* op create references must be SlideOnRemove */);\n        segoff = client.getContainingSegment(pos, op);\n        segoff = client.getSlideToSegment(segoff);\n    }\n    else {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)((refType & _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove) === 0, 0x2f6 /* SlideOnRemove references must be op created */);\n        segoff = client.getContainingSegment(pos);\n    }\n    return createPositionReferenceFromSegoff(client, segoff, refType, op);\n}\nfunction createSequenceInterval(label, start, end, client, intervalType, op) {\n    let beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.RangeBegin;\n    let endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.RangeEnd;\n    if (intervalType === IntervalType.Transient) {\n        beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.Transient;\n        endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.Transient;\n    }\n    else {\n        if (intervalType === IntervalType.Nest) {\n            beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.NestBegin;\n            endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.NestEnd;\n        }\n        // All non-transient interval references must eventually be SlideOnRemove\n        // To ensure eventual consistency, they must start as StayOnRemove when\n        // pending (created locally and creation op is not acked)\n        if (op) {\n            beginRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;\n            endRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;\n        }\n        else {\n            beginRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;\n            endRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;\n        }\n    }\n    const startLref = createPositionReference(client, start, beginRefType, op);\n    const endLref = createPositionReference(client, end, endRefType, op);\n    startLref.pairedRef = endLref;\n    endLref.pairedRef = startLref;\n    const rangeProp = {\n        [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey]: [label],\n    };\n    startLref.addProperties(rangeProp);\n    endLref.addProperties(rangeProp);\n    const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);\n    return ival;\n}\nfunction defaultIntervalConflictResolver(a, b) {\n    a.addPropertySet(b.properties);\n    return a;\n}\nfunction createIntervalIndex(conflict) {\n    const helpers = {\n        compareEnds: compareIntervalEnds,\n        create: createInterval,\n    };\n    const lc = new LocalIntervalCollection(undefined, \"\", helpers);\n    if (conflict) {\n        lc.addConflictResolver(conflict);\n    }\n    else {\n        lc.addConflictResolver(defaultIntervalConflictResolver);\n    }\n    return lc;\n}\nclass LocalIntervalCollection {\n    constructor(client, label, helpers, \n    /** Callback invoked each time one of the endpoints of an interval slides. */\n    onPositionChange) {\n        this.client = client;\n        this.label = label;\n        this.helpers = helpers;\n        this.onPositionChange = onPositionChange;\n        this.intervalTree = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.IntervalTree();\n        this.intervalIdMap = new Map();\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        this.endIntervalTree = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.RedBlackTree(helpers.compareEnds);\n    }\n    addConflictResolver(conflictResolver) {\n        this.conflictResolver = conflictResolver;\n        this.endConflictResolver =\n            (key, currentKey) => {\n                const ival = conflictResolver(key, currentKey);\n                return {\n                    data: ival,\n                    key: ival,\n                };\n            };\n    }\n    map(fn) {\n        this.intervalTree.map(fn);\n    }\n    createLegacyId(start, end) {\n        // Create a non-unique ID based on start and end to be used on intervals that come from legacy clients\n        // without ID's.\n        return `${LocalIntervalCollection.legacyIdPrefix}${start}-${end}`;\n    }\n    /**\n     * Validates that a serialized interval has the ID property. Creates an ID\n     * if one does not already exist\n     *\n     * @param serializedInterval - The interval to be checked\n     * @returns The interval's existing or newly created id\n     */\n    ensureSerializedId(serializedInterval) {\n        var _a;\n        let id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n        if (id === undefined) {\n            // An interval came over the wire without an ID, so create a non-unique one based on start/end.\n            // This will allow all clients to refer to this interval consistently.\n            id = this.createLegacyId(serializedInterval.start, serializedInterval.end);\n            const newProps = {\n                [reservedIntervalIdKey]: id,\n            };\n            serializedInterval.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.addProperties)(serializedInterval.properties, newProps);\n        }\n        // Make the ID immutable for safety's sake.\n        Object.defineProperty(serializedInterval.properties, reservedIntervalIdKey, {\n            configurable: false,\n            enumerable: true,\n            writable: false,\n        });\n        return id;\n    }\n    mapUntil(fn) {\n        this.intervalTree.mapUntil(fn);\n    }\n    gatherIterationResults(results, iteratesForward, start, end) {\n        if (this.intervalTree.intervals.isEmpty()) {\n            return;\n        }\n        if (start === undefined && end === undefined) {\n            // No start/end provided. Gather the whole tree in the specified order.\n            if (iteratesForward) {\n                this.intervalTree.map((interval) => {\n                    results.push(interval);\n                });\n            }\n            else {\n                this.intervalTree.mapBackward((interval) => {\n                    results.push(interval);\n                });\n            }\n        }\n        else {\n            const transientInterval = this.helpers.create(\"transient\", start, end, this.client, IntervalType.Transient);\n            if (start === undefined) {\n                // Only end position provided. Since the tree is not sorted by end position,\n                // walk the whole tree in the specified order, gathering intervals that match the end.\n                if (iteratesForward) {\n                    this.intervalTree.map((interval) => {\n                        if (transientInterval.compareEnd(interval) === 0) {\n                            results.push(interval);\n                        }\n                    });\n                }\n                else {\n                    this.intervalTree.mapBackward((interval) => {\n                        if (transientInterval.compareEnd(interval) === 0) {\n                            results.push(interval);\n                        }\n                    });\n                }\n            }\n            else {\n                // Start and (possibly) end provided. Walk the subtrees that may contain\n                // this start position.\n                const compareFn = end === undefined ?\n                    (node) => {\n                        return transientInterval.compareStart(node.key);\n                    } :\n                    (node) => {\n                        return transientInterval.compare(node.key);\n                    };\n                const continueLeftFn = (cmpResult) => cmpResult <= 0;\n                const continueRightFn = (cmpResult) => cmpResult >= 0;\n                const actionFn = (node) => {\n                    results.push(node.key);\n                };\n                if (iteratesForward) {\n                    this.intervalTree.intervals.walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn);\n                }\n                else {\n                    this.intervalTree.intervals.walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn);\n                }\n            }\n        }\n    }\n    findOverlappingIntervals(startPosition, endPosition) {\n        if (endPosition < startPosition || this.intervalTree.intervals.isEmpty()) {\n            return [];\n        }\n        const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, IntervalType.Transient);\n        const overlappingIntervalNodes = this.intervalTree.match(transientInterval);\n        return overlappingIntervalNodes.map((node) => node.key);\n    }\n    previousInterval(pos) {\n        const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, IntervalType.Transient);\n        const rbNode = this.endIntervalTree.floor(transientInterval);\n        if (rbNode) {\n            return rbNode.data;\n        }\n    }\n    nextInterval(pos) {\n        const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, IntervalType.Transient);\n        const rbNode = this.endIntervalTree.ceil(transientInterval);\n        if (rbNode) {\n            return rbNode.data;\n        }\n    }\n    removeInterval(startPosition, endPosition) {\n        const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, IntervalType.Transient);\n        this.intervalTree.remove(transientInterval);\n        this.endIntervalTree.remove(transientInterval);\n        return transientInterval;\n    }\n    removeIntervalFromIndex(interval) {\n        this.intervalTree.removeExisting(interval);\n        this.endIntervalTree.remove(interval);\n        const id = interval.getIntervalId();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(id !== undefined, 0x311 /* expected id to exist on interval */);\n        this.intervalIdMap.delete(id);\n    }\n    removeExistingInterval(interval) {\n        this.removeIntervalFromIndex(interval);\n        this.removeIntervalListeners(interval);\n    }\n    createInterval(start, end, intervalType, op) {\n        return this.helpers.create(this.label, start, end, this.client, intervalType, op);\n    }\n    addInterval(start, end, intervalType, props, op) {\n        const interval = this.createInterval(start, end, intervalType, op);\n        if (interval) {\n            if (!interval.properties) {\n                interval.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.createMap)();\n            }\n            if (props) {\n                interval.addProperties(props);\n            }\n            if (interval.properties[reservedIntervalIdKey] === undefined) {\n                // Create a new ID.\n                interval.properties[reservedIntervalIdKey] = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n            }\n            this.add(interval);\n        }\n        return interval;\n    }\n    addIntervalToIndex(interval) {\n        const id = interval.getIntervalId();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(id !== undefined, 0x2c0 /* \"ID must be created before adding interval to collection\" */);\n        // Make the ID immutable.\n        Object.defineProperty(interval.properties, reservedIntervalIdKey, {\n            configurable: false,\n            enumerable: true,\n            writable: false,\n        });\n        this.intervalTree.put(interval, this.conflictResolver);\n        this.endIntervalTree.put(interval, interval, this.endConflictResolver);\n        this.intervalIdMap.set(id, interval);\n    }\n    add(interval) {\n        this.addIntervalToIndex(interval);\n        this.addIntervalListeners(interval);\n    }\n    getIntervalById(id) {\n        return this.intervalIdMap.get(id);\n    }\n    changeInterval(interval, start, end, op) {\n        const newInterval = interval.modify(this.label, start, end, op);\n        if (newInterval) {\n            this.removeExistingInterval(interval);\n            this.add(newInterval);\n        }\n        return newInterval;\n    }\n    serialize() {\n        const client = this.client;\n        const intervals = this.intervalTree.intervals.keys();\n        return {\n            label: this.label,\n            intervals: intervals.map((interval) => compressInterval(interval.serialize(client))),\n            version: 2,\n        };\n    }\n    addIntervalListeners(interval) {\n        if (interval instanceof SequenceInterval) {\n            interval.addPositionChangeListeners(() => this.removeIntervalFromIndex(interval), () => {\n                var _a;\n                this.addIntervalToIndex(interval);\n                (_a = this.onPositionChange) === null || _a === void 0 ? void 0 : _a.call(this, interval);\n            });\n        }\n    }\n    removeIntervalListeners(interval) {\n        if (interval instanceof SequenceInterval) {\n            interval.removePositionChangeListeners();\n        }\n    }\n}\nLocalIntervalCollection.legacyIdPrefix = \"legacy\";\nconst compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);\nclass SequenceIntervalCollectionFactory {\n    load(emitter, raw = []) {\n        const helpers = {\n            compareEnds: compareSequenceIntervalEnds,\n            create: createSequenceInterval,\n        };\n        return new IntervalCollection(helpers, true, emitter, raw);\n    }\n    store(value) {\n        return value.serializeInternal();\n    }\n}\nclass SequenceIntervalCollectionValueType {\n    get name() {\n        return SequenceIntervalCollectionValueType.Name;\n    }\n    get factory() {\n        return SequenceIntervalCollectionValueType._factory;\n    }\n    get ops() {\n        return SequenceIntervalCollectionValueType._ops;\n    }\n}\nSequenceIntervalCollectionValueType.Name = \"sharedStringIntervalCollection\";\nSequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();\nSequenceIntervalCollectionValueType._ops = makeOpsMap();\nconst compareIntervalEnds = (a, b) => a.end - b.end;\nfunction createInterval(label, start, end, client) {\n    const rangeProp = {};\n    if (label && label.length > 0) {\n        rangeProp[_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey] = [label];\n    }\n    return new Interval(start, end, rangeProp);\n}\nclass IntervalCollectionFactory {\n    load(emitter, raw = []) {\n        const helpers = {\n            compareEnds: compareIntervalEnds,\n            create: createInterval,\n        };\n        const collection = new IntervalCollection(helpers, false, emitter, raw);\n        collection.attachGraph(undefined, \"\");\n        return collection;\n    }\n    store(value) {\n        return value.serializeInternal();\n    }\n}\nclass IntervalCollectionValueType {\n    get name() {\n        return IntervalCollectionValueType.Name;\n    }\n    get factory() {\n        return IntervalCollectionValueType._factory;\n    }\n    get ops() {\n        return IntervalCollectionValueType._ops;\n    }\n}\nIntervalCollectionValueType.Name = \"sharedIntervalCollection\";\nIntervalCollectionValueType._factory = new IntervalCollectionFactory();\nIntervalCollectionValueType._ops = makeOpsMap();\nfunction makeOpsMap() {\n    const rebase = (collection, op, localOpMetadata) => {\n        const { localSeq } = localOpMetadata;\n        const rebasedValue = collection.rebaseLocalInterval(op.opName, op.value, localSeq);\n        const rebasedOp = Object.assign(Object.assign({}, op), { value: rebasedValue });\n        return { rebasedOp, rebasedLocalOpMetadata: localOpMetadata };\n    };\n    return new Map([[\n            \"add\",\n            {\n                process: (collection, params, local, op) => {\n                    collection.ackAdd(params, local, op);\n                },\n                rebase,\n            },\n        ],\n        [\n            \"delete\",\n            {\n                process: (collection, params, local, op) => {\n                    collection.ackDelete(params, local, op);\n                },\n                rebase: (collection, op, localOpMetadata) => {\n                    // Deletion of intervals is based on id, so requires no rebasing.\n                    return { rebasedOp: op, rebasedLocalOpMetadata: localOpMetadata };\n                },\n            },\n        ],\n        [\n            \"change\",\n            {\n                process: (collection, params, local, op) => {\n                    collection.ackChange(params, local, op);\n                },\n                rebase,\n            },\n        ]]);\n}\nclass IntervalCollectionIterator {\n    constructor(collection, iteratesForward = true, start, end) {\n        this.results = [];\n        this.index = 0;\n        collection.gatherIterationResults(this.results, iteratesForward, start, end);\n    }\n    next() {\n        let _value;\n        let _done = true;\n        if (this.index < this.results.length) {\n            _value = this.results[this.index++];\n            _done = false;\n        }\n        return {\n            value: _value,\n            done: _done,\n        };\n    }\n}\nclass IntervalCollection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.TypedEventEmitter {\n    /** @internal */\n    constructor(helpers, requiresClient, emitter, serializedIntervals) {\n        super();\n        this.helpers = helpers;\n        this.requiresClient = requiresClient;\n        this.emitter = emitter;\n        this.pendingChangesStart = new Map();\n        this.pendingChangesEnd = new Map();\n        if (Array.isArray(serializedIntervals)) {\n            this.savedSerializedIntervals = serializedIntervals;\n        }\n        else {\n            this.savedSerializedIntervals =\n                serializedIntervals.intervals.map((i) => decompressInterval(i, serializedIntervals.label));\n        }\n    }\n    get attached() {\n        return !!this.localCollection;\n    }\n    attachGraph(client, label) {\n        if (this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Only supports one Sequence attach\");\n        }\n        if ((client === undefined) && (this.requiresClient)) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Client required for this collection\");\n        }\n        // Instantiate the local interval collection based on the saved intervals\n        this.client = client;\n        this.localCollection = new LocalIntervalCollection(client, label, this.helpers, (interval) => this.emit(\"changeInterval\", interval, true, undefined));\n        if (this.savedSerializedIntervals) {\n            for (const serializedInterval of this.savedSerializedIntervals) {\n                this.localCollection.ensureSerializedId(serializedInterval);\n                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n            }\n        }\n        this.savedSerializedIntervals = undefined;\n    }\n    /**\n     * Gets the next local sequence number, modifying this client's collab window in doing so.\n     */\n    getNextLocalSeq() {\n        return ++this.client.getCollabWindow().localSeq;\n    }\n    getIntervalById(id) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attach must be called before accessing intervals\");\n        }\n        return this.localCollection.getIntervalById(id);\n    }\n    /**\n     * Create a new interval and add it to the collection\n     * @param start - interval start position\n     * @param end - interval end position\n     * @param intervalType - type of the interval. All intervals are SlideOnRemove. Intervals may not be Transient.\n     * @param props - properties of the interval\n     * @returns - the created interval\n     */\n    add(start, end, intervalType, props) {\n        var _a, _b;\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attach must be called prior to adding intervals\");\n        }\n        if (intervalType & IntervalType.Transient) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Can not add transient intervals\");\n        }\n        const interval = this.localCollection.addInterval(start, end, intervalType, props);\n        if (interval) {\n            const serializedInterval = {\n                end,\n                intervalType,\n                properties: interval.properties,\n                sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,\n                start,\n            };\n            // Local ops get submitted to the server. Remote ops have the deserializer run.\n            this.emitter.emit(\"add\", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });\n        }\n        this.emit(\"addInterval\", interval, true, undefined);\n        return interval;\n    }\n    deleteExistingInterval(interval, local, op) {\n        // The given interval is known to exist in the collection.\n        this.localCollection.removeExistingInterval(interval);\n        if (interval) {\n            // Local ops get submitted to the server. Remote ops have the deserializer run.\n            if (local) {\n                this.emitter.emit(\"delete\", undefined, interval.serialize(this.client), { localSeq: this.getNextLocalSeq() });\n            }\n            else {\n                if (this.onDeserialize) {\n                    this.onDeserialize(interval);\n                }\n            }\n        }\n        this.emit(\"deleteInterval\", interval, local, op);\n    }\n    removeIntervalById(id) {\n        const interval = this.localCollection.getIntervalById(id);\n        if (interval) {\n            this.deleteExistingInterval(interval, true, undefined);\n        }\n        return interval;\n    }\n    changeProperties(id, props) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Attach must be called before accessing intervals\");\n        }\n        if (typeof (id) !== \"string\") {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Change API requires an ID that is a string\");\n        }\n        if (!props) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"changeProperties should be called with a property set\");\n        }\n        const interval = this.getIntervalById(id);\n        if (interval) {\n            // Pass Unassigned as the sequence number to indicate that this is a local op that is waiting for an ack.\n            const deltaProps = interval.addProperties(props, true, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_11__.UnassignedSequenceNumber);\n            const serializedInterval = interval.serialize(this.client);\n            // Emit a change op that will only change properties. Add the ID to\n            // the property bag provided by the caller.\n            serializedInterval.start = undefined;\n            serializedInterval.end = undefined;\n            serializedInterval.properties = props;\n            serializedInterval.properties[reservedIntervalIdKey] = interval.getIntervalId();\n            this.emitter.emit(\"change\", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });\n            this.emit(\"propertyChanged\", interval, deltaProps);\n        }\n        this.emit(\"changeInterval\", interval, true, undefined);\n    }\n    change(id, start, end) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Attach must be called before accessing intervals\");\n        }\n        // Force id to be a string.\n        if (typeof (id) !== \"string\") {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Change API requires an ID that is a string\");\n        }\n        const interval = this.getIntervalById(id);\n        if (interval) {\n            const newInterval = this.localCollection.changeInterval(interval, start, end);\n            const serializedInterval = interval.serialize(this.client);\n            serializedInterval.start = start;\n            serializedInterval.end = end;\n            // Emit a property bag containing only the ID, as we don't intend for this op to change any properties.\n            serializedInterval.properties =\n                {\n                    [reservedIntervalIdKey]: interval.getIntervalId(),\n                };\n            this.emitter.emit(\"change\", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });\n            this.addPendingChange(id, serializedInterval);\n            this.emit(\"changeInterval\", newInterval, true, undefined);\n            return newInterval;\n        }\n        // No interval to change\n        return undefined;\n    }\n    addPendingChange(id, serializedInterval) {\n        if (serializedInterval.start !== undefined) {\n            this.addPendingChangeHelper(id, this.pendingChangesStart, serializedInterval);\n        }\n        if (serializedInterval.end !== undefined) {\n            this.addPendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);\n        }\n    }\n    addPendingChangeHelper(id, pendingChanges, serializedInterval) {\n        let entries = pendingChanges.get(id);\n        if (!entries) {\n            entries = [];\n            pendingChanges.set(id, entries);\n        }\n        entries.push(serializedInterval);\n    }\n    removePendingChange(serializedInterval) {\n        var _a;\n        // Change ops always have an ID.\n        const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n        if (serializedInterval.start !== undefined) {\n            this.removePendingChangeHelper(id, this.pendingChangesStart, serializedInterval);\n        }\n        if (serializedInterval.end !== undefined) {\n            this.removePendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);\n        }\n    }\n    removePendingChangeHelper(id, pendingChanges, serializedInterval) {\n        const entries = pendingChanges.get(id);\n        if (entries) {\n            const pendingChange = entries.shift();\n            if (entries.length === 0) {\n                pendingChanges.delete(id);\n            }\n            if ((pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.start) !== serializedInterval.start ||\n                (pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.end) !== serializedInterval.end) {\n                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Mismatch in pending changes\");\n            }\n        }\n    }\n    hasPendingChangeStart(id) {\n        const entries = this.pendingChangesStart.get(id);\n        return entries && entries.length !== 0;\n    }\n    hasPendingChangeEnd(id) {\n        const entries = this.pendingChangesEnd.get(id);\n        return entries && entries.length !== 0;\n    }\n    /** @deprecated - use ackChange */\n    changeInterval(serializedInterval, local, op) {\n        return this.ackChange(serializedInterval, local, op);\n    }\n    /** @internal */\n    ackChange(serializedInterval, local, op) {\n        var _a, _b, _c, _d;\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"Attach must be called before accessing intervals\");\n        }\n        let interval;\n        if (local) {\n            // This is an ack from the server. Remove the pending change.\n            this.removePendingChange(serializedInterval);\n            const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n            interval = this.getIntervalById(id);\n            if (interval) {\n                // Let the propertyManager prune its pending change-properties set.\n                (_b = interval.propertyManager) === null || _b === void 0 ? void 0 : _b.ackPendingProperties({\n                    type: _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.MergeTreeDeltaType.ANNOTATE,\n                    props: (_c = serializedInterval.properties) !== null && _c !== void 0 ? _c : {},\n                });\n                this.ackInterval(interval, op);\n            }\n        }\n        else {\n            // If there are pending changes with this ID, don't apply the remote start/end change, as the local ack\n            // should be the winning change.\n            // Note that the ID is in the property bag only to allow us to find the interval.\n            // This API cannot change the ID, and writing to the ID property will result in an exception. So we\n            // strip it out of the properties here.\n            const _e = serializedInterval.properties, _f = reservedIntervalIdKey, id = _e[_f], newProps = __rest(_e, [typeof _f === \"symbol\" ? _f : _f + \"\"]);\n            interval = this.getIntervalById(id);\n            if (interval) {\n                let start;\n                let end;\n                // Track pending start/end independently of one another.\n                if (!this.hasPendingChangeStart(id)) {\n                    start = serializedInterval.start;\n                }\n                if (!this.hasPendingChangeEnd(id)) {\n                    end = serializedInterval.end;\n                }\n                if (start !== undefined || end !== undefined) {\n                    // If changeInterval gives us a new interval, work with that one. Otherwise keep working with\n                    // the one we originally found in the tree.\n                    interval = (_d = this.localCollection.changeInterval(interval, start, end, op)) !== null && _d !== void 0 ? _d : interval;\n                }\n                const deltaProps = interval.addProperties(newProps, true, op.sequenceNumber);\n                if (this.onDeserialize) {\n                    this.onDeserialize(interval);\n                }\n                this.emit(\"propertyChanged\", interval, deltaProps);\n            }\n        }\n        if (interval) {\n            this.emit(\"changeInterval\", interval, local, op);\n        }\n    }\n    addConflictResolver(conflictResolver) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        this.localCollection.addConflictResolver(conflictResolver);\n    }\n    attachDeserializer(onDeserialize) {\n        // If no deserializer is specified can skip all processing work\n        if (!onDeserialize) {\n            return;\n        }\n        // Start by storing the callbacks so that any subsequent modifications make use of them\n        this.onDeserialize = onDeserialize;\n        // Trigger the async prepare work across all values in the collection\n        this.localCollection.map((interval) => {\n            onDeserialize(interval);\n        });\n    }\n    /** @internal */\n    rebaseLocalInterval(opName, serializedInterval, localSeq) {\n        var _a, _b;\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        const { start, end, intervalType, properties, sequenceNumber } = serializedInterval;\n        const startRebased = start === undefined ? undefined :\n            this.client.rebasePosition(start, sequenceNumber, localSeq);\n        const endRebased = end === undefined ? undefined :\n            this.client.rebasePosition(end, sequenceNumber, localSeq);\n        const intervalId = properties === null || properties === void 0 ? void 0 : properties[reservedIntervalIdKey];\n        const rebased = {\n            start: startRebased,\n            end: endRebased,\n            intervalType,\n            sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,\n            properties,\n        };\n        if (opName === \"change\" && (this.hasPendingChangeStart(intervalId) || this.hasPendingChangeEnd(intervalId))) {\n            this.removePendingChange(serializedInterval);\n            this.addPendingChange(intervalId, rebased);\n        }\n        return rebased;\n    }\n    getSlideToSegment(lref) {\n        const segoff = { segment: lref.segment, offset: lref.offset };\n        const newSegoff = this.client.getSlideToSegment(segoff);\n        const value = (segoff.segment === newSegoff.segment && segoff.offset === newSegoff.offset) ? undefined : newSegoff;\n        return value;\n    }\n    setSlideOnRemove(lref) {\n        let refType = lref.refType;\n        refType = refType & ~_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;\n        refType = refType | _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;\n        lref.refType = refType;\n    }\n    ackInterval(interval, op) {\n        // in current usage, interval is always a SequenceInterval\n        if (!(interval instanceof SequenceInterval)) {\n            return;\n        }\n        if (!(0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(interval.start, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove) &&\n            !(0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(interval.end, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove)) {\n            return;\n        }\n        const newStart = this.getSlideToSegment(interval.start);\n        const newEnd = this.getSlideToSegment(interval.end);\n        const id = interval.properties[reservedIntervalIdKey];\n        const hasPendingStartChange = this.hasPendingChangeStart(id);\n        const hasPendingEndChange = this.hasPendingChangeEnd(id);\n        if (!hasPendingStartChange) {\n            this.setSlideOnRemove(interval.start);\n        }\n        if (!hasPendingEndChange) {\n            this.setSlideOnRemove(interval.end);\n        }\n        const needsStartUpdate = newStart !== undefined && !hasPendingStartChange;\n        const needsEndUpdate = newEnd !== undefined && !hasPendingEndChange;\n        if (needsStartUpdate || needsEndUpdate) {\n            // In this case, where we change the start or end of an interval,\n            // it is necessary to remove and re-add the interval listeners.\n            // This ensures that the correct listeners are added to the ReferencePosition.\n            this.localCollection.removeExistingInterval(interval);\n            if (needsStartUpdate) {\n                const props = interval.start.properties;\n                this.client.removeLocalReferencePosition(interval.start);\n                interval.start = createPositionReferenceFromSegoff(this.client, newStart, interval.start.refType, op);\n                if (props) {\n                    interval.start.addProperties(props);\n                }\n            }\n            if (needsEndUpdate) {\n                const props = interval.end.properties;\n                this.client.removeLocalReferencePosition(interval.end);\n                interval.end = createPositionReferenceFromSegoff(this.client, newEnd, interval.end.refType, op);\n                if (props) {\n                    interval.end.addProperties(props);\n                }\n            }\n            this.localCollection.add(interval);\n        }\n    }\n    /** @deprecated - use ackAdd */\n    addInternal(serializedInterval, local, op) {\n        return this.ackAdd(serializedInterval, local, op);\n    }\n    /** @internal */\n    ackAdd(serializedInterval, local, op) {\n        var _a;\n        if (local) {\n            const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n            const localInterval = this.getIntervalById(id);\n            if (localInterval) {\n                this.ackInterval(localInterval, op);\n            }\n            return;\n        }\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        this.localCollection.ensureSerializedId(serializedInterval);\n        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties, op);\n        if (interval) {\n            if (this.onDeserialize) {\n                this.onDeserialize(interval);\n            }\n        }\n        this.emit(\"addInterval\", interval, local, op);\n        return interval;\n    }\n    /** @deprecated - use ackDelete */\n    deleteInterval(serializedInterval, local, op) {\n        return this.ackDelete(serializedInterval, local, op);\n    }\n    /** @internal */\n    ackDelete(serializedInterval, local, op) {\n        if (local) {\n            // Local ops were applied when the message was created and there's no \"pending delete\"\n            // state to bookkeep: remote operation application takes into account possibility of\n            // locally deleted interval whenever a lookup happens.\n            return;\n        }\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attach must be called prior to deleting intervals\");\n        }\n        const id = this.localCollection.ensureSerializedId(serializedInterval);\n        const interval = this.localCollection.getIntervalById(id);\n        if (interval) {\n            this.deleteExistingInterval(interval, local, op);\n        }\n    }\n    /**\n     * @internal\n     */\n    serializeInternal() {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        return this.localCollection.serialize();\n    }\n    [Symbol.iterator]() {\n        const iterator = new IntervalCollectionIterator(this);\n        return iterator;\n    }\n    CreateForwardIteratorWithStartPosition(startPosition) {\n        const iterator = new IntervalCollectionIterator(this, true, startPosition);\n        return iterator;\n    }\n    CreateBackwardIteratorWithStartPosition(startPosition) {\n        const iterator = new IntervalCollectionIterator(this, false, startPosition);\n        return iterator;\n    }\n    CreateForwardIteratorWithEndPosition(endPosition) {\n        const iterator = new IntervalCollectionIterator(this, true, undefined, endPosition);\n        return iterator;\n    }\n    CreateBackwardIteratorWithEndPosition(endPosition) {\n        const iterator = new IntervalCollectionIterator(this, false, undefined, endPosition);\n        return iterator;\n    }\n    gatherIterationResults(results, iteratesForward, start, end) {\n        if (!this.attached) {\n            return;\n        }\n        this.localCollection.gatherIterationResults(results, iteratesForward, start, end);\n    }\n    findOverlappingIntervals(startPosition, endPosition) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);\n    }\n    map(fn) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        this.localCollection.map(fn);\n    }\n    previousInterval(pos) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        return this.localCollection.previousInterval(pos);\n    }\n    nextInterval(pos) {\n        if (!this.attached) {\n            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError(\"attachSequence must be called\");\n        }\n        return this.localCollection.nextInterval(pos);\n    }\n}\n//# sourceMappingURL=intervalCollection.js.map\n\n/***/ }),\n/* 280 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DetachedReferencePosition\": () => (/* binding */ DetachedReferencePosition),\n/* harmony export */   \"compareReferencePositions\": () => (/* binding */ compareReferencePositions),\n/* harmony export */   \"maxReferencePosition\": () => (/* binding */ maxReferencePosition),\n/* harmony export */   \"minReferencePosition\": () => (/* binding */ minReferencePosition),\n/* harmony export */   \"refGetRangeLabels\": () => (/* binding */ refGetRangeLabels),\n/* harmony export */   \"refGetTileLabels\": () => (/* binding */ refGetTileLabels),\n/* harmony export */   \"refHasRangeLabel\": () => (/* binding */ refHasRangeLabel),\n/* harmony export */   \"refHasRangeLabels\": () => (/* binding */ refHasRangeLabels),\n/* harmony export */   \"refHasTileLabel\": () => (/* binding */ refHasTileLabel),\n/* harmony export */   \"refHasTileLabels\": () => (/* binding */ refHasTileLabels),\n/* harmony export */   \"refTypeIncludesFlag\": () => (/* binding */ refTypeIncludesFlag),\n/* harmony export */   \"reservedRangeLabelsKey\": () => (/* binding */ reservedRangeLabelsKey),\n/* harmony export */   \"reservedTileLabelsKey\": () => (/* binding */ reservedTileLabelsKey)\n/* harmony export */ });\n/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nconst reservedTileLabelsKey = \"referenceTileLabels\";\nconst reservedRangeLabelsKey = \"referenceRangeLabels\";\nfunction refTypeIncludesFlag(refPosOrType, flags) {\n    const refType = typeof refPosOrType === \"number\" ? refPosOrType : refPosOrType.refType;\n    // eslint-disable-next-line no-bitwise\n    return (refType & flags) !== 0;\n}\nconst refGetTileLabels = (refPos) => refTypeIncludesFlag(refPos, _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.Tile)\n    && refPos.properties ? refPos.properties[reservedTileLabelsKey] : undefined;\nconst refGetRangeLabels = (refPos) => \n// eslint-disable-next-line no-bitwise\n(refTypeIncludesFlag(refPos, _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.NestEnd))\n    && refPos.properties ? refPos.properties[reservedRangeLabelsKey] : undefined;\nfunction refHasTileLabel(refPos, label) {\n    const tileLabels = refGetTileLabels(refPos);\n    if (tileLabels) {\n        for (const refLabel of tileLabels) {\n            if (label === refLabel) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction refHasRangeLabel(refPos, label) {\n    const rangeLabels = refGetRangeLabels(refPos);\n    if (rangeLabels) {\n        for (const refLabel of rangeLabels) {\n            if (label === refLabel) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction refHasTileLabels(refPos) {\n    return refGetTileLabels(refPos) !== undefined;\n}\nfunction refHasRangeLabels(refPos) {\n    return refGetRangeLabels(refPos) !== undefined;\n}\nconst DetachedReferencePosition = -1;\nfunction minReferencePosition(a, b) {\n    if (compareReferencePositions(a, b) < 0) {\n        return a;\n    }\n    else {\n        return b;\n    }\n}\nfunction maxReferencePosition(a, b) {\n    if (compareReferencePositions(a, b) > 0) {\n        return a;\n    }\n    else {\n        return b;\n    }\n}\nfunction compareReferencePositions(a, b) {\n    const aSeg = a.getSegment();\n    const bSeg = b.getSegment();\n    if (aSeg === bSeg) {\n        return a.getOffset() - b.getOffset();\n    }\n    else {\n        if (aSeg === undefined\n            || (bSeg !== undefined &&\n                aSeg.ordinal < bSeg.ordinal)) {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\n//# sourceMappingURL=referencePositions.js.map\n\n/***/ }),\n/* 281 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MergeTreeDeltaType\": () => (/* binding */ MergeTreeDeltaType),\n/* harmony export */   \"ReferenceType\": () => (/* binding */ ReferenceType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar ReferenceType;\n(function (ReferenceType) {\n    ReferenceType[ReferenceType[\"Simple\"] = 0] = \"Simple\";\n    ReferenceType[ReferenceType[\"Tile\"] = 1] = \"Tile\";\n    ReferenceType[ReferenceType[\"NestBegin\"] = 2] = \"NestBegin\";\n    ReferenceType[ReferenceType[\"NestEnd\"] = 4] = \"NestEnd\";\n    ReferenceType[ReferenceType[\"RangeBegin\"] = 16] = \"RangeBegin\";\n    ReferenceType[ReferenceType[\"RangeEnd\"] = 32] = \"RangeEnd\";\n    ReferenceType[ReferenceType[\"SlideOnRemove\"] = 64] = \"SlideOnRemove\";\n    ReferenceType[ReferenceType[\"StayOnRemove\"] = 128] = \"StayOnRemove\";\n    ReferenceType[ReferenceType[\"Transient\"] = 256] = \"Transient\";\n})(ReferenceType || (ReferenceType = {}));\n// Note: Assigned positive integers to avoid clashing with MergeTreeMaintenanceType\nconst MergeTreeDeltaType = {\n    INSERT: 0,\n    REMOVE: 1,\n    ANNOTATE: 2,\n    GROUP: 3,\n};\n//# sourceMappingURL=ops.js.map\n\n/***/ }),\n/* 282 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesManager\": () => (/* binding */ PropertiesManager)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(283);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(285);\n/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(284);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n\n\nclass PropertiesManager {\n    constructor() {\n        this.pendingRewriteCount = 0;\n    }\n    ackPendingProperties(annotateOp) {\n        var _a, _b;\n        if (annotateOp.combiningOp && annotateOp.combiningOp.name === \"rewrite\") {\n            this.pendingRewriteCount--;\n        }\n        for (const key of Object.keys(annotateOp.props)) {\n            if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) !== undefined) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pendingKeyUpdateCount[key] > 0, 0x05c /* \"Trying to update more annotate props than do exist!\" */);\n                this.pendingKeyUpdateCount[key]--;\n                if (((_b = this.pendingKeyUpdateCount) === null || _b === void 0 ? void 0 : _b[key]) === 0) {\n                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                    delete this.pendingKeyUpdateCount[key];\n                }\n            }\n        }\n    }\n    addProperties(oldProps, newProps, op, seq, collaborating = false) {\n        var _a;\n        if (!this.pendingKeyUpdateCount) {\n            this.pendingKeyUpdateCount = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.createMap)();\n        }\n        // There are outstanding local rewrites, so block all non-local changes\n        if (this.pendingRewriteCount > 0 && seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber && collaborating) {\n            return undefined;\n        }\n        const rewrite = (op && op.name === \"rewrite\");\n        const combiningOp = !rewrite ? op ? op : undefined : undefined;\n        const shouldModifyKey = (key) => {\n            var _a;\n            if (seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber\n                || ((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined\n                || combiningOp) {\n                return true;\n            }\n            return false;\n        };\n        const deltas = {};\n        if (rewrite) {\n            if (collaborating && seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {\n                this.pendingRewriteCount++;\n            }\n            // We are re-writing so delete all the properties\n            // not in the new props\n            for (const key of Object.keys(oldProps)) {\n                if (!newProps[key] && shouldModifyKey(key)) {\n                    deltas[key] = oldProps[key];\n                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                    delete oldProps[key];\n                }\n            }\n        }\n        for (const key of Object.keys(newProps)) {\n            if (collaborating) {\n                if (seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {\n                    if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {\n                        this.pendingKeyUpdateCount[key] = 0;\n                    }\n                    this.pendingKeyUpdateCount[key]++;\n                }\n                else if (!shouldModifyKey(key)) {\n                    continue;\n                }\n            }\n            const previousValue = oldProps[key];\n            // The delta should be null if undefined, as thats how we encode delete\n            deltas[key] = (previousValue === undefined) ? null : previousValue;\n            let newValue;\n            if (combiningOp) {\n                newValue = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.combine)(combiningOp, previousValue, newValue, seq);\n            }\n            else {\n                newValue = newProps[key];\n            }\n            if (newValue === null) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete oldProps[key];\n            }\n            else {\n                oldProps[key] = newValue;\n            }\n        }\n        return deltas;\n    }\n    copyTo(oldProps, newProps, newManager) {\n        if (oldProps) {\n            if (!newProps) {\n                // eslint-disable-next-line no-param-reassign\n                newProps = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.createMap)();\n            }\n            if (!newManager) {\n                throw new Error(\"Must provide new PropertyManager\");\n            }\n            for (const key of Object.keys(oldProps)) {\n                newProps[key] = oldProps[key];\n            }\n            newManager.pendingRewriteCount = this.pendingRewriteCount;\n            newManager.pendingKeyUpdateCount = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.createMap)();\n            for (const key of Object.keys(this.pendingKeyUpdateCount)) {\n                newManager.pendingKeyUpdateCount[key] = this.pendingKeyUpdateCount[key];\n            }\n        }\n        return newProps;\n    }\n    hasPendingProperties() {\n        return this.pendingRewriteCount > 0 || Object.keys(this.pendingKeyUpdateCount).length > 0;\n    }\n}\n//# sourceMappingURL=segmentPropertiesManager.js.map\n\n/***/ }),\n/* 283 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 284 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addProperties\": () => (/* binding */ addProperties),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"combine\": () => (/* binding */ combine),\n/* harmony export */   \"createMap\": () => (/* binding */ createMap),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"extendIfUndefined\": () => (/* binding */ extendIfUndefined),\n/* harmony export */   \"matchProperties\": () => (/* binding */ matchProperties)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction combine(combiningInfo, currentValue, newValue, seq) {\n    let _currentValue = currentValue;\n    if (_currentValue === undefined) {\n        _currentValue = combiningInfo.defaultValue;\n    }\n    // Fixed set of operations for now\n    switch (combiningInfo.name) {\n        case \"incr\":\n            _currentValue += newValue;\n            if (combiningInfo.minValue) {\n                if (_currentValue < combiningInfo.minValue) {\n                    _currentValue = combiningInfo.minValue;\n                }\n            }\n            break;\n        case \"consensus\":\n            if (_currentValue === undefined) {\n                const cv = {\n                    value: newValue,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    seq: seq,\n                };\n                _currentValue = cv;\n            }\n            else {\n                const cv = _currentValue;\n                if (cv.seq === -1) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    cv.seq = seq;\n                }\n            }\n            break;\n        default:\n            break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return _currentValue;\n}\nfunction matchProperties(a, b) {\n    if (a) {\n        if (!b) {\n            return false;\n        }\n        else {\n            // For now, straightforward; later use hashing\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key in a) {\n                if (b[key] === undefined) {\n                    return false;\n                }\n                else if (typeof b[key] === \"object\") {\n                    if (!matchProperties(a[key], b[key])) {\n                        return false;\n                    }\n                }\n                else if (b[key] !== a[key]) {\n                    return false;\n                }\n            }\n            // eslint-disable-next-line no-restricted-syntax\n            for (const key in b) {\n                if (a[key] === undefined) {\n                    return false;\n                }\n            }\n        }\n    }\n    else {\n        if (b) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction extend(base, extension, combiningOp, seq) {\n    if (extension !== undefined) {\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const key in extension) {\n            const v = extension[key];\n            if (v === null) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete base[key];\n            }\n            else {\n                if (combiningOp && (combiningOp.name !== \"rewrite\")) {\n                    base[key] = combine(combiningOp, base[key], v, seq);\n                }\n                else {\n                    base[key] = v;\n                }\n            }\n        }\n    }\n    return base;\n}\nfunction clone(extension) {\n    if (extension === undefined) {\n        return undefined;\n    }\n    const cloneMap = createMap();\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const key in extension) {\n        const v = extension[key];\n        if (v !== null) {\n            cloneMap[key] = v;\n        }\n    }\n    return cloneMap;\n}\nfunction addProperties(oldProps, newProps, op, seq) {\n    let _oldProps = oldProps;\n    if ((!_oldProps) || (op && (op.name === \"rewrite\"))) {\n        _oldProps = createMap();\n    }\n    extend(_oldProps, newProps, op, seq);\n    return _oldProps;\n}\nfunction extendIfUndefined(base, extension) {\n    if (extension !== undefined) {\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key in extension) {\n            if (base[key] === undefined) {\n                base[key] = extension[key];\n            }\n        }\n    }\n    return base;\n}\n// Create a MapLike with good performance.\nfunction createMap() {\n    return Object.create(null);\n}\n//# sourceMappingURL=properties.js.map\n\n/***/ }),\n/* 285 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LocalClientId\": () => (/* binding */ LocalClientId),\n/* harmony export */   \"NonCollabClient\": () => (/* binding */ NonCollabClient),\n/* harmony export */   \"TreeMaintenanceSequenceNumber\": () => (/* binding */ TreeMaintenanceSequenceNumber),\n/* harmony export */   \"UnassignedSequenceNumber\": () => (/* binding */ UnassignedSequenceNumber),\n/* harmony export */   \"UniversalSequenceNumber\": () => (/* binding */ UniversalSequenceNumber)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Sequence numbers for shared segments start at 1 or greater.  Every segment marked\n * with sequence number zero will be counted as part of the requested string.\n */\nconst UniversalSequenceNumber = 0;\nconst UnassignedSequenceNumber = -1;\nconst TreeMaintenanceSequenceNumber = -2;\nconst LocalClientId = -1;\nconst NonCollabClient = -2;\n//# sourceMappingURL=constants.js.map\n\n/***/ }),\n/* 286 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LocalReference\": () => (/* binding */ LocalReference),\n/* harmony export */   \"LocalReferenceCollection\": () => (/* binding */ LocalReferenceCollection),\n/* harmony export */   \"_validateReferenceType\": () => (/* binding */ _validateReferenceType)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(283);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51);\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(287);\n/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(281);\n/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(284);\n/* harmony import */ var _referencePositions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(280);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n/**\n * @internal\n */\nfunction _validateReferenceType(refType) {\n    let exclusiveCount = 0;\n    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Transient)) {\n        ++exclusiveCount;\n    }\n    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.SlideOnRemove)) {\n        ++exclusiveCount;\n    }\n    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.StayOnRemove)) {\n        ++exclusiveCount;\n    }\n    if (exclusiveCount > 1) {\n        throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__.UsageError(\"Reference types can only be one of Transient, SlideOnRemove, and StayOnRemove\");\n    }\n}\n/**\n * @deprecated - Use LocalReferencePosition\n */\nclass LocalReference {\n    /**\n     * @deprecated - use createReferencePosition\n     */\n    constructor(client, initSegment, \n    /**\n     * @deprecated - use getOffset\n     */\n    offset = 0, refType = _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Simple, properties) {\n        this.client = client;\n        this.offset = offset;\n        this.refType = refType;\n        _validateReferenceType(refType);\n        this.segment = initSegment;\n        this.properties = properties;\n    }\n    /**\n     * @deprecated - use minReferencePosition\n     */\n    min(b) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.minReferencePosition)(this, b);\n    }\n    /**\n     * @deprecated - use maxReferencePosition\n     */\n    max(b) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.maxReferencePosition)(this, b);\n    }\n    /**\n     * @deprecated - use compareReferencePositions\n     */\n    compare(b) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.compareReferencePositions)(this, b);\n    }\n    /**\n     * @deprecated - use getLocalReferencePosition\n     */\n    toPosition() {\n        return this.getClient().localReferencePositionToPosition(this);\n    }\n    /**\n     * @deprecated - use refHasTileLabels\n     */\n    hasTileLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(this);\n    }\n    /**\n     * @deprecated - use refHasRangeLabels\n     */\n    hasRangeLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(this);\n    }\n    /**\n     * @deprecated - use refHasTileLabel\n     */\n    hasTileLabel(label) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabel)(this, label);\n    }\n    /**\n     * @deprecated - use refHasRangeLabel\n     */\n    hasRangeLabel(label) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabel)(this, label);\n    }\n    /**\n     * @deprecated - use refGetTileLabels\n     */\n    getTileLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refGetTileLabels)(this);\n    }\n    /**\n     * @deprecated - use refGetRangeLabels\n     */\n    getRangeLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refGetRangeLabels)(this);\n    }\n    isLeaf() {\n        return false;\n    }\n    addProperties(newProps, op) {\n        this.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_3__.addProperties)(this.properties, newProps, op);\n    }\n    /**\n     * @deprecated - no longer supported\n     */\n    getClient() {\n        return this.client;\n    }\n    getSegment() {\n        return this.segment;\n    }\n    getOffset() {\n        return this.offset;\n    }\n    getProperties() {\n        return this.properties;\n    }\n}\n/**\n * @deprecated - use DetachedReferencePosition\n */\nLocalReference.DetachedPosition = -1;\nfunction assertLocalReferences(lref) {\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(lref instanceof LocalReference, 0x2e0 /* \"lref not a Local Reference\" */);\n}\n/**\n * Represents a collection of {@link ReferencePosition}s associated with one segment in a merge-tree.\n */\nclass LocalReferenceCollection {\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    constructor(\n    /** Segment this `LocalReferenceCollection` is associated to. */\n    segment, initialRefsByfOffset = new Array(segment.cachedLength)) {\n        this.segment = segment;\n        /**\n         *\n         * @internal - this method should only be called by mergeTree\n         */\n        this.hierRefCount = 0;\n        this.refCount = 0;\n        // Since javascript arrays are sparse the above won't populate any of the\n        // indices, but it will ensure the length property of the array matches\n        // the length of the segment.\n        this.refsByOffset = initialRefsByfOffset;\n    }\n    static append(seg1, seg2) {\n        if (seg2.localRefs && !seg2.localRefs.empty) {\n            if (!seg1.localRefs) {\n                seg1.localRefs = new LocalReferenceCollection(seg1);\n            }\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(seg1.localRefs.refsByOffset.length === seg1.cachedLength, 0x2be /* \"LocalReferences array contains a gap\" */);\n            seg1.localRefs.append(seg2.localRefs);\n        }\n        else if (seg1.localRefs) {\n            // Since creating the LocalReferenceCollection, we may have appended\n            // segments that had no local references. Account for them now by padding the array.\n            seg1.localRefs.refsByOffset.length += seg2.cachedLength;\n        }\n    }\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    [Symbol.iterator]() {\n        const subiterators = [];\n        for (const refs of this.refsByOffset) {\n            if (refs) {\n                if (refs.before) {\n                    subiterators.push(refs.before[Symbol.iterator]());\n                }\n                if (refs.at) {\n                    subiterators.push(refs.at[Symbol.iterator]());\n                }\n                if (refs.after) {\n                    subiterators.push(refs.after[Symbol.iterator]());\n                }\n            }\n        }\n        const iterator = {\n            next() {\n                while (subiterators.length > 0) {\n                    const next = subiterators[0].next();\n                    if (next.done === true) {\n                        subiterators.shift();\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                return { value: undefined, done: true };\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    clear() {\n        this.refCount = 0;\n        this.hierRefCount = 0;\n        const detachSegments = (refs) => {\n            if (refs) {\n                for (const r of refs) {\n                    if (r.segment === this.segment) {\n                        r.segment = undefined;\n                    }\n                }\n            }\n        };\n        for (let i = 0; i < this.refsByOffset.length; i++) {\n            const refsAtOffset = this.refsByOffset[i];\n            if (refsAtOffset) {\n                detachSegments(refsAtOffset.before);\n                detachSegments(refsAtOffset.at);\n                detachSegments(refsAtOffset.before);\n                this.refsByOffset[i] = undefined;\n            }\n        }\n    }\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    get empty() {\n        return this.refCount === 0;\n    }\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    createLocalRef(offset, refType, properties, client) {\n        const ref = new LocalReference(client, this.segment, offset, refType, properties);\n        if (!(0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(ref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Transient)) {\n            this.addLocalRef(ref);\n        }\n        return ref;\n    }\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    addLocalRef(lref) {\n        var _a, _b;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!(0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Transient), 0x2df /* \"transient references cannot be bound to segments\" */);\n        assertLocalReferences(lref);\n        const refsAtOffset = this.refsByOffset[lref.offset] =\n            (_a = this.refsByOffset[lref.offset]) !== null && _a !== void 0 ? _a : { at: (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)() };\n        const atRefs = refsAtOffset.at =\n            (_b = refsAtOffset.at) !== null && _b !== void 0 ? _b : (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)();\n        atRefs.enqueue(lref);\n        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {\n            this.hierRefCount++;\n        }\n        this.refCount++;\n    }\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n    removeLocalRef(lref) {\n        assertLocalReferences(lref);\n        const tryRemoveRef = (refs) => {\n            if (refs) {\n                let node = refs;\n                do {\n                    node = node.next;\n                    if (node.data === lref) {\n                        (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListRemoveEntry)(node);\n                        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {\n                            this.hierRefCount--;\n                        }\n                        this.refCount--;\n                        return lref;\n                    }\n                } while (!node.isHead);\n            }\n        };\n        const refAtOffset = this.refsByOffset[lref.offset];\n        if (refAtOffset !== undefined) {\n            let ref = tryRemoveRef(refAtOffset.before);\n            if (ref) {\n                return ref;\n            }\n            ref = tryRemoveRef(refAtOffset.at);\n            if (ref) {\n                return ref;\n            }\n            ref = tryRemoveRef(refAtOffset.after);\n            if (ref) {\n                return ref;\n            }\n        }\n    }\n    /**\n     * @internal - this method should only be called by mergeTree\n     *\n     * Called by 'append()' implementations to append local refs from the given 'other' segment to the\n     * end of 'this' segment.\n     *\n     * Note: This method should be invoked after the caller has ensured that segments can be merged,\n     *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs\n     *       will be incorrect.\n     */\n    append(other) {\n        if (!other || other.empty) {\n            return;\n        }\n        this.hierRefCount += other.hierRefCount;\n        this.refCount += other.refCount;\n        other.hierRefCount = 0;\n        for (const lref of other) {\n            lref.segment = this.segment;\n            lref.offset += this.refsByOffset.length;\n        }\n        this.refsByOffset.push(...other.refsByOffset);\n    }\n    /**\n     * @internal - this method should only be called by mergeTree\n     *\n     * Splits this `LocalReferenceCollection` into the intervals [0, offset) and [offset, originalLength).\n     * Local references in the former half of this split will remain associated with the segment used on construction.\n     * Local references in the latter half of this split will be transferred to `splitSeg`,\n     * and its `localRefs` field will be set.\n     * @param offset - Offset into the original segment at which the collection should be split\n     * @param splitSeg - Split segment which originally corresponded to the indices [offset, originalLength)\n     * before splitting.\n     */\n    split(offset, splitSeg) {\n        if (!this.empty) {\n            const localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));\n            splitSeg.localRefs = localRefs;\n            for (const lref of localRefs) {\n                lref.segment = splitSeg;\n                lref.offset -= offset;\n                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {\n                    this.hierRefCount--;\n                    localRefs.hierRefCount++;\n                }\n                this.refCount--;\n                localRefs.refCount++;\n            }\n        }\n        else {\n            // shrink the offset array when empty and splitting\n            this.refsByOffset.length = offset;\n        }\n    }\n    addBeforeTombstones(...refs) {\n        var _a, _b, _c, _d, _e;\n        const beforeRefs = (_b = (_a = this.refsByOffset[0]) === null || _a === void 0 ? void 0 : _a.before) !== null && _b !== void 0 ? _b : (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)();\n        for (const iterable of refs) {\n            for (const lref of iterable) {\n                assertLocalReferences(lref);\n                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.SlideOnRemove)) {\n                    beforeRefs.push(lref);\n                    lref.segment = this.segment;\n                    lref.offset = 0;\n                    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {\n                        this.hierRefCount++;\n                    }\n                    this.refCount++;\n                }\n                else {\n                    lref.segment = undefined;\n                }\n            }\n        }\n        if (!beforeRefs.empty() && ((_c = this.refsByOffset[0]) === null || _c === void 0 ? void 0 : _c.before) === undefined) {\n            const refsAtOffset = this.refsByOffset[0] =\n                (_d = this.refsByOffset[0]) !== null && _d !== void 0 ? _d : { before: beforeRefs };\n            refsAtOffset.before = (_e = refsAtOffset.before) !== null && _e !== void 0 ? _e : beforeRefs;\n        }\n    }\n    addAfterTombstones(...refs) {\n        var _a, _b, _c, _d, _e;\n        const lastOffset = this.refsByOffset.length - 1;\n        const afterRefs = (_b = (_a = this.refsByOffset[lastOffset]) === null || _a === void 0 ? void 0 : _a.after) !== null && _b !== void 0 ? _b : (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)();\n        for (const iterable of refs) {\n            for (const lref of iterable) {\n                assertLocalReferences(lref);\n                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.SlideOnRemove)) {\n                    afterRefs.push(lref);\n                    lref.segment = this.segment;\n                    lref.offset = this.segment.cachedLength - 1;\n                    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {\n                        this.hierRefCount++;\n                    }\n                    this.refCount++;\n                }\n                else {\n                    lref.segment = undefined;\n                }\n            }\n        }\n        if (!afterRefs.empty() && ((_c = this.refsByOffset[lastOffset]) === null || _c === void 0 ? void 0 : _c.after) === undefined) {\n            const refsAtOffset = this.refsByOffset[lastOffset] =\n                (_d = this.refsByOffset[lastOffset]) !== null && _d !== void 0 ? _d : { after: afterRefs };\n            refsAtOffset.after = (_e = refsAtOffset.after) !== null && _e !== void 0 ? _e : afterRefs;\n        }\n    }\n}\n//# sourceMappingURL=localReference.js.map\n\n/***/ }),\n/* 287 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Heap\": () => (/* binding */ Heap),\n/* harmony export */   \"IntervalTree\": () => (/* binding */ IntervalTree),\n/* harmony export */   \"List\": () => (/* binding */ List),\n/* harmony export */   \"ListMakeHead\": () => (/* binding */ ListMakeHead),\n/* harmony export */   \"ListRemoveEntry\": () => (/* binding */ ListRemoveEntry),\n/* harmony export */   \"RBColor\": () => (/* binding */ RBColor),\n/* harmony export */   \"RedBlackTree\": () => (/* binding */ RedBlackTree),\n/* harmony export */   \"Stack\": () => (/* binding */ Stack),\n/* harmony export */   \"TST\": () => (/* binding */ TST),\n/* harmony export */   \"integerRangeToString\": () => (/* binding */ integerRangeToString)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Stack {\n    constructor() {\n        this.items = [];\n    }\n    push(val) {\n        this.items.push(val);\n    }\n    empty() {\n        return this.items.length === 0;\n    }\n    top() {\n        return this.items[this.items.length - 1];\n    }\n    pop() {\n        return this.items.pop();\n    }\n}\nfunction ListRemoveEntry(entry) {\n    if (entry === undefined) {\n        return undefined;\n    }\n    else if (entry.isHead) {\n        return undefined;\n    }\n    else {\n        entry.next.prev = entry.prev;\n        entry.prev.next = entry.next;\n    }\n    return (entry);\n}\nfunction ListMakeEntry(data) {\n    return new List(false, data);\n}\nfunction ListMakeHead() {\n    return new List(true, undefined);\n}\nclass List {\n    constructor(isHead, data) {\n        this.isHead = isHead;\n        this.data = data;\n        this.prev = this;\n        this.next = this;\n    }\n    clear() {\n        if (this.isHead) {\n            this.prev = this;\n            this.next = this;\n        }\n    }\n    add(data) {\n        const entry = ListMakeEntry(data);\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return (entry);\n    }\n    dequeue() {\n        if (!this.empty()) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const removedEntry = ListRemoveEntry(this.next);\n            return removedEntry.data;\n        }\n    }\n    enqueue(data) {\n        return this.add(data);\n    }\n    walk(fn) {\n        for (let entry = this.next; !(entry.isHead); entry = entry.next) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            fn(entry.data, entry);\n        }\n    }\n    some(fn, rev) {\n        const rtn = [];\n        const start = rev ? this.prev : this.next;\n        for (let entry = start; !(entry.isHead); entry = rev ? entry.prev : entry.next) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const data = entry.data;\n            if (fn(data, entry)) {\n                if (rev) {\n                    // preserve list order when in reverse\n                    rtn.unshift(data);\n                }\n                else {\n                    rtn.push(data);\n                }\n            }\n        }\n        return rtn;\n    }\n    count() {\n        let entry;\n        let i;\n        entry = this.next;\n        for (i = 0; !(entry.isHead); i++) {\n            entry = entry.next;\n        }\n        return (i);\n    }\n    first() {\n        if (!this.empty()) {\n            return (this.next.data);\n        }\n    }\n    last() {\n        if (!this.empty()) {\n            return (this.prev.data);\n        }\n    }\n    empty() {\n        return (this.next === this);\n    }\n    /**\n     * @deprecated - use unshift\n     */\n    push(data) {\n        this.unshift(data);\n    }\n    unshift(data) {\n        const entry = ListMakeEntry(data);\n        entry.data = data;\n        entry.isHead = false;\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n    }\n    [Symbol.iterator]() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let node = this;\n        const iterator = {\n            next() {\n                while (node && node.next.isHead === false) {\n                    node = node.next;\n                    if (node.data !== undefined) {\n                        return { value: node.data, done: false };\n                    }\n                }\n                return { value: undefined, done: true };\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n}\nclass Heap {\n    constructor(a, comp) {\n        this.comp = comp;\n        this.L = [comp.min];\n        for (let i = 0, len = a.length; i < len; i++) {\n            this.add(a[i]);\n        }\n    }\n    count() {\n        return this.L.length - 1;\n    }\n    peek() {\n        return this.L[1];\n    }\n    get() {\n        const x = this.L[1];\n        this.L[1] = this.L[this.count()];\n        this.L.pop();\n        this.fixDown(1);\n        return x;\n    }\n    add(x) {\n        this.L.push(x);\n        this.fixup(this.count());\n    }\n    /* eslint-disable no-bitwise */\n    fixup(k) {\n        let _k = k;\n        while (_k > 1 && (this.comp.compare(this.L[_k >> 1], this.L[_k]) > 0)) {\n            const tmp = this.L[_k >> 1];\n            this.L[_k >> 1] = this.L[_k];\n            this.L[_k] = tmp;\n            _k = _k >> 1;\n        }\n    }\n    fixDown(k) {\n        let _k = k;\n        while ((_k << 1) <= (this.count())) {\n            let j = _k << 1;\n            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {\n                j++;\n            }\n            if (this.comp.compare(this.L[_k], this.L[j]) <= 0) {\n                break;\n            }\n            const tmp = this.L[_k];\n            this.L[_k] = this.L[j];\n            this.L[j] = tmp;\n            _k = j;\n        }\n    }\n}\nconst RBColor = {\n    RED: 0,\n    BLACK: 1,\n};\nclass RedBlackTree {\n    constructor(compareKeys, aug) {\n        this.compareKeys = compareKeys;\n        this.aug = aug;\n    }\n    makeNode(key, data, color, size) {\n        return { key, data, color, size };\n    }\n    isRed(node) {\n        return !!node && (node.color === RBColor.RED);\n    }\n    nodeSize(node) {\n        return node ? node.size : 0;\n    }\n    size() {\n        return this.nodeSize(this.root);\n    }\n    isEmpty() {\n        return !this.root;\n    }\n    get(key) {\n        if (key !== undefined) {\n            return this.nodeGet(this.root, key);\n        }\n    }\n    nodeGet(node, key) {\n        let _node = node;\n        while (_node) {\n            const cmp = this.compareKeys(key, _node.key);\n            if (cmp < 0) {\n                _node = _node.left;\n            }\n            else if (cmp > 0) {\n                _node = _node.right;\n            }\n            else {\n                return _node;\n            }\n        }\n    }\n    contains(key) {\n        return this.get(key);\n    }\n    gather(key, matcher) {\n        const results = [];\n        if (key !== undefined) {\n            this.nodeGather(this.root, results, key, matcher);\n        }\n        return results;\n    }\n    nodeGather(node, results, key, matcher) {\n        if (node) {\n            if (matcher.continueSubtree(node.left, key)) {\n                this.nodeGather(node.left, results, key, matcher);\n            }\n            if (matcher.matchNode(node, key)) {\n                results.push(node);\n            }\n            if (matcher.continueSubtree(node.right, key)) {\n                this.nodeGather(node.right, results, key, matcher);\n            }\n        }\n    }\n    walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn) {\n        this.nodeWalkExactMatchesForward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);\n    }\n    nodeWalkExactMatchesForward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {\n        if (!node) {\n            return;\n        }\n        const result = compareFn(node);\n        if (continueLeftFn(result)) {\n            this.nodeWalkExactMatchesForward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);\n        }\n        if (result === 0) {\n            actionFn(node);\n        }\n        if (continueRightFn(result)) {\n            this.nodeWalkExactMatchesForward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);\n        }\n    }\n    walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn) {\n        this.nodeWalkExactMatchesBackward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);\n    }\n    nodeWalkExactMatchesBackward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {\n        if (!node) {\n            return;\n        }\n        const result = compareFn(node);\n        if (continueRightFn(result)) {\n            this.nodeWalkExactMatchesBackward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);\n        }\n        if (result === 0) {\n            actionFn(node);\n        }\n        if (continueLeftFn(result)) {\n            this.nodeWalkExactMatchesBackward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);\n        }\n    }\n    put(key, data, conflict) {\n        if (key !== undefined) {\n            if (data === undefined) {\n                this.remove(key);\n            }\n            else {\n                this.root = this.nodePut(this.root, key, data, conflict);\n                this.root.color = RBColor.BLACK;\n            }\n        }\n    }\n    nodePut(node, key, data, conflict) {\n        let _node = node;\n        if (!_node) {\n            return this.makeNode(key, data, RBColor.RED, 1);\n        }\n        else {\n            const cmp = this.compareKeys(key, _node.key);\n            if (cmp < 0) {\n                _node.left = this.nodePut(_node.left, key, data, conflict);\n            }\n            else if (cmp > 0) {\n                _node.right = this.nodePut(_node.right, key, data, conflict);\n            }\n            else {\n                if (conflict) {\n                    const kd = conflict(key, _node.key, data, _node.data);\n                    if (kd.key) {\n                        _node.key = kd.key;\n                    }\n                    if (kd.data) {\n                        _node.data = kd.data;\n                    }\n                    else {\n                        _node.data = data;\n                    }\n                }\n                else {\n                    _node.data = data;\n                }\n            }\n            if (this.isRed(_node.right) && (!this.isRed(_node.left))) {\n                _node = this.rotateLeft(_node);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (this.isRed(_node.left) && this.isRed(_node.left.left)) {\n                _node = this.rotateRight(_node);\n            }\n            if (this.isRed(_node.left) && this.isRed(_node.right)) {\n                this.flipColors(_node);\n            }\n            _node.size = this.nodeSize(_node.left) + this.nodeSize(_node.right) + 1;\n            if (this.aug) {\n                this.updateLocal(_node);\n            }\n            return _node;\n        }\n    }\n    updateLocal(node) {\n        if (this.aug) {\n            if (this.isRed(node.left)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.aug.update(node.left);\n            }\n            if (this.isRed(node.right)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.aug.update(node.right);\n            }\n            this.aug.update(node);\n        }\n    }\n    nodeRemoveMin(node) {\n        let _node = node;\n        if (_node.left) {\n            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {\n                _node = this.moveRedLeft(_node);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _node.left = this.nodeRemoveMin(_node.left);\n            return this.balance(_node);\n        }\n    }\n    remove(key) {\n        if (key !== undefined) {\n            if (!this.contains(key)) {\n                return;\n            }\n            this.removeExisting(key);\n        }\n        // TODO: error on undefined key\n    }\n    removeExisting(key) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.root.color = RBColor.RED;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.root = this.nodeRemove(this.root, key);\n    }\n    nodeRemove(node, key) {\n        let _node = node;\n        if (this.compareKeys(key, _node.key) < 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {\n                _node = this.moveRedLeft(_node);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _node.left = this.nodeRemove(_node.left, key);\n        }\n        else {\n            if (this.isRed(_node.left)) {\n                _node = this.rotateRight(_node);\n            }\n            if ((this.compareKeys(key, _node.key) === 0) && (!_node.right)) {\n                return undefined;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {\n                _node = this.moveRedRight(_node);\n            }\n            if (this.compareKeys(key, _node.key) === 0) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const subtreeMin = this.nodeMin(_node.right);\n                _node.key = subtreeMin.key;\n                _node.data = subtreeMin.data;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                _node.right = this.nodeRemoveMin(_node.right);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                _node.right = this.nodeRemove(_node.right, key);\n            }\n        }\n        return this.balance(_node);\n    }\n    floor(key) {\n        if (!this.isEmpty()) {\n            return this.nodeFloor(this.root, key);\n        }\n    }\n    nodeFloor(node, key) {\n        if (node) {\n            const cmp = this.compareKeys(key, node.key);\n            if (cmp === 0) {\n                return node;\n            }\n            else if (cmp < 0) {\n                return this.nodeFloor(node.left, key);\n            }\n            else {\n                const rightFloor = this.nodeFloor(node.right, key);\n                if (rightFloor) {\n                    return rightFloor;\n                }\n                else {\n                    return node;\n                }\n            }\n        }\n    }\n    ceil(key) {\n        if (!this.isEmpty()) {\n            return this.nodeCeil(this.root, key);\n        }\n    }\n    nodeCeil(node, key) {\n        if (node) {\n            const cmp = this.compareKeys(key, node.key);\n            if (cmp === 0) {\n                return node;\n            }\n            else if (cmp > 0) {\n                return this.nodeCeil(node.right, key);\n            }\n            else {\n                const leftCeil = this.nodeCeil(node.left, key);\n                if (leftCeil) {\n                    return leftCeil;\n                }\n                else {\n                    return node;\n                }\n            }\n        }\n    }\n    min() {\n        if (this.root) {\n            return this.nodeMin(this.root);\n        }\n    }\n    nodeMin(node) {\n        if (!node.left) {\n            return node;\n        }\n        else {\n            return this.nodeMin(node.left);\n        }\n    }\n    max() {\n        if (this.root) {\n            return this.nodeMax(this.root);\n        }\n    }\n    nodeMax(node) {\n        if (!node.right) {\n            return node;\n        }\n        else {\n            return this.nodeMax(node.right);\n        }\n    }\n    rotateRight(node) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const leftChild = node.left;\n        node.left = leftChild.right;\n        leftChild.right = node;\n        leftChild.color = leftChild.right.color;\n        leftChild.right.color = RBColor.RED;\n        leftChild.size = node.size;\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.updateLocal(node);\n            this.updateLocal(leftChild);\n        }\n        return leftChild;\n    }\n    rotateLeft(node) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const rightChild = node.right;\n        node.right = rightChild.left;\n        rightChild.left = node;\n        rightChild.color = rightChild.left.color;\n        rightChild.left.color = RBColor.RED;\n        rightChild.size = node.size;\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.updateLocal(node);\n            this.updateLocal(rightChild);\n        }\n        return rightChild;\n    }\n    oppositeColor(c) {\n        return (c === RBColor.BLACK) ? RBColor.RED : RBColor.BLACK;\n    }\n    flipColors(node) {\n        node.color = this.oppositeColor(node.color);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        node.left.color = this.oppositeColor(node.left.color);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        node.right.color = this.oppositeColor(node.right.color);\n    }\n    moveRedLeft(node) {\n        let _node = node;\n        this.flipColors(_node);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isRed(_node.right.left)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            _node.right = this.rotateRight(_node.right);\n            _node = this.rotateLeft(_node);\n            this.flipColors(_node);\n        }\n        return _node;\n    }\n    moveRedRight(node) {\n        let _node = node;\n        this.flipColors(_node);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isRed(_node.left.left)) {\n            _node = this.rotateRight(_node);\n            this.flipColors(_node);\n        }\n        return _node;\n    }\n    balance(input) {\n        let node = input;\n        if (this.isRed(node.right)) {\n            node = this.rotateLeft(node);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isRed(node.left) && this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n        }\n        if (this.isRed(node.left) && (this.isRed(node.right))) {\n            this.flipColors(node);\n        }\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.aug.update(node);\n        }\n        return node;\n    }\n    mapRange(action, accum, start, end) {\n        this.nodeMap(this.root, action, start, end);\n    }\n    map(action, accum) {\n        // TODO: optimize to avoid comparisons\n        this.nodeMap(this.root, action, accum);\n    }\n    keys() {\n        const keyList = [];\n        const actions = {\n            showStructure: true,\n            infix: (node) => {\n                keyList.push(node.key);\n                return true;\n            },\n        };\n        this.walk(actions);\n        return keyList;\n    }\n    /**\n     * Depth-first traversal with custom action; if action returns\n     * false, traversal is halted.\n     * @param action - action to apply to each node\n     */\n    walk(actions) {\n        this.nodeWalk(this.root, actions);\n    }\n    walkBackward(actions) {\n        this.nodeWalkBackward(this.root, actions);\n    }\n    nodeWalk(node, actions) {\n        let go = true;\n        if (node) {\n            if (actions.pre) {\n                if (actions.showStructure || (node.color === RBColor.BLACK)) {\n                    go = actions.pre(node);\n                }\n            }\n            if (node.left) {\n                go = this.nodeWalk(node.left, actions);\n            }\n            if (go && actions.infix) {\n                if (actions.showStructure || (node.color === RBColor.BLACK)) {\n                    go = actions.infix(node);\n                }\n            }\n            if (go) {\n                go = this.nodeWalk(node.right, actions);\n            }\n            if (go && actions.post) {\n                if (actions.showStructure || (node.color === RBColor.BLACK)) {\n                    go = actions.post(node);\n                }\n            }\n        }\n        return go;\n    }\n    nodeWalkBackward(node, actions) {\n        let go = true;\n        if (node) {\n            if (actions.pre) {\n                if (actions.showStructure || (node.color === RBColor.BLACK)) {\n                    go = actions.pre(node);\n                }\n            }\n            if (node.right) {\n                go = this.nodeWalkBackward(node.right, actions);\n            }\n            if (go && actions.infix) {\n                if (actions.showStructure || (node.color === RBColor.BLACK)) {\n                    go = actions.infix(node);\n                }\n            }\n            if (go) {\n                go = this.nodeWalkBackward(node.left, actions);\n            }\n            if (go && actions.post) {\n                if (actions.showStructure || (node.color === RBColor.BLACK)) {\n                    go = actions.post(node);\n                }\n            }\n        }\n        return go;\n    }\n    nodeMap(node, action, accum, start, end) {\n        let _start = start;\n        let _end = end;\n        if (!node) {\n            return true;\n        }\n        if (_start === undefined) {\n            _start = this.nodeMin(node).key;\n        }\n        if (_end === undefined) {\n            _end = this.nodeMax(node).key;\n        }\n        const cmpStart = this.compareKeys(_start, node.key);\n        const cmpEnd = this.compareKeys(_end, node.key);\n        let go = true;\n        if (cmpStart < 0) {\n            go = this.nodeMap(node.left, action, accum, _start, _end);\n        }\n        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {\n            // REVIEW: test for black node here\n            go = action(node, accum);\n        }\n        if (go && (cmpEnd > 0)) {\n            go = this.nodeMap(node.right, action, accum, _start, _end);\n        }\n        return go;\n    }\n}\nconst integerRangeToString = (range) => `[${range.start},${range.end})`;\nconst intervalComparer = (a, b) => a.compare(b);\nclass IntervalTree {\n    constructor() {\n        this.intervals = new RedBlackTree(intervalComparer, this);\n    }\n    remove(x) {\n        this.intervals.remove(x);\n    }\n    removeExisting(x) {\n        this.intervals.removeExisting(x);\n    }\n    put(x, conflict) {\n        let rbConflict;\n        if (conflict) {\n            rbConflict = (key, currentKey) => {\n                const ival = conflict(key, currentKey);\n                return {\n                    key: ival,\n                };\n            };\n        }\n        this.intervals.put(x, { minmax: x.clone() }, rbConflict);\n    }\n    map(fn) {\n        const actions = {\n            infix: (node) => {\n                fn(node.key);\n                return true;\n            },\n            showStructure: true,\n        };\n        this.intervals.walk(actions);\n    }\n    mapUntil(fn) {\n        const actions = {\n            infix: (node) => {\n                return fn(node.key);\n            },\n            showStructure: true,\n        };\n        this.intervals.walk(actions);\n    }\n    mapBackward(fn) {\n        const actions = {\n            infix: (node) => {\n                fn(node.key);\n                return true;\n            },\n            showStructure: true,\n        };\n        this.intervals.walkBackward(actions);\n    }\n    // TODO: toString()\n    match(x) {\n        return this.intervals.gather(x, this);\n    }\n    matchNode(node, key) {\n        return !!node && node.key.overlaps(key);\n    }\n    continueSubtree(node, key) {\n        return !!node && node.data.minmax.overlaps(key);\n    }\n    update(node) {\n        if (node.left && node.right) {\n            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));\n        }\n        else {\n            if (node.left) {\n                node.data.minmax = node.key.union(node.left.data.minmax);\n            }\n            else if (node.right) {\n                node.data.minmax = node.key.union(node.right.data.minmax);\n            }\n            else {\n                node.data.minmax = node.key.clone();\n            }\n        }\n    }\n}\nclass TST {\n    constructor() {\n        this.n = 0;\n    }\n    size() {\n        return this.n;\n    }\n    contains(key) {\n        return this.get(key);\n    }\n    get(key) {\n        const x = this.nodeGet(this.root, key, 0);\n        if (x === undefined) {\n            return undefined;\n        }\n        return x.val;\n    }\n    nodeGet(x, key, d) {\n        if (x === undefined) {\n            return undefined;\n        }\n        const c = key.charAt(d);\n        if (c < x.c) {\n            return this.nodeGet(x.left, key, d);\n        }\n        else if (c > x.c) {\n            return this.nodeGet(x.right, key, d);\n        }\n        else if (d < (key.length - 1)) {\n            return this.nodeGet(x.mid, key, d + 1);\n        }\n        else {\n            return x;\n        }\n    }\n    put(key, val) {\n        if (!this.contains(key)) {\n            this.n++;\n        }\n        this.root = this.nodePut(this.root, key, val, 0);\n    }\n    nodePut(x, key, val, d) {\n        let _x = x;\n        const c = key.charAt(d);\n        if (_x === undefined) {\n            _x = { c };\n        }\n        if (c < _x.c) {\n            _x.left = this.nodePut(_x.left, key, val, d);\n        }\n        else if (c > _x.c) {\n            _x.right = this.nodePut(_x.right, key, val, d);\n        }\n        else if (d < (key.length - 1)) {\n            _x.mid = this.nodePut(_x.mid, key, val, d + 1);\n        }\n        else {\n            _x.val = val;\n        }\n        return _x;\n    }\n    neighbors(text, distance = 2) {\n        let q = [];\n        this.nodeProximity(this.root, { text: \"\" }, 0, text, distance, q);\n        q = q.filter((value) => (value.text.length > 0));\n        return q;\n    }\n    keysWithPrefix(text) {\n        const q = [];\n        const x = this.nodeGet(this.root, text, 0);\n        if (x === undefined) {\n            return q;\n        }\n        if (x.val !== undefined) {\n            q.push(text);\n        }\n        this.collect(x.mid, { text }, q);\n        return q;\n    }\n    collect(x, prefix, q) {\n        if (x === undefined) {\n            return;\n        }\n        this.collect(x.left, prefix, q);\n        if (x.val !== undefined) {\n            q.push(prefix.text + x.c);\n        }\n        this.collect(x.mid, { text: prefix.text + x.c }, q);\n        this.collect(x.right, prefix, q);\n    }\n    mapNode(x, prefix, fn) {\n        if (x === undefined) {\n            return;\n        }\n        const key = prefix.text + x.c;\n        this.mapNode(x.left, prefix, fn);\n        if (x.val) {\n            fn(key, x.val);\n        }\n        this.mapNode(x.mid, { text: key }, fn);\n        this.mapNode(x.right, prefix, fn);\n    }\n    map(fn) {\n        this.mapNode(this.root, { text: \"\" }, fn);\n    }\n    pairsWithPrefix(text) {\n        const q = [];\n        const x = this.nodeGet(this.root, text, 0);\n        if (x === undefined) {\n            return q;\n        }\n        if (x.val !== undefined) {\n            q.push({ key: text, val: x.val });\n        }\n        this.collectPairs(x.mid, { text }, q);\n        return q;\n    }\n    collectPairs(x, prefix, q) {\n        if (x === undefined) {\n            return;\n        }\n        this.collectPairs(x.left, prefix, q);\n        if (x.val !== undefined) {\n            q.push({ key: prefix.text + x.c, val: x.val });\n        }\n        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);\n        this.collectPairs(x.right, prefix, q);\n    }\n    nodeProximity(x, prefix, d, pattern, distance, q) {\n        if ((x === undefined) || (distance < 0)) {\n            return;\n        }\n        const c = pattern.charAt(d);\n        if ((distance > 0) || (c < x.c)) {\n            this.nodeProximity(x.left, prefix, d, pattern, distance, q);\n        }\n        if (x.val !== undefined) {\n            const remD = distance - (pattern.length - d);\n            if (remD >= 0) {\n                let invD = distance;\n                if (c !== x.c) {\n                    invD--;\n                }\n                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });\n            }\n        }\n        const recurD = (d < (pattern.length - 1)) ? d + 1 : d;\n        if (c === x.c) {\n            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);\n        }\n        else {\n            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);\n        }\n        if ((distance > 0) || (c > x.c)) {\n            this.nodeProximity(x.right, prefix, d, pattern, distance, q);\n        }\n    }\n}\n//# sourceMappingURL=collections.js.map\n\n/***/ }),\n/* 288 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 289 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 290 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedString\": () => (/* binding */ SharedString)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(294);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(305);\n/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(291);\n/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * The Shared String is a specialized data structure for handling collaborative\n * text. It is based on a more general Sequence data structure but has\n * additional features that make working with text easier.\n *\n * In addition to text, a Shared String can also contain markers. Markers can be\n * used to store metadata at positions within the text, like the details of an\n * image or Fluid object that should be rendered with the text.\n *\n */\nclass SharedString extends _sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSegmentSequence {\n    constructor(document, id, attributes) {\n        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory.segmentFromSpec);\n        this.id = id;\n        this.mergeTreeTextHelper = this.client.createTextHelper();\n    }\n    /**\n     * Create a new shared string.\n     * @param runtime - data store runtime the new shared string belongs to\n     * @param id - optional name of the shared string\n     * @returns newly create shared string (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory.Type);\n    }\n    /**\n     * Get a factory for SharedString to register with the data store.\n     * @returns a factory that creates and load SharedString\n     */\n    static getFactory() {\n        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory();\n    }\n    get ISharedString() {\n        return this;\n    }\n    /**\n     * Inserts a marker at a relative position.\n     * @param relativePos1 - The relative position to insert the marker at\n     * @param refType - The reference type of the marker\n     * @param props - The properties of the marker\n     */\n    insertMarkerRelative(relativePos1, refType, props) {\n        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Marker(refType);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const pos = this.posFromRelativePos(relativePos1);\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * {@inheritDoc ISharedString.insertMarker}\n     */\n    insertMarker(pos, refType, props) {\n        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Marker(refType);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n        return insertOp;\n    }\n    /**\n     * Inserts the text at the position.\n     * @param relativePos1 - The relative position to insert the text at\n     * @param text - The text to insert\n     * @param props - The properties of text\n     */\n    insertTextRelative(relativePos1, text, props) {\n        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment(text);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const pos = this.posFromRelativePos(relativePos1);\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * {@inheritDoc ISharedString.insertText}\n     */\n    insertText(pos, text, props) {\n        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment(text);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * Replaces a range with the provided text.\n     * @param start - The inclusive start of the range to replace\n     * @param end - The exclusive end of the range to replace\n     * @param text - The text to replace the range with\n     * @param props - Optional. The properties of the replacement text\n     */\n    replaceText(start, end, text, props) {\n        this.replaceRange(start, end, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment.make(text, props));\n    }\n    /**\n     * Removes the text in the given range.\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to replace\n     * @returns the message sent.\n     */\n    removeText(start, end) {\n        return this.removeRange(start, end);\n    }\n    /**\n     * Annotates the marker with the provided properties and calls the callback on consensus.\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param consensusCallback - The callback called when consensus is reached\n     */\n    annotateMarkerNotifyConsensus(marker, props, callback) {\n        const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);\n        if (annotateOp) {\n            this.submitSequenceMessage(annotateOp);\n        }\n    }\n    /**\n     * Annotates the marker with the provided properties.\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     */\n    annotateMarker(marker, props, combiningOp) {\n        const annotateOp = this.client.annotateMarker(marker, props, combiningOp);\n        if (annotateOp) {\n            this.submitSequenceMessage(annotateOp);\n        }\n    }\n    findTile(startPos, tileLabel, preceding = true) {\n        return this.client.findTile(startPos, tileLabel, preceding);\n    }\n    getTextAndMarkers(label) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);\n    }\n    /**\n     * Retrieve text from the SharedString in string format.\n     * @param start - The starting index of the text to retrieve, or 0 if omitted.\n     * @param end - The ending index of the text to retrieve, or the end of the string if omitted\n     * @returns The requested text content as a string.\n     */\n    getText(start, end) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"\", start, end);\n    }\n    /**\n     * Adds spaces for markers and handles, so that position calculations account for them.\n     */\n    getTextWithPlaceholders() {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \");\n    }\n    getTextRangeWithPlaceholders(start, end) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \", start, end);\n    }\n    getTextRangeWithMarkers(start, end) {\n        const segmentWindow = this.client.getCollabWindow();\n        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"*\", start, end);\n    }\n    getMarkerFromId(id) {\n        return this.client.getMarkerFromId(id);\n    }\n}\n//# sourceMappingURL=sharedString.js.map\n\n/***/ }),\n/* 291 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedSegmentSequence\": () => (/* binding */ SharedSegmentSequence)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(292);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(314);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(288);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(316);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(281);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(284);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(300);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(286);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(91);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(315);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(138);\n/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(279);\n/* harmony import */ var _defaultMap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(312);\n/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(311);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\nconst snapshotFileName = \"header\";\nconst contentPath = \"content\";\nclass SharedSegmentSequence extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.SharedObject {\n    constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {\n        super(id, dataStoreRuntime, attributes, \"fluid_sequence_\");\n        this.dataStoreRuntime = dataStoreRuntime;\n        this.id = id;\n        this.segmentFromSpec = segmentFromSpec;\n        // Deferred that triggers once the object is loaded\n        this.loadedDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        // cache out going ops created when partial loading\n        this.loadedDeferredOutgoingOps = [];\n        // cache incoming ops that arrive when partial loading\n        this.deferIncomingOps = true;\n        this.loadedDeferredIncomingOps = [];\n        this.messagesSinceMSNChange = [];\n        this.loadedDeferred.promise.catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"SequenceLoadFailed\" }, error);\n        });\n        this.client = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Client(segmentFromSpec, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, \"SharedSegmentSequence.MergeTreeClient\"), dataStoreRuntime.options);\n        super.on(\"newListener\", (event) => {\n            switch (event) {\n                case \"sequenceDelta\":\n                    if (!this.client.mergeTreeDeltaCallback) {\n                        this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {\n                            this.emit(\"sequenceDelta\", new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);\n                        };\n                    }\n                    break;\n                case \"maintenance\":\n                    if (!this.client.mergeTreeMaintenanceCallback) {\n                        this.client.mergeTreeMaintenanceCallback = (args, opArgs) => {\n                            this.emit(\"maintenance\", new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceMaintenanceEvent(opArgs, args, this.client), this);\n                        };\n                    }\n                    break;\n                default:\n            }\n        });\n        super.on(\"removeListener\", (event) => {\n            switch (event) {\n                case \"sequenceDelta\":\n                    if (super.listenerCount(event) === 0) {\n                        this.client.mergeTreeDeltaCallback = undefined;\n                    }\n                    break;\n                case \"maintenance\":\n                    if (super.listenerCount(event) === 0) {\n                        this.client.mergeTreeMaintenanceCallback = undefined;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        });\n        this.intervalCollections = new _defaultMap__WEBPACK_IMPORTED_MODULE_5__.DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new _intervalCollection__WEBPACK_IMPORTED_MODULE_6__.SequenceIntervalCollectionValueType());\n    }\n    get loaded() {\n        return this.loadedDeferred.promise;\n    }\n    static createOpsFromDelta(event) {\n        var _a, _b;\n        const ops = [];\n        for (const r of event.ranges) {\n            switch (event.deltaOperation) {\n                case _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.ANNOTATE: {\n                    const lastAnnotate = ops[ops.length - 1];\n                    const props = {};\n                    for (const key of Object.keys(r.propertyDeltas)) {\n                        props[key] = (_b = (_a = r.segment.properties) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;\n                    }\n                    if (lastAnnotate && lastAnnotate.pos2 === r.position &&\n                        (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.matchProperties)(lastAnnotate.props, props)) {\n                        lastAnnotate.pos2 += r.segment.cachedLength;\n                    }\n                    else {\n                        ops.push((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createAnnotateRangeOp)(r.position, r.position + r.segment.cachedLength, props, undefined));\n                    }\n                    break;\n                }\n                case _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.INSERT:\n                    ops.push((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createInsertOp)(r.position, r.segment.clone().toJSONObject()));\n                    break;\n                case _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.REMOVE: {\n                    const lastRem = ops[ops.length - 1];\n                    if ((lastRem === null || lastRem === void 0 ? void 0 : lastRem.pos1) === r.position) {\n                        lastRem.pos2 += r.segment.cachedLength;\n                    }\n                    else {\n                        ops.push((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createRemoveRangeOp)(r.position, r.position + r.segment.cachedLength));\n                    }\n                    break;\n                }\n                default:\n            }\n        }\n        return ops;\n    }\n    /**\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     */\n    removeRange(start, end) {\n        const removeOp = this.client.removeRangeLocal(start, end);\n        if (removeOp) {\n            this.submitSequenceMessage(removeOp);\n        }\n        return removeOp;\n    }\n    groupOperation(groupOp) {\n        this.client.localTransaction(groupOp);\n        this.submitSequenceMessage(groupOp);\n    }\n    getContainingSegment(pos) {\n        return this.client.getContainingSegment(pos);\n    }\n    /**\n     * Returns the length of the current sequence for the client\n     */\n    getLength() {\n        return this.client.getLength();\n    }\n    /**\n     * Returns the current position of a segment, and -1 if the segment\n     * does not exist in this sequence\n     * @param segment - The segment to get the position of\n     */\n    getPosition(segment) {\n        return this.client.getPosition(segment);\n    }\n    /**\n     * Annotates the range with the provided properties\n     *\n     * @param start - The inclusive start position of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     *\n     */\n    annotateRange(start, end, props, combiningOp) {\n        const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);\n        if (annotateOp) {\n            this.submitSequenceMessage(annotateOp);\n        }\n    }\n    getPropertiesAtPosition(pos) {\n        return this.client.getPropertiesAtPosition(pos);\n    }\n    getRangeExtentsOfPosition(pos) {\n        return this.client.getRangeExtentsOfPosition(pos);\n    }\n    /**\n     * @deprecated - use createLocalReferencePosition\n     */\n    createPositionReference(segment, offset, refType) {\n        const lref = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_10__.LocalReference(this.client, segment, offset, refType);\n        if (refType !== _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.ReferenceType.Transient) {\n            this.addLocalReference(lref);\n        }\n        return lref;\n    }\n    createLocalReferencePosition(segment, offset, refType, properties) {\n        return this.client.createLocalReferencePosition(segment, offset, refType, properties);\n    }\n    /**\n     * @deprecated - use localReferencePositionToPosition\n     */\n    localRefToPos(localRef) {\n        return this.client.localReferencePositionToPosition(localRef);\n    }\n    localReferencePositionToPosition(lref) {\n        return this.client.localReferencePositionToPosition(lref);\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence. The client ref seq must be above the minimum sequence number\n     * or the return value will be undefined.\n     * Generally this method is used in conjunction with signals which provide\n     * point in time values for the below parameters, and is useful for things\n     * like displaying user position. It should not be used with persisted values\n     * as persisted values will quickly become invalid as the remoteClientRefSeq\n     * moves below the minimum sequence number\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n        return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n    }\n    submitSequenceMessage(message) {\n        if (!this.isAttached()) {\n            return;\n        }\n        const translated = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__.makeHandlesSerializable)(message, this.serializer, this.handle);\n        const metadata = this.client.peekPendingSegmentGroups(message.type === _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.GROUP ? message.ops.length : 1);\n        // if loading isn't complete, we need to cache\n        // local ops until loading is complete, and then\n        // they will be resent\n        if (!this.loadedDeferred.isCompleted) {\n            this.loadedDeferredOutgoingOps.push([translated, metadata]);\n        }\n        else {\n            this.submitLocalMessage(translated, metadata);\n        }\n    }\n    /**\n     * @deprecated - use createLocalReferencePosition\n     */\n    addLocalReference(lref) {\n        return this.client.addLocalReference(lref);\n    }\n    /**\n     * @deprecated - use removeLocalReferencePosition\n     */\n    removeLocalReference(lref) {\n        return this.client.removeLocalReferencePosition(lref);\n    }\n    removeLocalReferencePosition(lref) {\n        return this.client.removeLocalReferencePosition(lref);\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     */\n    posFromRelativePos(relativePos) {\n        return this.client.posFromRelativePos(relativePos);\n    }\n    /**\n     * Walk the underlying segments of the sequence.\n     * The walked segments may extend beyond the range\n     * if the segments cross the ranges start or end boundaries.\n     * Set split range to true to ensure only segments within the\n     * range are walked.\n     *\n     * @param handler - The function to handle each segment\n     * @param start - Optional. The start of range walk.\n     * @param end - Optional. The end of range walk\n     * @param accum - Optional. An object that will be passed to the handler for accumulation\n     * @param splitRange - Optional. Splits boundary segments on the range boundaries\n     */\n    walkSegments(handler, start, end, accum, splitRange = false) {\n        return this.client.walkSegments(handler, start, end, accum, splitRange);\n    }\n    getStackContext(startPos, rangeLabels) {\n        return this.client.getStackContext(startPos, rangeLabels);\n    }\n    getCurrentSeq() {\n        return this.client.getCurrentSeq();\n    }\n    insertAtReferencePosition(pos, segment) {\n        const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates\n     * are supported. Use `getIntervalCollection` instead.\n     */\n    async waitIntervalCollection(label) {\n        return this.intervalCollections.get(label);\n    }\n    getIntervalCollection(label) {\n        return this.intervalCollections.get(label);\n    }\n    /**\n     * @returns an iterable object that enumerates the IntervalCollection labels\n     * Usage:\n     * const iter = this.getIntervalCollectionKeys();\n     * for (key of iter)\n     *     const collection = this.getIntervalCollection(key);\n     *     ...\n    */\n    getIntervalCollectionLabels() {\n        return this.intervalCollections.keys();\n    }\n    summarizeCore(serializer, telemetryContext) {\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.SummaryTreeBuilder();\n        // conditionally write the interval collection blob\n        // only if it has entries\n        if (this.intervalCollections.size > 0) {\n            builder.addBlob(snapshotFileName, this.intervalCollections.serialize(serializer));\n        }\n        builder.addWithStats(contentPath, this.summarizeMergeTree(serializer));\n        return builder.getSummaryTree();\n    }\n    /**\n     * Runs serializer over the GC data for this SharedMatrix.\n     * All the IFluidHandle's represent routes to other objects.\n     */\n    processGCDataCore(serializer) {\n        if (this.intervalCollections.size > 0) {\n            this.intervalCollections.serialize(serializer);\n        }\n        this.client.serializeGCData(this.handle, serializer);\n    }\n    /**\n     * Replace the range specified from start to end with the provided segment\n     * This is done by inserting the segment at the end of the range, followed\n     * by removing the contents of the range\n     * For a zero or reverse range (start \\>= end), insert at end do not remove anything\n     * @param start - The start of the range to replace\n     * @param end - The end of the range to replace\n     * @param segment - The segment that will replace the range\n     */\n    replaceRange(start, end, segment) {\n        // Insert at the max end of the range when start > end, but still remove the range later\n        const insertIndex = Math.max(start, end);\n        // Insert first, so local references can slide to the inserted seg if any\n        const insert = this.client.insertSegmentLocal(insertIndex, segment);\n        if (insert) {\n            if (start < end) {\n                const remove = this.client.removeRangeLocal(start, end);\n                this.submitSequenceMessage((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createGroupOp)(insert, remove));\n            }\n            else {\n                this.submitSequenceMessage(insert);\n            }\n        }\n    }\n    onConnect() {\n        // Update merge tree collaboration information with new client ID and then resend pending ops\n        this.client.startOrUpdateCollaboration(this.runtime.clientId);\n    }\n    onDisconnect() { }\n    reSubmitCore(content, localOpMetadata) {\n        if (!this.intervalCollections.tryResubmitMessage(content, localOpMetadata)) {\n            this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));\n        }\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     */\n    async loadCore(storage) {\n        var _a;\n        if (await storage.contains(snapshotFileName)) {\n            const blob = await storage.readBlob(snapshotFileName);\n            const header = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__.bufferToString)(blob, \"utf8\");\n            this.intervalCollections.populate(header);\n        }\n        try {\n            // this will load the header, and return a promise\n            // that will resolve when the body is loaded\n            // and the catchup ops are available.\n            const { catchupOpsP } = await this.client.load(this.runtime, new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.ObjectStoragePartition(storage, contentPath), this.serializer);\n            // setup a promise to process the\n            // catch up ops, and finishing the loading process\n            const loadCatchUpOps = catchupOpsP\n                .then((msgs) => {\n                msgs.forEach((m) => {\n                    const collabWindow = this.client.getCollabWindow();\n                    if (m.minimumSequenceNumber < collabWindow.minSeq\n                        || m.referenceSequenceNumber < collabWindow.minSeq\n                        || m.sequenceNumber <= collabWindow.minSeq\n                        || m.sequenceNumber <= collabWindow.currentSeq) {\n                        throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({\n                            op: {\n                                seq: m.sequenceNumber,\n                                minSeq: m.minimumSequenceNumber,\n                                refSeq: m.referenceSequenceNumber,\n                            },\n                            collabWindow: {\n                                seq: collabWindow.currentSeq,\n                                minSeq: collabWindow.minSeq,\n                            },\n                        })}`);\n                    }\n                    this.processMergeTreeMsg(m);\n                });\n                this.loadFinished();\n            })\n                .catch((error) => {\n                this.loadFinished(error);\n            });\n            if (((_a = this.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {\n                // if we not doing partial load, await the catch up ops,\n                // and the finalization of the load\n                await loadCatchUpOps;\n            }\n        }\n        catch (error) {\n            this.loadFinished(error);\n        }\n    }\n    processCore(message, local, localOpMetadata) {\n        // if loading isn't complete, we need to cache all\n        // incoming ops to be applied after loading is complete\n        if (this.deferIncomingOps) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(!local, 0x072 /* \"Unexpected local op when loading not finished\" */);\n            this.loadedDeferredIncomingOps.push(message);\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.MessageType.Operation, 0x073 /* \"Sequence message not operation\" */);\n            const handled = this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);\n            if (!handled) {\n                this.processMergeTreeMsg(message, local);\n            }\n        }\n    }\n    didAttach() {\n        var _a;\n        // If we are not local, and we've attached we need to start generating and sending ops\n        // so start collaboration and provide a default client id incase we are not connected\n        if (this.isAttached()) {\n            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : \"attached\");\n        }\n    }\n    initializeLocalCore() {\n        super.initializeLocalCore();\n        this.loadFinished();\n    }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}\n     */\n    applyStashedOp(content) {\n        return this.client.applyStashedOp(content);\n    }\n    summarizeMergeTree(serializer) {\n        // Are we fully loaded? If not, things will go south\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(this.loadedDeferred.isCompleted, 0x074 /* \"Snapshot called when not fully loaded\" */);\n        const minSeq = this.runtime.deltaManager.minimumSequenceNumber;\n        this.processMinSequenceNumberChanged(minSeq);\n        this.messagesSinceMSNChange.forEach((m) => { m.minimumSequenceNumber = minSeq; });\n        return this.client.summarize(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);\n    }\n    processMergeTreeMsg(rawMessage, local) {\n        var _a, _b;\n        const message = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__.parseHandles)(rawMessage, this.serializer);\n        const ops = [];\n        function transformOps(event) {\n            ops.push(...SharedSegmentSequence.createOpsFromDelta(event));\n        }\n        const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;\n        let stashMessage = message;\n        if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {\n            if (needsTransformation) {\n                this.on(\"sequenceDelta\", transformOps);\n            }\n        }\n        this.client.applyMsg(message, local);\n        if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {\n            if (needsTransformation) {\n                this.removeListener(\"sequenceDelta\", transformOps);\n                // shallow clone the message as we only overwrite top level properties,\n                // like referenceSequenceNumber and content only\n                stashMessage = Object.assign(Object.assign({}, message), { referenceSequenceNumber: stashMessage.sequenceNumber - 1, contents: ops.length !== 1 ? (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createGroupOp)(...ops) : ops[0] });\n            }\n            this.messagesSinceMSNChange.push(stashMessage);\n            // Do GC every once in a while...\n            if (this.messagesSinceMSNChange.length > 20\n                && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {\n                this.processMinSequenceNumberChanged(message.minimumSequenceNumber);\n            }\n        }\n    }\n    processMinSequenceNumberChanged(minSeq) {\n        let index = 0;\n        for (; index < this.messagesSinceMSNChange.length; index++) {\n            if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {\n                break;\n            }\n        }\n        if (index !== 0) {\n            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);\n        }\n    }\n    loadFinished(error) {\n        if (!this.loadedDeferred.isCompleted) {\n            // Initialize the interval collections\n            this.initializeIntervalCollections();\n            if (error) {\n                this.loadedDeferred.reject(error);\n                throw error;\n            }\n            else {\n                // it is important this series remains synchronous\n                // first we stop deferring incoming ops, and apply then all\n                this.deferIncomingOps = false;\n                for (const message of this.loadedDeferredIncomingOps) {\n                    this.processCore(message, false, undefined);\n                }\n                this.loadedDeferredIncomingOps.length = 0;\n                // then resolve the loaded promise\n                // and resubmit all the outstanding ops, as the snapshot\n                // is fully loaded, and all outstanding ops are applied\n                this.loadedDeferred.resolve();\n                for (const [messageContent, opMetadata] of this.loadedDeferredOutgoingOps) {\n                    this.reSubmitCore(messageContent, opMetadata);\n                }\n                this.loadedDeferredOutgoingOps.length = 0;\n            }\n        }\n    }\n    initializeIntervalCollections() {\n        // Listen and initialize new SharedIntervalCollections\n        this.intervalCollections.eventEmitter.on(\"create\", ({ key, previousValue }, local) => {\n            const intervalCollection = this.intervalCollections.get(key);\n            if (!intervalCollection.attached) {\n                intervalCollection.attachGraph(this.client, key);\n            }\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(previousValue === undefined, 0x2c1 /* \"Creating an interval collection that already exists?\" */);\n            this.emit(\"createIntervalCollection\", key, local, this);\n        });\n        // Initialize existing SharedIntervalCollections\n        for (const key of this.intervalCollections.keys()) {\n            const intervalCollection = this.intervalCollections.get(key);\n            intervalCollection.attachGraph(this.client, key);\n        }\n    }\n}\n//# sourceMappingURL=sequence.js.map\n\n/***/ }),\n/* 292 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"LazyPromise\": () => (/* binding */ LazyPromise)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nclass Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nclass LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map\n\n/***/ }),\n/* 293 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Client\": () => (/* binding */ Client)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(304);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(301);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(283);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(303);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(285);\n/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(286);\n/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);\n/* harmony import */ var _opBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(300);\n/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(281);\n/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(307);\n/* harmony import */ var _snapshotLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(310);\n/* harmony import */ var _textSegment__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(305);\n/* harmony import */ var _snapshotV1__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(306);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction elapsedMicroseconds(trace) {\n    return trace.trace().duration * 1000;\n}\nclass Client {\n    constructor(\n    // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence\n    specToSegment, logger, options) {\n        this.specToSegment = specToSegment;\n        this.logger = logger;\n        this.measureOps = false;\n        this.accumTime = 0;\n        this.localTime = 0;\n        this.localOps = 0;\n        this.accumWindowTime = 0;\n        this.accumWindow = 0;\n        this.accumOps = 0;\n        this.maxWindowTime = 0;\n        this.clientNameToIds = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareStrings);\n        this.shortClientIdMap = [];\n        this.pendingConsensus = new Map();\n        this.mergeTree = new _mergeTree__WEBPACK_IMPORTED_MODULE_1__.MergeTree(options);\n    }\n    get mergeTreeDeltaCallback() { return this.mergeTree.mergeTreeDeltaCallback; }\n    set mergeTreeDeltaCallback(callback) {\n        this.mergeTree.mergeTreeDeltaCallback = callback;\n    }\n    get mergeTreeMaintenanceCallback() {\n        return this.mergeTree.mergeTreeMaintenanceCallback;\n    }\n    set mergeTreeMaintenanceCallback(callback) {\n        this.mergeTree.mergeTreeMaintenanceCallback = callback;\n    }\n    /**\n     * The merge tree maintains a queue of segment groups for each local operation.\n     * These segment groups track segments modified by an operation.\n     * This method peeks the tail of that queue, and returns the segments groups there.\n     * It is used to get the segment group(s) for the previous operations.\n     * @param count - The number segment groups to get peek from the tail of the queue. Default 1.\n     */\n    peekPendingSegmentGroups(count = 1) {\n        var _a, _b;\n        if (count === 1) {\n            return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();\n        }\n        let taken = 0;\n        return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {\n            if (taken < count) {\n                taken++;\n                return true;\n            }\n            return false;\n        }, true);\n    }\n    /**\n     * Annotate a marker and call the callback on consensus.\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param consensusCallback - The callback called when consensus is reached\n     * @returns The annotate op if valid, otherwise undefined\n     */\n    annotateMarkerNotifyConsensus(marker, props, consensusCallback) {\n        const combiningOp = {\n            name: \"consensus\",\n        };\n        const annotateOp = this.annotateMarker(marker, props, combiningOp);\n        if (annotateOp) {\n            const consensusInfo = {\n                callback: consensusCallback,\n                marker,\n            };\n            this.pendingConsensus.set(marker.getId(), consensusInfo);\n            return annotateOp;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Annotates the markers with the provided properties\n     * @param marker - The marker to annotate\n     * @param props - The properties to annotate the marker with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @returns The annotate op if valid, otherwise undefined\n     */\n    annotateMarker(marker, props, combiningOp) {\n        const annotateOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateMarkerOp)(marker, props, combiningOp);\n        if (this.applyAnnotateRangeOp({ op: annotateOp })) {\n            return annotateOp;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Annotates the range with the provided properties\n     * @param start - The inclusive start position of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @returns The annotate op if valid, otherwise undefined\n     */\n    annotateRangeLocal(start, end, props, combiningOp) {\n        const annotateOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateRangeOp)(start, end, props, combiningOp);\n        if (this.applyAnnotateRangeOp({ op: annotateOp })) {\n            return annotateOp;\n        }\n        return undefined;\n    }\n    /**\n     * Removes the range\n     *\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     */\n    removeRangeLocal(start, end) {\n        const removeOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createRemoveRangeOp)(start, end);\n        if (this.applyRemoveRangeOp({ op: removeOp })) {\n            return removeOp;\n        }\n        return undefined;\n    }\n    /**\n     * @param pos - The position to insert the segment at\n     * @param segment - The segment to insert\n     */\n    insertSegmentLocal(pos, segment) {\n        if (segment.cachedLength <= 0) {\n            return undefined;\n        }\n        const insertOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp)(pos, segment);\n        if (this.applyInsertOp({ op: insertOp })) {\n            return insertOp;\n        }\n        return undefined;\n    }\n    /**\n     * @param refPos - The reference position to insert the segment at\n     * @param segment - The segment to insert\n     */\n    insertAtReferencePositionLocal(refPos, segment) {\n        const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());\n        if (pos === _localReference__WEBPACK_IMPORTED_MODULE_3__.LocalReference.DetachedPosition) {\n            return undefined;\n        }\n        const op = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp)(pos, segment);\n        const opArgs = { op };\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();\n        }\n        this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);\n        this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), { start: op.pos1 }, traceStart);\n        return op;\n    }\n    walkSegments(handler, start, end, accum, splitRange = false) {\n        this.mergeTree.mapRange({\n            leaf: handler,\n        }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);\n    }\n    /**\n     * Serializes the data required for garbage collection. The IFluidHandles stored in all segments that haven't\n     * been removed represent routes to other objects. We serialize the data in these segments using the passed in\n     * serializer which keeps track of all serialized handles.\n     */\n    serializeGCData(handle, handleCollectingSerializer) {\n        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {\n            // Only serialize segments that have not been removed.\n            if (seg.removedSeq === undefined) {\n                handleCollectingSerializer.stringify(seg.clone().toJSONObject(), handle);\n            }\n            return true;\n        });\n    }\n    getCollabWindow() {\n        return this.mergeTree.getCollabWindow();\n    }\n    /**\n     * Returns the current position of a segment, and -1 if the segment\n     * does not exist in this merge tree\n     * @param segment - The segment to get the position of\n     */\n    getPosition(segment) {\n        if ((segment === null || segment === void 0 ? void 0 : segment.parent) === undefined) {\n            return -1;\n        }\n        return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());\n    }\n    /**\n     * @deprecated - use createReferencePosition instead\n     */\n    addLocalReference(lref) {\n        return this.mergeTree.addLocalReference(lref);\n    }\n    /**\n     * @deprecated - use removeReferencePosition instead\n     */\n    removeLocalReference(lref) {\n        return this.removeLocalReferencePosition(lref);\n    }\n    createLocalReferencePosition(segment, offset, refType, properties) {\n        return this.mergeTree.createLocalReferencePosition(segment, offset, refType, properties, this);\n    }\n    removeLocalReferencePosition(lref) {\n        return this.mergeTree.removeLocalReferencePosition(lref);\n    }\n    localReferencePositionToPosition(lref) {\n        return this.mergeTree.referencePositionToLocalPosition(lref);\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     */\n    posFromRelativePos(relativePos) {\n        return this.mergeTree.posFromRelativePos(relativePos);\n    }\n    getMarkerFromId(id) {\n        return this.mergeTree.getMarkerFromId(id);\n    }\n    /**\n     * Performs the remove based on the provided op\n     * @param opArgs - The ops args for the op\n     * @returns True if the remove was applied. False if it could not be.\n     */\n    applyRemoveRangeOp(opArgs) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE, 0x02d /* \"Unexpected op type on range remove!\" */);\n        const op = opArgs.op;\n        const clientArgs = this.getClientSequenceArgs(opArgs);\n        const range = this.getValidOpRange(op, clientArgs);\n        if (!range) {\n            return false;\n        }\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();\n        }\n        this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);\n        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n        return true;\n    }\n    /**\n     * Performs the annotate based on the provided op\n     * @param opArgs - The ops args for the op\n     * @returns True if the annotate was applied. False if it could not be.\n     */\n    applyAnnotateRangeOp(opArgs) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE, 0x02e /* \"Unexpected op type on range annotate!\" */);\n        const op = opArgs.op;\n        const clientArgs = this.getClientSequenceArgs(opArgs);\n        const range = this.getValidOpRange(op, clientArgs);\n        if (!range) {\n            return false;\n        }\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();\n        }\n        this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n        return true;\n    }\n    /**\n     * Performs the insert based on the provided op\n     * @param opArgs - The ops args for the op\n     * @returns True if the insert was applied. False if it could not be.\n     */\n    applyInsertOp(opArgs) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT, 0x02f /* \"Unexpected op type on range insert!\" */);\n        const op = opArgs.op;\n        const clientArgs = this.getClientSequenceArgs(opArgs);\n        const range = this.getValidOpRange(op, clientArgs);\n        if (!range) {\n            return false;\n        }\n        let segments;\n        if (op.seg) {\n            segments = [this.specToSegment(op.seg)];\n        }\n        if (!segments || segments.length === 0) {\n            return false;\n        }\n        let traceStart;\n        if (this.measureOps) {\n            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();\n        }\n        this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n        return true;\n    }\n    /**\n     *\n     * @param opArgs - The op args of the op to complete\n     * @param clientArgs - The client args for the op\n     * @param range - The range the op applied to\n     * @param clockStart - Optional. The clock start if timing data should be updated.\n     */\n    completeAndLogOp(opArgs, clientArgs, range, traceStart) {\n        if (!opArgs.sequencedMessage) {\n            if (traceStart) {\n                this.localTime += elapsedMicroseconds(traceStart);\n                this.localOps++;\n            }\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, 0x030 /* \"Incoming remote op sequence# <= local collabWindow's currentSequence#\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, 0x031 /* \"Incoming remote op minSequence# < local collabWindow's minSequence#\" */);\n            if (traceStart) {\n                this.accumTime += elapsedMicroseconds(traceStart);\n                this.accumOps++;\n                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);\n            }\n        }\n    }\n    /**\n     * Returns a valid range for the op, or undefined\n     * @param op - The op to generate the range for\n     * @param clientArgs - The client args for the op\n     */\n    getValidOpRange(op, clientArgs) {\n        let start = op.pos1;\n        if (start === undefined && op.relativePos1) {\n            start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n        }\n        let end = op.pos2;\n        if (end === undefined && op.relativePos2) {\n            end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n        }\n        // Validate if local op\n        if (clientArgs.clientId === this.getClientId()) {\n            const length = this.getLength();\n            const invalidPositions = [];\n            // Validate start position\n            //\n            if (start === undefined\n                || start < 0\n                || start > length\n                || start === length && op.type !== _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT) {\n                invalidPositions.push(\"start\");\n            }\n            // Validate end if not insert, or insert has end\n            //\n            if (op.type !== _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT || end !== undefined) {\n                if (end === undefined || end <= start) {\n                    invalidPositions.push(\"end\");\n                }\n            }\n            if (invalidPositions.length > 0) {\n                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError(\"RangeOutOfBounds\", {\n                    usageError: true,\n                    end,\n                    invalidPositions: invalidPositions.toString(),\n                    length,\n                    opPos1: op.pos1,\n                    opPos1Relative: op.relativePos1 !== undefined,\n                    opPos2: op.pos2,\n                    opPos2Relative: op.relativePos2 !== undefined,\n                    opType: op.type,\n                    start,\n                });\n            }\n        }\n        // start and end are guaranteed to be non-null here, otherwise we throw above.\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        return { start, end };\n    }\n    /**\n     * Gets the client args from the op if remote, otherwise uses the local clients info\n     * @param sequencedMessage - The sequencedMessage to get the client sequence args for\n     */\n    getClientSequenceArgsForMessage(sequencedMessage) {\n        // If there this no sequenced message, then the op is local\n        // and unacked, so use this clients sequenced args\n        //\n        if (!sequencedMessage) {\n            const segWindow = this.getCollabWindow();\n            return {\n                clientId: segWindow.clientId,\n                referenceSequenceNumber: segWindow.currentSeq,\n                sequenceNumber: this.getLocalSequenceNumber(),\n            };\n        }\n        else {\n            return {\n                clientId: this.getOrAddShortClientId(sequencedMessage.clientId),\n                referenceSequenceNumber: sequencedMessage.referenceSequenceNumber,\n                sequenceNumber: sequencedMessage.sequenceNumber,\n            };\n        }\n    }\n    /**\n     * Gets the client args from the op if remote, otherwise uses the local clients info\n     * @param opArgs - The op arg to get the client sequence args for\n     */\n    getClientSequenceArgs(opArgs) {\n        return this.getClientSequenceArgsForMessage(opArgs.sequencedMessage);\n    }\n    ackPendingSegment(opArgs) {\n        const ackOp = (deltaOpArgs) => {\n            let trace;\n            if (this.measureOps) {\n                trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();\n            }\n            this.mergeTree.ackPendingSegment(deltaOpArgs);\n            if (deltaOpArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE) {\n                if (deltaOpArgs.op.combiningOp && (deltaOpArgs.op.combiningOp.name === \"consensus\")) {\n                    this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);\n                }\n            }\n            if (trace) {\n                this.accumTime += elapsedMicroseconds(trace);\n                this.accumOps++;\n                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);\n            }\n        };\n        if (opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP) {\n            for (const memberOp of opArgs.op.ops) {\n                ackOp({\n                    groupOp: opArgs.op,\n                    op: memberOp,\n                    sequencedMessage: opArgs.sequencedMessage,\n                });\n            }\n        }\n        else {\n            ackOp(opArgs);\n        }\n    }\n    // as functions are modified move them above the eslint-disabled waterline and lint them\n    cloneFromSegments() {\n        const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);\n        const segments = [];\n        const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);\n        clone.mergeTree.root = newRoot;\n        return clone;\n    }\n    getOrAddShortClientId(longClientId) {\n        if (!this.clientNameToIds.get(longClientId)) {\n            this.addLongClientId(longClientId);\n        }\n        return this.getShortClientId(longClientId);\n    }\n    getShortClientId(longClientId) {\n        return this.clientNameToIds.get(longClientId).data;\n    }\n    getLongClientId(shortClientId) {\n        if (shortClientId >= 0) {\n            return this.shortClientIdMap[shortClientId];\n        }\n        else {\n            return \"original\";\n        }\n    }\n    addLongClientId(longClientId) {\n        this.clientNameToIds.put(longClientId, this.shortClientIdMap.length);\n        this.shortClientIdMap.push(longClientId);\n    }\n    /**\n     * During reconnect, we must find the positions to pending segments\n     * relative to other pending segments. This methods computes that\n     * position relative to a localSeq. Pending segments above the localSeq\n     * will be ignored.\n     *\n     * @param segment - The segment to find the position for\n     * @param localSeq - The localSeq to find the position of the segment at\n     */\n    findReconnectionPosition(segment, localSeq) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x032 /* \"localSeq greater than collab window\" */);\n        let segmentPosition = 0;\n        /*\n            Walk the segments up to the current segment, and calculate it's\n            position taking into account local segments that were modified,\n            after the current segment.\n\n            TODO: Consider embedding this information into the tree for\n            more efficient look up of pending segment positions.\n        */\n        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {\n            // If we've found the desired segment, terminate the walk and return 'segmentPosition'.\n            if (seg === segment) {\n                return false;\n            }\n            // Otherwise, advance segmentPosition if the segment has been inserted and not removed\n            // with respect to the given 'localSeq'.\n            //\n            // Note that all ACKed / remote ops are applied and we only need concern ourself with\n            // determining if locally pending ops fall before/after the given 'localSeq'.\n            if ((seg.localSeq === undefined || seg.localSeq <= localSeq) // Is inserted\n                && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed\n            ) {\n                segmentPosition += seg.cachedLength;\n            }\n            return true;\n        });\n        return segmentPosition;\n    }\n    /**\n     * Rebases a (local) position from the perspective `{ seq: seqNumberFrom, localSeq }` to the perspective\n     * of the current sequence number. This is desirable when rebasing operations for reconnection.\n     *\n     * If the position refers to a segment/offset that was removed by some operation between `seqNumberFrom` and\n     * the current sequence number, the returned position will align with the position of a reference given\n     * `SlideOnRemove` semantics.\n     */\n    rebasePosition(pos, seqNumberFrom, localSeq) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x300 /* localSeq greater than collab window */);\n        let segment;\n        let posAccumulated = 0;\n        let offset = pos;\n        const isInsertedInView = (seg) => (seg.seq !== undefined && seg.seq !== _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber && seg.seq <= seqNumberFrom)\n            || (seg.localSeq !== undefined && seg.localSeq <= localSeq);\n        const isRemovedFromView = ({ removedSeq, localRemovedSeq }) => (removedSeq !== undefined && removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber && removedSeq <= seqNumberFrom)\n            || (localRemovedSeq !== undefined && localRemovedSeq <= localSeq);\n        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(seg.seq !== undefined || seg.localSeq !== undefined, 0x301 /* Either seq or localSeq should be defined */);\n            segment = seg;\n            if (isInsertedInView(seg) && !isRemovedFromView(seg)) {\n                posAccumulated += seg.cachedLength;\n                if (offset >= seg.cachedLength) {\n                    offset -= seg.cachedLength;\n                }\n            }\n            // Keep going while we've yet to reach the segment at the desired position\n            return posAccumulated <= pos;\n        });\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segment !== undefined, 0x302 /* No segment found */);\n        const seqNumberTo = this.getCollabWindow().currentSeq;\n        if ((segment.removedSeq !== undefined &&\n            segment.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber &&\n            segment.removedSeq <= seqNumberTo)\n            || (segment.localRemovedSeq !== undefined && segment.localRemovedSeq <= localSeq)) {\n            // Segment that the position was in has been removed: null out offset.\n            offset = 0;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(0 <= offset && offset < segment.cachedLength, 0x303 /* Invalid offset */);\n        return this.findReconnectionPosition(segment, localSeq) + offset;\n    }\n    resetPendingDeltaToOps(resetOp, segmentGroup) {\n        var _a, _b;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!segmentGroup, 0x033 /* \"Segment group undefined\" */);\n        const NACKedSegmentGroup = (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.dequeue();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segmentGroup === NACKedSegmentGroup, 0x034 /* \"Segment group not at head of merge tree pending queue\" */);\n        const opList = [];\n        // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.\n        // The reason they need them sorted, as they have the same local sequence number and which means\n        // farther segments will  take into account nearer segments when calculating their position.\n        // By sorting we ensure the nearer segment will be applied and sequenced before the father segments\n        // so their recalculated positions will be correct.\n        for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {\n            const segmentSegGroup = segment.segmentGroups.dequeue();\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segmentGroup === segmentSegGroup, 0x035 /* \"Segment group not at head of segment pending queue\" */);\n            const segmentPosition = this.findReconnectionPosition(segment, segmentGroup.localSeq);\n            let newOp;\n            switch (resetOp.type) {\n                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(((_b = segment.propertyManager) === null || _b === void 0 ? void 0 : _b.hasPendingProperties()) === true, 0x036 /* \"Segment has no pending properties\" */);\n                    // if the segment has been removed, there's no need to send the annotate op\n                    // unless the remove was local, in which case the annotate must have come\n                    // before the remove\n                    if (segment.removedSeq === undefined || segment.localRemovedSeq !== undefined) {\n                        newOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateRangeOp)(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);\n                    }\n                    break;\n                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segment.seq === _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber, 0x037 /* \"Segment already has assigned sequence number\" */);\n                    let segInsertOp = segment;\n                    if (typeof resetOp.seg === \"object\" && resetOp.seg.props !== undefined) {\n                        segInsertOp = segment.clone();\n                        segInsertOp.properties = resetOp.seg.props;\n                    }\n                    newOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp)(segmentPosition, segInsertOp);\n                    break;\n                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:\n                    if (segment.localRemovedSeq !== undefined) {\n                        newOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createRemoveRangeOp)(segmentPosition, segmentPosition + segment.cachedLength);\n                    }\n                    break;\n                default:\n                    throw new Error(`Invalid op type`);\n            }\n            if (newOp) {\n                const newSegmentGroup = { segments: [], localSeq: segmentGroup.localSeq };\n                segment.segmentGroups.enqueue(newSegmentGroup);\n                this.mergeTree.pendingSegments.enqueue(newSegmentGroup);\n                opList.push(newOp);\n            }\n        }\n        return opList;\n    }\n    applyRemoteOp(opArgs) {\n        const op = opArgs.op;\n        const msg = opArgs.sequencedMessage;\n        this.getOrAddShortClientId(msg.clientId);\n        switch (op.type) {\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:\n                this.applyInsertOp(opArgs);\n                break;\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:\n                this.applyRemoveRangeOp(opArgs);\n                break;\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:\n                this.applyAnnotateRangeOp(opArgs);\n                break;\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP: {\n                for (const memberOp of op.ops) {\n                    this.applyRemoteOp({\n                        op: memberOp,\n                        groupOp: op,\n                        sequencedMessage: msg,\n                    });\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    applyStashedOp(op) {\n        let metadata;\n        switch (op.type) {\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:\n                this.applyInsertOp({ op });\n                metadata = this.peekPendingSegmentGroups();\n                break;\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:\n                this.applyRemoveRangeOp({ op });\n                metadata = this.peekPendingSegmentGroups();\n                break;\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:\n                this.applyAnnotateRangeOp({ op });\n                metadata = this.peekPendingSegmentGroups();\n                break;\n            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP:\n                return op.ops.map((o) => this.applyStashedOp(o));\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.unreachableCase)(op, \"unrecognized op type\");\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!metadata, 0x2db /* \"Applying op must generate a pending segment\" */);\n        return metadata;\n    }\n    applyMsg(msg, local = false) {\n        var _a;\n        // Ensure client ID is registered\n        this.getOrAddShortClientId(msg.clientId);\n        // Apply if an operation message\n        if (msg.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_10__.MessageType.Operation) {\n            const opArgs = {\n                op: msg.contents,\n                sequencedMessage: msg,\n            };\n            if (((_a = opArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.clientId) === this.longClientId || local) {\n                this.ackPendingSegment(opArgs);\n            }\n            else {\n                this.applyRemoteOp(opArgs);\n            }\n        }\n        this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);\n    }\n    updateSeqNumbers(min, seq) {\n        const collabWindow = this.mergeTree.getCollabWindow();\n        // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(collabWindow.currentSeq <= seq, 0x038 /* \"Incoming op sequence# < local collabWindow's currentSequence#\" */);\n        collabWindow.currentSeq = seq;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(min <= seq, 0x039 /* \"Incoming op sequence# < minSequence#\" */);\n        this.updateMinSeq(min);\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n        const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);\n        return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);\n    }\n    /**\n     *  Given an pending operation and segment group, regenerate the op, so it\n     *  can be resubmitted\n     * @param resetOp - The op to reset\n     * @param segmentGroup - The segment group associated with the op\n     */\n    regeneratePendingOp(resetOp, segmentGroup) {\n        const opList = [];\n        if (resetOp.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP) {\n            if (Array.isArray(segmentGroup)) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.ops.length === segmentGroup.length, 0x03a /* \"Number of ops in 'resetOp' must match the number of segment groups provided.\" */);\n                for (let i = 0; i < resetOp.ops.length; i++) {\n                    opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));\n                }\n            }\n            else {\n                // A group op containing a single op will pass a direct reference to 'segmentGroup'\n                // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.ops.length === 1, 0x03b /* \"Number of ops in 'resetOp' must match the number of segment groups provided.\" */);\n                opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));\n            }\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.type !== _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP, 0x03c /* \"Reset op has 'group' delta type!\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!Array.isArray(segmentGroup), 0x03d /* \"segmentGroup is array rather than singleton!\" */);\n            opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));\n        }\n        return opList.length === 1 ? opList[0] : (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createGroupOp)(...opList);\n    }\n    createTextHelper() {\n        return new _textSegment__WEBPACK_IMPORTED_MODULE_11__.MergeTreeTextHelper(this.mergeTree);\n    }\n    summarize(runtime, handle, serializer, catchUpMsgs) {\n        var _a;\n        const deltaManager = runtime.deltaManager;\n        const minSeq = deltaManager.minimumSequenceNumber;\n        // Catch up to latest MSN, if we have not had a chance to do it.\n        // Required for case where FluidDataStoreRuntime.attachChannel()\n        // generates summary right after loading data store.\n        this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber);\n        // One of the summaries (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!\n        // Not sure why - need to catch it sooner\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.getCollabWindow().minSeq === minSeq, 0x03e /* \"minSeq mismatch between collab window and delta manager!\" */);\n        // Must continue to support legacy\n        //       (See https://github.com/microsoft/FluidFramework/issues/84)\n        if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(catchUpMsgs === undefined || catchUpMsgs.length === 0, 0x03f /* \"New format should not emit catchup ops\" */);\n            const snap = new _snapshotV1__WEBPACK_IMPORTED_MODULE_12__.SnapshotV1(this.mergeTree, this.logger, (id) => this.getLongClientId(id));\n            snap.extractSync();\n            return snap.emit(serializer, handle);\n        }\n        else {\n            const snap = new _snapshotlegacy__WEBPACK_IMPORTED_MODULE_13__.SnapshotLegacy(this.mergeTree, this.logger);\n            snap.extractSync();\n            return snap.emit(catchUpMsgs, serializer, handle);\n        }\n    }\n    async load(runtime, storage, serializer) {\n        const loader = new _snapshotLoader__WEBPACK_IMPORTED_MODULE_14__.SnapshotLoader(runtime, this, this.mergeTree, this.logger, serializer);\n        return loader.initialize(storage);\n    }\n    getStackContext(startPos, rangeLabels) {\n        return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);\n    }\n    getLocalSequenceNumber() {\n        const segWindow = this.getCollabWindow();\n        if (segWindow.collaborating) {\n            return _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber;\n        }\n        else {\n            return _constants__WEBPACK_IMPORTED_MODULE_8__.UniversalSequenceNumber;\n        }\n    }\n    localTransaction(groupOp) {\n        for (const op of groupOp.ops) {\n            const opArgs = {\n                op,\n                groupOp,\n            };\n            switch (op.type) {\n                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:\n                    this.applyInsertOp(opArgs);\n                    break;\n                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:\n                    this.applyAnnotateRangeOp(opArgs);\n                    break;\n                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:\n                    this.applyRemoveRangeOp(opArgs);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    updateConsensusProperty(op, msg) {\n        const markerId = op.relativePos1.id;\n        const consensusInfo = this.pendingConsensus.get(markerId);\n        if (consensusInfo) {\n            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);\n        }\n        this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));\n    }\n    updateMinSeq(minSeq) {\n        let trace;\n        if (this.measureOps) {\n            trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();\n        }\n        this.mergeTree.setMinSeq(minSeq);\n        if (trace) {\n            const elapsed = elapsedMicroseconds(trace);\n            this.accumWindowTime += elapsed;\n            if (elapsed > this.maxWindowTime) {\n                this.maxWindowTime = elapsed;\n            }\n        }\n    }\n    getContainingSegment(pos, op) {\n        const args = this.getClientSequenceArgsForMessage(op);\n        return this.mergeTree.getContainingSegment(pos, args.referenceSequenceNumber, args.clientId);\n    }\n    /**\n     * Returns the position to slide a reference to if a slide is required.\n     * @param segoff - The segment and offset to slide from\n     * @returns - segment and offset to slide the reference to\n     */\n    getSlideToSegment(segoff) {\n        return this.mergeTree._getSlideToSegment(segoff);\n    }\n    getPropertiesAtPosition(pos) {\n        let propertiesAtPosition;\n        const segoff = this.getContainingSegment(pos);\n        const seg = segoff.segment;\n        if (seg) {\n            propertiesAtPosition = seg.properties;\n        }\n        return propertiesAtPosition;\n    }\n    getRangeExtentsOfPosition(pos) {\n        let posStart;\n        let posAfterEnd;\n        const segoff = this.getContainingSegment(pos);\n        const seg = segoff.segment;\n        if (seg) {\n            posStart = this.getPosition(seg);\n            posAfterEnd = posStart + seg.cachedLength;\n        }\n        return { posStart, posAfterEnd };\n    }\n    getCurrentSeq() {\n        return this.getCollabWindow().currentSeq;\n    }\n    getClientId() {\n        return this.getCollabWindow().clientId;\n    }\n    getLength() { return this.mergeTree.length; }\n    startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0) {\n        // we should always have a client id if we are collaborating\n        // if the client id is undefined we are likely bound to a detached\n        // container, so we should keep going in local mode. once\n        // the container attaches this will be called again on connect with the\n        // client id\n        if (longClientId !== undefined) {\n            if (this.longClientId === undefined) {\n                this.longClientId = longClientId;\n                this.addLongClientId(this.longClientId);\n                this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq);\n            }\n            else {\n                const oldClientId = this.longClientId;\n                const oldData = this.clientNameToIds.get(oldClientId).data;\n                this.longClientId = longClientId;\n                this.clientNameToIds.put(longClientId, oldData);\n                this.shortClientIdMap[oldData] = longClientId;\n            }\n        }\n    }\n    findTile(startPos, tileLabel, preceding = true) {\n        const clientId = this.getClientId();\n        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);\n    }\n}\n//# sourceMappingURL=client.js.map\n\n/***/ }),\n/* 294 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseSegment\": () => (/* binding */ BaseSegment),\n/* harmony export */   \"CollaborationWindow\": () => (/* binding */ CollaborationWindow),\n/* harmony export */   \"IncrementalExecOp\": () => (/* binding */ IncrementalExecOp),\n/* harmony export */   \"IncrementalMapState\": () => (/* binding */ IncrementalMapState),\n/* harmony export */   \"Marker\": () => (/* binding */ Marker),\n/* harmony export */   \"MaxNodesInBlock\": () => (/* binding */ MaxNodesInBlock),\n/* harmony export */   \"MergeBlock\": () => (/* binding */ MergeBlock),\n/* harmony export */   \"MergeNode\": () => (/* binding */ MergeNode),\n/* harmony export */   \"MergeTree\": () => (/* binding */ MergeTree),\n/* harmony export */   \"clientSeqComparer\": () => (/* binding */ clientSeqComparer),\n/* harmony export */   \"compareNumbers\": () => (/* binding */ compareNumbers),\n/* harmony export */   \"compareStrings\": () => (/* binding */ compareStrings),\n/* harmony export */   \"internedSpaces\": () => (/* binding */ internedSpaces),\n/* harmony export */   \"ordinalToArray\": () => (/* binding */ ordinalToArray),\n/* harmony export */   \"reservedMarkerIdKey\": () => (/* binding */ reservedMarkerIdKey),\n/* harmony export */   \"reservedMarkerSimpleTypeKey\": () => (/* binding */ reservedMarkerSimpleTypeKey),\n/* harmony export */   \"toRemovalInfo\": () => (/* binding */ toRemovalInfo)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(283);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(51);\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(287);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(285);\n/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(286);\n/* harmony import */ var _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(298);\n/* harmony import */ var _mergeTreeTracking__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(296);\n/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(281);\n/* harmony import */ var _partialLengths__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(299);\n/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(284);\n/* harmony import */ var _referencePositions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(280);\n/* harmony import */ var _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(295);\n/* harmony import */ var _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(282);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/consistent-type-assertions */\n/* eslint-disable @typescript-eslint/prefer-optional-chain, no-bitwise */\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction toRemovalInfo(maybe) {\n    if ((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) !== undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) !== undefined) {\n        return maybe;\n    }\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) === undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) === undefined, 0x2bf /* \"both removedClientIds and removedSeq should be set or not set\" */);\n}\nfunction isRemoved(segment) {\n    return toRemovalInfo(segment) !== undefined;\n}\nfunction isRemovedAndAcked(segment) {\n    const removalInfo = toRemovalInfo(segment);\n    return removalInfo !== undefined && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber;\n}\nclass MergeNode {\n    constructor() {\n        this.index = 0;\n        this.ordinal = \"\";\n        this.cachedLength = 0;\n    }\n    isLeaf() {\n        return false;\n    }\n}\nfunction addTile(tile, tiles) {\n    const tileLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(tile);\n    if (tileLabels) {\n        for (const tileLabel of tileLabels) {\n            tiles[tileLabel] = tile;\n        }\n    }\n}\nfunction addTileIfNotPresent(tile, tiles) {\n    const tileLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(tile);\n    if (tileLabels) {\n        for (const tileLabel of tileLabels) {\n            if (tiles[tileLabel] === undefined) {\n                tiles[tileLabel] = tile;\n            }\n        }\n    }\n}\nfunction applyStackDelta(currentStackMap, deltaStackMap) {\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for (const label in deltaStackMap) {\n        const deltaStack = deltaStackMap[label];\n        if (!deltaStack.empty()) {\n            let currentStack = currentStackMap[label];\n            if (currentStack === undefined) {\n                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_3__.Stack();\n                currentStackMap[label] = currentStack;\n            }\n            for (const delta of deltaStack.items) {\n                applyRangeReference(currentStack, delta);\n            }\n        }\n    }\n}\nfunction applyRangeReference(stack, delta) {\n    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(delta, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin)) {\n        stack.push(delta);\n        return true;\n    }\n    else {\n        // Assume delta is end reference\n        const top = stack.top();\n        // TODO: match end with begin\n        if (top && ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(top, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin))) {\n            stack.pop();\n        }\n        else {\n            stack.push(delta);\n        }\n        return false;\n    }\n}\nfunction addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {\n    var _a;\n    function updateRangeInfo(label, refPos) {\n        let stack = rangeStacks[label];\n        if (stack === undefined) {\n            stack = new _collections__WEBPACK_IMPORTED_MODULE_3__.Stack();\n            rangeStacks[label] = stack;\n        }\n        applyRangeReference(stack, refPos);\n    }\n    if (node.isLeaf()) {\n        const segment = node;\n        if (((_a = mergeTree.localNetLength(segment)) !== null && _a !== void 0 ? _a : 0) > 0) {\n            if (Marker.is(segment)) {\n                const markerId = segment.getId();\n                // Also in insertMarker but need for reload segs case\n                // can add option for this only from reload segs\n                if (markerId) {\n                    mergeTree.mapIdToSegment(markerId, segment);\n                }\n                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(segment, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Tile)) {\n                    addTile(segment, rightmostTiles);\n                    addTileIfNotPresent(segment, leftmostTiles);\n                }\n                if (segment.refType & (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {\n                    const rangeLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(segment);\n                    if (rangeLabels) {\n                        for (const label of rangeLabels) {\n                            updateRangeInfo(label, segment);\n                        }\n                    }\n                }\n            }\n            else {\n                const baseSegment = node;\n                if (baseSegment.localRefs && (baseSegment.localRefs.hierRefCount !== undefined) &&\n                    (baseSegment.localRefs.hierRefCount > 0)) {\n                    for (const lref of baseSegment.localRefs) {\n                        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Tile)) {\n                            addTile(lref, rightmostTiles);\n                            addTileIfNotPresent(lref, leftmostTiles);\n                        }\n                        if (lref.refType & (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {\n                            for (const label of (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(lref)) {\n                                updateRangeInfo(label, lref);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else {\n        const block = node;\n        applyStackDelta(rangeStacks, block.rangeStacks);\n        (0,_properties__WEBPACK_IMPORTED_MODULE_5__.extend)(rightmostTiles, block.rightmostTiles);\n        (0,_properties__WEBPACK_IMPORTED_MODULE_5__.extendIfUndefined)(leftmostTiles, block.leftmostTiles);\n    }\n}\nfunction ordinalToArray(ord) {\n    const a = [];\n    if (ord) {\n        for (let i = 0, len = ord.length; i < len; i++) {\n            a.push(ord.charCodeAt(i));\n        }\n    }\n    return a;\n}\n// Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because\n// the MergeTree always inserts first, then checks for overflow and splits if the child count equals\n// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to\n// facilitate splits.)\nconst MaxNodesInBlock = 8;\nclass MergeBlock extends MergeNode {\n    constructor(childCount) {\n        super();\n        this.childCount = childCount;\n        this.children = new Array(MaxNodesInBlock);\n    }\n    hierBlock() {\n        return undefined;\n    }\n    setOrdinal(child, index) {\n        let childCount = this.childCount;\n        if (childCount === 8) {\n            childCount = 7;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((childCount >= 1) && (childCount <= 7), 0x040 /* \"Child count is not within [1,7] range!\" */);\n        let localOrdinal;\n        const ordinalWidth = 1 << (MaxNodesInBlock - (childCount + 1));\n        if (index === 0) {\n            localOrdinal = ordinalWidth - 1;\n        }\n        else {\n            const prevOrd = this.children[index - 1].ordinal;\n            const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);\n            localOrdinal = prevOrdCode + ordinalWidth;\n        }\n        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(child.ordinal.length === (this.ordinal.length + 1), 0x041 /* \"Unexpected child ordinal length!\" */);\n        if (index > 0) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(child.ordinal > this.children[index - 1].ordinal, 0x042);\n        }\n    }\n    assignChild(child, index, updateOrdinal = true) {\n        child.parent = this;\n        child.index = index;\n        if (updateOrdinal) {\n            this.setOrdinal(child, index);\n        }\n        this.children[index] = child;\n    }\n}\nclass HierMergeBlock extends MergeBlock {\n    constructor(childCount) {\n        super(childCount);\n        this.rightmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();\n        this.leftmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();\n        this.rangeStacks = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();\n    }\n    addNodeReferences(mergeTree, node) {\n        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);\n    }\n    hierBlock() {\n        return this;\n    }\n    hierToString(indentCount) {\n        let strbuf = \"\";\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const key in this.rangeStacks) {\n            const stack = this.rangeStacks[key];\n            strbuf += internedSpaces(indentCount);\n            strbuf += `${key}: `;\n            for (const item of stack.items) {\n                strbuf += `${item.toString()} `;\n            }\n            strbuf += \"\\n\";\n        }\n        return strbuf;\n    }\n}\nfunction nodeTotalLength(mergeTree, node) {\n    if (!node.isLeaf()) {\n        return node.cachedLength;\n    }\n    return mergeTree.localNetLength(node);\n}\nclass BaseSegment extends MergeNode {\n    constructor() {\n        super(...arguments);\n        this.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId;\n        this.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;\n        this.segmentGroups = new _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_6__.SegmentGroupCollection(this);\n        this.trackingCollection = new _mergeTreeTracking__WEBPACK_IMPORTED_MODULE_7__.TrackingGroupCollection(this);\n    }\n    addProperties(newProps, op, seq, collabWindow) {\n        if (!this.propertyManager) {\n            this.propertyManager = new _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_8__.PropertiesManager();\n        }\n        if (!this.properties) {\n            this.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();\n        }\n        return this.propertyManager.addProperties(this.properties, newProps, op, seq, collabWindow && collabWindow.collaborating);\n    }\n    hasProperty(key) {\n        return !!this.properties && (this.properties[key] !== undefined);\n    }\n    isLeaf() {\n        return true;\n    }\n    cloneInto(b) {\n        var _a;\n        b.clientId = this.clientId;\n        // TODO: deep clone properties\n        b.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.clone)(this.properties);\n        b.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();\n        // TODO: copy removed client overlap and branch removal info\n        b.removedSeq = this.removedSeq;\n        b.seq = this.seq;\n    }\n    canAppend(segment) {\n        return false;\n    }\n    addSerializedProps(jseg) {\n        if (this.properties) {\n            jseg.props = this.properties;\n        }\n    }\n    ack(segmentGroup, opArgs, mergeTree) {\n        const currentSegmentGroup = this.segmentGroups.dequeue();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(currentSegmentGroup === segmentGroup, 0x043 /* \"On ack, unexpected segmentGroup!\" */);\n        switch (opArgs.op.type) {\n            case _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.ANNOTATE:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.propertyManager, 0x044 /* \"On annotate ack, missing segment property manager!\" */);\n                this.propertyManager.ackPendingProperties(opArgs.op);\n                return true;\n            case _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.INSERT:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, 0x045 /* \"On insert, seq number already assigned!\" */);\n                this.seq = opArgs.sequencedMessage.sequenceNumber;\n                this.localSeq = undefined;\n                return true;\n            case _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.REMOVE:\n                const removalInfo = toRemovalInfo(this);\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(removalInfo !== undefined, 0x046 /* \"On remove ack, missing removal info!\" */);\n                this.localRemovedSeq = undefined;\n                if (removalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {\n                    removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;\n                    return true;\n                }\n                return false;\n            default:\n                throw new Error(`${opArgs.op.type} is in unrecognized operation type`);\n        }\n    }\n    splitAt(pos) {\n        var _a;\n        if (pos > 0) {\n            const leafSegment = this.createSplitSegmentAt(pos);\n            if (leafSegment) {\n                this.copyPropertiesTo(leafSegment);\n                leafSegment.parent = this.parent;\n                // Give the leaf a temporary yet valid ordinal.\n                // when this segment is put in the tree, it will get it's real ordinal,\n                // but this ordinal meets all the necessary invariants for now.\n                leafSegment.ordinal = this.ordinal + String.fromCharCode(0);\n                leafSegment.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();\n                leafSegment.removedSeq = this.removedSeq;\n                leafSegment.localRemovedSeq = this.localRemovedSeq;\n                leafSegment.seq = this.seq;\n                leafSegment.localSeq = this.localSeq;\n                leafSegment.clientId = this.clientId;\n                this.segmentGroups.copyTo(leafSegment);\n                this.trackingCollection.copyTo(leafSegment);\n                if (this.localRefs) {\n                    this.localRefs.split(pos, leafSegment);\n                }\n            }\n            return leafSegment;\n        }\n    }\n    copyPropertiesTo(other) {\n        if (this.propertyManager) {\n            if (this.properties) {\n                other.propertyManager = new _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_8__.PropertiesManager();\n                other.properties = this.propertyManager.copyTo(this.properties, other.properties, other.propertyManager);\n            }\n        }\n    }\n}\nconst reservedMarkerIdKey = \"markerId\";\nconst reservedMarkerSimpleTypeKey = \"markerSimpleType\";\nclass Marker extends BaseSegment {\n    constructor(refType) {\n        super();\n        this.refType = refType;\n        this.type = Marker.type;\n        this.cachedLength = 1;\n    }\n    static is(segment) {\n        return segment.type === Marker.type;\n    }\n    static make(refType, props) {\n        const marker = new Marker(refType);\n        if (props) {\n            marker.addProperties(props);\n        }\n        return marker;\n    }\n    toJSONObject() {\n        const obj = { marker: { refType: this.refType } };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    static fromJSONObject(spec) {\n        if (spec && typeof spec === \"object\" && \"marker\" in spec) {\n            return Marker.make(spec.marker.refType, spec.props);\n        }\n        return undefined;\n    }\n    clone() {\n        const b = Marker.make(this.refType, this.properties);\n        this.cloneInto(b);\n        return b;\n    }\n    getSegment() {\n        return this;\n    }\n    getOffset() {\n        return 0;\n    }\n    hasSimpleType(simpleTypeName) {\n        return !!this.properties &&\n            this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;\n    }\n    getProperties() {\n        return this.properties;\n    }\n    getId() {\n        if (this.properties && this.properties[reservedMarkerIdKey]) {\n            return this.properties[reservedMarkerIdKey];\n        }\n    }\n    /**\n     * @deprecated - use refHasTileLabels\n     */\n    hasTileLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabels)(this);\n    }\n    /**\n     * @deprecated - use refHasRangeLabels\n     */\n    hasRangeLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasRangeLabels)(this);\n    }\n    /**\n     * @deprecated - use refHasTileLabel\n     */\n    hasTileLabel(label) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabel)(this, label);\n    }\n    /**\n     * @deprecated - use refHasRangeLabel\n     */\n    hasRangeLabel(label) {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasRangeLabel)(this, label);\n    }\n    /**\n     * @deprecated - use refGetTileLabels\n     */\n    getTileLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(this);\n    }\n    /**\n     * @deprecated - use refGetRangeLabels\n     */\n    getRangeLabels() {\n        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(this);\n    }\n    toString() {\n        let bbuf = \"\";\n        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Tile)) {\n            bbuf += \"Tile\";\n        }\n        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin)) {\n            if (bbuf.length > 0) {\n                bbuf += \"; \";\n            }\n            bbuf += \"RangeBegin\";\n        }\n        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {\n            if (bbuf.length > 0) {\n                bbuf += \"; \";\n            }\n            bbuf += \"RangeEnd\";\n        }\n        let lbuf = \"\";\n        const id = this.getId();\n        if (id) {\n            bbuf += ` (${id}) `;\n        }\n        const tileLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(this);\n        if (tileLabels) {\n            lbuf += \"tile -- \";\n            for (let i = 0, len = tileLabels.length; i < len; i++) {\n                const tileLabel = tileLabels[i];\n                if (i > 0) {\n                    lbuf += \"; \";\n                }\n                lbuf += tileLabel;\n            }\n        }\n        const rangeLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(this);\n        if (rangeLabels) {\n            let rangeKind = \"begin\";\n            if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {\n                rangeKind = \"end\";\n            }\n            if (tileLabels) {\n                lbuf += \" \";\n            }\n            lbuf += `range ${rangeKind} -- `;\n            const labels = rangeLabels;\n            for (let i = 0, len = labels.length; i < len; i++) {\n                const rangeLabel = labels[i];\n                if (i > 0) {\n                    lbuf += \"; \";\n                }\n                lbuf += rangeLabel;\n            }\n        }\n        let pbuf = \"\";\n        if (this.properties) {\n            pbuf += JSON.stringify(this.properties, (key, value) => {\n                // Avoid circular reference when stringifying makers containing handles.\n                // (Substitute a debug string instead.)\n                const handle = !!value && value.IFluidHandle;\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return handle\n                    ? `#Handle(${handle.routeContext.path}/${handle.path})`\n                    : value;\n            });\n        }\n        return `M ${bbuf}: ${lbuf} ${pbuf}`;\n    }\n    createSplitSegmentAt(pos) {\n        return undefined;\n    }\n    canAppend(segment) {\n        return false;\n    }\n    append() { throw new Error(\"Can not append to marker\"); }\n}\nMarker.type = \"Marker\";\nvar IncrementalExecOp;\n(function (IncrementalExecOp) {\n    IncrementalExecOp[IncrementalExecOp[\"Go\"] = 0] = \"Go\";\n    IncrementalExecOp[IncrementalExecOp[\"Stop\"] = 1] = \"Stop\";\n    IncrementalExecOp[IncrementalExecOp[\"Yield\"] = 2] = \"Yield\";\n})(IncrementalExecOp || (IncrementalExecOp = {}));\nclass IncrementalMapState {\n    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {\n        this.block = block;\n        this.actions = actions;\n        this.pos = pos;\n        this.refSeq = refSeq;\n        this.clientId = clientId;\n        this.context = context;\n        this.start = start;\n        this.end = end;\n        this.childIndex = childIndex;\n        this.op = IncrementalExecOp.Go;\n    }\n}\nclass CollaborationWindow {\n    constructor() {\n        this.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId;\n        this.collaborating = false;\n        // Lowest-numbered segment in window; no client can reference a state before this one\n        this.minSeq = 0;\n        // Highest-numbered segment in window and current\n        // reference segment for this client\n        this.currentSeq = 0;\n        this.localSeq = 0;\n    }\n    loadFrom(a) {\n        this.clientId = a.clientId;\n        this.collaborating = a.collaborating;\n        this.minSeq = a.minSeq;\n        this.currentSeq = a.currentSeq;\n    }\n}\nconst compareNumbers = (a, b) => a - b;\nconst compareStrings = (a, b) => a.localeCompare(b);\nconst indentStrings = [\"\", \" \", \"  \"];\nfunction internedSpaces(n) {\n    if (indentStrings[n] === undefined) {\n        indentStrings[n] = \"\";\n        for (let i = 0; i < n; i++) {\n            indentStrings[n] += \" \";\n        }\n    }\n    return indentStrings[n];\n}\nconst clientSeqComparer = {\n    min: { refSeq: -1, clientId: \"\" },\n    compare: (a, b) => a.refSeq - b.refSeq,\n};\nconst LRUSegmentComparer = {\n    min: { maxSeq: -2 },\n    compare: (a, b) => a.maxSeq - b.maxSeq,\n};\nfunction applyLeafRangeMarker(marker, searchInfo) {\n    for (const rangeLabel of searchInfo.rangeLabels) {\n        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasRangeLabel)(marker, rangeLabel)) {\n            let currentStack = searchInfo.stacks[rangeLabel];\n            if (currentStack === undefined) {\n                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_3__.Stack();\n                searchInfo.stacks[rangeLabel] = currentStack;\n            }\n            applyRangeReference(currentStack, marker);\n        }\n    }\n}\nfunction recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n    if (Marker.is(segment)) {\n        if (segment.refType &\n            (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {\n            applyLeafRangeMarker(segment, searchInfo);\n        }\n    }\n    return false;\n}\nfunction rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n    var _a;\n    if (node.isLeaf()) {\n        const seg = node;\n        if ((((_a = searchInfo.mergeTree.localNetLength(seg)) !== null && _a !== void 0 ? _a : 0) > 0) && Marker.is(seg)) {\n            if (seg.refType &\n                (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {\n                applyLeafRangeMarker(seg, searchInfo);\n            }\n        }\n    }\n    else {\n        const block = node;\n        applyStackDelta(searchInfo.stacks, block.rangeStacks);\n    }\n    return true;\n}\nfunction recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n    if (Marker.is(segment)) {\n        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabel)(segment, searchInfo.tileLabel)) {\n            searchInfo.tile = segment;\n        }\n    }\n    return false;\n}\nfunction tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n    if (node.isLeaf()) {\n        const seg = node;\n        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {\n            if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabel)(seg, searchInfo.tileLabel)) {\n                searchInfo.tile = seg;\n            }\n        }\n    }\n    else {\n        const block = node;\n        let marker;\n        if (searchInfo.posPrecedesTile) {\n            marker = block.rightmostTiles[searchInfo.tileLabel];\n        }\n        else {\n            marker = block.leftmostTiles[searchInfo.tileLabel];\n        }\n        if (marker !== undefined) {\n            searchInfo.tile = marker;\n        }\n    }\n    return true;\n}\nconst minListenerComparer = {\n    min: { minRequired: Number.MIN_VALUE, onMinGE: () => { (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 0x048 /* \"onMinGE()\" */); } },\n    compare: (a, b) => a.minRequired - b.minRequired,\n};\n// Represents a sequence of text segments\nclass MergeTree {\n    // TODO: make and use interface describing options\n    constructor(options) {\n        this.options = options;\n        this.blockUpdateActions = MergeTree.initBlockUpdateActions;\n        this.collabWindow = new CollaborationWindow();\n        // TODO: add remove on segment remove\n        // for now assume only markers have ids and so point directly at the Segment\n        // if we need to have pointers to non-markers, we can change to point at local refs\n        this.idToSegment = new Map();\n        this.splitLeafSegment = (segment, pos) => {\n            if (!(pos > 0 && segment)) {\n                return {};\n            }\n            const next = segment.splitAt(pos);\n            if (this.mergeTreeMaintenanceCallback) {\n                this.mergeTreeMaintenanceCallback({\n                    operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.SPLIT,\n                    deltaSegments: [{ segment }, { segment: next }],\n                }, undefined);\n            }\n            return { next };\n        };\n        this.root = this.makeBlock(0);\n    }\n    makeBlock(childCount) {\n        const block = new HierMergeBlock(childCount);\n        block.ordinal = \"\";\n        return block;\n    }\n    clone() {\n        const b = new MergeTree(this.options);\n        // For now assume that b will not collaborate\n        b.root = b.blockClone(this.root);\n    }\n    blockClone(block, segments) {\n        const bBlock = this.makeBlock(block.childCount);\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (child.isLeaf()) {\n                const segment = this.segmentClone(child);\n                bBlock.assignChild(segment, i);\n                if (segments) {\n                    segments.push(segment);\n                }\n            }\n            else {\n                bBlock.assignChild(this.blockClone(child, segments), i);\n            }\n        }\n        this.nodeUpdateLengthNewStructure(bBlock);\n        this.nodeUpdateOrdinals(bBlock);\n        return bBlock;\n    }\n    segmentClone(segment) {\n        const b = segment.clone();\n        return b;\n    }\n    localNetLength(segment) {\n        const removalInfo = toRemovalInfo(segment);\n        if (removalInfo !== undefined) {\n            return 0;\n        }\n        else {\n            return segment.cachedLength;\n        }\n    }\n    // TODO: remove id when segment removed\n    mapIdToSegment(id, segment) {\n        this.idToSegment.set(id, segment);\n    }\n    addNode(block, node) {\n        const index = block.childCount++;\n        block.assignChild(node, index, false);\n        return index;\n    }\n    /* eslint-disable max-len */\n    reloadFromSegments(segments) {\n        // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.collabWindow.collaborating, 0x049 /* \"Trying to reload from segments while collaborating!\" */);\n        const maxChildren = MaxNodesInBlock - 1;\n        // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.\n        const buildMergeBlock = (nodes) => {\n            const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree\n            const blocks = new Array(blockCount); // Pre-alloc array to collect nodes\n            // For each block in this level of the B-Tree...\n            for (let nodeIndex = 0, blockIndex = 0; // Start with the first block and first node\n             blockIndex < blockCount; // If we have more blocks, we also have more nodes to insert\n             blockIndex++ // Advance to next block in this layer.\n            ) {\n                const block = blocks[blockIndex] = this.makeBlock(0);\n                // For each child of the current block, insert a node (while we have nodes left)\n                // and update the block's info.\n                for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length; // While we still have children & nodes left\n                 childIndex++, nodeIndex++ // Advance to next child & node\n                ) {\n                    // Insert the next node into the current block\n                    this.addNode(block, nodes[nodeIndex]);\n                }\n                // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,\n                // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the\n                // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.\n                this.blockUpdate(block);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return blocks.length === 1 // If there is only one block at this layer...\n                ? blocks[0] // ...then we're done.  Return the root.\n                : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.\n        };\n        if (segments.length > 0) {\n            this.root = buildMergeBlock(segments);\n            this.nodeUpdateOrdinals(this.root);\n        }\n        else {\n            this.root = this.makeBlock(0);\n        }\n    }\n    /* eslint-enable max-len */\n    // For now assume min starts at zero\n    startCollaboration(localClientId, minSeq, currentSeq) {\n        this.collabWindow.clientId = localClientId;\n        this.collabWindow.minSeq = minSeq;\n        this.collabWindow.collaborating = true;\n        this.collabWindow.currentSeq = currentSeq;\n        this.segmentsToScour = new _collections__WEBPACK_IMPORTED_MODULE_3__.Heap([], LRUSegmentComparer);\n        this.pendingSegments = (0,_collections__WEBPACK_IMPORTED_MODULE_3__.ListMakeHead)();\n        this.nodeUpdateLengthNewStructure(this.root, true);\n    }\n    addToLRUSet(segment, seq) {\n        // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),\n        // add the segment and mark the mark the node now.\n        // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed\n        //       segments from a snapshot.  We currently skip these for now.\n        if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {\n            segment.parent.needsScour = true;\n            this.segmentsToScour.add({ segment, maxSeq: seq });\n        }\n    }\n    underflow(node) {\n        return node.childCount < (MaxNodesInBlock / 2);\n    }\n    scourNode(node, holdNodes) {\n        let prevSegment;\n        for (let k = 0; k < node.childCount; k++) {\n            const childNode = node.children[k];\n            if (childNode.isLeaf()) {\n                const segment = childNode;\n                if (segment.segmentGroups.empty) {\n                    if (segment.removedSeq !== undefined) {\n                        if (segment.removedSeq > this.collabWindow.minSeq) {\n                            holdNodes.push(segment);\n                        }\n                        else if (!segment.trackingCollection.empty) {\n                            holdNodes.push(segment);\n                        }\n                        else {\n                            // Notify maintenance event observers that the segment is being unlinked from the MergeTree\n                            if (this.mergeTreeMaintenanceCallback) {\n                                this.mergeTreeMaintenanceCallback({\n                                    operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.UNLINK,\n                                    deltaSegments: [{ segment }],\n                                }, undefined);\n                            }\n                            segment.parent = undefined;\n                        }\n                        prevSegment = undefined;\n                    }\n                    else {\n                        if (segment.seq <= this.collabWindow.minSeq) {\n                            const canAppend = prevSegment\n                                && prevSegment.canAppend(segment)\n                                && (0,_properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties)(prevSegment.properties, segment.properties)\n                                && prevSegment.trackingCollection.matches(segment.trackingCollection)\n                                && this.localNetLength(segment) > 0;\n                            if (canAppend) {\n                                prevSegment.append(segment);\n                                if (this.mergeTreeMaintenanceCallback) {\n                                    this.mergeTreeMaintenanceCallback({\n                                        operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.APPEND,\n                                        deltaSegments: [{ segment: prevSegment }, { segment }],\n                                    }, undefined);\n                                }\n                                segment.parent = undefined;\n                                segment.trackingCollection.trackingGroups.forEach((tg) => tg.unlink(segment));\n                            }\n                            else {\n                                holdNodes.push(segment);\n                                if (this.localNetLength(segment) > 0) {\n                                    prevSegment = segment;\n                                }\n                                else {\n                                    prevSegment = undefined;\n                                }\n                            }\n                        }\n                        else {\n                            holdNodes.push(segment);\n                            prevSegment = undefined;\n                        }\n                    }\n                }\n                else {\n                    holdNodes.push(segment);\n                    prevSegment = undefined;\n                }\n            }\n            else {\n                holdNodes.push(childNode);\n                prevSegment = undefined;\n            }\n        }\n    }\n    // Interior node with all node children\n    packParent(parent) {\n        const children = parent.children;\n        let childIndex;\n        let childBlock;\n        const holdNodes = [];\n        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n            // Debug assert not isLeaf()\n            childBlock = children[childIndex];\n            this.scourNode(childBlock, holdNodes);\n            // Will replace this block with a packed block\n            childBlock.parent = undefined;\n        }\n        const totalNodeCount = holdNodes.length;\n        const halfCount = MaxNodesInBlock / 2;\n        let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));\n        if (childCount < 1) {\n            childCount = 1;\n        }\n        const baseCount = Math.floor(totalNodeCount / childCount);\n        let extraCount = totalNodeCount % childCount;\n        const packedBlocks = new Array(MaxNodesInBlock);\n        let readCount = 0;\n        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {\n            let nodeCount = baseCount;\n            if (extraCount > 0) {\n                nodeCount++;\n                extraCount--;\n            }\n            const packedBlock = this.makeBlock(nodeCount);\n            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {\n                const nodeToPack = holdNodes[readCount++];\n                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);\n            }\n            packedBlock.parent = parent;\n            packedBlocks[nodeIndex] = packedBlock;\n            this.nodeUpdateLengthNewStructure(packedBlock);\n        }\n        parent.children = packedBlocks;\n        for (let j = 0; j < childCount; j++) {\n            parent.assignChild(packedBlocks[j], j, false);\n        }\n        parent.childCount = childCount;\n        if (this.underflow(parent) && (parent.parent)) {\n            this.packParent(parent.parent);\n        }\n        else {\n            this.nodeUpdateOrdinals(parent);\n            this.blockUpdatePathLengths(parent, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, -1, true);\n        }\n    }\n    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {\n        if (!this.collabWindow.collaborating) {\n            return;\n        }\n        for (let i = 0; i < zamboniSegmentsMaxCount; i++) {\n            let segmentToScour = this.segmentsToScour.peek();\n            if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {\n                break;\n            }\n            segmentToScour = this.segmentsToScour.get();\n            // Only skip scouring if needs scour is explicitly false, not true or undefined\n            if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {\n                const block = segmentToScour.segment.parent;\n                const childrenCopy = [];\n                this.scourNode(block, childrenCopy);\n                // This will avoid the cost of re-scouring nodes\n                // that have recently been scoured\n                block.needsScour = false;\n                const newChildCount = childrenCopy.length;\n                if (newChildCount < block.childCount) {\n                    block.childCount = newChildCount;\n                    block.children = childrenCopy;\n                    for (let j = 0; j < newChildCount; j++) {\n                        block.assignChild(childrenCopy[j], j, false);\n                    }\n                    if (this.underflow(block) && block.parent) {\n                        this.packParent(block.parent);\n                    }\n                    else {\n                        this.nodeUpdateOrdinals(block);\n                        this.blockUpdatePathLengths(block, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, -1, true);\n                    }\n                }\n            }\n        }\n    }\n    getCollabWindow() {\n        return this.collabWindow;\n    }\n    getStats() {\n        const nodeGetStats = (block) => {\n            const stats = {\n                maxHeight: 0,\n                nodeCount: 0,\n                leafCount: 0,\n                removedLeafCount: 0,\n                liveCount: 0,\n                histo: [],\n            };\n            for (let k = 0; k < MaxNodesInBlock; k++) {\n                stats.histo[k] = 0;\n            }\n            for (let i = 0; i < block.childCount; i++) {\n                const child = block.children[i];\n                let height = 1;\n                if (!child.isLeaf()) {\n                    const childStats = nodeGetStats(child);\n                    height = 1 + childStats.maxHeight;\n                    stats.nodeCount += childStats.nodeCount;\n                    stats.leafCount += childStats.leafCount;\n                    stats.removedLeafCount += childStats.removedLeafCount;\n                    stats.liveCount += childStats.liveCount;\n                    for (let j = 0; j < MaxNodesInBlock; j++) {\n                        stats.histo[j] += childStats.histo[j];\n                    }\n                }\n                else {\n                    stats.leafCount++;\n                    const segment = child;\n                    if (segment.removedSeq !== undefined) {\n                        stats.removedLeafCount++;\n                    }\n                }\n                if (height > stats.maxHeight) {\n                    stats.maxHeight = height;\n                }\n            }\n            stats.histo[block.childCount]++;\n            stats.nodeCount++;\n            stats.liveCount += block.childCount;\n            return stats;\n        };\n        const rootStats = nodeGetStats(this.root);\n        return rootStats;\n    }\n    getLength(refSeq, clientId) {\n        return this.blockLength(this.root, refSeq, clientId);\n    }\n    /**\n     * Returns the current length of the MergeTree for the local client.\n     */\n    get length() { return this.root.cachedLength; }\n    getPosition(node, refSeq, clientId) {\n        var _a;\n        let totalOffset = 0;\n        let parent = node.parent;\n        let prevParent;\n        while (parent) {\n            const children = parent.children;\n            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {\n                const child = children[childIndex];\n                if ((prevParent && (child === prevParent)) || (child === node)) {\n                    break;\n                }\n                totalOffset += (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n            }\n            prevParent = parent;\n            parent = parent.parent;\n        }\n        return totalOffset;\n    }\n    getContainingSegment(pos, refSeq, clientId) {\n        let segment;\n        let offset;\n        const leaf = (leafSeg, segpos, _refSeq, _clientId, start) => {\n            segment = leafSeg;\n            offset = start;\n            return false;\n        };\n        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf }, undefined);\n        return { segment, offset };\n    }\n    /**\n     * @internal must only be used by client\n     * @param segoff - The segment and offset to slide from\n     * @returns The segment and offset to slide to\n     */\n    _getSlideToSegment(segoff) {\n        if (!segoff.segment || !isRemovedAndAcked(segoff.segment)) {\n            return segoff;\n        }\n        let slideToSegment;\n        const goFurtherToFindSlideToSegment = (seg) => {\n            if (seg.seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber && !isRemovedAndAcked(seg)) {\n                slideToSegment = seg;\n                return false;\n            }\n            return true;\n        };\n        // Slide to the next farthest valid segment in the tree.\n        this.rightExcursion(segoff.segment, goFurtherToFindSlideToSegment);\n        if (slideToSegment) {\n            return { segment: slideToSegment, offset: 0 };\n        }\n        // If no such segment is found, slide to the last valid segment.\n        this.leftExcursion(segoff.segment, goFurtherToFindSlideToSegment);\n        // Workaround TypeScript issue (https://github.com/microsoft/TypeScript/issues/9998)\n        slideToSegment = slideToSegment;\n        if (slideToSegment) {\n            // If slid nearer then offset should be at the end of the segment\n            return { segment: slideToSegment, offset: slideToSegment.cachedLength - 1 };\n        }\n        return { segment: undefined, offset: 0 };\n    }\n    /**\n     * This method should only be called when the current client sequence number is\n     * max(remove segment sequence number, add reference sequence number).\n     * Otherwise eventual consistency is not guaranteed.\n     * See `packages\\dds\\merge-tree\\REFERENCEPOSITIONS.md`\n     */\n    slideReferences(segment, refsToSlide) {\n        var _a, _b, _c, _d, _e;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(isRemovedAndAcked(segment), 0x2f1 /* slideReferences from a segment which has not been removed and acked */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!segment.localRefs, 0x2f2 /* Ref not in the segment localRefs */);\n        const newSegoff = this._getSlideToSegment({ segment, offset: 0 });\n        const newSegment = newSegoff.segment;\n        if (newSegment && !newSegment.localRefs) {\n            newSegment.localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReferenceCollection(newSegment);\n        }\n        for (const ref of refsToSlide) {\n            (_b = (_a = ref.callbacks) === null || _a === void 0 ? void 0 : _a.beforeSlide) === null || _b === void 0 ? void 0 : _b.call(_a);\n            const removedRef = segment.localRefs.removeLocalRef(ref);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(ref === removedRef, 0x2f3 /* Ref not in the segment localRefs */);\n            if (!newSegment) {\n                // No valid segments (all nodes removed or not yet created)\n                ref.segment = undefined;\n                ref.offset = 0;\n            }\n            else {\n                ref.segment = newSegment;\n                ref.offset = (_c = newSegoff.offset) !== null && _c !== void 0 ? _c : 0;\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!newSegment.localRefs, 0x2f4 /* localRefs must be allocated */);\n                newSegment.localRefs.addLocalRef(ref);\n            }\n            (_e = (_d = ref.callbacks) === null || _d === void 0 ? void 0 : _d.afterSlide) === null || _e === void 0 ? void 0 : _e.call(_d);\n        }\n        // TODO is it required to update the path lengths?\n        if (newSegment) {\n            this.blockUpdatePathLengths(newSegment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);\n        }\n    }\n    updateSegmentRefsAfterMarkRemoved(segment, pending) {\n        if (!segment.localRefs || segment.localRefs.empty) {\n            return;\n        }\n        const refsToSlide = [];\n        const refsToStay = [];\n        for (const lref of segment.localRefs) {\n            if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.StayOnRemove)) {\n                refsToStay.push(lref);\n            }\n            else if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.SlideOnRemove)) {\n                if (pending) {\n                    refsToStay.push(lref);\n                }\n                else {\n                    refsToSlide.push(lref);\n                }\n            }\n        }\n        // Rethink implementation of keeping and sliding refs once other reference\n        // changes are complete. This works but is fragile and possibly slow.\n        if (!pending) {\n            this.slideReferences(segment, refsToSlide);\n        }\n        segment.localRefs.clear();\n        for (const lref of refsToStay) {\n            lref.segment = segment;\n            segment.localRefs.addLocalRef(lref);\n        }\n    }\n    blockLength(node, refSeq, clientId) {\n        if ((this.collabWindow.collaborating) && (clientId !== this.collabWindow.clientId)) {\n            return node.partialLengths.getPartialLength(refSeq, clientId);\n        }\n        else {\n            return node.cachedLength;\n        }\n    }\n    nodeLength(node, refSeq, clientId) {\n        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId === clientId)) {\n            // Local client sees all segments, even when collaborating\n            if (!node.isLeaf()) {\n                return node.cachedLength;\n            }\n            else {\n                return this.localNetLength(node);\n            }\n        }\n        else {\n            // Sequence number within window\n            if (!node.isLeaf()) {\n                return node.partialLengths.getPartialLength(refSeq, clientId);\n            }\n            else {\n                const segment = node;\n                const removalInfo = toRemovalInfo(segment);\n                if (removalInfo !== undefined\n                    && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber\n                    && removalInfo.removedSeq <= refSeq) {\n                    // this segment is a tombstone eligible for zamboni\n                    // so should never be considered, as it may not exist\n                    // on other clients\n                    return undefined;\n                }\n                if (((segment.clientId === clientId) ||\n                    ((segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {\n                    // Segment happened by reference sequence number or segment from requesting client\n                    if (removalInfo !== undefined) {\n                        if (removalInfo.removedClientIds.includes(clientId)) {\n                            return 0;\n                        }\n                        else {\n                            return segment.cachedLength;\n                        }\n                    }\n                    else {\n                        return segment.cachedLength;\n                    }\n                }\n                else {\n                    // the segment was inserted and removed before the\n                    // this context, so it will never exist for this\n                    // context\n                    if (removalInfo !== undefined\n                        && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {\n                        return undefined;\n                    }\n                    // Segment invisible to client at reference sequence number/branch id/client id of op\n                    return 0;\n                }\n            }\n        }\n    }\n    addMinSeqListener(minRequired, onMinGE) {\n        if (!this.minSeqListeners) {\n            this.minSeqListeners = new _collections__WEBPACK_IMPORTED_MODULE_3__.Heap([], minListenerComparer);\n        }\n        this.minSeqListeners.add({ minRequired, onMinGE });\n    }\n    notifyMinSeqListeners() {\n        if (this.minSeqListeners) {\n            while ((this.minSeqListeners.count() > 0) &&\n                (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {\n                const minListener = this.minSeqListeners.get();\n                minListener.onMinGE(this.collabWindow.minSeq);\n            }\n        }\n    }\n    setMinSeq(minSeq) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(minSeq <= this.collabWindow.currentSeq, 0x04e);\n        // Only move forward\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.collabWindow.minSeq <= minSeq, 0x04f /* \"minSeq of collab window > target minSeq!\" */);\n        if (minSeq > this.collabWindow.minSeq) {\n            this.collabWindow.minSeq = minSeq;\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n            this.notifyMinSeqListeners();\n        }\n    }\n    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n        const seg = refPos.getSegment();\n        if (seg && seg.parent) {\n            const offset = !seg.removedSeq ? refPos.getOffset() : 0;\n            return offset + this.getPosition(seg, refSeq, clientId);\n        }\n        return _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReference.DetachedPosition;\n    }\n    getStackContext(startPos, clientId, rangeLabels) {\n        const searchInfo = {\n            mergeTree: this,\n            stacks: (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)(),\n            rangeLabels,\n        };\n        this.search(startPos, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);\n        return searchInfo.stacks;\n    }\n    // TODO: filter function\n    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {\n        const searchInfo = {\n            mergeTree: this,\n            posPrecedesTile,\n            tileLabel,\n        };\n        if (posPrecedesTile) {\n            this.search(startPos, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);\n        }\n        else {\n            this.backwardSearch(startPos, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);\n        }\n        if (searchInfo.tile) {\n            let pos;\n            if (searchInfo.tile.isLeaf()) {\n                const marker = searchInfo.tile;\n                pos = this.getPosition(marker, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId);\n            }\n            else {\n                const localRef = searchInfo.tile;\n                pos = localRef.toPosition();\n            }\n            return { tile: searchInfo.tile, pos };\n        }\n    }\n    search(pos, refSeq, clientId, actions, clientData) {\n        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);\n    }\n    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {\n        var _a;\n        let _pos = pos;\n        let _segpos = segpos;\n        const children = block.children;\n        if (actions && actions.pre) {\n            actions.pre(block, _segpos, refSeq, clientId, undefined, undefined, clientData);\n        }\n        const contains = actions && actions.contains;\n        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n            const child = children[childIndex];\n            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n            if ((!contains && _pos < len)\n                || (contains && contains(child, _pos, refSeq, clientId, undefined, undefined, clientData))) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    return this.searchBlock(child, _pos, _segpos, refSeq, clientId, actions, clientData);\n                }\n                else {\n                    if (actions && actions.leaf) {\n                        actions.leaf(child, _segpos, refSeq, clientId, _pos, -1, clientData);\n                    }\n                    return child;\n                }\n            }\n            else {\n                if (actions && actions.shift) {\n                    actions.shift(child, _segpos, refSeq, clientId, _pos, undefined, clientData);\n                }\n                _pos -= len;\n                _segpos += len;\n            }\n        }\n        if (actions && actions.post) {\n            actions.post(block, _segpos, refSeq, clientId, undefined, undefined, clientData);\n        }\n    }\n    backwardSearch(pos, refSeq, clientId, actions, clientData) {\n        const len = this.getLength(refSeq, clientId);\n        if (pos > len) {\n            return undefined;\n        }\n        return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);\n    }\n    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {\n        var _a;\n        let _segEnd = segEnd;\n        const children = block.children;\n        if (actions && actions.pre) {\n            actions.pre(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);\n        }\n        const contains = actions && actions.contains;\n        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n            const child = children[childIndex];\n            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n            const segpos = _segEnd - len;\n            if (((!contains) && (pos >= segpos)) ||\n                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    return this.backwardSearchBlock(child, pos, _segEnd, refSeq, clientId, actions, clientData);\n                }\n                else {\n                    if (actions && actions.leaf) {\n                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n                    }\n                    return child;\n                }\n            }\n            else {\n                if (actions && actions.shift) {\n                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n                }\n                _segEnd = segpos;\n            }\n        }\n        if (actions && actions.post) {\n            actions.post(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);\n        }\n    }\n    updateRoot(splitNode) {\n        if (splitNode !== undefined) {\n            const newRoot = this.makeBlock(2);\n            newRoot.assignChild(this.root, 0, false);\n            newRoot.assignChild(splitNode, 1, false);\n            this.root = newRoot;\n            this.nodeUpdateOrdinals(this.root);\n            this.nodeUpdateLengthNewStructure(this.root);\n        }\n    }\n    /**\n     * Assign sequence number to existing segment; update partial lengths to reflect the change\n     * @param seq - sequence number given by server to pending segment\n     */\n    ackPendingSegment(opArgs) {\n        const seq = opArgs.sequencedMessage.sequenceNumber;\n        const pendingSegmentGroup = this.pendingSegments.dequeue();\n        const nodesToUpdate = [];\n        let overwrite = false;\n        if (pendingSegmentGroup !== undefined) {\n            const deltaSegments = [];\n            pendingSegmentGroup.segments.map((pendingSegment) => {\n                const overlappingRemove = !pendingSegment.ack(pendingSegmentGroup, opArgs, this);\n                overwrite = overlappingRemove || overwrite;\n                if (!overlappingRemove && opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.REMOVE) {\n                    this.updateSegmentRefsAfterMarkRemoved(pendingSegment, false);\n                }\n                if (MergeTree.options.zamboniSegments) {\n                    this.addToLRUSet(pendingSegment, seq);\n                }\n                if (!nodesToUpdate.includes(pendingSegment.parent)) {\n                    nodesToUpdate.push(pendingSegment.parent);\n                }\n                deltaSegments.push({\n                    segment: pendingSegment,\n                });\n            });\n            if (this.mergeTreeMaintenanceCallback) {\n                this.mergeTreeMaintenanceCallback({\n                    deltaSegments,\n                    operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.ACKNOWLEDGED,\n                }, opArgs);\n            }\n            const clientId = this.collabWindow.clientId;\n            for (const node of nodesToUpdate) {\n                this.blockUpdatePathLengths(node, seq, clientId, overwrite);\n                // NodeUpdatePathLengths(node, seq, clientId, true);\n            }\n        }\n        if (MergeTree.options.zamboniSegments) {\n            this.zamboniSegments();\n        }\n    }\n    addToPendingList(segment, segmentGroup, localSeq) {\n        let _segmentGroup = segmentGroup;\n        if (_segmentGroup === undefined) {\n            // TODO: review the cast\n            _segmentGroup = { segments: [], localSeq };\n            this.pendingSegments.enqueue(_segmentGroup);\n        }\n        segment.segmentGroups.enqueue(_segmentGroup);\n        return _segmentGroup;\n    }\n    // TODO: error checking\n    getMarkerFromId(id) {\n        return this.idToSegment.get(id);\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     * @param refseq - The reference sequence number at which to compute the position.\n     * @param clientId - The client id with which to compute the position.\n     */\n    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n        let pos = -1;\n        let marker;\n        if (relativePos.id) {\n            marker = this.getMarkerFromId(relativePos.id);\n        }\n        if (marker) {\n            pos = this.getPosition(marker, refseq, clientId);\n            if (!relativePos.before) {\n                pos += marker.cachedLength;\n                if (relativePos.offset !== undefined) {\n                    pos += relativePos.offset;\n                }\n            }\n            else {\n                if (relativePos.offset !== undefined) {\n                    pos -= relativePos.offset;\n                }\n            }\n        }\n        return pos;\n    }\n    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {\n        this.ensureIntervalBoundary(pos, refSeq, clientId);\n        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n        this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments);\n        // opArgs == undefined => loading snapshot or test code\n        if (this.mergeTreeDeltaCallback && opArgs !== undefined) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.INSERT,\n                deltaSegments: segments.map((segment) => ({ segment })),\n            });\n        }\n        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&\n            (seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {\n            this.zamboniSegments();\n        }\n    }\n    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {\n        if (insertSegment.cachedLength === 0) {\n            return;\n        }\n        if (insertSegment.parent\n            || insertSegment.removedSeq\n            || insertSegment.seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber) {\n            throw new Error(\"Cannot insert segment that has already been inserted.\");\n        }\n        const rebalanceTree = (segment) => {\n            // Blocks should never be left full\n            // if the inserts makes the block full\n            // then we need to walk up the chain of parents\n            // and split the blocks until we find a block with\n            // room\n            let block = segment.parent;\n            let ordinalUpdateNode = block;\n            while (block !== undefined) {\n                if (block.childCount >= MaxNodesInBlock) {\n                    const splitNode = this.split(block);\n                    if (block === this.root) {\n                        this.updateRoot(splitNode);\n                        // Update root already updates all it's children ordinals\n                        ordinalUpdateNode = undefined;\n                    }\n                    else {\n                        this.insertChildNode(block.parent, splitNode, block.index + 1);\n                        ordinalUpdateNode = splitNode.parent;\n                        this.blockUpdateLength(block.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, clientId);\n                    }\n                }\n                else {\n                    this.blockUpdateLength(block, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, clientId);\n                }\n                block = block.parent;\n            }\n            // Only update ordinals once, for all children,\n            // on the path\n            if (ordinalUpdateNode) {\n                this.nodeUpdateOrdinals(ordinalUpdateNode);\n            }\n        };\n        const clientId = this.collabWindow.clientId;\n        const refSegment = referencePosition.getSegment();\n        const refOffset = referencePosition.getOffset();\n        const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);\n        let startSeg = refSegment;\n        // if the change isn't at a boundary, we need to split the segment\n        if (refOffset !== 0 && refSegLen !== undefined && refSegLen !== 0) {\n            const splitSeg = this.splitLeafSegment(refSegment, refOffset);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!splitSeg.next, 0x050 /* \"Next segment changes are undefined!\" */);\n            this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);\n            rebalanceTree(splitSeg.next);\n            startSeg = splitSeg.next;\n        }\n        // walk back from the segment, to see if there is a previous tie break seg\n        this.leftExcursion(startSeg, (backSeg) => {\n            if (!backSeg.isLeaf()) {\n                return true;\n            }\n            const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId);\n            // ignore removed segments\n            if (backLen === undefined) {\n                return true;\n            }\n            // Find the nearest 0 length seg we can insert over, as all other inserts\n            // go near to far\n            if (backLen === 0) {\n                if (this.breakTie(0, backSeg, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {\n                    startSeg = backSeg;\n                }\n                return true;\n            }\n            return false;\n        });\n        if (this.collabWindow.collaborating) {\n            insertSegment.localSeq = ++this.collabWindow.localSeq;\n            insertSegment.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber;\n        }\n        else {\n            insertSegment.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;\n        }\n        insertSegment.clientId = clientId;\n        if (Marker.is(insertSegment)) {\n            const markerId = insertSegment.getId();\n            if (markerId) {\n                this.mapIdToSegment(markerId, insertSegment);\n            }\n        }\n        this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);\n        rebalanceTree(insertSegment);\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                deltaSegments: [{ segment: insertSegment }],\n                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.INSERT,\n            });\n        }\n        if (this.collabWindow.collaborating) {\n            this.addToPendingList(insertSegment, undefined, insertSegment.localSeq);\n        }\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence. The client ref seq must be above the minimum sequence number\n     * or the return value will be undefined.\n     * Generally this method is used in conjunction with signals which provide\n     * point in time values for the below parameters, and is useful for things\n     * like displaying user position. It should not be used with persisted values\n     * as persisted values will quickly become invalid as the remoteClientRefSeq\n     * moves below the minimum sequence number\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n        if (remoteClientRefSeq < this.collabWindow.minSeq) {\n            return undefined;\n        }\n        const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n        const segwindow = this.getCollabWindow();\n        if (segmentInfo && segmentInfo.segment) {\n            const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);\n            return segmentPosition + segmentInfo.offset;\n        }\n        else {\n            if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {\n                return this.getLength(segwindow.currentSeq, segwindow.clientId);\n            }\n        }\n    }\n    insertChildNode(block, child, childIndex) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(block.childCount < MaxNodesInBlock, 0x051 /* \"Too many children on merge block!\" */);\n        for (let i = block.childCount; i > childIndex; i--) {\n            block.children[i] = block.children[i - 1];\n            block.children[i].index = i;\n        }\n        block.childCount++;\n        block.assignChild(child, childIndex, false);\n    }\n    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {\n        let segIsLocal = false;\n        const checkSegmentIsLocal = (segment) => {\n            if (segment.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {\n                segIsLocal = true;\n            }\n            // Only need to look at first segment that follows finished node\n            return false;\n        };\n        const continueFrom = (node) => {\n            segIsLocal = false;\n            this.rightExcursion(node, checkSegmentIsLocal);\n            return segIsLocal;\n        };\n        let segmentGroup;\n        const saveIfLocal = (locSegment) => {\n            // Save segment so can assign sequence number when acked by server\n            if (this.collabWindow.collaborating) {\n                if ((locSegment.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {\n                    segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq);\n                    // eslint-disable-next-line @typescript-eslint/brace-style\n                }\n                // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()\n                // In all other cases this has to be true (checked by addToLRUSet):\n                // locSegment.seq > this.collabWindow.currentSeq\n                else if ((locSegment.seq > this.collabWindow.minSeq) &&\n                    MergeTree.options.zamboniSegments) {\n                    this.addToLRUSet(locSegment, locSegment.seq);\n                }\n            }\n        };\n        const onLeaf = (segment, _pos, context) => {\n            const segmentChanges = {};\n            if (segment) {\n                // Insert before segment\n                segmentChanges.replaceCurrent = context.candidateSegment;\n                segmentChanges.next = segment;\n            }\n            else {\n                segmentChanges.next = context.candidateSegment;\n            }\n            return segmentChanges;\n        };\n        // TODO: build tree from segs and insert all at once\n        let insertPos = pos;\n        for (const newSegment of newSegments) {\n            segIsLocal = false;\n            if (newSegment.cachedLength > 0) {\n                newSegment.seq = seq;\n                newSegment.localSeq = localSeq;\n                newSegment.clientId = clientId;\n                if (Marker.is(newSegment)) {\n                    const markerId = newSegment.getId();\n                    if (markerId) {\n                        this.mapIdToSegment(markerId, newSegment);\n                    }\n                }\n                const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });\n                if (newSegment.parent === undefined) {\n                    throw new Error(`MergeTree insert failed: ${JSON.stringify({\n                        currentSeq: this.collabWindow.currentSeq,\n                        minSeq: this.collabWindow.minSeq,\n                        segSeq: newSegment.seq,\n                    })}`);\n                }\n                this.updateRoot(splitNode);\n                saveIfLocal(newSegment);\n                insertPos += newSegment.cachedLength;\n            }\n        }\n    }\n    ensureIntervalBoundary(pos, refSeq, clientId) {\n        const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, { leaf: this.splitLeafSegment });\n        this.updateRoot(splitNode);\n    }\n    // Assume called only when pos == len\n    breakTie(pos, node, seq) {\n        var _a;\n        if (node.isLeaf()) {\n            if (pos === 0) {\n                // normalize the seq numbers\n                // if the new seg is local (UnassignedSequenceNumber) give it the highest possible\n                // seq for comparison, as it will get a seq higher than any other seq once sequences\n                // if the current seg is local (UnassignedSequenceNumber) give it the second highest\n                // possible seq, as the highest is reserved for the previous.\n                const newSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER : seq;\n                const segSeq = node.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER - 1 : (_a = node.seq) !== null && _a !== void 0 ? _a : 0;\n                return newSeq > segSeq;\n            }\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    // Visit segments starting from node's left siblings, then up to node's parent\n    leftExcursion(node, leafAction) {\n        let go = true;\n        let startNode = node;\n        let parent = startNode.parent;\n        while (parent) {\n            const children = parent.children;\n            let childIndex;\n            let _node;\n            let matchedStart = false;\n            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {\n                _node = children[childIndex];\n                if (matchedStart) {\n                    if (!_node.isLeaf()) {\n                        const childBlock = _node;\n                        go = this.nodeMapReverse(childBlock, leafAction, 0, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, this.collabWindow.clientId);\n                    }\n                    else {\n                        go = leafAction(_node, 0, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);\n                    }\n                    if (!go) {\n                        return;\n                    }\n                }\n                else {\n                    matchedStart = (startNode === _node);\n                }\n            }\n            startNode = parent;\n            parent = parent.parent;\n        }\n    }\n    /**\n     * Visit segments starting from node's right siblings, then up to node's parent.\n     * All segments past `node` are visited, regardless of their visibility.\n     */\n    rightExcursion(node, leafAction) {\n        let go = true;\n        let startNode = node;\n        let parent = startNode.parent;\n        while (parent) {\n            const children = parent.children;\n            let childIndex;\n            let _node;\n            let matchedStart = false;\n            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n                _node = children[childIndex];\n                if (matchedStart) {\n                    if (!_node.isLeaf()) {\n                        const childBlock = _node;\n                        go = this.walkAllSegments(childBlock, leafAction);\n                    }\n                    else {\n                        go = leafAction(_node);\n                    }\n                    if (!go) {\n                        return;\n                    }\n                }\n                else {\n                    matchedStart = (startNode === _node);\n                }\n            }\n            startNode = parent;\n            parent = parent.parent;\n        }\n    }\n    insertingWalk(block, pos, refSeq, clientId, seq, context) {\n        let _pos = pos;\n        const children = block.children;\n        let childIndex;\n        let child;\n        let newNode;\n        let fromSplit;\n        for (childIndex = 0; childIndex < block.childCount; childIndex++) {\n            child = children[childIndex];\n            const len = this.nodeLength(child, refSeq, clientId);\n            if (len === undefined) {\n                // if the seg len in undefined, the segment\n                // will be removed, so should just be skipped for now\n                continue;\n            }\n            if ((_pos < len) || ((_pos === len) && this.breakTie(_pos, child, seq))) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    const childBlock = child;\n                    // Internal node\n                    const splitNode = this.insertingWalk(childBlock, _pos, refSeq, clientId, seq, context);\n                    if (splitNode === undefined) {\n                        if (context.structureChange) {\n                            this.nodeUpdateLengthNewStructure(block);\n                        }\n                        else {\n                            this.blockUpdateLength(block, seq, clientId);\n                        }\n                        return undefined;\n                    }\n                    else if (splitNode === MergeTree.theUnfinishedNode) {\n                        _pos -= len; // Act as if shifted segment\n                        continue;\n                    }\n                    else {\n                        newNode = splitNode;\n                        fromSplit = splitNode;\n                        childIndex++; // Insert after\n                    }\n                }\n                else {\n                    const segment = child;\n                    const segmentChanges = context.leaf(segment, _pos, context);\n                    if (segmentChanges.replaceCurrent) {\n                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);\n                        segmentChanges.replaceCurrent.ordinal = child.ordinal;\n                    }\n                    if (segmentChanges.next) {\n                        newNode = segmentChanges.next;\n                        childIndex++; // Insert after\n                    }\n                    else {\n                        // No change\n                        if (context.structureChange) {\n                            this.nodeUpdateLengthNewStructure(block);\n                        }\n                        return undefined;\n                    }\n                }\n                break;\n            }\n            else {\n                _pos -= len;\n            }\n        }\n        if (!newNode) {\n            if (_pos === 0) {\n                if ((seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) && context.continuePredicate &&\n                    context.continuePredicate(block)) {\n                    return MergeTree.theUnfinishedNode;\n                }\n                else {\n                    const segmentChanges = context.leaf(undefined, _pos, context);\n                    newNode = segmentChanges.next;\n                    // Assert segmentChanges.replaceCurrent === undefined\n                }\n            }\n        }\n        if (newNode) {\n            for (let i = block.childCount; i > childIndex; i--) {\n                block.children[i] = block.children[i - 1];\n                block.children[i].index = i;\n            }\n            block.assignChild(newNode, childIndex, false);\n            block.childCount++;\n            block.setOrdinal(newNode, childIndex);\n            if (block.childCount < MaxNodesInBlock) {\n                if (fromSplit) {\n                    this.nodeUpdateOrdinals(fromSplit);\n                }\n                if (context.structureChange) {\n                    this.nodeUpdateLengthNewStructure(block);\n                }\n                else {\n                    this.blockUpdateLength(block, seq, clientId);\n                }\n                return undefined;\n            }\n            else {\n                // Don't update ordinals because higher block will do it\n                return this.split(block);\n            }\n        }\n        else {\n            return undefined;\n        }\n    }\n    split(node) {\n        const halfCount = MaxNodesInBlock / 2;\n        const newNode = this.makeBlock(halfCount);\n        node.childCount = halfCount;\n        // Update ordinals to reflect lowered child count\n        this.nodeUpdateOrdinals(node);\n        for (let i = 0; i < halfCount; i++) {\n            newNode.assignChild(node.children[halfCount + i], i, false);\n            node.children[halfCount + i] = undefined;\n        }\n        this.nodeUpdateLengthNewStructure(node);\n        this.nodeUpdateLengthNewStructure(newNode);\n        return newNode;\n    }\n    nodeUpdateOrdinals(block) {\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            block.setOrdinal(child, i);\n            if (!child.isLeaf()) {\n                this.nodeUpdateOrdinals(child);\n            }\n        }\n    }\n    /**\n     * Annotate a range with properties\n     * @param start - The inclusive start position of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @param refSeq - The reference sequence number to use to apply the annotate\n     * @param clientId - The id of the client making the annotate\n     * @param seq - The sequence number of the annotate operation\n     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one\n     */\n    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {\n        this.ensureIntervalBoundary(start, refSeq, clientId);\n        this.ensureIntervalBoundary(end, refSeq, clientId);\n        const deltaSegments = [];\n        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n        let segmentGroup;\n        const annotateSegment = (segment) => {\n            const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);\n            deltaSegments.push({ segment, propertyDeltas });\n            if (this.collabWindow.collaborating) {\n                if (seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {\n                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n                }\n                else {\n                    if (MergeTree.options.zamboniSegments) {\n                        this.addToLRUSet(segment, seq);\n                    }\n                }\n            }\n            return true;\n        };\n        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);\n        // OpArgs == undefined => test code\n        if (this.mergeTreeDeltaCallback && deltaSegments.length > 0) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.ANNOTATE,\n                deltaSegments,\n            });\n        }\n        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n        }\n    }\n    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {\n        let _overwrite = overwrite;\n        this.ensureIntervalBoundary(start, refSeq, clientId);\n        this.ensureIntervalBoundary(end, refSeq, clientId);\n        let segmentGroup;\n        const removedSegments = [];\n        const segmentsWithRefs = [];\n        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n        const markRemoved = (segment, pos, _start, _end) => {\n            const existingRemovalInfo = toRemovalInfo(segment);\n            if (existingRemovalInfo !== undefined) {\n                _overwrite = true;\n                if (existingRemovalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {\n                    // we removed this locally, but someone else removed it first\n                    // so put them at the head of the list\n                    // the list isn't ordered, but we\n                    // keep first removal at the head.\n                    existingRemovalInfo.removedClientIds.unshift(clientId);\n                    existingRemovalInfo.removedSeq = seq;\n                    segment.localRemovedSeq = undefined;\n                }\n                else {\n                    // Do not replace earlier sequence number for remove\n                    existingRemovalInfo.removedClientIds.push(clientId);\n                }\n            }\n            else {\n                segment.removedClientIds = [clientId];\n                segment.removedSeq = seq;\n                segment.localRemovedSeq = localSeq;\n                removedSegments.push({ segment });\n            }\n            if (segment.localRefs && !segment.localRefs.empty) {\n                segmentsWithRefs.push(segment);\n            }\n            // Save segment so can assign removed sequence number when acked by server\n            if (this.collabWindow.collaborating) {\n                if (segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {\n                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n                }\n                else {\n                    if (MergeTree.options.zamboniSegments) {\n                        this.addToLRUSet(segment, seq);\n                    }\n                }\n            }\n            return true;\n        };\n        const afterMarkRemoved = (node, pos, _start, _end) => {\n            if (_overwrite) {\n                this.nodeUpdateLengthNewStructure(node);\n            }\n            else {\n                this.blockUpdateLength(node, seq, clientId);\n            }\n            return true;\n        };\n        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);\n        const pending = this.collabWindow.collaborating && clientId === this.collabWindow.clientId;\n        for (const segment of segmentsWithRefs) {\n            this.updateSegmentRefsAfterMarkRemoved(segment, pending);\n        }\n        // opArgs == undefined => test code\n        if (this.mergeTreeDeltaCallback && removedSegments.length > 0) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.REMOVE,\n                deltaSegments: removedSegments,\n            });\n        }\n        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n        }\n    }\n    nodeUpdateLengthNewStructure(node, recur = false) {\n        this.blockUpdate(node);\n        if (this.collabWindow.collaborating) {\n            node.partialLengths = _partialLengths__WEBPACK_IMPORTED_MODULE_11__.PartialSequenceLengths.combine(this, node, this.collabWindow, recur);\n        }\n    }\n    removeLocalReferencePosition(lref) {\n        var _a;\n        const segment = lref.getSegment();\n        if (segment) {\n            const removedRefs = (_a = segment === null || segment === void 0 ? void 0 : segment.localRefs) === null || _a === void 0 ? void 0 : _a.removeLocalRef(lref);\n            if (removedRefs !== undefined) {\n                this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);\n            }\n            return removedRefs;\n        }\n    }\n    createLocalReferencePosition(segment, offset, refType, properties, client) {\n        var _a;\n        if (isRemoved(segment)) {\n            if (!(0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.SlideOnRemove | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Transient)) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_12__.UsageError(\"Can only create SlideOnRemove or Transient local reference position on a removed segment\");\n            }\n        }\n        const localRefs = (_a = segment.localRefs) !== null && _a !== void 0 ? _a : new _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReferenceCollection(segment);\n        segment.localRefs = localRefs;\n        const segRef = localRefs.createLocalRef(offset, refType, properties, client);\n        this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);\n        return segRef;\n    }\n    /**\n     * @deprecated - use removeLocalReferencePosition\n     */\n    removeLocalReference(segment, lref) {\n        if (segment.localRefs) {\n            const removedRef = segment.localRefs.removeLocalRef(lref);\n            if (removedRef) {\n                this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);\n            }\n        }\n    }\n    /**\n     * @deprecated - use createLocalReference\n     */\n    addLocalReference(lref) {\n        const segment = lref.segment;\n        let localRefs = segment.localRefs;\n        if (!localRefs) {\n            localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReferenceCollection(segment);\n            segment.localRefs = localRefs;\n        }\n        localRefs.addLocalRef(lref);\n        this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);\n    }\n    blockUpdate(block) {\n        var _a;\n        let len = 0;\n        const hierBlock = block.hierBlock();\n        if (hierBlock) {\n            hierBlock.rightmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();\n            hierBlock.leftmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();\n            hierBlock.rangeStacks = {};\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            len += (_a = nodeTotalLength(this, child)) !== null && _a !== void 0 ? _a : 0;\n            if (hierBlock) {\n                hierBlock.addNodeReferences(this, child);\n            }\n            if (this.blockUpdateActions) {\n                this.blockUpdateActions.child(block, i);\n            }\n        }\n        block.cachedLength = len;\n    }\n    blockUpdatePathLengths(startBlock, seq, clientId, newStructure = false) {\n        let block = startBlock;\n        while (block !== undefined) {\n            if (newStructure) {\n                this.nodeUpdateLengthNewStructure(block);\n            }\n            else {\n                this.blockUpdateLength(block, seq, clientId);\n            }\n            block = block.parent;\n        }\n    }\n    blockUpdateLength(node, seq, clientId) {\n        this.blockUpdate(node);\n        if (this.collabWindow.collaborating\n            && seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber\n            && seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber) {\n            if (node.partialLengths !== undefined\n                && MergeTree.options.incrementalUpdate\n                && clientId !== _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient) {\n                node.partialLengths.update(this, node, seq, clientId, this.collabWindow);\n            }\n            else {\n                node.partialLengths = _partialLengths__WEBPACK_IMPORTED_MODULE_11__.PartialSequenceLengths.combine(this, node, this.collabWindow);\n            }\n        }\n    }\n    map(actions, refSeq, clientId, accum) {\n        // TODO: optimize to avoid comparisons\n        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);\n    }\n    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {\n        if (splitRange) {\n            if (start) {\n                this.ensureIntervalBoundary(start, refSeq, clientId);\n            }\n            if (end) {\n                this.ensureIntervalBoundary(end, refSeq, clientId);\n            }\n        }\n        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);\n    }\n    incrementalBlockMap(stateStack) {\n        var _a;\n        while (!stateStack.empty()) {\n            // We already check the stack is not empty\n            const state = stateStack.top();\n            if (state.op !== IncrementalExecOp.Go) {\n                return;\n            }\n            if (state.childIndex === 0) {\n                if (state.start === undefined) {\n                    state.start = 0;\n                }\n                if (state.end === undefined) {\n                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);\n                }\n                if (state.actions.pre) {\n                    state.actions.pre(state);\n                }\n            }\n            if ((state.op === IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {\n                const child = state.block.children[state.childIndex];\n                const len = (_a = this.nodeLength(child, state.refSeq, state.clientId)) !== null && _a !== void 0 ? _a : 0;\n                if ((len > 0) && (state.start < len) && (state.end > 0)) {\n                    if (!child.isLeaf()) {\n                        const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);\n                        stateStack.push(childState);\n                    }\n                    else {\n                        state.actions.leaf(child, state);\n                    }\n                }\n                state.pos += len;\n                state.start -= len;\n                state.end -= len;\n                state.childIndex++;\n            }\n            else {\n                if (state.childIndex === state.block.childCount) {\n                    if ((state.op === IncrementalExecOp.Go) && state.actions.post) {\n                        state.actions.post(state);\n                    }\n                    stateStack.pop();\n                }\n            }\n        }\n    }\n    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {\n        var _a;\n        let _start = start;\n        let _end = end;\n        let _pos = pos;\n        if (_start === undefined) {\n            _start = 0;\n        }\n        if (_end === undefined) {\n            _end = this.blockLength(node, refSeq, clientId);\n        }\n        let go = true;\n        if (actions.pre) {\n            go = actions.pre(node, _pos, refSeq, clientId, _start, _end, accum);\n            if (!go) {\n                // Cancel this node but not entire traversal\n                return true;\n            }\n        }\n        const children = node.children;\n        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {\n            const child = children[childIndex];\n            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n            if (go && (_end > 0) && (len > 0) && (_start < len)) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    if (go) {\n                        go = this.nodeMap(child, actions, _pos, refSeq, clientId, accum, _start, _end);\n                    }\n                }\n                else {\n                    if (actions.leaf) {\n                        go = actions.leaf(child, _pos, refSeq, clientId, _start, _end, accum);\n                    }\n                }\n            }\n            if (!go) {\n                break;\n            }\n            if (actions.shift) {\n                actions.shift(child, _pos, refSeq, clientId, _start, _end, accum);\n            }\n            _pos += len;\n            _start -= len;\n            _end -= len;\n        }\n        if (go && actions.post) {\n            go = actions.post(node, _pos, refSeq, clientId, _start, _end, accum);\n        }\n        return go;\n    }\n    // Invokes the leaf action for all segments.  Note that *all* segments are visited\n    // regardless of if they would be visible to the current `clientId` and `refSeq`.\n    walkAllSegments(block, action, accum) {\n        let go = true;\n        const children = block.children;\n        for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {\n            const child = children[childIndex];\n            go = child.isLeaf()\n                ? action(child, accum)\n                : this.walkAllSegments(child, action, accum);\n        }\n        return go;\n    }\n    // Straight call every segment; goes until leaf action returns false\n    nodeMapReverse(block, leafAction, pos, refSeq, clientId) {\n        let go = true;\n        const children = block.children;\n        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n            const child = children[childIndex];\n            if (go) {\n                // Found entry containing pos\n                if (!child.isLeaf()) {\n                    if (go) {\n                        go = this.nodeMapReverse(child, leafAction, pos, refSeq, clientId);\n                    }\n                }\n                else {\n                    go = leafAction(child, pos, refSeq, clientId, 0, 0, undefined);\n                }\n            }\n            if (!go) {\n                break;\n            }\n        }\n        return go;\n    }\n}\nMergeTree.zamboniSegmentsMaxCount = 2;\nMergeTree.options = {\n    incrementalUpdate: true,\n    insertAfterRemovedSegs: true,\n    zamboniSegments: true,\n};\nMergeTree.theUnfinishedNode = { childCount: -1 };\n//# sourceMappingURL=mergeTree.js.map\n\n/***/ }),\n/* 295 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SegmentGroupCollection\": () => (/* binding */ SegmentGroupCollection)\n/* harmony export */ });\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass SegmentGroupCollection {\n    constructor(segment) {\n        this.segment = segment;\n        this.segmentGroups = (0,_collections__WEBPACK_IMPORTED_MODULE_0__.ListMakeHead)();\n    }\n    get size() {\n        return this.segmentGroups.count();\n    }\n    get empty() {\n        return this.segmentGroups.empty();\n    }\n    enqueue(segmentGroup) {\n        this.segmentGroups.enqueue(segmentGroup);\n        segmentGroup.segments.push(this.segment);\n    }\n    dequeue() {\n        return this.segmentGroups.dequeue();\n    }\n    clear() {\n        this.segmentGroups.clear();\n    }\n    copyTo(segment) {\n        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));\n    }\n}\n//# sourceMappingURL=segmentGroupCollection.js.map\n\n/***/ }),\n/* 296 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TrackingGroup\": () => (/* binding */ TrackingGroup),\n/* harmony export */   \"TrackingGroupCollection\": () => (/* binding */ TrackingGroupCollection)\n/* harmony export */ });\n/* harmony import */ var _sortedSegmentSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(297);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass TrackingGroup {\n    constructor() {\n        this.segmentSet = new _sortedSegmentSet__WEBPACK_IMPORTED_MODULE_0__.SortedSegmentSet();\n    }\n    get segments() {\n        return this.segmentSet.items;\n    }\n    get size() {\n        return this.segmentSet.size;\n    }\n    has(segment) {\n        return this.segmentSet.has(segment);\n    }\n    link(segment) {\n        if (!this.segmentSet.has(segment)) {\n            this.segmentSet.addOrUpdate(segment);\n            segment.trackingCollection.link(this);\n        }\n    }\n    unlink(segment) {\n        if (this.segmentSet.remove(segment)) {\n            segment.trackingCollection.unlink(this);\n        }\n    }\n}\nclass TrackingGroupCollection {\n    constructor(segment) {\n        this.segment = segment;\n        this.trackingGroups = new Set();\n    }\n    link(trackingGroup) {\n        if (trackingGroup) {\n            if (!this.trackingGroups.has(trackingGroup)) {\n                this.trackingGroups.add(trackingGroup);\n            }\n            if (!trackingGroup.has(this.segment)) {\n                trackingGroup.link(this.segment);\n            }\n        }\n    }\n    unlink(trackingGroup) {\n        if (trackingGroup.has(this.segment)) {\n            trackingGroup.unlink(this.segment);\n        }\n        this.trackingGroups.delete(trackingGroup);\n    }\n    copyTo(segment) {\n        this.trackingGroups.forEach((sg) => segment.trackingCollection.link(sg));\n    }\n    get empty() {\n        return this.trackingGroups.size === 0;\n    }\n    matches(trackingCollection) {\n        if (!trackingCollection\n            || this.trackingGroups.size !== trackingCollection.trackingGroups.size) {\n            return false;\n        }\n        for (const tg of this.trackingGroups.values()) {\n            if (!trackingCollection.trackingGroups.has(tg)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=mergeTreeTracking.js.map\n\n/***/ }),\n/* 297 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SortedSegmentSet\": () => (/* binding */ SortedSegmentSet)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Stores a unique and sorted set of segments, or objects with segments\n *\n * This differs from a normal sorted set in that the keys are not fixed.\n * The segments are sorted via their ordinals which can change as the merge tree is modified.\n * Even though the values of the ordinals can change their ordering and uniqueness cannot, so the order of a set of\n * segments ordered by their ordinals will always have the same order even if the ordinal values on\n * the segments changes. This invariant allows ensure the segments stay ordered and unique, and that new segments\n * can be inserted into that order.\n */\nclass SortedSegmentSet {\n    constructor() {\n        this.ordinalSortedItems = [];\n    }\n    get size() {\n        return this.ordinalSortedItems.length;\n    }\n    get items() {\n        return this.ordinalSortedItems;\n    }\n    addOrUpdate(newItem, update) {\n        const position = this.findOrdinalPosition(this.getOrdinal(newItem));\n        if (position.exists) {\n            if (update) {\n                update(this.ordinalSortedItems[position.index], newItem);\n            }\n        }\n        else {\n            this.ordinalSortedItems.splice(position.index, 0, newItem);\n        }\n    }\n    remove(item) {\n        const position = this.findOrdinalPosition(this.getOrdinal(item));\n        if (position.exists) {\n            this.ordinalSortedItems.splice(position.index, 1);\n            return true;\n        }\n        return false;\n    }\n    has(item) {\n        const position = this.findOrdinalPosition(this.getOrdinal(item));\n        return position.exists;\n    }\n    getOrdinal(item) {\n        const maybeObject = item;\n        if (maybeObject === null || maybeObject === void 0 ? void 0 : maybeObject.segment) {\n            return maybeObject.segment.ordinal;\n        }\n        const maybeSegment = item;\n        return maybeSegment.ordinal;\n    }\n    findOrdinalPosition(ordinal, start, end) {\n        if (this.ordinalSortedItems.length === 0) {\n            return { exists: false, index: 0 };\n        }\n        if (start === undefined || end === undefined) {\n            return this.findOrdinalPosition(ordinal, 0, this.ordinalSortedItems.length - 1);\n        }\n        const index = start + Math.floor((end - start) / 2);\n        if (this.getOrdinal(this.ordinalSortedItems[index]) > ordinal) {\n            if (start === index) {\n                return { exists: false, index };\n            }\n            return this.findOrdinalPosition(ordinal, start, index - 1);\n        }\n        else if (this.getOrdinal(this.ordinalSortedItems[index]) < ordinal) {\n            if (index === end) {\n                return { exists: false, index: index + 1 };\n            }\n            return this.findOrdinalPosition(ordinal, index + 1, end);\n        }\n        return { exists: true, index };\n    }\n}\n//# sourceMappingURL=sortedSegmentSet.js.map\n\n/***/ }),\n/* 298 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MergeTreeMaintenanceType\": () => (/* binding */ MergeTreeMaintenanceType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Enum-like constant defining the types of \"maintenance\" events on a merge tree.\n * Maintenance events correspond to structural segment changes or acks of pending segments.\n *\n * Note: these values are assigned negative integers to avoid clashing with `MergeTreeDeltaType`.\n */\nconst MergeTreeMaintenanceType = {\n    /**\n     * Notification that a segment \"append\" has occurred, i.e. two adjacent segments have been merged.\n     * BEWARE: `deltaSegments` on the corresponding event will contain both the merged segment and the latter\n     * segment, pre-merge.\n     * For example, if the merge tree originally had two adjacent segments [A][B] and called A.append(B) to get\n     * segment [AB], `deltaSegments` would contain [AB] and [B].\n     */\n    APPEND: -1,\n    /**\n     * Notification that a segment has been split in two.\n     * `deltaSegments` on the corresponding event will contain the resulting two segments.\n     */\n    SPLIT: -2,\n    /**\n     * Notification that a segment has been unlinked (i.e. removed) from the MergeTree.\n     * This occurs on leaf segments during Zamboni when the segment's tracking collection is empty\n     * (e.g., not being tracked for undo/redo).\n     * It also occurs on internal merge tree segments when re-packing children to maintain tree balancing invariants.\n     */\n    UNLINK: -3,\n    /**\n     * Notification that a local change has been acknowledged by the server.\n     * This means that it has made the round trip to the server and has had a sequence number assigned.\n     */\n    ACKNOWLEDGED: -4,\n};\n//# sourceMappingURL=mergeTreeDeltaCallback.js.map\n\n/***/ }),\n/* 299 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PartialSequenceLengths\": () => (/* binding */ PartialSequenceLengths)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(283);\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(285);\n/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n/**\n * Returns the partial length whose sequence number is\n * the greatest sequence number within a that is\n * less than or equal to key.\n * @param a - array of partial segment lengths\n * @param key - sequence number\n */\nfunction latestLEQ(a, key) {\n    let best = -1;\n    let lo = 0;\n    let hi = a.length - 1;\n    while (lo <= hi) {\n        const mid = lo + Math.floor((hi - lo) / 2);\n        if (a[mid].seq <= key) {\n            if ((best < 0) || (a[best].seq < a[mid].seq)) {\n                best = mid;\n            }\n            lo = mid + 1;\n        }\n        else {\n            hi = mid - 1;\n        }\n    }\n    return best;\n}\n/**\n * Keep track of partial sums of segment lengths for all sequence numbers\n * in the current collaboration window (if any).  Only used during active\n * collaboration.\n */\nclass PartialSequenceLengths {\n    constructor(minSeq) {\n        this.minSeq = minSeq;\n        this.minLength = 0;\n        this.segmentCount = 0;\n        this.partialLengths = [];\n        this.clientSeqNumbers = [];\n    }\n    static combine(mergeTree, block, collabWindow, recur = false) {\n        return PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, recur);\n    }\n    /**\n     * Combine the partial lengths of block's children\n     * @param block - an interior node; it is assumed that each interior node child of this block\n     * has its partials up to date\n     * @param collabWindow - segment window of the segment tree containing textSegmentBlock\n     */\n    static combineBranch(mergeTree, block, collabWindow, recur = false) {\n        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n        PartialSequenceLengths.fromLeaves(combinedPartialLengths, block, collabWindow);\n        let prevPartial;\n        function cloneOverlapRemoveClients(oldTree) {\n            if (!oldTree) {\n                return undefined;\n            }\n            const newTree = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);\n            oldTree.map((bProp) => {\n                newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));\n                return true;\n            });\n            return newTree;\n        }\n        function combineOverlapClients(a, b) {\n            const overlapRemoveClientsA = a.overlapRemoveClients;\n            if (overlapRemoveClientsA) {\n                if (b.overlapRemoveClients) {\n                    b.overlapRemoveClients.map((bProp) => {\n                        const aProp = overlapRemoveClientsA.get(bProp.key);\n                        if (aProp) {\n                            aProp.data.seglen += bProp.data.seglen;\n                        }\n                        else {\n                            overlapRemoveClientsA.put(bProp.data.clientId, Object.assign({}, bProp.data));\n                        }\n                        return true;\n                    });\n                }\n            }\n            else {\n                a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);\n            }\n        }\n        function addNext(partialLength) {\n            const seq = partialLength.seq;\n            let pLen = 0;\n            if (prevPartial) {\n                if (prevPartial.seq === partialLength.seq) {\n                    prevPartial.seglen += partialLength.seglen;\n                    prevPartial.len += partialLength.seglen;\n                    combineOverlapClients(prevPartial, partialLength);\n                    return;\n                }\n                else {\n                    pLen = prevPartial.len;\n                    // Previous sequence number is finished\n                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n                }\n            }\n            prevPartial = {\n                clientId: partialLength.clientId,\n                len: pLen + partialLength.seglen,\n                overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),\n                seglen: partialLength.seglen,\n                seq,\n            };\n            combinedPartialLengths.partialLengths.push(prevPartial);\n        }\n        const childPartials = [];\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (!child.isLeaf()) {\n                const childBlock = child;\n                if (recur) {\n                    childBlock.partialLengths =\n                        PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                childPartials.push(childBlock.partialLengths);\n            }\n        }\n        let childPartialsLen = childPartials.length;\n        if (childPartialsLen !== 0) {\n            // Some children are interior nodes\n            if (combinedPartialLengths.partialLengths.length > 0) {\n                // Some children were leaves; add combined partials from these segments\n                childPartials.push(combinedPartialLengths);\n                childPartialsLen++;\n                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n            }\n            const indices = new Array(childPartialsLen);\n            const childPartialsCounts = new Array(childPartialsLen);\n            for (let i = 0; i < childPartialsLen; i++) {\n                indices[i] = 0;\n                childPartialsCounts[i] = childPartials[i].partialLengths.length;\n                combinedPartialLengths.minLength += childPartials[i].minLength;\n                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;\n            }\n            let outerIndexOfEarliest = 0;\n            let earliestPartialLength;\n            while (outerIndexOfEarliest >= 0) {\n                outerIndexOfEarliest = -1;\n                for (let k = 0; k < childPartialsLen; k++) {\n                    // Find next earliest sequence number\n                    if (indices[k] < childPartialsCounts[k]) {\n                        const cpLen = childPartials[k].partialLengths[indices[k]];\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {\n                            outerIndexOfEarliest = k;\n                            earliestPartialLength = cpLen;\n                        }\n                    }\n                }\n                if (outerIndexOfEarliest >= 0) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    addNext(earliestPartialLength);\n                    indices[outerIndexOfEarliest]++;\n                }\n            }\n            // Add client entry for last partial, if any\n            if (prevPartial) {\n                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n            }\n        }\n        // TODO: incremental zamboni during build\n        if (PartialSequenceLengths.options.zamboni) {\n            combinedPartialLengths.zamboni(collabWindow);\n        }\n        if (PartialSequenceLengths.options.verify) {\n            combinedPartialLengths.verify();\n        }\n        return combinedPartialLengths;\n    }\n    static fromLeaves(combinedPartialLengths, block, collabWindow) {\n        combinedPartialLengths.minLength = 0;\n        combinedPartialLengths.segmentCount = block.childCount;\n        function seqLTE(seq, minSeq) {\n            return seq !== undefined && seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber && seq <= minSeq;\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            const child = block.children[i];\n            if (child.isLeaf()) {\n                // Leaf segment\n                const segment = child;\n                if (seqLTE(segment.seq, collabWindow.minSeq)) {\n                    combinedPartialLengths.minLength += segment.cachedLength;\n                }\n                else {\n                    if (segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {\n                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);\n                    }\n                }\n                const removalInfo = (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.toRemovalInfo)(segment);\n                if (seqLTE(removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq, collabWindow.minSeq)) {\n                    combinedPartialLengths.minLength -= segment.cachedLength;\n                }\n                else {\n                    if (removalInfo !== undefined\n                        && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {\n                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, removalInfo);\n                    }\n                }\n            }\n        }\n        // Post-process correctly-ordered partials computing sums and creating\n        // lists for each present client id\n        const seqPartials = combinedPartialLengths.partialLengths;\n        const seqPartialsLen = seqPartials.length;\n        let prevLen = 0;\n        for (let i = 0; i < seqPartialsLen; i++) {\n            seqPartials[i].len = prevLen + seqPartials[i].seglen;\n            prevLen = seqPartials[i].len;\n            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);\n        }\n        if (PartialSequenceLengths.options.verify) {\n            combinedPartialLengths.verify();\n        }\n    }\n    static getOverlapClients(overlapClientIds, seglen) {\n        const bst = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);\n        for (const clientId of overlapClientIds) {\n            bst.put(clientId, { clientId, seglen });\n        }\n        return bst;\n    }\n    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {\n        if (partialLength.overlapRemoveClients) {\n            for (const clientId of overlapRemoveClientIds) {\n                const overlapClientNode = partialLength.overlapRemoveClients.get(clientId);\n                if (!overlapClientNode) {\n                    partialLength.overlapRemoveClients.put(clientId, { clientId, seglen });\n                }\n                else {\n                    overlapClientNode.data.seglen += seglen;\n                }\n            }\n        }\n        else {\n            partialLength.overlapRemoveClients =\n                PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);\n        }\n    }\n    static insertSegment(combinedPartialLengths, segment, removalInfo) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        let seq = segment.seq;\n        let segmentLen = segment.cachedLength;\n        let clientId = segment.clientId;\n        let removeClientOverlap;\n        if (removalInfo) {\n            seq = removalInfo.removedSeq;\n            segmentLen = -segmentLen;\n            // this code still assume removed client id and\n            // overlap clients are separate. so we need to pull\n            // then apart first.\n            clientId = removalInfo.removedClientIds[0];\n            removeClientOverlap = removalInfo.removedClientIds.length > 1\n                ? removalInfo.removedClientIds.slice(1)\n                : undefined;\n        }\n        const seqPartials = combinedPartialLengths.partialLengths;\n        const seqPartialsLen = seqPartials.length;\n        // Find the first entry with sequence number greater or equal to seq\n        let indexFirstGTE = 0;\n        for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {\n            if (seqPartials[indexFirstGTE].seq >= seq) {\n                break;\n            }\n        }\n        if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq === seq)) {\n            seqPartials[indexFirstGTE].seglen += segmentLen;\n            if (removeClientOverlap) {\n                PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);\n            }\n        }\n        else {\n            let pLen;\n            if (removeClientOverlap) {\n                const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);\n                pLen = { seq, clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };\n            }\n            else {\n                pLen = { seq, clientId, len: 0, seglen: segmentLen };\n            }\n            if (indexFirstGTE < seqPartialsLen) {\n                // Shift entries with greater sequence numbers\n                // TODO: investigate performance improvement using BST\n                for (let k = seqPartialsLen; k > indexFirstGTE; k--) {\n                    seqPartials[k] = seqPartials[k - 1];\n                }\n                seqPartials[indexFirstGTE] = pLen;\n            }\n            else {\n                seqPartials.push(pLen);\n            }\n        }\n    }\n    static addSeq(partialLengths, seq, seqSeglen, clientId) {\n        let seqPartialLen;\n        let penultPartialLen;\n        let leqIndex = latestLEQ(partialLengths, seq);\n        if (leqIndex >= 0) {\n            const pLen = partialLengths[leqIndex];\n            if (pLen.seq === seq) {\n                seqPartialLen = pLen;\n                leqIndex = latestLEQ(partialLengths, seq - 1);\n                if (leqIndex >= 0) {\n                    penultPartialLen = partialLengths[leqIndex];\n                }\n            }\n            else {\n                penultPartialLen = pLen;\n            }\n        }\n        if (seqPartialLen === undefined) {\n            // len will be assigned below, making this assertion true.\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            seqPartialLen = {\n                clientId,\n                seglen: seqSeglen,\n                seq,\n            };\n            partialLengths.push(seqPartialLen);\n        }\n        else {\n            seqPartialLen.seglen = seqSeglen;\n            // Assert client id matches\n        }\n        if (penultPartialLen !== undefined) {\n            seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;\n        }\n        else {\n            seqPartialLen.len = seqPartialLen.seglen;\n        }\n    }\n    // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment\n    // with sequence number seq has been added within the sub-tree\n    // TODO: assert client id matches\n    update(mergeTree, node, seq, clientId, collabWindow) {\n        let seqSeglen = 0;\n        let segCount = 0;\n        // Compute length for seq across children\n        for (let i = 0; i < node.childCount; i++) {\n            const child = node.children[i];\n            if (!child.isLeaf()) {\n                const childBlock = child;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const branchPartialLengths = childBlock.partialLengths;\n                const partialLengths = branchPartialLengths.partialLengths;\n                const seqIndex = latestLEQ(partialLengths, seq);\n                if (seqIndex >= 0) {\n                    const leqPartial = partialLengths[seqIndex];\n                    if (leqPartial.seq === seq) {\n                        seqSeglen += leqPartial.seglen;\n                    }\n                }\n                segCount += branchPartialLengths.segmentCount;\n            }\n            else {\n                const segment = child;\n                const removalInfo = (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.toRemovalInfo)(segment);\n                if (segment.seq === seq) {\n                    if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) !== seq) {\n                        seqSeglen += segment.cachedLength;\n                    }\n                }\n                else {\n                    if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) === seq) {\n                        seqSeglen -= segment.cachedLength;\n                    }\n                }\n                segCount++;\n            }\n        }\n        this.segmentCount = segCount;\n        PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);\n        if (this.clientSeqNumbers[clientId] === undefined) {\n            this.clientSeqNumbers[clientId] = [];\n        }\n        PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);\n        if (PartialSequenceLengths.options.zamboni) {\n            this.zamboni(collabWindow);\n        }\n        if (PartialSequenceLengths.options.verify) {\n            this.verify();\n        }\n    }\n    getPartialLength(refSeq, clientId) {\n        let pLen = this.minLength;\n        const seqIndex = latestLEQ(this.partialLengths, refSeq);\n        const cliLatestIndex = this.cliLatest(clientId);\n        const cliSeq = this.clientSeqNumbers[clientId];\n        if (seqIndex >= 0) {\n            // Add the partial length up to refSeq\n            pLen += this.partialLengths[seqIndex].len;\n            if (cliLatestIndex >= 0) {\n                const cliLatest = cliSeq[cliLatestIndex];\n                if (cliLatest.seq > refSeq) {\n                    // The client has local edits after refSeq, add in the length adjustments\n                    pLen += cliLatest.len;\n                    const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);\n                    if (precedingCliIndex >= 0) {\n                        pLen -= cliSeq[precedingCliIndex].len;\n                    }\n                }\n            }\n        }\n        else {\n            // RefSeq is before any of the partial lengths\n            // so just add in all local edits of that client (which should all be after the refSeq)\n            if (cliLatestIndex >= 0) {\n                const cliLatest = cliSeq[cliLatestIndex];\n                pLen += cliLatest.len;\n            }\n        }\n        return pLen;\n    }\n    toString(glc, indentCount = 0) {\n        let buf = \"\";\n        for (const partial of this.partialLengths) {\n            buf += `(${partial.seq},${partial.len}) `;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax\n        for (const clientId in this.clientSeqNumbers) {\n            if (this.clientSeqNumbers[clientId].length > 0) {\n                buf += `Client `;\n                if (glc) {\n                    buf += `${glc(+clientId)}`;\n                }\n                else {\n                    buf += `${clientId}`;\n                }\n                buf += \"[\";\n                for (const partial of this.clientSeqNumbers[clientId]) {\n                    buf += `(${partial.seq},${partial.len})`;\n                }\n                buf += \"]\";\n            }\n        }\n        buf = `min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;\n        return buf;\n    }\n    // Clear away partial sums for sequence numbers earlier than the current window\n    zamboni(segmentWindow) {\n        function copyDown(partialLengths) {\n            const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);\n            let minLength = 0;\n            if (mindex >= 0) {\n                minLength = partialLengths[mindex].len;\n                const seqCount = partialLengths.length;\n                if (mindex <= (seqCount - 1)) {\n                    // Still some entries remaining\n                    const remainingCount = (seqCount - mindex) - 1;\n                    // Copy down\n                    for (let i = 0; i < remainingCount; i++) {\n                        partialLengths[i] = partialLengths[i + mindex + 1];\n                        partialLengths[i].len -= minLength;\n                    }\n                    partialLengths.length = remainingCount;\n                }\n            }\n            return minLength;\n        }\n        this.minLength += copyDown(this.partialLengths);\n        // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax\n        for (const clientId in this.clientSeqNumbers) {\n            const cliPartials = this.clientSeqNumbers[clientId];\n            if (cliPartials) {\n                copyDown(cliPartials);\n            }\n        }\n    }\n    addClientSeqNumber(clientId, seq, seglen) {\n        if (this.clientSeqNumbers[clientId] === undefined) {\n            this.clientSeqNumbers[clientId] = [];\n        }\n        const cli = this.clientSeqNumbers[clientId];\n        let pLen = seglen;\n        if (cli.length > 0) {\n            pLen += cli[cli.length - 1].len;\n        }\n        cli.push({ seq, len: pLen, seglen });\n    }\n    // Assumes sequence number already coalesced\n    addClientSeqNumberFromPartial(partialLength) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);\n        if (partialLength.overlapRemoveClients) {\n            partialLength.overlapRemoveClients.map((oc) => {\n                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);\n                return true;\n            });\n        }\n    }\n    cliLatestLEQ(clientId, refSeq) {\n        const cliSeqs = this.clientSeqNumbers[clientId];\n        if (cliSeqs) {\n            return latestLEQ(cliSeqs, refSeq);\n        }\n        else {\n            return -1;\n        }\n    }\n    cliLatest(clientId) {\n        const cliSeqs = this.clientSeqNumbers[clientId];\n        if (cliSeqs && (cliSeqs.length > 0)) {\n            return cliSeqs.length - 1;\n        }\n        else {\n            return -1;\n        }\n    }\n    // Debug only\n    verifyPartialLengths(partialLengths, clientPartials) {\n        if (partialLengths.length === 0) {\n            return 0;\n        }\n        let lastSeqNum = 0;\n        let accumSegLen = 0;\n        let count = 0;\n        for (const partialLength of partialLengths) {\n            // Count total number of partial length\n            count++;\n            // Sequence number should be larger or equal to minseq\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.minSeq <= partialLength.seq, 0x054 /* \"Sequence number less than minSeq!\" */);\n            // Sequence number should be sorted\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(lastSeqNum < partialLength.seq, 0x055 /* \"Sequence number is not sorted!\" */);\n            lastSeqNum = partialLength.seq;\n            // Len is a accumulation of all the seglen adjustments\n            accumSegLen += partialLength.seglen;\n            if (accumSegLen !== partialLength.len) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x056 /* \"Unexpected total for accumulation of all seglen adjustments!\" */);\n            }\n            if (clientPartials) {\n                // Client partials used to track local edits so we can account for them some refSeq.\n                // But the information we keep track of are since minSeq, so we keep track of more history\n                // then needed, and some of them doesn't make sense to be used for length calculations\n                // e.g. if you have this sequence, where the minSeq is #5 because of other clients\n                //    seq 10: client 1: insert seg #1\n                //    seq 11: client 2: delete seg #2 refseq: 10\n                // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2\n                // So if you ask for partial length for client 2 @ seq 5, we will have return -1.\n                // However, that combination is invalid, since we should never see any ops with refseq < 10 for\n                // client 2 after seq 11.\n            }\n            else {\n                // Len adjustment should not make length negative\n                if (this.minLength + partialLength.len < 0) {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x057 /* \"Negative length after length adjustment!\" */);\n                }\n            }\n            if (partialLength.overlapRemoveClients) {\n                // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!clientPartials, 0x058 /* \"Both overlapRemoveClients and clientPartials are set!\" */);\n                // Each overlap client count as one\n                count += partialLength.overlapRemoveClients.size();\n            }\n        }\n        return count;\n    }\n    verify() {\n        if (this.clientSeqNumbers) {\n            let cliCount = 0;\n            for (const cliSeq of this.clientSeqNumbers) {\n                if (cliSeq) {\n                    cliCount += this.verifyPartialLengths(cliSeq, true);\n                }\n            }\n            // If we have client view, we should have the flat view\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.partialLengths, 0x059 /* \"Client view exists but flat view does not!\" */);\n            const flatCount = this.verifyPartialLengths(this.partialLengths, false);\n            // The number of partial lengths on the client view and flat view should be the same\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(flatCount === cliCount, 0x05a /* \"Mismatch between number of partial lengths on client and flat views!\" */);\n        }\n        else {\n            // If we don't have a client view, we shouldn't have the flat view either\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.partialLengths, 0x05b /* \"Flat view exists but client view does not!\" */);\n        }\n    }\n}\nPartialSequenceLengths.options = {\n    verify: false,\n    zamboni: true,\n};\n//# sourceMappingURL=partialLengths.js.map\n\n/***/ }),\n/* 300 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createAnnotateMarkerOp\": () => (/* binding */ createAnnotateMarkerOp),\n/* harmony export */   \"createAnnotateRangeOp\": () => (/* binding */ createAnnotateRangeOp),\n/* harmony export */   \"createGroupOp\": () => (/* binding */ createGroupOp),\n/* harmony export */   \"createInsertOp\": () => (/* binding */ createInsertOp),\n/* harmony export */   \"createInsertSegmentOp\": () => (/* binding */ createInsertSegmentOp),\n/* harmony export */   \"createRemoveRangeOp\": () => (/* binding */ createRemoveRangeOp)\n/* harmony export */ });\n/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Creates the op for annotating the markers with the provided properties\n * @param marker - The marker to annotate\n * @param props - The properties to annotate the marker with\n * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n * @returns The annotate op\n */\nfunction createAnnotateMarkerOp(marker, props, combiningOp) {\n    const id = marker.getId();\n    if (!id) {\n        return undefined;\n    }\n    return {\n        combiningOp,\n        props,\n        relativePos1: { id, before: true },\n        relativePos2: { id },\n        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.ANNOTATE,\n    };\n}\n/**\n * Creates the op for annotating the range with the provided properties\n * @param start - The inclusive start position of the range to annotate\n * @param end - The exclusive end position of the range to annotate\n * @param props - The properties to annotate the range with\n * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n * @returns The annotate op\n */\nfunction createAnnotateRangeOp(start, end, props, combiningOp) {\n    return {\n        combiningOp,\n        pos1: start,\n        pos2: end,\n        props,\n        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.ANNOTATE,\n    };\n}\n/**\n * Creates the op to remove a range\n *\n * @param start - The inclusive start of the range to remove\n * @param end - The exclusive end of the range to remove\n */\nfunction createRemoveRangeOp(start, end) {\n    return {\n        pos1: start,\n        pos2: end,\n        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.REMOVE,\n    };\n}\n/**\n *\n * @param pos - The position to insert the segment at\n * @param segment - The segment to insert\n */\nfunction createInsertSegmentOp(pos, segment) {\n    return createInsertOp(pos, segment.toJSONObject());\n}\nfunction createInsertOp(pos, segSpec) {\n    return {\n        pos1: pos,\n        seg: segSpec,\n        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.INSERT,\n    };\n}\n/**\n *\n * @param ops - The ops to group\n */\nfunction createGroupOp(...ops) {\n    return {\n        ops,\n        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.GROUP,\n    };\n}\n//# sourceMappingURL=opBuilder.js.map\n\n/***/ }),\n/* 301 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Trace\": () => (/* binding */ Trace)\n/* harmony export */ });\n/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(302);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Helper class for tracing performance of events\n * Time measurements are in milliseconds as a floating point with a decimal\n */\nclass Trace {\n    constructor(startTick) {\n        this.startTick = startTick;\n        this.lastTick = startTick;\n    }\n    static start() {\n        const startTick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        return new Trace(startTick);\n    }\n    trace() {\n        const tick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n        const event = {\n            totalTimeElapsed: tick - this.startTick,\n            duration: tick - this.lastTick,\n            tick,\n        };\n        this.lastTick = tick;\n        return event;\n    }\n}\n//# sourceMappingURL=trace.js.map\n\n/***/ }),\n/* 302 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst performance = window.performance;\n//# sourceMappingURL=performanceBrowser.js.map\n\n/***/ }),\n/* 303 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 304 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 305 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MergeTreeTextHelper\": () => (/* binding */ MergeTreeTextHelper),\n/* harmony export */   \"TextSegment\": () => (/* binding */ TextSegment)\n/* harmony export */ });\n/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);\n/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n// Maximum length of text segment to be considered to be merged with other segment.\n// Maximum segment length is at least 2x of it (not taking into account initial segment creation).\n// The bigger it is, the more expensive it is to break segment into sub-segments (on edits)\n// The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.\n// Small number also makes ReplayTool produce false positives (\"same\" snapshots have slightly different binary\n// representations).  More measurements needs to be done, but it's very likely the right spot is somewhere between\n// 1K-2K mark.  That said, we also break segments on newline and there are very few segments that are longer than 256\n// because of it.  Must be an even number\nconst TextSegmentGranularity = 256;\nclass TextSegment extends _mergeTree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {\n    constructor(text) {\n        super();\n        this.text = text;\n        this.type = TextSegment.type;\n        this.cachedLength = text.length;\n    }\n    static is(segment) {\n        return segment.type === TextSegment.type;\n    }\n    static make(text, props) {\n        const seg = new TextSegment(text);\n        if (props) {\n            seg.addProperties(props);\n        }\n        return seg;\n    }\n    static fromJSONObject(spec) {\n        if (typeof spec === \"string\") {\n            return new TextSegment(spec);\n        }\n        else if (spec && typeof spec === \"object\" && \"text\" in spec) {\n            const textSpec = spec;\n            return TextSegment.make(textSpec.text, textSpec.props);\n        }\n        return undefined;\n    }\n    toJSONObject() {\n        // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is\n        // not annotated.\n        return this.properties\n            ? { text: this.text, props: this.properties }\n            : this.text;\n    }\n    clone(start = 0, end) {\n        const text = this.text.substring(start, end);\n        const b = TextSegment.make(text, this.properties);\n        this.cloneInto(b);\n        return b;\n    }\n    canAppend(segment) {\n        return !this.text.endsWith(\"\\n\")\n            && TextSegment.is(segment)\n            && (this.cachedLength <= TextSegmentGranularity ||\n                segment.cachedLength <= TextSegmentGranularity);\n    }\n    toString() {\n        return this.text;\n    }\n    append(segment) {\n        if (TextSegment.is(segment)) {\n            // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n            // 'this.cachedLength' is used to adjust the offsets of the local refs.\n            _localReference__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);\n            this.text += segment.text;\n            this.cachedLength = this.text.length;\n        }\n        else {\n            throw new Error(\"can only append text segment\");\n        }\n    }\n    // TODO: retain removed text for undo\n    // returns true if entire string removed\n    removeRange(start, end) {\n        let remnantString = \"\";\n        const len = this.text.length;\n        if (start > 0) {\n            remnantString += this.text.substring(0, start);\n        }\n        if (end < len) {\n            remnantString += this.text.substring(end);\n        }\n        this.text = remnantString;\n        this.cachedLength = remnantString.length;\n        return (remnantString.length === 0);\n    }\n    createSplitSegmentAt(pos) {\n        if (pos > 0) {\n            const remainingText = this.text.substring(pos);\n            this.text = this.text.substring(0, pos);\n            this.cachedLength = this.text.length;\n            const leafSegment = new TextSegment(remainingText);\n            return leafSegment;\n        }\n    }\n}\nTextSegment.type = \"TextSegment\";\nfunction isTextAndMarkerAccumulator(accum) {\n    return accum.parallelArrays === true;\n}\nclass MergeTreeTextHelper {\n    constructor(mergeTree) {\n        this.mergeTree = mergeTree;\n        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {\n            var _a, _b;\n            let _start = start;\n            if (TextSegment.is(segment)) {\n                let beginTags = \"\";\n                let endTags = \"\";\n                if (isTextAndMarkerAccumulator(accumText)) {\n                    // TODO: let clients pass in function to get tag\n                    const tags = [];\n                    const initTags = [];\n                    if ((_a = segment.properties) === null || _a === void 0 ? void 0 : _a[\"font-weight\"]) {\n                        tags.push(\"b\");\n                    }\n                    if ((_b = segment.properties) === null || _b === void 0 ? void 0 : _b[\"text-decoration\"]) {\n                        tags.push(\"u\");\n                    }\n                    const remTags = [];\n                    if (tags.length > 0) {\n                        for (const tag of tags) {\n                            if (!accumText.tagsInProgress.includes(tag)) {\n                                beginTags += `<${tag}>`;\n                                initTags.push(tag);\n                            }\n                        }\n                        for (const accumTag of accumText.tagsInProgress) {\n                            if (!tags.includes(accumTag)) {\n                                endTags += `</${accumTag}>`;\n                                remTags.push(accumTag);\n                            }\n                        }\n                        for (const initTag of initTags.reverse()) {\n                            accumText.tagsInProgress.push(initTag);\n                        }\n                    }\n                    else {\n                        for (const accumTag of accumText.tagsInProgress) {\n                            endTags += `</${accumTag}>`;\n                            remTags.push(accumTag);\n                        }\n                    }\n                    for (const remTag of remTags) {\n                        const remdex = accumText.tagsInProgress.indexOf(remTag);\n                        if (remdex >= 0) {\n                            accumText.tagsInProgress.splice(remdex, 1);\n                        }\n                    }\n                }\n                accumText.textSegment.text += endTags;\n                accumText.textSegment.text += beginTags;\n                if ((_start <= 0) && (end >= segment.text.length)) {\n                    accumText.textSegment.text += segment.text;\n                }\n                else {\n                    if (_start < 0) {\n                        _start = 0;\n                    }\n                    if (end >= segment.text.length) {\n                        accumText.textSegment.text += segment.text.substring(_start);\n                    }\n                    else {\n                        accumText.textSegment.text += segment.text.substring(_start, end);\n                    }\n                }\n            }\n            else {\n                if (accumText.placeholder && (accumText.placeholder.length > 0)) {\n                    if (accumText.placeholder === \"*\") {\n                        const marker = segment;\n                        accumText.textSegment.text += `\\n${marker.toString()}`;\n                    }\n                    else {\n                        for (let i = 0; i < segment.cachedLength; i++) {\n                            accumText.textSegment.text += accumText.placeholder;\n                        }\n                    }\n                }\n                else if (isTextAndMarkerAccumulator(accumText)) {\n                    const marker = segment;\n                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {\n                        accumText.parallelMarkers.push(marker);\n                        accumText.parallelText.push(accumText.textSegment.text);\n                        accumText.textSegment.text = \"\";\n                    }\n                }\n            }\n            return true;\n        };\n    }\n    getTextAndMarkers(refSeq, clientId, label, start, end) {\n        const range = this.getValidRange(start, end, refSeq, clientId);\n        const accum = {\n            parallelArrays: true,\n            parallelMarkerLabel: label,\n            parallelMarkers: [],\n            parallelText: [],\n            tagsInProgress: [],\n            textSegment: new TextSegment(\"\"),\n        };\n        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);\n        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };\n    }\n    getText(refSeq, clientId, placeholder = \"\", start, end) {\n        const range = this.getValidRange(start, end, refSeq, clientId);\n        const accum = { textSegment: new TextSegment(\"\"), placeholder };\n        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);\n        return accum.textSegment.text;\n    }\n    getValidRange(start, end, refSeq, clientId) {\n        const range = {\n            end: end !== null && end !== void 0 ? end : this.mergeTree.getLength(refSeq, clientId),\n            start: start !== null && start !== void 0 ? start : 0,\n        };\n        return range;\n    }\n}\n//# sourceMappingURL=textSegment.js.map\n\n/***/ }),\n/* 306 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SnapshotV1\": () => (/* binding */ SnapshotV1)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(283);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(309);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(285);\n/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(284);\n/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);\n/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(307);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\nclass SnapshotV1 {\n    constructor(mergeTree, logger, getLongClientId, filename, onCompletion) {\n        var _a, _b;\n        this.mergeTree = mergeTree;\n        this.getLongClientId = getLongClientId;\n        this.filename = filename;\n        this.onCompletion = onCompletion;\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(logger, \"Snapshot\");\n        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotV1.chunkSize;\n        const { currentSeq, minSeq } = mergeTree.getCollabWindow();\n        this.header = {\n            minSequenceNumber: minSeq,\n            sequenceNumber: currentSeq,\n            orderedChunkMetadata: [],\n            totalLength: 0,\n            totalSegmentCount: 0,\n        };\n        this.segments = [];\n        this.segmentLengths = [];\n    }\n    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {\n        const segments = [];\n        let length = 0;\n        let segmentCount = 0;\n        while ((length < approxSequenceLength) && ((startIndex + segmentCount) < allSegments.length)) {\n            const pseg = allSegments[startIndex + segmentCount];\n            segments.push(pseg);\n            length += allLengths[startIndex + segmentCount];\n            segmentCount++;\n        }\n        return {\n            version: \"1\",\n            segmentCount,\n            length,\n            segments,\n            startIndex,\n            headerMetadata: undefined,\n        };\n    }\n    /**\n     * Emits the snapshot to an ISummarizeResult. If provided the optional IFluidSerializer will be used when\n     * serializing the summary data rather than JSON.stringify.\n     */\n    emit(serializer, bind) {\n        const chunks = [];\n        this.header.totalSegmentCount = 0;\n        this.header.totalLength = 0;\n        do {\n            const chunk = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize, this.header.totalSegmentCount);\n            chunks.push(chunk);\n            this.header.totalSegmentCount += chunk.segmentCount;\n            this.header.totalLength += chunk.length;\n        } while (this.header.totalSegmentCount < this.segments.length);\n        // The do while loop should have added at least one chunk\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const headerChunk = chunks.shift();\n        headerChunk.headerMetadata = this.header;\n        headerChunk.headerMetadata.orderedChunkMetadata = [{ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header }];\n        const blobs = [];\n        chunks.forEach((chunk, index) => {\n            const id = `${_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.body}_${index}`;\n            this.header.orderedChunkMetadata.push({ id });\n            blobs.push([id, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMaxSupportedVersion)(id, chunk, this.logger, this.mergeTree.options, serializer, bind)]);\n        });\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__.SummaryTreeBuilder();\n        builder.addBlob(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMaxSupportedVersion)(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header, headerChunk, this.logger, this.mergeTree.options, serializer, bind));\n        blobs.forEach((value) => {\n            builder.addBlob(value[0], value[1]);\n        });\n        return builder.getSummaryTree();\n    }\n    extractSync() {\n        const mergeTree = this.mergeTree;\n        const minSeq = this.header.minSequenceNumber;\n        // Helper to add the given `MergeTreeChunkV0SegmentSpec` to the snapshot.\n        const pushSegRaw = (json, length) => {\n            this.segments.push(json);\n            this.segmentLengths.push(length);\n        };\n        // Helper to serialize the given `segment` and add it to the snapshot (if a segment is provided).\n        const pushSeg = (segment) => {\n            if (segment) {\n                pushSegRaw(segment.toJSONObject(), segment.cachedLength);\n            }\n        };\n        let prev;\n        const extractSegment = (segment) => {\n            var _a;\n            // Elide segments that do not need to be included in the snapshot.  A segment may be elided if\n            // either condition is true:\n            //   a) The segment has not yet been ACKed.  We do not need to snapshot unACKed segments because\n            //      there is a pending insert op that will deliver the segment on reconnection.\n            //   b) The segment was removed at or below the MSN.  Pending ops can no longer reference this\n            //      segment, and therefore we can discard it.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (segment.seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber || segment.removedSeq <= minSeq) {\n                return true;\n            }\n            // Next determine if the snapshot needs to preserve information required for merging the segment\n            // (seq, client, etc.)  This information is only needed if the segment is above the MSN (and doesn't\n            // have a pending remove.)\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if ((segment.seq <= minSeq) // Segment is below the MSN, and...\n                && (segment.removedSeq === undefined // .. Segment has not been removed, or...\n                    || segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) // .. Removal op to be delivered on reconnect\n            ) {\n                // This segment is below the MSN, which means that future ops will not reference it.  Attempt to\n                // coalesce the new segment with the previous (if any).\n                if (!prev) {\n                    // We do not have a previous candidate for coalescing.  Make the current segment the new candidate.\n                    prev = segment;\n                }\n                else if (prev.canAppend(segment) && (0,_properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties)(prev.properties, segment.properties)) {\n                    // We have a compatible pair.  Replace `prev` with the coalesced segment.  Clone to avoid\n                    // modifying the segment instances currently in the MergeTree.\n                    prev = prev.clone();\n                    prev.append(segment.clone());\n                }\n                else {\n                    // The segment pair could not be coalesced.  Record the `prev` segment in the snapshot\n                    // and make the current segment the new candidate for coalescing.\n                    pushSeg(prev);\n                    prev = segment;\n                }\n            }\n            else {\n                // This segment needs to preserve it's metadata as it may be referenced by future ops.  It's ineligible\n                // for coalescing, so emit the 'prev' segment now (if any).\n                pushSeg(prev);\n                prev = undefined;\n                const raw = { json: segment.toJSONObject() };\n                // If the segment insertion is above the MSN, record the insertion merge info.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (segment.seq > minSeq) {\n                    raw.seq = segment.seq;\n                    raw.client = this.getLongClientId(segment.clientId);\n                }\n                // We have already dispensed with removed segments below the MSN and removed segments with unassigned\n                // sequence numbers.  Any remaining removal info should be preserved.\n                if (segment.removedSeq !== undefined) {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(segment.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber && segment.removedSeq > minSeq, 0x065 /* \"On removal info preservation, segment has invalid removed sequence number!\" */);\n                    raw.removedSeq = segment.removedSeq;\n                    // back compat for when we split overlap and removed client\n                    raw.removedClient =\n                        segment.removedClientIds !== undefined\n                            ? this.getLongClientId(segment.removedClientIds[0])\n                            : undefined;\n                    raw.removedClientIds = (_a = segment.removedClientIds) === null || _a === void 0 ? void 0 : _a.map((id) => this.getLongClientId(id));\n                }\n                // Sanity check that we are preserving either the seq < minSeq or a removed segment's info.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(raw.seq !== undefined && raw.client !== undefined\n                    || raw.removedSeq !== undefined && raw.removedClient !== undefined, 0x066 /* \"Corrupted preservation of segment metadata!\" */);\n                // Record the segment with it's required metadata.\n                pushSegRaw(raw, segment.cachedLength);\n            }\n            return true;\n        };\n        mergeTree.walkAllSegments(mergeTree.root, extractSegment, this);\n        // If the last segment in the walk was coalescable, push it now.\n        pushSeg(prev);\n        return this.segments;\n    }\n    static async loadChunk(storage, path, logger, options, serializer) {\n        const blob = await storage.readBlob(path);\n        const chunkAsString = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.bufferToString)(blob, \"utf8\");\n        return SnapshotV1.processChunk(path, chunkAsString, logger, options, serializer);\n    }\n    static processChunk(path, chunk, logger, options, serializer) {\n        const chunkObj = serializer ? serializer.parse(chunk) : JSON.parse(chunk);\n        return (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.toLatestVersion)(path, chunkObj, logger, options);\n    }\n}\n// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content\n// Please note that this number has no direct relationship to anything other than size of raw text (characters).\n// As we produce json for the blob (and then send over the wire compressed), this number\n// is really hard to correlate with any actual metric that matters (like bytes over the wire).\n// For test with small number of chunks it would be closer to blob size,\n// for very chunky text, blob size can easily be 4x-8x of that number.\nSnapshotV1.chunkSize = 10000;\n//# sourceMappingURL=snapshotV1.js.map\n\n/***/ }),\n/* 307 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SnapshotLegacy\": () => (/* binding */ SnapshotLegacy)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(283);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(285);\n/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(284);\n/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\nclass SnapshotLegacy {\n    constructor(mergeTree, logger, filename, onCompletion) {\n        var _a, _b;\n        this.mergeTree = mergeTree;\n        this.filename = filename;\n        this.onCompletion = onCompletion;\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(logger, \"Snapshot\");\n        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotLegacy.sizeOfFirstChunk;\n    }\n    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {\n        const segs = [];\n        let sequenceLength = 0;\n        let segCount = 0;\n        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {\n            const pseg = allSegments[startIndex + segCount];\n            segs.push(pseg);\n            sequenceLength += allLengths[startIndex + segCount];\n            segCount++;\n        }\n        return {\n            version: undefined,\n            chunkStartSegmentIndex: startIndex,\n            chunkSegmentCount: segCount,\n            chunkLengthChars: sequenceLength,\n            totalLengthChars: this.header.segmentsTotalLength,\n            totalSegmentCount: allSegments.length,\n            chunkSequenceNumber: this.header.seq,\n            segmentTexts: segs,\n        };\n    }\n    /**\n     * Emits the snapshot to an ISummarizeResult. If provided the optional IFluidSerializer will be used when\n     * serializing the summary data rather than JSON.stringify.\n     */\n    emit(catchUpMsgs, serializer, bind) {\n        var _a, _b;\n        const chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize);\n        let length = chunk1.chunkLengthChars;\n        let segments = chunk1.chunkSegmentCount;\n        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeBuilder();\n        builder.addBlob(SnapshotLegacy.header, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMinSupportedVersion)(SnapshotLegacy.header, chunk1, this.logger, this.mergeTree.options, serializer, bind));\n        if (chunk1.chunkSegmentCount < chunk1.totalSegmentCount) {\n            const chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.header.segmentsTotalLength, chunk1.chunkSegmentCount);\n            length += chunk2.chunkLengthChars;\n            segments += chunk2.chunkSegmentCount;\n            builder.addBlob(SnapshotLegacy.body, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMinSupportedVersion)(SnapshotLegacy.body, chunk2, this.logger, this.mergeTree.options, serializer, bind));\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(length === this.header.segmentsTotalLength, 0x05d /* \"emit: mismatch in segmentsTotalLength\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(segments === chunk1.totalSegmentCount, 0x05e /* \"emit: mismatch in totalSegmentCount\" */);\n        if (catchUpMsgs !== undefined && catchUpMsgs.length > 0) {\n            builder.addBlob((_b = (_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.catchUpBlobName) !== null && _b !== void 0 ? _b : SnapshotLegacy.catchupOps, serializer ? serializer.stringify(catchUpMsgs, bind) : JSON.stringify(catchUpMsgs));\n        }\n        return builder.getSummaryTree();\n    }\n    extractSync() {\n        const collabWindow = this.mergeTree.getCollabWindow();\n        this.seq = collabWindow.minSeq;\n        this.header = {\n            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient),\n            seq: this.mergeTree.collabWindow.minSeq,\n        };\n        const segs = [];\n        let prev;\n        const extractSegment = \n        // eslint-disable-next-line max-len\n        (segment, pos, refSeq, clientId, start, end) => {\n            if ((segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (segment.seq <= this.seq) &&\n                ((segment.removedSeq === undefined) || (segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) ||\n                    (segment.removedSeq > this.seq))) {\n                if ((prev === null || prev === void 0 ? void 0 : prev.canAppend(segment))\n                    && (0,_properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties)(prev.properties, segment.properties)) {\n                    prev = prev.clone();\n                    prev.append(segment.clone());\n                }\n                else {\n                    if (prev) {\n                        segs.push(prev);\n                    }\n                    prev = segment;\n                }\n            }\n            return true;\n        };\n        this.mergeTree.map({ leaf: extractSegment }, this.seq, _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient, undefined);\n        if (prev) {\n            segs.push(prev);\n        }\n        this.segments = [];\n        this.segmentLengths = [];\n        let totalLength = 0;\n        segs.map((segment) => {\n            totalLength += segment.cachedLength;\n            this.segments.push(segment.toJSONObject());\n            this.segmentLengths.push(segment.cachedLength);\n        });\n        // We observed this.header.segmentsTotalLength < totalLength to happen in some cases\n        // When this condition happens, we might not write out all segments in getSeqLengthSegs()\n        // when writing out \"body\". Issue #1995 tracks following up on the core of the problem.\n        // In the meantime, this code makes sure we will write out all segments properly\n        if (this.header.segmentsTotalLength !== totalLength) {\n            this.logger.sendErrorEvent({\n                eventName: \"SegmentsTotalLengthMismatch\",\n                totalLength,\n                segmentsTotalLength: this.header.segmentsTotalLength,\n            });\n            this.header.segmentsTotalLength = totalLength;\n        }\n        return this.segments;\n    }\n}\nSnapshotLegacy.header = \"header\";\nSnapshotLegacy.body = \"body\";\nSnapshotLegacy.catchupOps = \"catchupOps\";\n// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content\n// Please note that this number has no direct relationship to anything other than size of raw text (characters).\n// As we produce json for the blob (and then send over the wire compressed), this number\n// is really hard to correlate with any actual metric that matters (like bytes over the wire).\n// For test with small number of chunks it would be closer to blob size,\n// for very chunky text, blob size can easily be 4x-8x of that number.\nSnapshotLegacy.sizeOfFirstChunk = 10000;\n//# sourceMappingURL=snapshotlegacy.js.map\n\n/***/ }),\n/* 308 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasMergeInfo\": () => (/* binding */ hasMergeInfo),\n/* harmony export */   \"serializeAsMaxSupportedVersion\": () => (/* binding */ serializeAsMaxSupportedVersion),\n/* harmony export */   \"serializeAsMinSupportedVersion\": () => (/* binding */ serializeAsMinSupportedVersion),\n/* harmony export */   \"toLatestVersion\": () => (/* binding */ toLatestVersion)\n/* harmony export */ });\n/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(307);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.\n */\nfunction hasMergeInfo(spec) {\n    return !!spec && typeof spec === \"object\" && \"json\" in spec;\n}\nfunction serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {\n    let targetChuck;\n    if (chunk.version !== undefined) {\n        logger.send({\n            eventName: \"MergeTreeChunk:serializeAsMinSupportedVersion\",\n            category: \"generic\",\n            fromChunkVersion: chunk.version,\n            toChunkVersion: undefined,\n        });\n    }\n    switch (chunk.version) {\n        case undefined:\n            targetChuck = chunk;\n            targetChuck.headerMetadata = buildHeaderMetadataForLegacyChunk(path, targetChuck, options);\n            break;\n        case \"1\":\n            const chunkV1 = chunk;\n            const headerMetadata = path === _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;\n            targetChuck = {\n                version: undefined,\n                chunkStartSegmentIndex: chunkV1.startIndex,\n                chunkLengthChars: chunkV1.length,\n                chunkSegmentCount: chunkV1.segmentCount,\n                segmentTexts: chunkV1.segments,\n                totalLengthChars: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalLength,\n                totalSegmentCount: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalSegmentCount,\n                chunkSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.sequenceNumber,\n                chunkMinSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.minSequenceNumber,\n                headerMetadata,\n            };\n            break;\n        default:\n            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n    }\n    return serializer.stringify(targetChuck, bind);\n}\nfunction serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {\n    const targetChuck = toLatestVersion(path, chunk, logger, options);\n    return serializer.stringify(targetChuck, bind);\n}\nfunction toLatestVersion(path, chunk, logger, options) {\n    switch (chunk.version) {\n        case undefined: {\n            const chunkLegacy = chunk;\n            return {\n                version: \"1\",\n                length: chunkLegacy.chunkLengthChars,\n                segmentCount: chunkLegacy.chunkSegmentCount,\n                headerMetadata: buildHeaderMetadataForLegacyChunk(path, chunkLegacy, options),\n                segments: chunkLegacy.segmentTexts,\n                startIndex: chunkLegacy.chunkStartSegmentIndex,\n            };\n        }\n        case \"1\":\n            return chunk;\n        default:\n            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n    }\n}\nfunction buildHeaderMetadataForLegacyChunk(path, chunk, options) {\n    if (path === _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header) {\n        if (chunk.headerMetadata !== undefined) {\n            return chunk.headerMetadata;\n        }\n        const chunkIds = [{ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header }];\n        if (chunk.chunkLengthChars < chunk.totalLengthChars) {\n            chunkIds.push({ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.body });\n        }\n        return {\n            orderedChunkMetadata: chunkIds,\n            minSequenceNumber: chunk.chunkMinSequenceNumber,\n            sequenceNumber: chunk.chunkSequenceNumber,\n            totalLength: chunk.totalLengthChars,\n            totalSegmentCount: chunk.totalSegmentCount,\n        };\n    }\n    return undefined;\n}\n//# sourceMappingURL=snapshotChunks.js.map\n\n/***/ }),\n/* 309 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(283);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 310 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SnapshotLoader\": () => (/* binding */ SnapshotLoader)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(283);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(309);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(285);\n/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(308);\n/* harmony import */ var _snapshotV1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(306);\n/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(307);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n\n\n\n\n\n\nclass SnapshotLoader {\n    constructor(runtime, client, mergeTree, logger, serializer) {\n        this.runtime = runtime;\n        this.client = client;\n        this.mergeTree = mergeTree;\n        this.serializer = serializer;\n        this.specToSegment = (spec) => {\n            var _a;\n            let seg;\n            if ((0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_0__.hasMergeInfo)(spec)) {\n                seg = this.client.specToSegment(spec.json);\n                // `specToSegment()` initializes `seg` with the LocalClientId.  Overwrite this with\n                // the `spec` client (if specified).  Otherwise overwrite with `NonCollabClient`.\n                seg.clientId = spec.client !== undefined\n                    ? this.client.getOrAddShortClientId(spec.client)\n                    : _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient;\n                seg.seq = spec.seq !== undefined\n                    ? spec.seq\n                    : _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;\n                if (spec.removedSeq !== undefined) {\n                    seg.removedSeq = spec.removedSeq;\n                }\n                // this format had a bug where it didn't store all the overlap clients\n                // this is for back compat, so we change the singular id to an array\n                // this will only cause problems if there is an overlapping delete\n                // spanning the snapshot, which should be rare\n                if (spec.removedClient !== undefined) {\n                    seg.removedClientIds = [this.client.getOrAddShortClientId(spec.removedClient)];\n                }\n                if (spec.removedClientIds !== undefined) {\n                    seg.removedClientIds = (_a = spec.removedClientIds) === null || _a === void 0 ? void 0 : _a.map((sid) => this.client.getOrAddShortClientId(sid));\n                }\n            }\n            else {\n                seg = this.client.specToSegment(spec);\n                seg.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;\n                // `specToSegment()` initializes `seg` with the LocalClientId.  We must overwrite this with\n                // `NonCollabClient`.\n                seg.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient;\n            }\n            return seg;\n        };\n        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(logger, \"SnapshotLoader\");\n    }\n    async initialize(services) {\n        const headerLoadedP = services.readBlob(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__.SnapshotLegacy.header).then((header) => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!!header, 0x05f /* \"Missing blob header on legacy snapshot!\" */);\n            return this.loadHeader((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(header, \"utf8\"));\n        });\n        const catchupOpsP = this.loadBodyAndCatchupOps(headerLoadedP, services);\n        catchupOpsP.catch((err) => this.logger.sendErrorEvent({ eventName: \"CatchupOpsLoadFailure\" }, err));\n        await headerLoadedP;\n        return { catchupOpsP };\n    }\n    async loadBodyAndCatchupOps(headerChunkP, services) {\n        const blobsP = services.list(\"\");\n        const headerChunk = await headerChunkP;\n        // TODO we shouldn't need to wait on the body being complete to finish initialization.\n        // To fully support this we need to be able to process inbound ops for pending segments.\n        await this.loadBody(headerChunk, services);\n        const blobs = await blobsP;\n        if (blobs.length === headerChunk.headerMetadata.orderedChunkMetadata.length + 1) {\n            headerChunk.headerMetadata.orderedChunkMetadata.forEach((md) => blobs.splice(blobs.indexOf(md.id), 1));\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(blobs.length === 1, 0x060 /* There should be only one blob with catch up ops */);\n            // TODO: The 'Snapshot.catchupOps' tree entry is purely for backwards compatibility.\n            //       (See https://github.com/microsoft/FluidFramework/issues/84)\n            return this.loadCatchupOps(services.readBlob(blobs[0]));\n        }\n        else if (blobs.length !== headerChunk.headerMetadata.orderedChunkMetadata.length) {\n            throw new Error(\"Unexpected blobs in snapshot\");\n        }\n        return [];\n    }\n    loadHeader(header) {\n        var _a;\n        const chunk = _snapshotV1__WEBPACK_IMPORTED_MODULE_6__.SnapshotV1.processChunk(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__.SnapshotLegacy.header, header, this.logger, this.mergeTree.options, this.serializer);\n        const segs = chunk.segments.map(this.specToSegment);\n        this.mergeTree.reloadFromSegments(segs);\n        if (chunk.headerMetadata === undefined) {\n            throw new Error(\"header metadata not available\");\n        }\n        // If we load a detached container from snapshot, then we don't supply a default clientId\n        // because we don't want to start collaboration.\n        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached) {\n            // specify a default client id, \"snapshot\" here as we\n            // should enter collaboration/op sending mode if we load\n            // a snapshot in any case (summary or attach message)\n            // once we get a client id this will be called with that\n            // clientId in the connected event\n            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : \"snapshot\", \n            // TODO: Make 'minSeq' non-optional once the new snapshot format becomes the default?\n            //       (See https://github.com/microsoft/FluidFramework/issues/84)\n            /* minSeq: */ chunk.headerMetadata.minSequenceNumber !== undefined\n                ? chunk.headerMetadata.minSequenceNumber\n                : chunk.headerMetadata.sequenceNumber, \n            /* currentSeq: */ chunk.headerMetadata.sequenceNumber);\n        }\n        return chunk;\n    }\n    async loadBody(chunk1, services) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.length <= chunk1.headerMetadata.totalLength, 0x061 /* \"Mismatch in totalLength\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.segmentCount <= chunk1.headerMetadata.totalSegmentCount, 0x062 /* \"Mismatch in totalSegmentCount\" */);\n        if (chunk1.segmentCount === chunk1.headerMetadata.totalSegmentCount) {\n            return;\n        }\n        const segs = [];\n        let lengthSofar = chunk1.length;\n        for (let chunkIndex = 1; chunkIndex < chunk1.headerMetadata.orderedChunkMetadata.length; chunkIndex++) {\n            const chunk = await _snapshotV1__WEBPACK_IMPORTED_MODULE_6__.SnapshotV1.loadChunk(services, chunk1.headerMetadata.orderedChunkMetadata[chunkIndex].id, this.logger, this.mergeTree.options, this.serializer);\n            lengthSofar += chunk.length;\n            // Deserialize each chunk segment and append it to the end of the MergeTree.\n            segs.push(...chunk.segments.map(this.specToSegment));\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(lengthSofar === chunk1.headerMetadata.totalLength, 0x063 /* \"Mismatch in totalLength\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.segmentCount + segs.length === chunk1.headerMetadata.totalSegmentCount, 0x064 /* \"Mismatch in totalSegmentCount\" */);\n        // Helper to insert segments at the end of the MergeTree.\n        const mergeTree = this.mergeTree;\n        const append = (segments, cli, seq) => {\n            mergeTree.insertSegments(mergeTree.root.cachedLength, segments, \n            /* refSeq: */ _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, cli, seq, undefined);\n        };\n        // Helpers to batch-insert segments that are below the min seq\n        const batch = [];\n        const flushBatch = () => {\n            if (batch.length > 0) {\n                append(batch, _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber);\n            }\n        };\n        for (const seg of segs) {\n            const cli = seg.clientId;\n            const seq = seg.seq;\n            // If the segment can be batch inserted, add it to the 'batch' array.  Otherwise, flush\n            // any batched segments and then insert the current segment individually.\n            if (cli === _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient && seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber) {\n                batch.push(seg);\n            }\n            else {\n                flushBatch();\n                append([seg], cli, seq);\n            }\n        }\n        flushBatch();\n    }\n    /**\n     * If loading from a snapshot, get the catchup messages.\n     * @param rawMessages - The messages in original encoding\n     * @returns The decoded messages, but handles aren't parsed.  Matches the format that will be passed in\n     * SharedObject.processCore.\n     */\n    async loadCatchupOps(rawMessages) {\n        return JSON.parse((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(await rawMessages, \"utf8\"));\n    }\n}\n//# sourceMappingURL=snapshotLoader.js.map\n\n/***/ }),\n/* 311 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SequenceDeltaEvent\": () => (/* binding */ SequenceDeltaEvent),\n/* harmony export */   \"SequenceEvent\": () => (/* binding */ SequenceEvent),\n/* harmony export */   \"SequenceMaintenanceEvent\": () => (/* binding */ SequenceMaintenanceEvent)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(288);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(297);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.\n *\n * The properties of this object and its sub-objects represent the state of the sequence at the\n * point in time at which the operation was applied.\n * They will not take into any future modifications performed to the underlying sequence and merge tree.\n */\nclass SequenceEvent {\n    constructor(deltaArgs, mergeTreeClient) {\n        this.deltaArgs = deltaArgs;\n        this.mergeTreeClient = mergeTreeClient;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(deltaArgs.deltaSegments.length > 0, 0x2d8 /* \"Empty change event should not be emitted.\" */);\n        this.isEmpty = false;\n        this.deltaOperation = deltaArgs.operation;\n        this.sortedRanges = new Lazy(() => {\n            const set = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.SortedSegmentSet();\n            this.deltaArgs.deltaSegments.forEach((delta) => {\n                const newRange = {\n                    operation: this.deltaArgs.operation,\n                    position: this.mergeTreeClient.getPosition(delta.segment),\n                    propertyDeltas: delta.propertyDeltas,\n                    segment: delta.segment,\n                };\n                set.addOrUpdate(newRange);\n            });\n            return set;\n        });\n        this.pFirst = new Lazy(() => this.sortedRanges.value.items[0]);\n        this.pLast = new Lazy(() => this.sortedRanges.value.items[this.sortedRanges.value.size - 1]);\n    }\n    /**\n     * The in-order ranges affected by this delta.\n     * These may not be continuous.\n     */\n    get ranges() {\n        return this.sortedRanges.value.items;\n    }\n    /**\n     * The client id of the client that made the change which caused the delta event\n     */\n    get clientId() {\n        return this.mergeTreeClient.longClientId;\n    }\n    /**\n     * The first of the modified ranges.\n     */\n    get first() {\n        return this.pFirst.value;\n    }\n    /**\n     * The last of the modified ranges.\n     */\n    get last() {\n        return this.pLast.value;\n    }\n}\n/**\n * The event object returned on sequenceDelta events.\n *\n * The properties of this object and its sub-objects represent the state of the sequence at the\n * point in time at which the operation was applied.\n * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.\n *\n * For group ops, each op will get its own event, and the group op property will be set on the op args.\n *\n * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.\n */\nclass SequenceDeltaEvent extends SequenceEvent {\n    constructor(opArgs, deltaArgs, mergeTreeClient) {\n        super(deltaArgs, mergeTreeClient);\n        this.opArgs = opArgs;\n        this.isLocal = opArgs.sequencedMessage === undefined;\n    }\n}\n/**\n * The event object returned on maintenance events.\n *\n * The properties of this object and its sub-objects represent the state of the sequence at the\n * point in time at which the operation was applied.\n * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.\n */\nclass SequenceMaintenanceEvent extends SequenceEvent {\n    constructor(opArgs, deltaArgs, mergeTreeClient) {\n        super(deltaArgs, mergeTreeClient);\n        this.opArgs = opArgs;\n    }\n}\nclass Lazy {\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this.pEvaluated = false;\n    }\n    get evaluated() {\n        return this.pEvaluated;\n    }\n    get value() {\n        if (!this.pEvaluated) {\n            this.pEvaluated = true;\n            this.pValue = this.valueGenerator();\n        }\n        return this.pValue;\n    }\n}\n//# sourceMappingURL=sequenceDeltaEvent.js.map\n\n/***/ }),\n/* 312 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultMap\": () => (/* binding */ DefaultMap)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(137);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(138);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(289);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(288);\n/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(313);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * A DefaultMap is a map-like distributed data structure, supporting operations on values stored by\n * string key locations.\n *\n * Creation of values is implicit on access (either via `get` or a remote op application referring to\n * a collection that wasn't previously known)\n */\nclass DefaultMap {\n    /**\n     * Create a new default map.\n     * @param serializer - The serializer to serialize / parse handles\n     * @param handle - The handle of the shared object using the kernel\n     * @param submitMessage - A callback to submit a message through the shared object\n     * @param type - The value type to create at values of this map\n     * @param eventEmitter - The object that will emit map events\n     */\n    constructor(serializer, handle, submitMessage, type, eventEmitter = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter()) {\n        this.serializer = serializer;\n        this.handle = handle;\n        this.submitMessage = submitMessage;\n        this.type = type;\n        this.eventEmitter = eventEmitter;\n        /**\n         * Mapping of op types to message handlers.\n         */\n        this.messageHandlers = new Map();\n        /**\n         * The in-memory data the map is storing.\n         */\n        this.data = new Map();\n        this.messageHandlers = this.getMessageHandlers();\n    }\n    /**\n     * The number of key/value pairs stored in the map.\n     */\n    get size() {\n        return this.data.size;\n    }\n    /**\n     * Get an iterator over the keys in this map.\n     * @returns The iterator\n     */\n    keys() {\n        return this.data.keys();\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    entries() {\n        const localEntriesIterator = this.data.entries();\n        const iterator = {\n            next() {\n                const nextVal = localEntriesIterator.next();\n                return nextVal.done\n                    ? { value: undefined, done: true }\n                    : { value: [nextVal.value[0], nextVal.value[1].value], done: false }; // Unpack the stored value\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the values in this map.\n     * @returns The iterator\n     */\n    values() {\n        const localValuesIterator = this.data.values();\n        const iterator = {\n            next() {\n                const nextVal = localValuesIterator.next();\n                return nextVal.done\n                    ? { value: undefined, done: true }\n                    : { value: nextVal.value.value, done: false }; // Unpack the stored value\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n        return iterator;\n    }\n    /**\n     * Get an iterator over the entries in this map.\n     * @returns The iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Executes the given callback on each entry in the map.\n     * @param callbackFn - Callback function\n     */\n    forEach(callbackFn) {\n        this.data.forEach((localValue, key, m) => {\n            callbackFn(localValue.value, key, m);\n        });\n    }\n    /**\n     * {@inheritDoc ISharedMap.get}\n     */\n    get(key) {\n        var _a;\n        const localValue = (_a = this.data.get(key)) !== null && _a !== void 0 ? _a : this.createCore(key, true);\n        return localValue.value;\n    }\n    /**\n     * Check if a key exists in the map.\n     * @param key - The key to check\n     * @returns True if the key exists, false otherwise\n     */\n    has(key) {\n        return this.data.has(key);\n    }\n    /**\n     * Serializes the data stored in the shared map to a JSON string\n     * @param serializer - The serializer to use to serialize handles in its values.\n     * @returns A JSON string containing serialized map data\n     */\n    getSerializedStorage(serializer) {\n        const serializableMapData = {};\n        this.data.forEach((localValue, key) => {\n            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);\n        });\n        return serializableMapData;\n    }\n    getSerializableStorage(serializer) {\n        const serializableMapData = {};\n        this.data.forEach((localValue, key) => {\n            serializableMapData[key] = (0,_localValues__WEBPACK_IMPORTED_MODULE_1__.makeSerializable)(localValue, serializer, this.handle);\n        });\n        return serializableMapData;\n    }\n    serialize(serializer) {\n        return JSON.stringify(this.getSerializableStorage(serializer));\n    }\n    /**\n     * Populate the kernel with the given map data.\n     * @param data - A JSON string containing serialized map data\n     */\n    populateFromSerializable(json) {\n        for (const [key, serializable] of Object.entries(json)) {\n            // Back-compat: legacy documents may have handles to an intervalCollection map kernel.\n            // These collections should be empty, and ValueTypes are no longer supported.\n            if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Plain]\n                || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Shared]) {\n                continue;\n            }\n            // Back-compat: Sequence previously arbitrarily prefixed all interval collection keys with\n            // \"intervalCollections/\". This would burden users trying to iterate the collection and\n            // access its value, as well as those trying to match a create message to its underlying\n            // collection. See https://github.com/microsoft/FluidFramework/issues/10557 for more context.\n            const normalizedKey = key.startsWith(\"intervalCollections/\") ? key.substring(20) : key;\n            const localValue = {\n                key: normalizedKey,\n                value: this.makeLocal(key, serializable),\n            };\n            this.data.set(localValue.key, localValue.value);\n        }\n    }\n    populate(json) {\n        this.populateFromSerializable(JSON.parse(json));\n    }\n    /**\n     * Submit the given op if a handler is registered.\n     * @param op - The operation to attempt to submit\n     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime\n     * and not sent to the server. This will be sent back when this message is received back from the server. This is\n     * also sent if we are asked to resubmit the message.\n     * @returns True if the operation was submitted, false otherwise.\n     */\n    tryResubmitMessage(op, localOpMetadata) {\n        const type = op.type;\n        const handler = this.messageHandlers.get(type);\n        if (handler !== undefined) {\n            handler.resubmit(op, localOpMetadata);\n            return true;\n        }\n        return false;\n    }\n    tryGetStashedOpLocalMetadata(op) {\n        const type = op.type;\n        if (this.messageHandlers.has(type)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return this.messageHandlers.get(type).getStashedOpLocalMetadata(op);\n        }\n        throw new Error(\"no apply stashed op handler\");\n    }\n    /**\n     * Process the given op if a handler is registered.\n     * @param message - The message to process\n     * @param local - Whether the message originated from the local client\n     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n     * For messages from a remote client, this will be undefined.\n     * @returns True if the operation was processed, false otherwise.\n     */\n    tryProcessMessage(op, local, message, localOpMetadata) {\n        const handler = this.messageHandlers.get(op.type);\n        if (handler !== undefined) {\n            handler.process(op, local, message, localOpMetadata);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Initializes a default ValueType at the provided key.\n     * Should be used when a map operation incurs creation.\n     * @param key - The key being initialized\n     * @param local - Whether the message originated from the local client\n     */\n    createCore(key, local) {\n        const localValue = new _localValues__WEBPACK_IMPORTED_MODULE_1__.ValueTypeLocalValue(this.type.factory.load(this.makeMapValueOpEmitter(key), undefined), this.type);\n        const previousValue = this.data.get(key);\n        this.data.set(key, localValue);\n        const event = { key, previousValue };\n        this.eventEmitter.emit(\"create\", event, local, this.eventEmitter);\n        return localValue;\n    }\n    /**\n     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will\n     * have the information we need to create a real object, but will not be the real object yet.  For example,\n     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's\n     * job is to convert that information into a real object for local usage.\n     * @param key - The key that the caller intends to store the local value into (used for ops later).  But\n     * doesn't actually store the local value into that key.  So better not lie!\n     * @param serializable - The remote information that we can convert into a real object\n     * @returns The local value that was produced\n     */\n    makeLocal(key, serializable) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(serializable.type !== _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Plain] && serializable.type !== _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Shared], 0x2e1 /* \"Support for plain value types removed.\" */);\n        serializable.value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.parseHandles)(serializable.value, this.serializer);\n        const localValue = this.type.factory.load(this.makeMapValueOpEmitter(key), serializable.value);\n        return new _localValues__WEBPACK_IMPORTED_MODULE_1__.ValueTypeLocalValue(localValue, this.type);\n    }\n    /**\n     * Get the message handlers for the map.\n     * @returns A map of string op names to IMapMessageHandlers for those ops\n     */\n    getMessageHandlers() {\n        const messageHandlers = new Map();\n        // Ops with type \"act\" describe actions taken by custom value type handlers of whatever item is\n        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has\n        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone\n        // watching for manipulations of that item.\n        messageHandlers.set(\"act\", {\n            process: (op, local, message, localOpMetadata) => {\n                var _a;\n                const localValue = (_a = this.data.get(op.key)) !== null && _a !== void 0 ? _a : this.createCore(op.key, local);\n                const handler = localValue.getOpHandler(op.value.opName);\n                const previousValue = localValue.value;\n                const translatedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.parseHandles)(op.value.value, this.serializer);\n                handler.process(previousValue, translatedValue, local, message, localOpMetadata);\n                const event = { key: op.key, previousValue };\n                this.eventEmitter.emit(\"valueChanged\", event, local, message, this.eventEmitter);\n            },\n            submit: (op, localOpMetadata) => {\n                this.submitMessage(op, localOpMetadata);\n            },\n            resubmit: (op, localOpMetadata) => {\n                const localValue = this.data.get(op.key);\n                const handler = localValue.getOpHandler(op.value.opName);\n                const { rebasedOp, rebasedLocalOpMetadata, } = handler.rebase(localValue.value, op.value, localOpMetadata);\n                this.submitMessage(Object.assign(Object.assign({}, op), { value: rebasedOp }), rebasedLocalOpMetadata);\n            },\n            getStashedOpLocalMetadata: (op) => {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x016 /* \"apply stashed op not implemented for custom value type ops\" */);\n            },\n        });\n        return messageHandlers;\n    }\n    /**\n     * Create an emitter for a value type to emit ops from the given key.\n     * @alpha\n     * @param key - The key of the map that the value type will be stored on\n     * @returns A value op emitter for the given key\n     */\n    makeMapValueOpEmitter(key) {\n        const emit = (opName, previousValue, params, localOpMetadata) => {\n            const translatedParams = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.makeHandlesSerializable)(params, this.serializer, this.handle);\n            const op = {\n                key,\n                type: \"act\",\n                value: {\n                    opName,\n                    value: translatedParams,\n                },\n            };\n            this.submitMessage(op, localOpMetadata);\n            const event = { key, previousValue };\n            this.eventEmitter.emit(\"valueChanged\", event, true, null, this.eventEmitter);\n        };\n        return { emit };\n    }\n}\n//# sourceMappingURL=defaultMap.js.map\n\n/***/ }),\n/* 313 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValueTypeLocalValue\": () => (/* binding */ ValueTypeLocalValue),\n/* harmony export */   \"makeSerializable\": () => (/* binding */ makeSerializable)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nfunction makeSerializable(localValue, serializer, bind) {\n    const value = localValue.makeSerialized(serializer, bind);\n    return {\n        type: value.type,\n        value: value.value && JSON.parse(value.value),\n    };\n}\n/**\n * Manages a contained value type.\n *\n * @alpha\n */\nclass ValueTypeLocalValue {\n    /**\n     * Create a new ValueTypeLocalValue.\n     * @param value - The instance of the value type stored within\n     * @param valueType - The type object of the value type stored within\n     */\n    constructor(value, valueType) {\n        this.value = value;\n        this.valueType = valueType;\n    }\n    /**\n     * {@inheritDoc ILocalValue.\"type\"}\n     */\n    get type() {\n        return this.valueType.name;\n    }\n    /**\n     * {@inheritDoc ILocalValue.makeSerialized}\n     */\n    makeSerialized(serializer, bind) {\n        const storedValueType = this.valueType.factory.store(this.value);\n        const value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.serializeHandles)(storedValueType, serializer, bind);\n        return {\n            type: this.type,\n            value,\n        };\n    }\n    /**\n     * Get the handler for a given op of this value type.\n     * @param opName - The name of the operation that needs processing\n     * @returns The object which can process the given op\n     */\n    getOpHandler(opName) {\n        const handler = this.valueType.ops.get(opName);\n        if (!handler) {\n            throw new Error(\"Unknown type message\");\n        }\n        return handler;\n    }\n}\n//# sourceMappingURL=localValues.js.map\n\n/***/ }),\n/* 314 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(288);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 315 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjectStoragePartition\": () => (/* binding */ ObjectStoragePartition)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Returns a new IChannelStorageService that resolves the given `path` as root.\n */\nclass ObjectStoragePartition {\n    constructor(storage, path) {\n        this.storage = storage;\n        this.path = path;\n        // `path` must not include the trailing separator.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!path.endsWith(\"/\"), 0x19c /* \"storage service path has trailing separator\" */);\n    }\n    async readBlob(path) {\n        return this.storage.readBlob(`${this.path}/${path}`);\n    }\n    async contains(path) {\n        return this.storage.contains(`${this.path}/${path}`);\n    }\n    async list(path) {\n        return this.storage.list(`${this.path}/${path}`);\n    }\n}\n//# sourceMappingURL=objectstoragepartition.js.map\n\n/***/ }),\n/* 316 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 317 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedNumberSequenceFactory\": () => (/* binding */ SharedNumberSequenceFactory),\n/* harmony export */   \"SharedObjectSequenceFactory\": () => (/* binding */ SharedObjectSequenceFactory),\n/* harmony export */   \"SharedStringFactory\": () => (/* binding */ SharedStringFactory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(305);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(318);\n/* harmony import */ var _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(321);\n/* harmony import */ var _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(320);\n/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(319);\n/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(290);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\nclass SharedStringFactory {\n    static segmentFromSpec(spec) {\n        const maybeText = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.TextSegment.fromJSONObject(spec);\n        if (maybeText) {\n            return maybeText;\n        }\n        const maybeMarker = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.Marker.fromJSONObject(spec);\n        if (maybeMarker) {\n            return maybeMarker;\n        }\n    }\n    get type() {\n        return SharedStringFactory.Type;\n    }\n    get attributes() {\n        return SharedStringFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_2__.SharedString(runtime, id, attributes);\n        await sharedString.load(services);\n        return sharedString;\n    }\n    create(document, id) {\n        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_2__.SharedString(document, id, this.attributes);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\n// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically\n// load code\nSharedStringFactory.Type = \"https://graph.microsoft.com/types/mergeTree\";\nSharedStringFactory.Attributes = {\n    type: SharedStringFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,\n};\n/**\n * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nclass SharedObjectSequenceFactory {\n    /**\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    static segmentFromSpec(segSpec) {\n        const runSegment = segSpec;\n        if (runSegment.items) {\n            const seg = new _sharedSequence__WEBPACK_IMPORTED_MODULE_4__.SubSequence(runSegment.items);\n            if (runSegment.props) {\n                seg.addProperties(runSegment.props);\n            }\n            return seg;\n        }\n    }\n    /**\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    get type() {\n        return SharedObjectSequenceFactory.Type;\n    }\n    /**\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    get attributes() {\n        return SharedObjectSequenceFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     *\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    async load(runtime, id, services, attributes) {\n        const sharedSeq = new _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence(runtime, id, attributes);\n        await sharedSeq.load(services);\n        return sharedSeq;\n    }\n    /**\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    create(document, id) {\n        const sharedString = new _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence(document, id, this.attributes);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\n/**\n * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nSharedObjectSequenceFactory.Type = \"https://graph.microsoft.com/types/mergeTree/object-sequence\";\n/**\n * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nSharedObjectSequenceFactory.Attributes = {\n    type: SharedObjectSequenceFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,\n};\n/**\n * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nclass SharedNumberSequenceFactory {\n    /**\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    static segmentFromSpec(segSpec) {\n        const runSegment = segSpec;\n        if (runSegment.items) {\n            const seg = new _sharedSequence__WEBPACK_IMPORTED_MODULE_4__.SubSequence(runSegment.items);\n            if (runSegment.props) {\n                seg.addProperties(runSegment.props);\n            }\n            return seg;\n        }\n    }\n    /**\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    get type() {\n        return SharedNumberSequenceFactory.Type;\n    }\n    /**\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    get attributes() {\n        return SharedNumberSequenceFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     *\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    async load(runtime, id, services, attributes) {\n        const sharedSeq = new _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__.SharedNumberSequence(runtime, id, attributes);\n        await sharedSeq.load(services);\n        return sharedSeq;\n    }\n    /**\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    create(document, id) {\n        const sharedString = new _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__.SharedNumberSequence(document, id, this.attributes);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\n/**\n * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nSharedNumberSequenceFactory.Type = \"https://graph.microsoft.com/types/mergeTree/number-sequence\";\n/**\n * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nSharedNumberSequenceFactory.Attributes = {\n    type: SharedNumberSequenceFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,\n};\n//# sourceMappingURL=sequenceFactory.js.map\n\n/***/ }),\n/* 318 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/sequence\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 319 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedSequence\": () => (/* binding */ SharedSequence),\n/* harmony export */   \"SubSequence\": () => (/* binding */ SubSequence)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);\n/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nconst MaxRun = 128;\nclass SubSequence extends _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {\n    constructor(items) {\n        super();\n        this.items = items;\n        this.type = SubSequence.typeString;\n        this.cachedLength = items.length;\n    }\n    static is(segment) {\n        return segment.type === SubSequence.typeString;\n    }\n    static fromJSONObject(spec) {\n        if (spec && typeof spec === \"object\" && \"items\" in spec) {\n            const segment = new SubSequence(spec.items);\n            if (spec.props) {\n                segment.addProperties(spec.props);\n            }\n            return segment;\n        }\n        return undefined;\n    }\n    toJSONObject() {\n        const obj = { items: this.items };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    clone(start = 0, end) {\n        const clonedItems = this.items.slice(start, end);\n        const b = new SubSequence(clonedItems);\n        this.cloneInto(b);\n        return b;\n    }\n    canAppend(segment) {\n        return SubSequence.is(segment)\n            && (this.cachedLength <= MaxRun || segment.cachedLength <= MaxRun);\n    }\n    toString() {\n        return this.items.toString();\n    }\n    append(segment) {\n        if (!SubSequence.is(segment)) {\n            throw new Error(\"can only append another run segment\");\n        }\n        // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n        //       'this.cachedLength' is used to adjust the offsets of the local refs.\n        _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);\n        this.items = this.items.concat(segment.items);\n        this.cachedLength = this.items.length;\n    }\n    // TODO: retain removed items for undo\n    // returns true if entire run removed\n    removeRange(start, end) {\n        let remnantItems = [];\n        const len = this.items.length;\n        if (start > 0) {\n            remnantItems = remnantItems.concat(this.items.slice(0, start));\n        }\n        if (end < len) {\n            remnantItems = remnantItems.concat(this.items.slice(end));\n        }\n        this.items = remnantItems;\n        this.cachedLength = this.items.length;\n        return (this.items.length === 0);\n    }\n    createSplitSegmentAt(pos) {\n        if (pos > 0) {\n            const remainingItems = this.items.slice(pos);\n            this.items = this.items.slice(0, pos);\n            this.cachedLength = this.items.length;\n            const leafSegment = new SubSequence(remainingItems);\n            return leafSegment;\n        }\n    }\n}\nSubSequence.typeString = \"SubSequence\";\nclass SharedSequence extends _sequence__WEBPACK_IMPORTED_MODULE_2__.SharedSegmentSequence {\n    constructor(document, id, attributes, specToSegment) {\n        super(document, id, attributes, specToSegment);\n        this.id = id;\n    }\n    /**\n     * @param pos - The position to insert the items at.\n     * @param items - The items to insert.\n     * @param props - Optional. Properties to set on the inserted items.\n     */\n    insert(pos, items, props) {\n        const segment = new SubSequence(items);\n        if (props) {\n            segment.addProperties(props);\n        }\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    /**\n     * @param start - The inclusive start of the range to remove\n     * @param end - The exclusive end of the range to remove\n     */\n    remove(start, end) {\n        this.removeRange(start, end);\n    }\n    /**\n     * Returns the total count of items in the sequence\n     */\n    getItemCount() {\n        return this.getLength();\n    }\n    /**\n     * Gets the items in the specified range\n     *\n     * @param start - The inclusive start of the range\n     * @param end - The exclusive end of the range\n     */\n    getItems(start, end) {\n        const items = [];\n        let firstSegment;\n        // Return if the range is incorrect.\n        if (end !== undefined && end <= start) {\n            return items;\n        }\n        this.walkSegments((segment) => {\n            if (SubSequence.is(segment)) {\n                if (firstSegment === undefined) {\n                    firstSegment = segment;\n                }\n                items.push(...segment.items);\n            }\n            return true;\n        }, start, end);\n        // The above call to walkSegments adds all the items in the walked\n        // segments. However, we only want items beginning at |start| in\n        // the first segment. Similarly, if |end| is passed in, we only\n        // want items until |end| in the last segment. Remove the rest of\n        // the items.\n        if (firstSegment !== undefined) {\n            items.splice(0, start - this.getPosition(firstSegment));\n        }\n        if (end !== undefined) {\n            items.splice(end - start);\n        }\n        return items;\n    }\n}\n//# sourceMappingURL=sharedSequence.js.map\n\n/***/ }),\n/* 320 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedObjectSequence\": () => (/* binding */ SharedObjectSequence)\n/* harmony export */ });\n/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);\n/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(319);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * The SharedObjectSequence holds a sequence of serializable objects. Each object will be stored\n * at a position within the sequence. See the\n * {@link https://fluidframework.com/docs/data-structures/sequences/ | sequence documentation}\n * for details on working with sequences.\n *\n * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nclass SharedObjectSequence extends _sharedSequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence {\n    /**\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    constructor(document, id, attributes) {\n        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory.segmentFromSpec);\n        this.id = id;\n    }\n    /**\n     * Create a new shared object sequence\n     *\n     * @param runtime - data store runtime the new shared object sequence belongs to\n     * @param id - optional name of the shared object sequence\n     * @returns newly create shared object sequence (but not attached yet)\n     *\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory.Type);\n    }\n    /**\n     * Get a factory for SharedObjectSequence to register with the data store.\n     *\n     * @returns a factory that creates and load SharedObjectSequence\n     *\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    static getFactory() {\n        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory();\n    }\n    /**\n     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    getRange(start, end) {\n        return this.getItems(start, end);\n    }\n}\n//# sourceMappingURL=sharedObjectSequence.js.map\n\n/***/ }),\n/* 321 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedNumberSequence\": () => (/* binding */ SharedNumberSequence)\n/* harmony export */ });\n/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);\n/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(319);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * The SharedNumberSequence holds a sequence of numbers. Each number will be stored\n * at a position within the sequence. See the\n * {@link https://fluidframework.com/docs/data-structures/sequences/ | sequence documentation}\n * for details on working with sequences.\n *\n * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n */\nclass SharedNumberSequence extends _sharedSequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence {\n    /**\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    constructor(document, id, attributes) {\n        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory.segmentFromSpec);\n        this.id = id;\n    }\n    /**\n     * Create a new shared number sequence\n     *\n     * @param runtime - data store runtime the new shared number sequence belongs to\n     * @param id - optional name of the shared number sequence\n     * @returns newly create shared number sequence (but not attached yet)\n     *\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory.Type);\n    }\n    /**\n     * Get a factory for SharedNumberSequence to register with the data store.\n     *\n     * @returns a factory that creates and load SharedNumberSequence\n     *\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    static getFactory() {\n        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory();\n    }\n    /**\n     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.\n     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)\n     */\n    getRange(start, end) {\n        return this.getItems(start, end);\n    }\n}\n//# sourceMappingURL=sharedNumberSequence.js.map\n\n/***/ }),\n/* 322 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PaddingSegment\": () => (/* binding */ PaddingSegment),\n/* harmony export */   \"RunSegment\": () => (/* binding */ RunSegment),\n/* harmony export */   \"SparseMatrix\": () => (/* binding */ SparseMatrix),\n/* harmony export */   \"SparseMatrixFactory\": () => (/* binding */ SparseMatrixFactory),\n/* harmony export */   \"maxCellPosition\": () => (/* binding */ maxCellPosition),\n/* harmony export */   \"maxCol\": () => (/* binding */ maxCol),\n/* harmony export */   \"maxCols\": () => (/* binding */ maxCols),\n/* harmony export */   \"maxRow\": () => (/* binding */ maxRow),\n/* harmony export */   \"maxRows\": () => (/* binding */ maxRows),\n/* harmony export */   \"positionToRowCol\": () => (/* binding */ positionToRowCol),\n/* harmony export */   \"rowColToPosition\": () => (/* binding */ rowColToPosition)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);\n/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(300);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(318);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(319);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * An empty segment that occupies 'cachedLength' positions.  SparseMatrix uses PaddingSegment\n * to \"pad\" a run of unoccupied cells.\n *\n * @deprecated PaddingSegment is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nclass PaddingSegment extends _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {\n    constructor(size) {\n        super();\n        this.type = PaddingSegment.typeString;\n        this.cachedLength = size;\n    }\n    static is(segment) {\n        return segment.type === PaddingSegment.typeString;\n    }\n    static fromJSONObject(spec) {\n        if (spec && typeof spec === \"object\" && \"pad\" in spec) {\n            const segment = new PaddingSegment(spec.pad);\n            if (spec.props) {\n                segment.addProperties(spec.props);\n            }\n            return segment;\n        }\n        return undefined;\n    }\n    toJSONObject() {\n        return { pad: this.cachedLength, props: this.properties };\n    }\n    clone(start = 0, end) {\n        const b = new PaddingSegment(this.cachedLength);\n        this.cloneInto(b);\n        return b;\n    }\n    canAppend(segment) {\n        return PaddingSegment.is(segment);\n    }\n    toString() {\n        return `[padding: ${this.cachedLength}]`;\n    }\n    append(segment) {\n        if (!PaddingSegment.is(segment)) {\n            throw new Error(\"can only append padding segment\");\n        }\n        // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n        //       'this.cachedLength' is used to adjust the offsets of the local refs.\n        _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);\n        this.cachedLength += segment.cachedLength;\n    }\n    // Returns true if entire run removed\n    removeRange(start, end) {\n        this.cachedLength -= (end - start);\n        return (this.cachedLength === 0);\n    }\n    createSplitSegmentAt(pos) {\n        const leftLength = pos;\n        const rightLength = this.cachedLength - pos;\n        this.cachedLength = leftLength;\n        return new PaddingSegment(rightLength);\n    }\n}\nPaddingSegment.typeString = \"PaddingSegment\";\n/**\n * @deprecated RunSegment is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nclass RunSegment extends ___WEBPACK_IMPORTED_MODULE_2__.SubSequence {\n    constructor(items) {\n        super(items);\n        this.items = items;\n        this.type = RunSegment.typeString;\n        this.tags = new Array(items.length).fill(undefined);\n    }\n    static is(segment) {\n        return segment.type === RunSegment.typeString;\n    }\n    static fromJSONObject(spec) {\n        if (spec && typeof spec === \"object\" && \"items\" in spec) {\n            const segment = new RunSegment(spec.items);\n            if (spec.props) {\n                segment.addProperties(spec.props);\n            }\n            return segment;\n        }\n        return undefined;\n    }\n    clone(start = 0, end) {\n        const b = new RunSegment(this.items.slice(start, end));\n        if (this.tags) {\n            b.tags = this.tags.slice(start, end);\n        }\n        this.cloneInto(b);\n        return b;\n    }\n    append(segment) {\n        super.append(segment);\n        const asRun = segment;\n        if (asRun.tags) {\n            if (this.tags) {\n                this.tags.splice(this.items.length, 0, ...asRun.tags);\n            }\n        }\n        return this;\n    }\n    // TODO: retain removed items for undo\n    // returns true if entire run removed\n    removeRange(start, end) {\n        this.tags.splice(start, end - start);\n        return super.removeRange(start, end);\n    }\n    getTag(pos) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.tags[pos];\n    }\n    setTag(pos, tag) {\n        this.tags[pos] = tag;\n    }\n    createSplitSegmentAt(pos) {\n        if (pos > 0) {\n            const remainingItems = this.items.slice(pos);\n            this.items = this.items.slice(0, pos);\n            this.cachedLength = this.items.length;\n            const leafSegment = new RunSegment(remainingItems);\n            leafSegment.tags = this.tags.slice(pos);\n            this.tags.length = pos;\n            return leafSegment;\n        }\n    }\n}\nRunSegment.typeString = \"RunSegment\";\n/**\n * @deprecated maxCol is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nconst maxCol = 0x200000; // X128 Excel maximum of 16,384 columns\n/**\n * @deprecated maxCols is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nconst maxCols = maxCol + 1;\n/**\n * @deprecated maxRow is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nconst maxRow = 0xFFFFFFFF; // X4096 Excel maximum of 1,048,576 rows\n/**\n * @deprecated maxRows is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nconst maxRows = maxRow + 1;\n/**\n * @deprecated maxCellPosition is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nconst maxCellPosition = maxCol * maxRow;\n/**\n * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nconst rowColToPosition = (row, col) => row * maxCols + col;\n/**\n * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.\n */\nfunction positionToRowCol(position) {\n    const row = Math.floor(position / maxCols);\n    const col = position - (row * maxCols);\n    return { row, col };\n}\n/**\n * @deprecated SparseMatrix is an abandoned prototype.  Use SharedMatrix instead.\n */\nclass SparseMatrix extends ___WEBPACK_IMPORTED_MODULE_3__.SharedSegmentSequence {\n    constructor(document, id, attributes) {\n        super(document, id, attributes, SparseMatrixFactory.segmentFromSpec);\n        this.id = id;\n    }\n    /**\n     * Create a new sparse matrix\n     *\n     * @param runtime - data store runtime the new sparse matrix belongs to\n     * @param id - optional name of the sparse matrix\n     * @returns newly create sparse matrix (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, SparseMatrixFactory.Type);\n    }\n    /**\n     * Get a factory for SharedMap to register with the data store.\n     *\n     * @returns a factory that creates and load SharedMap\n     */\n    static getFactory() {\n        return new SparseMatrixFactory();\n    }\n    get numRows() {\n        return positionToRowCol(this.getLength()).row;\n    }\n    setItems(row, col, values, props) {\n        const start = rowColToPosition(row, col);\n        const end = start + values.length;\n        const segment = new RunSegment(values);\n        if (props) {\n            segment.addProperties(props);\n        }\n        this.replaceRange(start, end, segment);\n    }\n    getItem(row, col) {\n        const pos = rowColToPosition(row, col);\n        const { segment, offset } = this.getContainingSegment(pos);\n        if (segment && RunSegment.is(segment)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return segment.items[offset];\n        }\n        else if (segment && PaddingSegment.is(segment)) {\n            return undefined;\n        }\n        throw new Error(`Unrecognized Segment type`);\n    }\n    getTag(row, col) {\n        const { segment, offset } = this.getSegment(row, col);\n        if (RunSegment.is(segment)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return segment.getTag(offset);\n        }\n        return undefined;\n    }\n    setTag(row, col, tag) {\n        const { segment, offset } = this.getSegment(row, col);\n        if (RunSegment.is(segment)) {\n            segment.setTag(offset, tag);\n        }\n        else if (tag !== undefined) {\n            throw new Error(`Must not attempt to set tags on '${segment.constructor.name}'.`);\n        }\n    }\n    insertRows(row, numRows) {\n        const pos = rowColToPosition(row, 0);\n        const size = maxCols * numRows;\n        const segment = new PaddingSegment(size);\n        const insertOp = this.client.insertSegmentLocal(pos, segment);\n        if (insertOp) {\n            this.submitSequenceMessage(insertOp);\n        }\n    }\n    removeRows(row, numRows) {\n        const pos = rowColToPosition(row, 0);\n        const size = maxCols * numRows;\n        this.removeRange(pos, pos + size);\n    }\n    insertCols(col, numCols) {\n        this.moveAsPadding(maxCol - numCols, col, numCols);\n    }\n    removeCols(col, numCols) {\n        this.moveAsPadding(col, maxCol - numCols, numCols);\n    }\n    annotatePosition(row, col, props) {\n        const pos = rowColToPosition(row, col);\n        this.annotateRange(pos, pos + 1, props);\n    }\n    getPositionProperties(row, col) {\n        const pos = rowColToPosition(row, col);\n        return this.getPropertiesAtPosition(pos);\n    }\n    // For each row, moves 'numCols' items starting from 'srcCol' and inserts 'numCols' padding\n    // at 'destCol'.  Used by insertCols and removeCols.\n    moveAsPadding(srcCol, destCol, numCols) {\n        const removeColStart = srcCol;\n        const removeColEnd = srcCol + numCols;\n        const ops = [];\n        for (let r = 0, rowStart = 0; r < this.numRows; r++, rowStart += maxCols) {\n            ops.push(this.client.removeRangeLocal(rowStart + removeColStart, rowStart + removeColEnd));\n            const insertPos = rowStart + destCol;\n            const segment = new PaddingSegment(numCols);\n            ops.push(this.client.insertSegmentLocal(insertPos, segment));\n        }\n        this.submitSequenceMessage((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.createGroupOp)(...ops));\n    }\n    getSegment(row, col) {\n        const pos = rowColToPosition(row, col);\n        return this.getContainingSegment(pos);\n    }\n}\n/**\n * @deprecated SparseMatrixFactory is an abandoned prototype.  Use SharedMatrixFactory instead.\n */\nclass SparseMatrixFactory {\n    static segmentFromSpec(spec) {\n        const maybePadding = PaddingSegment.fromJSONObject(spec);\n        if (maybePadding) {\n            return maybePadding;\n        }\n        const maybeRun = RunSegment.fromJSONObject(spec);\n        if (maybeRun) {\n            return maybeRun;\n        }\n        throw new Error(`Unrecognized IJSONObject: '${JSON.stringify(spec)}'`);\n    }\n    get type() {\n        return SparseMatrixFactory.Type;\n    }\n    get attributes() {\n        return SparseMatrixFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const sharedObject = new SparseMatrix(runtime, id, attributes);\n        await sharedObject.load(services);\n        return sharedObject;\n    }\n    create(document, id) {\n        const sharedObject = new SparseMatrix(document, id, this.attributes);\n        sharedObject.initializeLocal();\n        return sharedObject;\n    }\n}\nSparseMatrixFactory.Type = \"https://graph.microsoft.com/types/mergeTree/sparse-matrix\";\nSparseMatrixFactory.Attributes = {\n    type: SparseMatrixFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_5__.pkgVersion,\n};\n//# sourceMappingURL=sparsematrix.js.map\n\n/***/ }),\n/* 323 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SharedIntervalCollection\": () => (/* binding */ SharedIntervalCollection),\n/* harmony export */   \"SharedIntervalCollectionFactory\": () => (/* binding */ SharedIntervalCollectionFactory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(314);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(316);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);\n/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(138);\n/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(279);\n/* harmony import */ var _defaultMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(312);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(318);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a;\n\n\n\n\n\n\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the SharedIntervalCollection\n * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.\n */\nclass SharedIntervalCollectionFactory {\n    get type() {\n        return SharedIntervalCollectionFactory.Type;\n    }\n    get attributes() {\n        return SharedIntervalCollectionFactory.Attributes;\n    }\n    /**\n     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n     */\n    async load(runtime, id, services, attributes) {\n        const map = new SharedIntervalCollection(id, runtime, attributes);\n        await map.load(services);\n        return map;\n    }\n    create(runtime, id) {\n        const map = new SharedIntervalCollection(id, runtime, this.attributes);\n        map.initializeLocal();\n        return map;\n    }\n}\nSharedIntervalCollectionFactory.Type = \"https://graph.microsoft.com/types/sharedIntervalCollection\";\nSharedIntervalCollectionFactory.Attributes = {\n    type: SharedIntervalCollectionFactory.Type,\n    snapshotFormatVersion: \"0.1\",\n    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion,\n};\n/**\n * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.\n */\nclass SharedIntervalCollection extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.SharedObject {\n    /**\n     * Constructs a new shared SharedIntervalCollection. If the object is non-local an id and service interfaces will\n     * be provided\n     */\n    constructor(id, runtime, attributes) {\n        super(id, runtime, attributes, \"fluid_sharedIntervalCollection_\");\n        this[_a] = \"SharedIntervalCollection\";\n        this.intervalCollections = new _defaultMap__WEBPACK_IMPORTED_MODULE_2__.DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new _intervalCollection__WEBPACK_IMPORTED_MODULE_3__.IntervalCollectionValueType());\n    }\n    /**\n     * Create a SharedIntervalCollection\n     *\n     * @param runtime - data store runtime the new shared map belongs to\n     * @param id - optional name of the shared map\n     * @returns newly create shared map (but not attached yet)\n     */\n    static create(runtime, id) {\n        return runtime.createChannel(id, SharedIntervalCollectionFactory.Type);\n    }\n    /**\n     * Get a factory for SharedIntervalCollection to register with the data store.\n     *\n     * @returns a factory that creates and load SharedIntervalCollection\n     */\n    static getFactory() {\n        return new SharedIntervalCollectionFactory();\n    }\n    /**\n     * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates\n     * are supported. Use `getIntervalCollection` instead.\n     */\n    async waitIntervalCollection(label) {\n        return this.intervalCollections.get(this.getIntervalCollectionPath(label));\n    }\n    getIntervalCollection(label) {\n        const realLabel = this.getIntervalCollectionPath(label);\n        const sharedCollection = this.intervalCollections.get(realLabel);\n        return sharedCollection;\n    }\n    summarizeCore(serializer) {\n        return (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.createSingleBlobSummary)(snapshotFileName, this.intervalCollections.serialize(serializer));\n    }\n    reSubmitCore(content, localOpMetadata) {\n        this.intervalCollections.tryResubmitMessage(content, localOpMetadata);\n    }\n    onDisconnect() { }\n    /**\n     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n     */\n    async loadCore(storage) {\n        const blob = await storage.readBlob(snapshotFileName);\n        const header = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(blob, \"utf8\");\n        this.intervalCollections.populate(header);\n    }\n    processCore(message, local, localOpMetadata) {\n        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.Operation) {\n            this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);\n        }\n    }\n    /**\n     * Creates the full path of the intervalCollection label\n     * @param label - the incoming label\n     */\n    getIntervalCollectionPath(label) {\n        return label;\n    }\n    applyStashedOp() {\n        throw new Error(\"not implemented\");\n    }\n}\n_a = Symbol.toStringTag;\n//# sourceMappingURL=sharedIntervalCollection.js.map\n\n/***/ }),\n/* 324 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AzureAudience\": () => (/* reexport safe */ _AzureAudience__WEBPACK_IMPORTED_MODULE_0__.AzureAudience),\n/* harmony export */   \"AzureClient\": () => (/* reexport safe */ _AzureClient__WEBPACK_IMPORTED_MODULE_1__.AzureClient),\n/* harmony export */   \"AzureFunctionTokenProvider\": () => (/* reexport safe */ _AzureFunctionTokenProvider__WEBPACK_IMPORTED_MODULE_2__.AzureFunctionTokenProvider),\n/* harmony export */   \"ScopeType\": () => (/* reexport safe */ _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType)\n/* harmony export */ });\n/* harmony import */ var _AzureAudience__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(325);\n/* harmony import */ var _AzureClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(327);\n/* harmony import */ var _AzureFunctionTokenProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(549);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(550);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A simple and powerful way to consume collaborative Fluid data with the Azure Fluid Relay.\n *\n * @packageDocumentation\n */\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 325 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AzureAudience\": () => (/* binding */ AzureAudience)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(326);\n/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(274);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass AzureAudience extends _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.ServiceAudience {\n    /**\n     * Creates a {@link @fluidframework/fluid-static#ServiceAudience} from the provided\n     * {@link @fluidframework/protocol-definitions#IClient | audience member}.\n     *\n     * @param audienceMember - Audience member for which the `ServiceAudience` will be generated.\n     * Note: its {@link @fluidframework/protocol-definitions#IClient.user} is required to be an {@link AzureUser}.\n     *\n     * @internal\n     */\n    createServiceMember(audienceMember) {\n        const azureUser = audienceMember.user;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)((azureUser === null || azureUser === void 0 ? void 0 : azureUser.name) !== undefined, 'Provided user was not an \"AzureUser\".');\n        return {\n            userId: audienceMember.user.id,\n            userName: azureUser.name,\n            connections: [],\n            additionalDetails: azureUser.additionalDetails,\n        };\n    }\n}\n//# sourceMappingURL=AzureAudience.js.map\n\n/***/ }),\n/* 326 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n * A number should not be specificed manually: use a string.\n * Before a release, policy-check should be run, which will convert any asserts still using strings to\n * use numbered error codes instead.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 327 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AzureClient\": () => (/* binding */ AzureClient)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(465);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(332);\n/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);\n/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(464);\n/* harmony import */ var _fluidframework_routerlicious_driver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(330);\n/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);\n/* harmony import */ var _AzureAudience__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(325);\n/* harmony import */ var _AzureUrlResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(329);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(328);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * Strongly typed id for connecting to a local Azure Fluid Relay.\n */\nconst LOCAL_MODE_TENANT_ID = \"local\";\nconst getTenantId = (connectionProps) => {\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isAzureRemoteConnectionConfig)(connectionProps)\n        ? connectionProps.tenantId\n        : LOCAL_MODE_TENANT_ID;\n};\nconst MAX_VERSION_COUNT = 5;\n/**\n * AzureClient provides the ability to have a Fluid object backed by the Azure Fluid Relay or,\n * when running with local tenantId, have it be backed by a local Azure Fluid Relay instance.\n */\nclass AzureClient {\n    /**\n     * Creates a new client instance using configuration parameters.\n     * @param props - Properties for initializing a new AzureClient instance\n     */\n    constructor(props) {\n        this.props = props;\n        // remove trailing slash from URL if any\n        props.connection.endpoint = props.connection.endpoint.replace(/\\/$/, \"\");\n        this.urlResolver = new _AzureUrlResolver__WEBPACK_IMPORTED_MODULE_1__.AzureUrlResolver();\n        // The local service implementation differs from the Azure Fluid Relay in blob\n        // storage format. Azure Fluid Relay supports whole summary upload. Local currently does not.\n        const isRemoteConnection = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isAzureRemoteConnectionConfig)(this.props.connection);\n        this.documentServiceFactory = new _fluidframework_routerlicious_driver__WEBPACK_IMPORTED_MODULE_2__.RouterliciousDocumentServiceFactory(this.props.connection.tokenProvider, { enableWholeSummaryUpload: isRemoteConnection, enableDiscovery: isRemoteConnection });\n    }\n    /**\n     * Creates a new detached container instance in the Azure Fluid Relay.\n     * @param containerSchema - Container schema for the new container.\n     * @returns New detached container instance along with associated services.\n     */\n    async createContainer(containerSchema) {\n        const loader = this.createLoader(containerSchema);\n        const container = await loader.createDetachedContainer({\n            package: \"no-dynamic-package\",\n            config: {},\n        });\n        const fluidContainer = await this.createFluidContainer(container, this.props.connection);\n        const services = this.getContainerServices(container);\n        return { container: fluidContainer, services };\n    }\n    /**\n     * Creates new detached container out of specific version of another container.\n     * @param id - Unique ID of the source container in Azure Fluid Relay.\n     * @param containerSchema - Container schema used to access data objects in the container.\n     * @param version - Unique version of the source container in Azure Fluid Relay.\n     * It defaults to latest version if parameter not provided.\n     * @returns New detached container instance along with associated services.\n     */\n    async copyContainer(id, containerSchema, version) {\n        var _a;\n        const loader = this.createLoader(containerSchema);\n        const url = new URL(this.props.connection.endpoint);\n        url.searchParams.append(\"storage\", encodeURIComponent(this.props.connection.endpoint));\n        url.searchParams.append(\"tenantId\", encodeURIComponent(getTenantId(this.props.connection)));\n        url.searchParams.append(\"containerId\", encodeURIComponent(id));\n        const sourceContainer = await loader.resolve({ url: url.href });\n        if (sourceContainer.resolvedUrl === undefined) {\n            throw new Error(\"Source container cannot resolve URL.\");\n        }\n        const documentService = await this.documentServiceFactory.createDocumentService(sourceContainer.resolvedUrl);\n        const storage = await documentService.connectToStorage();\n        const handle = {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Handle,\n            handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Tree,\n            handle: (_a = version === null || version === void 0 ? void 0 : version.id) !== null && _a !== void 0 ? _a : \"latest\",\n        };\n        const tree = await storage.downloadSummary(handle);\n        const container = await loader.rehydrateDetachedContainerFromSnapshot(JSON.stringify(tree));\n        const fluidContainer = await this.createFluidContainer(container, this.props.connection);\n        const services = this.getContainerServices(container);\n        return { container: fluidContainer, services };\n    }\n    /**\n     * Accesses the existing container given its unique ID in the Azure Fluid Relay.\n     * @param id - Unique ID of the container in Azure Fluid Relay.\n     * @param containerSchema - Container schema used to access data objects in the container.\n     * @returns Existing container instance along with associated services.\n     */\n    async getContainer(id, containerSchema) {\n        const loader = this.createLoader(containerSchema);\n        const url = new URL(this.props.connection.endpoint);\n        url.searchParams.append(\"storage\", encodeURIComponent(this.props.connection.endpoint));\n        url.searchParams.append(\"tenantId\", encodeURIComponent(getTenantId(this.props.connection)));\n        url.searchParams.append(\"containerId\", encodeURIComponent(id));\n        const container = await loader.resolve({ url: url.href });\n        const rootDataObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__.requestFluidObject)(container, \"/\");\n        const fluidContainer = new _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_5__.FluidContainer(container, rootDataObject);\n        const services = this.getContainerServices(container);\n        return { container: fluidContainer, services };\n    }\n    /**\n     * Get the list of versions for specific container.\n     * @param id - Unique ID of the source container in Azure Fluid Relay.\n     * @param options - \"Get\" options. If options are not provided, API\n     * will assume maxCount of versions to retreive to be 5.\n     * @returns Array of available container versions.\n     */\n    async getContainerVersions(id, options) {\n        var _a;\n        const url = new URL(this.props.connection.endpoint);\n        url.searchParams.append(\"storage\", encodeURIComponent(this.props.connection.endpoint));\n        url.searchParams.append(\"tenantId\", encodeURIComponent(getTenantId(this.props.connection)));\n        url.searchParams.append(\"containerId\", encodeURIComponent(id));\n        const resolvedUrl = await this.urlResolver.resolve({ url: url.href });\n        if (!resolvedUrl) {\n            throw new Error(\"Unable to resolved URL\");\n        }\n        const documentService = await this.documentServiceFactory.createDocumentService(resolvedUrl);\n        const storage = await documentService.connectToStorage();\n        // External API uses null\n        // eslint-disable-next-line unicorn/no-null\n        const versions = await storage.getVersions(null, (_a = options === null || options === void 0 ? void 0 : options.maxCount) !== null && _a !== void 0 ? _a : MAX_VERSION_COUNT);\n        return versions.map((item) => {\n            return { id: item.id, date: item.date };\n        });\n    }\n    getContainerServices(container) {\n        return {\n            audience: new _AzureAudience__WEBPACK_IMPORTED_MODULE_6__.AzureAudience(container),\n        };\n    }\n    createLoader(containerSchema) {\n        const runtimeFactory = new _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_7__.DOProviderContainerRuntimeFactory(containerSchema);\n        const load = async () => {\n            return {\n                module: { fluidExport: runtimeFactory },\n                details: { package: \"no-dynamic-package\", config: {} },\n            };\n        };\n        const codeLoader = { load };\n        return new _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_8__.Loader({\n            urlResolver: this.urlResolver,\n            documentServiceFactory: this.documentServiceFactory,\n            codeLoader,\n            logger: this.props.logger,\n        });\n    }\n    async createFluidContainer(container, connection) {\n        const createNewRequest = (0,_AzureUrlResolver__WEBPACK_IMPORTED_MODULE_1__.createAzureCreateNewRequest)(connection.endpoint, getTenantId(connection));\n        const rootDataObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__.requestFluidObject)(container, \"/\");\n        /**\n         * See {@link FluidContainer.attach}\n         */\n        const attach = async () => {\n            if (container.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_9__.AttachState.Detached) {\n                throw new Error(\"Cannot attach container. Container is not in detached state\");\n            }\n            await container.attach(createNewRequest);\n            const resolved = container.resolvedUrl;\n            (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_10__.ensureFluidResolvedUrl)(resolved);\n            return resolved.id;\n        };\n        const fluidContainer = new _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_5__.FluidContainer(container, rootDataObject);\n        fluidContainer.attach = attach;\n        return fluidContainer;\n    }\n}\n//# sourceMappingURL=AzureClient.js.map\n\n/***/ }),\n/* 328 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAzureLocalConnectionConfig\": () => (/* binding */ isAzureLocalConnectionConfig),\n/* harmony export */   \"isAzureRemoteConnectionConfig\": () => (/* binding */ isAzureRemoteConnectionConfig)\n/* harmony export */ });\n/**\n * Type guard for validating a given AzureConnectionConfig is a remote connection type (AzureRemoteConnectionConfig)\n */\nfunction isAzureRemoteConnectionConfig(connectionConfig) {\n    return connectionConfig.type === \"remote\";\n}\n/**\n * Type guard for validating a given AzureConnectionConfig is a local connection type (AzureLocalConnectionConfig)\n */\nfunction isAzureLocalConnectionConfig(connectionConfig) {\n    return connectionConfig.type === \"local\";\n}\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 329 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AzureUrlResolver\": () => (/* binding */ AzureUrlResolver),\n/* harmony export */   \"createAzureCreateNewRequest\": () => (/* binding */ createAzureCreateNewRequest)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);\n\n/**\n * Implementation of {@link @fluidframework/driver-definitions#IUrlResolver} to resolve documents stored using the\n * Azure Fluid Relay based off of the orderer and storage URLs provide.\n *\n * @remarks The token provider here can be an `InsecureTokenProvider` for basic scenarios or more robust, secure\n * providers that fulfill the {@link @fluidframework/routerlicious-driver#ITokenProvider} interface.\n */\nclass AzureUrlResolver {\n    constructor() { }\n    async resolve(request) {\n        const { ordererUrl, storageUrl, tenantId, containerId } = decodeAzureUrl(request.url);\n        // determine whether the request is for creating of a new container.\n        // such request has the `createNew` header set to true and doesn't have a container ID.\n        if (request.headers && request.headers[_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__.DriverHeader.createNew] === true) {\n            return {\n                endpoints: {\n                    deltaStorageUrl: `${ordererUrl}/deltas/${tenantId}/new`,\n                    ordererUrl,\n                    storageUrl: `${storageUrl}/repos/${tenantId}`,\n                },\n                // id is a mandatory attribute, but it's ignored by the driver for new container requests.\n                id: \"\",\n                // tokens attribute is redundant as all tokens are generated via ITokenProvider\n                tokens: {},\n                type: \"fluid\",\n                url: `${ordererUrl}/${tenantId}/new`,\n            };\n        }\n        if (containerId === undefined) {\n            throw new Error(\"Azure URL did not contain containerId\");\n        }\n        const documentUrl = `${ordererUrl}/${tenantId}/${containerId}`;\n        return {\n            endpoints: {\n                deltaStorageUrl: `${ordererUrl}/deltas/${tenantId}/${containerId}`,\n                ordererUrl,\n                storageUrl: `${storageUrl}/repos/${tenantId}`,\n            },\n            id: containerId,\n            tokens: {},\n            type: \"fluid\",\n            url: documentUrl,\n        };\n    }\n    async getAbsoluteUrl(resolvedUrl, relativeUrl) {\n        if (resolvedUrl.type !== \"fluid\") {\n            throw new Error(\"Invalid Resolved Url\");\n        }\n        return `${resolvedUrl.url}/${relativeUrl}`;\n    }\n}\nfunction decodeAzureUrl(urlString) {\n    const url = new URL(urlString);\n    const ordererUrl = url.origin;\n    const searchParams = url.searchParams;\n    const storageUrl = searchParams.get(\"storage\");\n    if (storageUrl === null) {\n        throw new Error(\"Azure URL did not contain a storage URL\");\n    }\n    const tenantId = searchParams.get(\"tenantId\");\n    if (tenantId === null) {\n        throw new Error(\"Azure URL did not contain a tenant ID\");\n    }\n    const storageUrlDecoded = decodeURIComponent(storageUrl);\n    const tenantIdDecoded = decodeURIComponent(tenantId);\n    const containerId = searchParams.get(\"containerId\");\n    const containerIdDecoded = containerId !== null ? decodeURIComponent(containerId) : undefined;\n    return {\n        ordererUrl,\n        storageUrl: storageUrlDecoded,\n        tenantId: tenantIdDecoded,\n        containerId: containerIdDecoded,\n    };\n}\nconst createAzureCreateNewRequest = (endpointUrl, tenantId) => {\n    const url = new URL(endpointUrl);\n    url.searchParams.append(\"storage\", encodeURIComponent(endpointUrl));\n    url.searchParams.append(\"tenantId\", encodeURIComponent(tenantId));\n    return {\n        url: url.href,\n        headers: {\n            [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__.DriverHeader.createNew]: true,\n        },\n    };\n};\n//# sourceMappingURL=AzureUrlResolver.js.map\n\n/***/ }),\n/* 330 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DocumentPostCreateError\": () => (/* binding */ DocumentPostCreateError),\n/* harmony export */   \"RouterliciousDocumentServiceFactory\": () => (/* binding */ RouterliciousDocumentServiceFactory)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(333);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(338);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(340);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);\n/* harmony import */ var _documentService__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(403);\n/* harmony import */ var _restWrapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(341);\n/* harmony import */ var _createNewUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(401);\n/* harmony import */ var _urlUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(334);\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(397);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\nconst defaultRouterliciousDriverPolicies = {\n    enablePrefetch: true,\n    maxConcurrentStorageRequests: 100,\n    maxConcurrentOrdererRequests: 100,\n    aggregateBlobsSmallerThanBytes: undefined,\n    enableDiscovery: false,\n    enableWholeSummaryUpload: false,\n    enableRestLess: true,\n};\n/**\n * Factory for creating the routerlicious document service. Use this if you want to\n * use the routerlicious implementation.\n */\nclass RouterliciousDocumentServiceFactory {\n    constructor(tokenProvider, driverPolicies = {}) {\n        this.tokenProvider = tokenProvider;\n        this.protocolName = \"fluid:\";\n        this.blobCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();\n        this.snapshotTreeCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();\n        this.driverPolicies = Object.assign(Object.assign({}, defaultRouterliciousDriverPolicies), driverPolicies);\n    }\n    /**\n     * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createContainer}\n     *\n     * @throws {@link DocumentPostCreateError}\n     * If an exception is thrown while invoking the provided {@link ITokenProvider.documentPostCreateCallback}.\n     */\n    async createContainer(createNewSummary, resolvedUrl, logger, clientIsSummarizer) {\n        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);\n        if (createNewSummary === undefined) {\n            throw new Error(\"Empty file summary creation isn't supported in this driver.\");\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!resolvedUrl.endpoints.ordererUrl, 0x0b2 /* \"Missing orderer URL!\" */);\n        let parsedUrl = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.parseFluidUrl)(resolvedUrl.url);\n        if (!parsedUrl.pathname) {\n            throw new Error(\"Parsed url should contain tenant and doc Id!!\");\n        }\n        const [, tenantId] = parsedUrl.pathname.split(\"/\");\n        const protocolSummary = createNewSummary.tree[\".protocol\"];\n        const appSummary = createNewSummary.tree[\".app\"];\n        if (!(protocolSummary && appSummary)) {\n            throw new Error(\"Protocol and App Summary required in the full summary\");\n        }\n        const documentAttributes = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getDocAttributesFromProtocolSummary)(protocolSummary);\n        const quorumValues = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getQuorumValuesFromProtocolSummary)(protocolSummary);\n        const logger2 = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(logger, \"RouterliciousDriver\");\n        const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);\n        const ordererRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_7__.RouterliciousOrdererRestWrapper.load(tenantId, undefined, this.tokenProvider, logger2, rateLimiter, this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl);\n        // @TODO: Remove returned \"string\" type when removing back-compat code\n        const res = await ordererRestWrapper.post(`/documents/${tenantId}`, {\n            summary: (0,_createNewUtils__WEBPACK_IMPORTED_MODULE_8__.convertSummaryToCreateNewSummary)(appSummary),\n            sequenceNumber: documentAttributes.sequenceNumber,\n            values: quorumValues,\n            enableDiscovery: this.driverPolicies.enableDiscovery,\n            generateToken: this.tokenProvider.documentPostCreateCallback !== undefined,\n        });\n        // For supporting backward compatibility, when the request has generateToken === true, it will return\n        // an object instead of string\n        // @TODO: Remove the logic when no need to support back-compat\n        let documentId;\n        let token;\n        let session;\n        if (typeof res === \"string\") {\n            documentId = res;\n        }\n        else {\n            documentId = res.id;\n            token = res.token;\n            session = this.driverPolicies.enableDiscovery ? res.session : undefined;\n        }\n        parsedUrl = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.parseFluidUrl)(resolvedUrl.url);\n        // @TODO: Remove token from the condition, checking the documentPostCreateCallback !== undefined\n        // is sufficient to determine if the token will be undefined or not.\n        if (token && this.tokenProvider.documentPostCreateCallback !== undefined) {\n            try {\n                await this.tokenProvider.documentPostCreateCallback(documentId, token);\n            }\n            catch (error) {\n                throw new DocumentPostCreateError(error);\n            }\n        }\n        parsedUrl.set(\"pathname\", (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.replaceDocumentIdInPath)(parsedUrl.pathname, documentId));\n        const deltaStorageUrl = resolvedUrl.endpoints.deltaStorageUrl;\n        if (!deltaStorageUrl) {\n            throw new Error(`All endpoints urls must be provided. [deltaStorageUrl:${deltaStorageUrl}]`);\n        }\n        const parsedDeltaStorageUrl = new URL(deltaStorageUrl);\n        parsedDeltaStorageUrl.pathname = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.replaceDocumentIdInPath)(parsedDeltaStorageUrl.pathname, documentId);\n        return this.createDocumentService(Object.assign(Object.assign({}, resolvedUrl), { url: parsedUrl.toString(), id: documentId, endpoints: Object.assign(Object.assign({}, resolvedUrl.endpoints), { deltaStorageUrl: parsedDeltaStorageUrl.toString() }) }), logger, clientIsSummarizer, session);\n    }\n    /**\n     * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createDocumentService}\n     *\n     * @returns Routerlicious document service.\n     */\n    async createDocumentService(resolvedUrl, logger, clientIsSummarizer, session) {\n        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);\n        const parsedUrl = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.parseFluidUrl)(resolvedUrl.url);\n        const [, tenantId, documentId] = parsedUrl.pathname.split(\"/\");\n        if (!documentId || !tenantId) {\n            throw new Error(`Couldn't parse documentId and/or tenantId. [documentId:${documentId}][tenantId:${tenantId}]`);\n        }\n        const logger2 = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(logger, \"RouterliciousDriver\", { all: { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_9__.pkgVersion } });\n        const discoverFluidResolvedUrl = async () => {\n            if (!this.driverPolicies.enableDiscovery) {\n                return resolvedUrl;\n            }\n            const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);\n            const ordererRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_7__.RouterliciousOrdererRestWrapper.load(tenantId, documentId, this.tokenProvider, logger2, rateLimiter, this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl);\n            // The service responds with the current document session associated with the container.\n            const discoveredSession = await ordererRestWrapper.get(`/documents/${tenantId}/session/${documentId}`);\n            return (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.getDiscoveredFluidResolvedUrl)(resolvedUrl, discoveredSession);\n        };\n        const fluidResolvedUrl = session !== undefined\n            ? (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.getDiscoveredFluidResolvedUrl)(resolvedUrl, session)\n            : await discoverFluidResolvedUrl();\n        const storageUrl = fluidResolvedUrl.endpoints.storageUrl;\n        const ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;\n        const deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;\n        if (!ordererUrl || !deltaStorageUrl) {\n            throw new Error(`All endpoints urls must be provided. [ordererUrl:${ordererUrl}][deltaStorageUrl:${deltaStorageUrl}]`);\n        }\n        return new _documentService__WEBPACK_IMPORTED_MODULE_10__.DocumentService(fluidResolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger2, this.tokenProvider, tenantId, documentId, this.driverPolicies, this.blobCache, this.snapshotTreeCache, discoverFluidResolvedUrl);\n    }\n}\n/**\n * Error returned by {@link RouterliciousDocumentServiceFactory.createContainer} when an error is thrown\n * in {@link ITokenProvider.documentPostCreateCallback}.\n * It is the consumer's responsibility to ensure that any state related to container creation is appropriately\n * cleaned up in the event of failure.\n * This includes the document itself, which will have been created by the time this error was thrown.\n *\n * @remarks TODO: examples of suggested actions for recovery.\n * - How would a user delete the created document?\n * - What would a retry pattern look like here?\n */\nclass DocumentPostCreateError extends Error {\n    constructor(\n    /**\n     * Inner error being wrapped.\n     */\n    innerError) {\n        super(innerError.message);\n        this.innerError = innerError;\n        this.name = \"DocumentPostCreateError\";\n    }\n    get stack() { return this.innerError.stack; }\n}\n//# sourceMappingURL=documentServiceFactory.js.map\n\n/***/ }),\n/* 331 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InMemoryCache\": () => (/* binding */ InMemoryCache)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nclass InMemoryCache {\n    constructor() {\n        this.cache = new Map();\n    }\n    async get(key) {\n        return this.cache.get(key);\n    }\n    async put(key, value) {\n        this.cache.set(key, value);\n    }\n}\n//# sourceMappingURL=cache.js.map\n\n/***/ }),\n/* 332 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ensureFluidResolvedUrl\": () => (/* binding */ ensureFluidResolvedUrl),\n/* harmony export */   \"isFluidResolvedUrl\": () => (/* binding */ isFluidResolvedUrl)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst isFluidResolvedUrl = (resolved) => (resolved === null || resolved === void 0 ? void 0 : resolved.type) === \"fluid\";\nfunction ensureFluidResolvedUrl(resolved) {\n    if (!isFluidResolvedUrl(resolved)) {\n        throw new Error(`resolved is not a Fluid url. Type: ${resolved === null || resolved === void 0 ? void 0 : resolved.type}`);\n    }\n}\n//# sourceMappingURL=fluidResolvedUrl.js.map\n\n/***/ }),\n/* 333 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 334 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDiscoveredFluidResolvedUrl\": () => (/* binding */ getDiscoveredFluidResolvedUrl),\n/* harmony export */   \"parseFluidUrl\": () => (/* binding */ parseFluidUrl),\n/* harmony export */   \"replaceDocumentIdInPath\": () => (/* binding */ replaceDocumentIdInPath)\n/* harmony export */ });\n/* harmony import */ var url_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(335);\n/* harmony import */ var url_parse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_parse__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nconst parseFluidUrl = (fluidUrl) => {\n    return new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(fluidUrl, true);\n};\n/**\n * Assume documentId is at end of url path.\n * This is true for Routerlicious' and Tinylicious' documentUrl and deltaStorageUrl.\n * Routerlicious and Tinylicious do not use documentId in storageUrl nor ordererUrl.\n * TODO: Ideally we would be able to regenerate the resolvedUrl, rather than patching the current one.\n */\nconst replaceDocumentIdInPath = (urlPath, documentId) => urlPath.split(\"/\").slice(0, -1).concat([documentId]).join(\"/\");\nconst getDiscoveredFluidResolvedUrl = (resolvedUrl, session) => {\n    if (session) {\n        const discoveredOrdererUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(session.ordererUrl);\n        const deltaStorageUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(resolvedUrl.endpoints.deltaStorageUrl);\n        deltaStorageUrl.set(\"host\", discoveredOrdererUrl.host);\n        const discoveredStorageUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(session.historianUrl);\n        const storageUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(resolvedUrl.endpoints.storageUrl);\n        storageUrl.set(\"host\", discoveredStorageUrl.host);\n        const parsedUrl = parseFluidUrl(resolvedUrl.url);\n        const discoveredResolvedUrl = {\n            endpoints: {\n                deltaStorageUrl: deltaStorageUrl.toString(),\n                ordererUrl: session.ordererUrl,\n                storageUrl: storageUrl.toString(),\n            },\n            id: resolvedUrl.id,\n            tokens: resolvedUrl.tokens,\n            type: resolvedUrl.type,\n            url: new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(`fluid://${discoveredOrdererUrl.host}${parsedUrl.pathname}`).toString(),\n        };\n        return discoveredResolvedUrl;\n    }\n    else {\n        return resolvedUrl;\n    }\n};\n//# sourceMappingURL=urlUtils.js.map\n\n/***/ }),\n/* 335 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar required = __webpack_require__(336)\n  , qs = __webpack_require__(337)\n  , controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/\n  , CRHTLF = /[\\n\\r\\t]/g\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , port = /:\\d+$/\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n  , windowsDriveLetter = /^[a-zA-Z]:/;\n\n/**\n * Remove control characters and whitespace from the beginning of a string.\n *\n * @param {Object|String} str String to trim.\n * @returns {String} A new string representing `str` stripped of control\n *     characters and whitespace from its beginning.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(controlOrWhitespace, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4]\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@'\n        ? address.lastIndexOf(parse)\n        : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password))\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username +':'+ url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (port.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.auth = url.password ? url.username +':'+ url.password : url.username;\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , host = url.host\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result =\n    protocol +\n    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  } else if (url.password) {\n    result += ':'+ url.password;\n    result += '@';\n  } else if (\n    url.protocol !== 'file:' &&\n    isSpecial(url.protocol) &&\n    !host &&\n    url.pathname !== '/'\n  ) {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  }\n\n  //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {\n    host += ':';\n  }\n\n  result += host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n\n\n/***/ }),\n/* 336 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n\n/***/ }),\n/* 337 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n\n/***/ }),\n/* 338 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"combineAppAndProtocolSummary\": () => (/* binding */ combineAppAndProtocolSummary),\n/* harmony export */   \"getDocAttributesFromProtocolSummary\": () => (/* binding */ getDocAttributesFromProtocolSummary),\n/* harmony export */   \"getQuorumValuesFromProtocolSummary\": () => (/* binding */ getQuorumValuesFromProtocolSummary)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Combine the app summary and protocol summary in 1 tree.\n * @param appSummary - Summary of the app.\n * @param protocolSummary - Summary of the protocol.\n */\nfunction combineAppAndProtocolSummary(appSummary, protocolSummary) {\n    const createNewSummary = {\n        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,\n        tree: {\n            \".protocol\": protocolSummary,\n            \".app\": appSummary,\n        },\n    };\n    return createNewSummary;\n}\n/**\n * Extract the attributes from the protocol summary.\n * @param protocolSummary - protocol summary from which the values are to be extracted.\n */\nfunction getDocAttributesFromProtocolSummary(protocolSummary) {\n    var _a;\n    const attributesBlob = protocolSummary.tree.attributes;\n    const documentAttributes = JSON.parse(attributesBlob.content);\n    documentAttributes.term = (_a = documentAttributes.term) !== null && _a !== void 0 ? _a : 1;\n    return documentAttributes;\n}\n/**\n * Extract quorum values from the protocol summary.\n * @param protocolSummary - protocol summary from which the values are to be extracted.\n */\nfunction getQuorumValuesFromProtocolSummary(protocolSummary) {\n    const quorumValuesBlob = protocolSummary.tree.quorumValues;\n    const quorumValues = JSON.parse(quorumValuesBlob.content);\n    return quorumValues;\n}\n//# sourceMappingURL=summaryForCreateNew.js.map\n\n/***/ }),\n/* 339 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 340 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RateLimiter\": () => (/* binding */ RateLimiter)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass RateLimiter {\n    constructor(maxRequests) {\n        this.maxRequests = maxRequests;\n        this.tasks = [];\n        // Run when one of the tasks finished running.\n        // Release next task if we have one, or allow more tasks to run in future.\n        this.release = () => {\n            const task = this.tasks.shift();\n            if (task !== undefined) {\n                return task();\n            }\n            this.maxRequests++;\n        };\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(maxRequests > 0, 0x0ae /* \"Tried to create rate limiter with 0 max requests!\" */);\n    }\n    get waitQueueLength() {\n        return this.tasks.length;\n    }\n    async acquire() {\n        if (this.maxRequests > 0) {\n            this.maxRequests--;\n            return;\n        }\n        return new Promise((resolve) => {\n            this.tasks.push(resolve);\n        });\n    }\n    async schedule(work) {\n        await this.acquire();\n        return work().finally(this.release);\n    }\n}\n//# sourceMappingURL=rateLimiter.js.map\n\n/***/ }),\n/* 341 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RouterliciousOrdererRestWrapper\": () => (/* binding */ RouterliciousOrdererRestWrapper),\n/* harmony export */   \"RouterliciousRestWrapper\": () => (/* binding */ RouterliciousRestWrapper),\n/* harmony export */   \"RouterliciousStorageRestWrapper\": () => (/* binding */ RouterliciousStorageRestWrapper)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(398);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(344);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(395);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(400);\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(342);\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(343);\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(27);\n/* harmony import */ var _errorUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(396);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(397);\n\n\n\n\n\n\n\nconst axiosRequestConfigToFetchRequestConfig = (requestConfig) => {\n    var _a, _b;\n    const requestInfo = requestConfig.baseURL !== undefined\n        ? `${requestConfig.baseURL}${(_a = requestConfig.url) !== null && _a !== void 0 ? _a : \"\"}`\n        : (_b = requestConfig.url) !== null && _b !== void 0 ? _b : \"\";\n    const requestInit = {\n        method: requestConfig.method,\n        // NOTE: I believe that although the Axios type permits non-string values in the header, here we are\n        // guaranteed the requestConfig only has string values in its header.\n        headers: requestConfig.headers,\n        body: requestConfig.data,\n    };\n    return [requestInfo, requestInit];\n};\nclass RouterliciousRestWrapper extends _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_2__.RestWrapper {\n    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {\n        super(baseurl, defaultQueryString);\n        this.rateLimiter = rateLimiter;\n        this.getAuthorizationHeader = getAuthorizationHeader;\n        this.useRestLess = useRestLess;\n        this.restLess = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_3__.RestLessClient();\n    }\n    async load() {\n        this.authorizationHeader = await this.getAuthorizationHeader();\n    }\n    async request(requestConfig, statusCode, canRetry = true) {\n        var _a;\n        const config = Object.assign(Object.assign({}, requestConfig), { headers: this.generateHeaders(requestConfig.headers) });\n        const translatedConfig = this.useRestLess ? this.restLess.translate(config) : config;\n        const fetchRequestConfig = axiosRequestConfigToFetchRequestConfig(translatedConfig);\n        const response = await this.rateLimiter.schedule(async () => cross_fetch__WEBPACK_IMPORTED_MODULE_0___default()(...fetchRequestConfig)\n            .catch(async (error) => {\n            // Browser Fetch throws a TypeError on network error, `node-fetch` throws a FetchError\n            const isNetworkError = [\"TypeError\", \"FetchError\"].includes(error === null || error === void 0 ? void 0 : error.name);\n            (0,_errorUtils__WEBPACK_IMPORTED_MODULE_4__.throwR11sNetworkError)(isNetworkError ? `NetworkError: ${error.message}` : json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default()(error));\n        }));\n        const responseBody = ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\"))\n            ? await response.json()\n            : await response.text();\n        // Success\n        if (response.ok || response.status === statusCode) {\n            const result = responseBody;\n            return result;\n        }\n        // Failure\n        if (response.status === 401 && canRetry) {\n            // Refresh Authorization header and retry once\n            this.authorizationHeader = await this.getAuthorizationHeader(true /* refreshToken */);\n            return this.request(config, statusCode, false);\n        }\n        if (response.status === 429 && (responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter) > 0) {\n            // Retry based on retryAfter[Seconds]\n            return new Promise((resolve, reject) => setTimeout(() => {\n                this.request(config, statusCode)\n                    .then(resolve)\n                    .catch(reject);\n            }, responseBody.retryAfter * 1000));\n        }\n        const responseSummary = responseBody !== undefined\n            ? typeof responseBody === \"string\" ? responseBody : json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default()(responseBody)\n            : response.statusText;\n        (0,_errorUtils__WEBPACK_IMPORTED_MODULE_4__.throwR11sNetworkError)(`R11s fetch error: ${responseSummary}`, response.status, responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter);\n    }\n    generateHeaders(requestHeaders) {\n        const correlationId = (requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[\"x-correlation-id\"]) || (0,uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n        return Object.assign(Object.assign({}, requestHeaders), { \n            // TODO: replace header names with CorrelationIdHeaderName and DriverVersionHeaderName from services-client\n            // NOTE: Can correlationId actually be number | true?\n            \"x-correlation-id\": correlationId, \"x-driver-version\": _packageVersion__WEBPACK_IMPORTED_MODULE_6__.pkgVersion, \n            // NOTE: If this.authorizationHeader is undefined, should \"Authorization\" be removed entirely?\n            \"Authorization\": this.authorizationHeader });\n    }\n}\nclass RouterliciousStorageRestWrapper extends RouterliciousRestWrapper {\n    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {\n        super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);\n    }\n    static async load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {\n        const defaultQueryString = {\n            token: `${(0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.fromUtf8ToBase64)(tenantId)}`,\n        };\n        const getAuthorizationHeader = async (refreshToken) => {\n            // Craft credentials using tenant id and token\n            const storageToken = await tokenProvider.fetchStorageToken(tenantId, documentId, refreshToken);\n            const credentials = {\n                password: storageToken.jwt,\n                user: tenantId,\n            };\n            return (0,_fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_8__.getAuthorizationTokenFromCredentials)(credentials);\n        };\n        const restWrapper = new RouterliciousStorageRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);\n        try {\n            await restWrapper.load();\n        }\n        catch (e) {\n            logger.sendErrorEvent({\n                eventName: \"R11sRestWrapperLoadFailure\",\n            }, e);\n            await restWrapper.load();\n        }\n        return restWrapper;\n    }\n}\nclass RouterliciousOrdererRestWrapper extends RouterliciousRestWrapper {\n    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {\n        super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);\n    }\n    static async load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {\n        const getAuthorizationHeader = async (refreshToken) => {\n            const ordererToken = await tokenProvider.fetchOrdererToken(tenantId, documentId, refreshToken);\n            return `Basic ${ordererToken.jwt}`;\n        };\n        const restWrapper = new RouterliciousOrdererRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl);\n        try {\n            await restWrapper.load();\n        }\n        catch (e) {\n            logger.sendErrorEvent({\n                eventName: \"R11sRestWrapperLoadFailure\",\n            }, e);\n            await restWrapper.load();\n        }\n        return restWrapper;\n    }\n}\n//# sourceMappingURL=restWrapper.js.map\n\n/***/ }),\n/* 342 */\n/***/ (function(module, exports) {\n\nvar global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n\n\n/***/ }),\n/* 343 */\n/***/ ((module, exports) => {\n\nexports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n\n\n/***/ }),\n/* 344 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasicRestWrapper\": () => (/* binding */ BasicRestWrapper),\n/* harmony export */   \"RestWrapper\": () => (/* binding */ RestWrapper)\n/* harmony export */ });\n/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(343);\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(348);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(388);\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(394);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(393);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\nclass RestWrapper {\n    constructor(baseurl, defaultQueryString = {}, maxBodyLength = 1000 * 1024 * 1024, maxContentLength = 1000 * 1024 * 1024) {\n        this.baseurl = baseurl;\n        this.defaultQueryString = defaultQueryString;\n        this.maxBodyLength = maxBodyLength;\n        this.maxContentLength = maxContentLength;\n    }\n    async get(url, queryString, headers) {\n        const options = {\n            baseURL: this.baseurl,\n            headers,\n            maxBodyLength: this.maxBodyLength,\n            maxContentLength: this.maxContentLength,\n            method: \"GET\",\n            url: `${url}${this.generateQueryString(queryString)}`,\n        };\n        return this.request(options, 200);\n    }\n    async post(url, requestBody, queryString, headers) {\n        const options = {\n            baseURL: this.baseurl,\n            data: requestBody,\n            headers,\n            maxBodyLength: this.maxBodyLength,\n            maxContentLength: this.maxContentLength,\n            method: \"POST\",\n            url: `${url}${this.generateQueryString(queryString)}`,\n        };\n        return this.request(options, 201);\n    }\n    async delete(url, queryString, headers) {\n        const options = {\n            baseURL: this.baseurl,\n            headers,\n            maxBodyLength: this.maxBodyLength,\n            maxContentLength: this.maxContentLength,\n            method: \"DELETE\",\n            url: `${url}${this.generateQueryString(queryString)}`,\n        };\n        return this.request(options, 204);\n    }\n    async patch(url, requestBody, queryString, headers) {\n        const options = {\n            baseURL: this.baseurl,\n            data: requestBody,\n            headers,\n            maxBodyLength: this.maxBodyLength,\n            maxContentLength: this.maxContentLength,\n            method: \"PATCH\",\n            url: `${url}${this.generateQueryString(queryString)}`,\n        };\n        return this.request(options, 200);\n    }\n    generateQueryString(queryStringValues) {\n        if (this.defaultQueryString || queryStringValues) {\n            const queryStringMap = Object.assign(Object.assign({}, this.defaultQueryString), queryStringValues);\n            const queryString = querystring__WEBPACK_IMPORTED_MODULE_0__.stringify(queryStringMap);\n            if (queryString !== \"\") {\n                return `?${queryString}`;\n            }\n        }\n        return \"\";\n    }\n}\nclass BasicRestWrapper extends RestWrapper {\n    constructor(baseurl, defaultQueryString = {}, maxBodyLength = 1000 * 1024 * 1024, maxContentLength = 1000 * 1024 * 1024, defaultHeaders = {}, axios = (axios__WEBPACK_IMPORTED_MODULE_2___default()), refreshDefaultQueryString, refreshDefaultHeaders, getCorrelationId) {\n        super(baseurl, defaultQueryString, maxBodyLength, maxContentLength);\n        this.defaultHeaders = defaultHeaders;\n        this.axios = axios;\n        this.refreshDefaultQueryString = refreshDefaultQueryString;\n        this.refreshDefaultHeaders = refreshDefaultHeaders;\n        this.getCorrelationId = getCorrelationId;\n    }\n    async request(requestConfig, statusCode, canRetry = true) {\n        var _a, _b;\n        const options = Object.assign({}, requestConfig);\n        options.headers = this.generateHeaders(options.headers, (_b = (_a = this.getCorrelationId) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])());\n        return new Promise((resolve, reject) => {\n            this.axios.request(options)\n                .then((response) => { resolve(response.data); })\n                .catch((error) => {\n                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n                if (((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) === statusCode) {\n                    // Axios misinterpreted as error, return as successful response\n                    resolve((_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.data);\n                }\n                if (error === null || error === void 0 ? void 0 : error.config) {\n                    // eslint-disable-next-line max-len\n                    (0,_debug__WEBPACK_IMPORTED_MODULE_4__.debug)(`[${error.config.method}] request to [${(_c = error.config.baseURL) !== null && _c !== void 0 ? _c : \"\"}${(_d = error.config.url) !== null && _d !== void 0 ? _d : \"\"}] failed with [${(_e = error.response) === null || _e === void 0 ? void 0 : _e.status}] [${json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default()((_f = error.response) === null || _f === void 0 ? void 0 : _f.data, undefined, 2)}]`);\n                }\n                else {\n                    (0,_debug__WEBPACK_IMPORTED_MODULE_4__.debug)(`request to ${options.url} failed ${error ? error.message : \"\"}`);\n                }\n                if (((_g = error === null || error === void 0 ? void 0 : error.response) === null || _g === void 0 ? void 0 : _g.status) === 429 && ((_j = (_h = error === null || error === void 0 ? void 0 : error.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.retryAfter) > 0 && canRetry) {\n                    setTimeout(() => {\n                        this.request(options, statusCode)\n                            .then(resolve)\n                            .catch(reject);\n                    }, error.response.data.retryAfter * 1000);\n                }\n                else if (((_k = error === null || error === void 0 ? void 0 : error.response) === null || _k === void 0 ? void 0 : _k.status) === 401 && canRetry && this.refreshOnAuthError()) {\n                    const retryConfig = Object.assign({}, requestConfig);\n                    retryConfig.headers = this.generateHeaders(retryConfig.headers, options.headers[_constants__WEBPACK_IMPORTED_MODULE_5__.CorrelationIdHeaderName]);\n                    this.request(retryConfig, statusCode, false)\n                        .then(resolve)\n                        .catch(reject);\n                }\n                else {\n                    // From https://axios-http.com/docs/handling_errors\n                    if (error === null || error === void 0 ? void 0 : error.response) {\n                        // The request was made and the server responded with a status code\n                        // that falls out of the range of 2xx\n                        reject((0,_error__WEBPACK_IMPORTED_MODULE_6__.createFluidServiceNetworkError)((_l = error === null || error === void 0 ? void 0 : error.response) === null || _l === void 0 ? void 0 : _l.status, (_m = error === null || error === void 0 ? void 0 : error.response) === null || _m === void 0 ? void 0 : _m.data));\n                    }\n                    else if (error === null || error === void 0 ? void 0 : error.request) {\n                        // The request was made but no response was received. That can happen if a service is\n                        // temporarily down or inaccessible due to network failures. We leverage that in here\n                        // to detect network failures and transform them into a NetworkError with code 502,\n                        // which can be retried and is not fatal.\n                        reject((0,_error__WEBPACK_IMPORTED_MODULE_6__.createFluidServiceNetworkError)(502, `Network Error: ${(_o = error === null || error === void 0 ? void 0 : error.message) !== null && _o !== void 0 ? _o : \"undefined\"}`));\n                    }\n                    else {\n                        // Something happened in setting up the request that triggered an Error\n                        const details = {\n                            canRetry: false,\n                            isFatal: false,\n                            message: (_p = error === null || error === void 0 ? void 0 : error.message) !== null && _p !== void 0 ? _p : \"Unknown Error\",\n                        };\n                        reject((0,_error__WEBPACK_IMPORTED_MODULE_6__.createFluidServiceNetworkError)(500, details));\n                    }\n                }\n            });\n        });\n    }\n    generateHeaders(headers, fallbackCorrelationId) {\n        let result = headers !== null && headers !== void 0 ? headers : {};\n        if (this.defaultHeaders) {\n            result = Object.assign(Object.assign({}, this.defaultHeaders), headers);\n        }\n        if (result[_constants__WEBPACK_IMPORTED_MODULE_5__.CorrelationIdHeaderName]) {\n            return result;\n        }\n        return Object.assign({ [_constants__WEBPACK_IMPORTED_MODULE_5__.CorrelationIdHeaderName]: fallbackCorrelationId }, result);\n    }\n    refreshOnAuthError() {\n        if (this.refreshDefaultQueryString === undefined && this.refreshDefaultHeaders === undefined) {\n            // retry will not succeed with the same params and headers\n            return false;\n        }\n        if (this.refreshDefaultHeaders !== undefined) {\n            this.defaultHeaders = this.refreshDefaultHeaders();\n        }\n        if (this.refreshDefaultQueryString !== undefined) {\n            this.defaultQueryString = this.refreshDefaultQueryString();\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=restWrapper.js.map\n\n/***/ }),\n/* 345 */\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nexports.decode = exports.parse = __webpack_require__(346);\nexports.encode = exports.stringify = __webpack_require__(347);\n\n\n/***/ }),\n/* 346 */\n/***/ ((module) => {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n\n/***/ }),\n/* 347 */\n/***/ ((module) => {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).filter(Boolean).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n\n/***/ }),\n/* 348 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nmodule.exports = __webpack_require__(349);\n\n/***/ }),\n/* 349 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar bind = __webpack_require__(351);\nvar Axios = __webpack_require__(352);\nvar mergeConfig = __webpack_require__(382);\nvar defaults = __webpack_require__(362);\nvar formDataToJSON = __webpack_require__(370);\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = __webpack_require__(379);\naxios.CancelToken = __webpack_require__(385);\naxios.isCancel = __webpack_require__(381);\naxios.VERSION = (__webpack_require__(384).version);\naxios.toFormData = __webpack_require__(355);\n\n// Expose AxiosError class\naxios.AxiosError = __webpack_require__(356);\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(386);\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(387);\n\naxios.formToJSON = function(thing) {\n  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n};\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n\n\n/***/ }),\n/* 350 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar bind = __webpack_require__(351);\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n// eslint-disable-next-line func-names\nvar kindOf = (function(cache) {\n  // eslint-disable-next-line func-names\n  return function(thing) {\n    var str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n  };\n})(Object.create(null));\n\nfunction kindOfTest(type) {\n  type = type.toLowerCase();\n  return function isKindOf(thing) {\n    return kindOf(thing) === type;\n  };\n}\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a empty Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a empty Object, otherwise false\n */\nfunction isEmptyObject(val) {\n  return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nvar isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nvar isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} thing The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(thing) {\n  var pattern = '[object FormData]';\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) ||\n    toString.call(thing) === pattern ||\n    (isFunction(thing.toString) && thing.toString() === pattern)\n  );\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  var product;\n  if (typeof navigator !== 'undefined' && (\n    (product = navigator.product) === 'ReactNative' ||\n    product === 'NativeScript' ||\n    product === 'NS')\n  ) {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n */\n\nfunction inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n * @returns {Object}\n */\n\nfunction toFlatObject(sourceObj, destObj, filter, propFilter) {\n  var props;\n  var i;\n  var prop;\n  var merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && Object.getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/*\n * determines whether a string ends with the characters of a specified string\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n * @returns {boolean}\n */\nfunction endsWith(str, searchString, position) {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  var lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n * @param {*} [thing]\n * @returns {?Array}\n */\nfunction toArray(thing) {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  var i = thing.length;\n  if (!isNumber(i)) return null;\n  var arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n// eslint-disable-next-line func-names\nvar isTypedArray = (function(TypedArray) {\n  // eslint-disable-next-line func-names\n  return function(thing) {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));\n\nfunction forEachEntry(obj, fn) {\n  var generator = obj && obj[Symbol.iterator];\n\n  var iterator = generator.call(obj);\n\n  var result;\n\n  while ((result = iterator.next()) && !result.done) {\n    var pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\nfunction matchAll(regExp, str) {\n  var matches;\n  var arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\nvar isHTMLForm = kindOfTest('HTMLFormElement');\n\nvar hasOwnProperty = (function resolver(_hasOwnProperty) {\n  return function(obj, prop) {\n    return _hasOwnProperty.call(obj, prop);\n  };\n})(Object.prototype.hasOwnProperty);\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isEmptyObject: isEmptyObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM,\n  inherits: inherits,\n  toFlatObject: toFlatObject,\n  kindOf: kindOf,\n  kindOfTest: kindOfTest,\n  endsWith: endsWith,\n  toArray: toArray,\n  isTypedArray: isTypedArray,\n  isFileList: isFileList,\n  forEachEntry: forEachEntry,\n  matchAll: matchAll,\n  isHTMLForm: isHTMLForm,\n  hasOwnProperty: hasOwnProperty\n};\n\n\n/***/ }),\n/* 351 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n};\n\n\n/***/ }),\n/* 352 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar buildURL = __webpack_require__(353);\nvar InterceptorManager = __webpack_require__(359);\nvar dispatchRequest = __webpack_require__(360);\nvar mergeConfig = __webpack_require__(382);\nvar buildFullPath = __webpack_require__(374);\nvar validator = __webpack_require__(383);\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n * @param {?Object} config\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  var paramsSerializer = config.paramsSerializer;\n\n  utils.isFunction(paramsSerializer) && (config.paramsSerializer = {serialize: paramsSerializer});\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  var fullPath = buildFullPath(config.baseURL, config.url);\n  return buildURL(fullPath, config.params, config.paramsSerializer);\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method: method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url: url,\n        data: data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nmodule.exports = Axios;\n\n\n/***/ }),\n/* 353 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar AxiosURLSearchParams = __webpack_require__(354);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var hashmarkIndex = url.indexOf('#');\n\n  if (hashmarkIndex !== -1) {\n    url = url.slice(0, hashmarkIndex);\n  }\n\n  var _encode = options && options.encode || encode;\n\n  var serializerParams = utils.isURLSearchParams(params) ?\n    params.toString() :\n    new AxiosURLSearchParams(params, options).toString(_encode);\n\n  if (serializerParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializerParams;\n  }\n\n  return url;\n};\n\n\n/***/ }),\n/* 354 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar toFormData = __webpack_require__(355);\n\nfunction encode(str) {\n  var charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'\\(\\)~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nvar prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  var _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nmodule.exports = AxiosURLSearchParams;\n\n\n/***/ }),\n/* 355 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar AxiosError = __webpack_require__(356);\nvar envFormData = __webpack_require__(357);\n\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nvar predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\nfunction isSpecCompliant(thing) {\n  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];\n}\n\n/**\n * Convert a data object to FormData\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n * @returns {Object}\n **/\n\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (envFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  var metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  var visitor = options.visitor || defaultVisitor;\n  var dots = options.dots;\n  var indexes = options.indexes;\n  var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  var useBlob = _Blob && isSpecCompliant(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    var arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !utils.isUndefined(el) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  var stack = [];\n\n  var exposedHelpers = Object.assign(predicates, {\n    defaultVisitor: defaultVisitor,\n    convertValue: convertValue,\n    isVisitable: isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      var result = !utils.isUndefined(el) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nmodule.exports = toFormData;\n\n\n/***/ }),\n/* 356 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nvar prototype = AxiosError.prototype;\nvar descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(function(code) {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = function(error, code, config, request, response, customProps) {\n  var axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nmodule.exports = AxiosError;\n\n\n/***/ }),\n/* 357 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n// eslint-disable-next-line strict\nmodule.exports = __webpack_require__(358);\n\n\n/***/ }),\n/* 358 */\n/***/ ((module) => {\n\n/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n\n\n/***/ }),\n/* 359 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Clear all interceptors from the stack\n */\nInterceptorManager.prototype.clear = function clear() {\n  if (this.handlers) {\n    this.handlers = [];\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n/***/ }),\n/* 360 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar transformData = __webpack_require__(361);\nvar isCancel = __webpack_require__(381);\nvar defaults = __webpack_require__(362);\nvar CanceledError = __webpack_require__(379);\nvar normalizeHeaderName = __webpack_require__(363);\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    null,\n    config.transformRequest\n  );\n\n  normalizeHeaderName(config.headers, 'Accept');\n  normalizeHeaderName(config.headers, 'Content-Type');\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      response.status,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          reason.response.status,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n/***/ }),\n/* 361 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar defaults = __webpack_require__(362);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Number} status HTTP status code\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, status, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers, status);\n  });\n\n  return data;\n};\n\n\n/***/ }),\n/* 362 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar normalizeHeaderName = __webpack_require__(363);\nvar AxiosError = __webpack_require__(356);\nvar transitionalDefaults = __webpack_require__(364);\nvar toFormData = __webpack_require__(355);\nvar toURLEncodedForm = __webpack_require__(365);\nvar platform = __webpack_require__(366);\nvar formDataToJSON = __webpack_require__(370);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(371);\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(371);\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    var contentType = headers && headers['Content-Type'] || '';\n    var hasJSONContentType = contentType.indexOf('application/json') > -1;\n    var isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    var isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    var isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') !== -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        var _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var JSONRequested = this.responseType === 'json';\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      var silentJSONParsing = transitional && transitional.silentJSONParsing;\n      var strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n/***/ }),\n/* 363 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n/***/ }),\n/* 364 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nmodule.exports = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\n\n/***/ }),\n/* 365 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar toFormData = __webpack_require__(355);\nvar platform = __webpack_require__(366);\n\nmodule.exports = function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n};\n\n\n/***/ }),\n/* 366 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(367);\n\n\n/***/ }),\n/* 367 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nmodule.exports = {\n  isBrowser: true,\n  classes: {\n    URLSearchParams: __webpack_require__(368),\n    FormData: __webpack_require__(369),\n    Blob: Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n\n\n/***/ }),\n/* 368 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar AxiosURLSearchParams = __webpack_require__(354);\n\nmodule.exports = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n\n\n/***/ }),\n/* 369 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nmodule.exports = FormData;\n\n\n/***/ }),\n/* 370 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(function(match) {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\nfunction arrayToObject(arr) {\n  var obj = {};\n  var keys = Object.keys(arr);\n  var i;\n  var len = keys.length;\n  var key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    var name = path[index++];\n    var isNumericKey = Number.isFinite(+name);\n    var isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProperty(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    var result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    var obj = {};\n\n    utils.forEachEntry(formData, function(name, value) {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nmodule.exports = formDataToJSON;\n\n\n/***/ }),\n/* 371 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\nvar settle = __webpack_require__(372);\nvar cookies = __webpack_require__(373);\nvar buildURL = __webpack_require__(353);\nvar buildFullPath = __webpack_require__(374);\nvar parseHeaders = __webpack_require__(377);\nvar isURLSameOrigin = __webpack_require__(378);\nvar transitionalDefaults = __webpack_require__(364);\nvar AxiosError = __webpack_require__(356);\nvar CanceledError = __webpack_require__(379);\nvar parseProtocol = __webpack_require__(380);\nvar platform = __webpack_require__(366);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var withXSRFToken = config.withXSRFToken;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {\n        // Add xsrf header\n        var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n        if (xsrfValue) {\n          requestHeaders[config.xsrfHeaderName] = xsrfValue;\n        }\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, req) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    // false, 0 (zero number), and '' (empty string) are valid JSON values\n    if (!requestData && requestData !== false && requestData !== 0 && requestData !== '') {\n      requestData = null;\n    }\n\n    var protocol = parseProtocol(fullPath);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n/***/ }),\n/* 372 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar AxiosError = __webpack_require__(356);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n/***/ }),\n/* 373 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n/***/ }),\n/* 374 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar isAbsoluteURL = __webpack_require__(375);\nvar combineURLs = __webpack_require__(376);\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n/***/ }),\n/* 375 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};\n\n\n/***/ }),\n/* 376 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n/***/ }),\n/* 377 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.slice(0, i)).toLowerCase();\n    val = utils.trim(line.slice(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n/***/ }),\n/* 378 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n      * Parse a URL to discover it's components\n      *\n      * @param {String} url The URL to be parsed\n      * @returns {Object}\n      */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n          // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n      * Determine if a URL shares the same origin as the current location\n      *\n      * @param {String} requestURL The URL to test\n      * @returns {boolean} True if URL shares the same origin, otherwise false\n      */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n    // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n/***/ }),\n/* 379 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar AxiosError = __webpack_require__(356);\nvar utils = __webpack_require__(350);\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nmodule.exports = CanceledError;\n\n\n/***/ }),\n/* 380 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nmodule.exports = function parseProtocol(url) {\n  var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n};\n\n\n/***/ }),\n/* 381 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n/***/ }),\n/* 382 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isEmptyObject(source)) {\n      return utils.merge({}, target);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'withXSRFToken': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'beforeRedirect': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n\n\n/***/ }),\n/* 383 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar VERSION = (__webpack_require__(384).version);\nvar AxiosError = __webpack_require__(356);\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n\n/***/ }),\n/* 384 */\n/***/ ((module) => {\n\nmodule.exports = {\n  \"version\": \"0.28.0\"\n};\n\n/***/ }),\n/* 385 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar CanceledError = __webpack_require__(379);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i = token._listeners.length;\n\n    while (i-- > 0) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message, config, request) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new CanceledError(message, config, request);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n/***/ }),\n/* 386 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n/***/ }),\n/* 387 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(350);\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n};\n\n\n/***/ }),\n/* 388 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debug\": () => (/* binding */ debug)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(389);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(392);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nconst debug = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(\"fluid:services-client\");\ndebug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);\n//# sourceMappingURL=debug.js.map\n\n/***/ }),\n/* 389 */\n/***/ ((module, exports, __webpack_require__) => {\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(390)(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n/***/ }),\n/* 390 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(391);\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n/***/ }),\n/* 391 */\n/***/ ((module) => {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n/***/ }),\n/* 392 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/server-services-client\";\nconst pkgVersion = \"0.1036.5001\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 393 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CorrelationIdHeaderName\": () => (/* binding */ CorrelationIdHeaderName),\n/* harmony export */   \"DriverVersionHeaderName\": () => (/* binding */ DriverVersionHeaderName)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst CorrelationIdHeaderName = \"x-correlation-id\";\nconst DriverVersionHeaderName = \"x-driver-version\";\n//# sourceMappingURL=constants.js.map\n\n/***/ }),\n/* 394 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NetworkError\": () => (/* binding */ NetworkError),\n/* harmony export */   \"createFluidServiceNetworkError\": () => (/* binding */ createFluidServiceNetworkError),\n/* harmony export */   \"isNetworkError\": () => (/* binding */ isNetworkError),\n/* harmony export */   \"throwFluidServiceNetworkError\": () => (/* binding */ throwFluidServiceNetworkError)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Represents errors associated with network communication.\n *\n * @remarks\n * The Fluid Framework server implementation includes a collection of services that communicate with each other\n * over the network. Network communication is subject to a diverse range of errors. {@link NetworkError} helps\n * convey more information than a simple HTTP status code, allowing services to be aware of the context of a\n * network error and making those services more prepared to react to such kinds of errors.\n */\nclass NetworkError extends Error {\n    constructor(\n    /**\n     * HTTP status code that describes the error.\n     * @public\n     */\n    code, \n    /**\n     * The message associated with the error.\n     * @public\n     */\n    message, \n    /**\n     * Optional boolean indicating whether this is an error that can be retried.\n     * Only relevant when {@link NetworkError.isFatal} is false.\n     * @public\n     */\n    canRetry, \n    /**\n     * Optional boolean indicating whether this error is fatal. This generally indicates that the error causes\n     * negative, non-recoverable impact to the component/caller and cannot be ignored.\n     * @public\n     */\n    isFatal, \n    /**\n     * Optional value representing the time in milliseconds that should be waited before retrying.\n     * @public\n     */\n    retryAfterMs) {\n        super(message);\n        this.code = code;\n        this.canRetry = canRetry;\n        this.isFatal = isFatal;\n        this.retryAfterMs = retryAfterMs;\n        this.name = \"NetworkError\";\n        this.retryAfter = retryAfterMs !== undefined ? retryAfterMs / 1000 : undefined;\n    }\n    /**\n     * Gets the details associated with this {@link NetworkError}.\n     * @returns A simple string conveying the message if no other details are included in this {@link NetworkError},\n     * or an {@link INetworkErrorDetails} object otherwise.\n     * @public\n     */\n    get details() {\n        if (this.canRetry === undefined && this.isFatal === undefined && this.retryAfterMs === undefined) {\n            return this.message;\n        }\n        return {\n            message: this.message,\n            canRetry: this.canRetry,\n            isFatal: this.isFatal,\n            retryAfter: this.retryAfter,\n            retryAfterMs: this.retryAfterMs,\n        };\n    }\n    /**\n     * Explicitly define how to serialize as JSON so that socket.io can emit relevant info.\n     * @public\n     */\n    toJSON() {\n        return {\n            code: this.code,\n            message: this.message,\n            canRetry: this.canRetry,\n            isFatal: this.isFatal,\n            retryAfterMs: this.retryAfterMs,\n            retryAfter: this.retryAfter,\n        };\n    }\n}\nfunction isNetworkError(error) {\n    return error.name === \"NetworkError\" &&\n        typeof error.code === \"number\" &&\n        typeof error.message === \"string\";\n}\n/**\n * Convenience function for generating a {@link NetworkError}.\n * @remarks Generates a {@link NetworkError} instance appropriately configured given the status code and error data\n * provided. This function is intended to be used in situations where a {@link NetworkError} is dynamically created\n * based variable parameters. That is, when it is not known whether the status code can be 404 or 500.\n * @param statusCode - HTTP status code that describes the error.\n * @param errorData - Optional additional data associated with the error. Can either be a simple string representing\n *  the message, or an {@link INetworkErrorDetails} object.\n * @returns A {@link NetworkError} instance properly configured according to the parameters provided.\n * @public\n */\nfunction createFluidServiceNetworkError(statusCode, errorData) {\n    var _a;\n    let message;\n    let canRetry;\n    let isFatal;\n    let retryAfter;\n    if (errorData && typeof errorData === \"object\") {\n        message = (_a = errorData.message) !== null && _a !== void 0 ? _a : \"Unknown Error\";\n        canRetry = errorData.canRetry;\n        isFatal = errorData.isFatal;\n        retryAfter = errorData.retryAfter;\n    }\n    else if (errorData && typeof errorData === \"string\") {\n        message = errorData;\n    }\n    else {\n        message = \"Unknown Error\";\n    }\n    switch (statusCode) {\n        case 401:\n        case 403:\n        case 404:\n            return new NetworkError(statusCode, message, false, /* canRetry */ false); /* isFatal */\n        case 413:\n        case 422:\n            return new NetworkError(statusCode, message, canRetry !== null && canRetry !== void 0 ? canRetry : false, /* canRetry */ isFatal !== null && isFatal !== void 0 ? isFatal : false, /* isFatal */ canRetry ? retryAfter : undefined);\n        case 429:\n            return new NetworkError(statusCode, message, true, /* canRetry */ false, /* isFatal */ retryAfter);\n        case 500: {\n            return new NetworkError(statusCode, message, canRetry !== null && canRetry !== void 0 ? canRetry : true, /* canRetry */ isFatal !== null && isFatal !== void 0 ? isFatal : false, /* isFatal */ canRetry ? retryAfter : undefined);\n        }\n        case 502:\n        case 503:\n        case 504:\n            return new NetworkError(statusCode, message, true, /* canRetry */ false, /* isFatal */ retryAfter);\n        default:\n            return new NetworkError(statusCode, message, false, /* canRetry */ true); /* isFatal */\n    }\n}\n/**\n * Convenience function to both generate and throw a {@link NetworkError}.\n * @remarks Similarly to {@link createFluidServiceNetworkError}, this function generates a {@link NetworkError}\n * instance appropriately configured given the status code and error data provided. The difference is that this\n * function also throws the {@link NetworkError}.\n * @param statusCode - HTTP status code that describes the error.\n * @param errorData - Optional additional data associated with the error. Can either be a simple string representing\n *  the message, or an {@link INetworkErrorDetails} object.\n * @public\n */\nfunction throwFluidServiceNetworkError(statusCode, errorData) {\n    const networkError = createFluidServiceNetworkError(statusCode, errorData);\n    throw networkError;\n}\n//# sourceMappingURL=error.js.map\n\n/***/ }),\n/* 395 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RestLessClient\": () => (/* binding */ RestLessClient),\n/* harmony export */   \"RestLessFieldNames\": () => (/* binding */ RestLessFieldNames)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar RestLessFieldNames;\n(function (RestLessFieldNames) {\n    RestLessFieldNames[\"Method\"] = \"method\";\n    RestLessFieldNames[\"Header\"] = \"header\";\n    RestLessFieldNames[\"Body\"] = \"body\";\n})(RestLessFieldNames || (RestLessFieldNames = {}));\nconst encodeHeader = (headerKey, headerValue) => {\n    return `${headerKey}: ${headerValue}`;\n};\n/**\n * Client for communicating with a \"RestLess\" server.\n * Translates a typical RESTful HTTP request into \"RestLess\" HTTP format:\n *\n * POST \\<path\\> HTTP/\\<1.1|2\\>\n *\n * HOST \\<hostname\\>\n *\n * Content-Type: application/x-www-form-urlencoded\n *\n * <url-encoded-headers-body-and-method>\n */\nclass RestLessClient {\n    /**\n     * Translates request from REST to \"RestLess\" out-of-place.\n     */\n    translate(request) {\n        var _a, _b;\n        const newRequest = Object.assign({}, request);\n        const body = new URLSearchParams();\n        body.append(RestLessFieldNames.Method, (_a = newRequest.method) !== null && _a !== void 0 ? _a : \"GET\");\n        if (newRequest.headers) {\n            for (const [headerKey, headerValue] of Object.entries(newRequest.headers)) {\n                const encodedHeader = encodeHeader(headerKey, headerValue);\n                body.append(RestLessFieldNames.Header, encodedHeader);\n            }\n        }\n        if (newRequest.data && [\"post\", \"put\", \"patch\"].includes((_b = newRequest.method) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {\n            const stringifiedBody = JSON.stringify(newRequest.data);\n            body.append(RestLessFieldNames.Body, stringifiedBody);\n        }\n        newRequest.data = body.toString();\n        newRequest.method = \"POST\";\n        newRequest.headers = {\n            // TODO: when we support blob/file uploads, we should potentially add compatibility with multipart/form-data\n            \"Content-Type\": \"application/x-www-form-urlencoded;restless\",\n        };\n        return newRequest;\n    }\n}\n//# sourceMappingURL=restLessClient.js.map\n\n/***/ }),\n/* 396 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"R11sErrorType\": () => (/* binding */ R11sErrorType),\n/* harmony export */   \"createR11sNetworkError\": () => (/* binding */ createR11sNetworkError),\n/* harmony export */   \"errorObjectFromSocketError\": () => (/* binding */ errorObjectFromSocketError),\n/* harmony export */   \"throwR11sNetworkError\": () => (/* binding */ throwR11sNetworkError)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(397);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar R11sErrorType;\n(function (R11sErrorType) {\n    R11sErrorType[\"fileNotFoundOrAccessDeniedError\"] = \"fileNotFoundOrAccessDeniedError\";\n})(R11sErrorType || (R11sErrorType = {}));\nfunction createR11sNetworkError(errorMessage, statusCode, retryAfterMs) {\n    const props = { statusCode, driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion };\n    switch (statusCode) {\n        case undefined:\n            // If a service is temporarily down or a browser resource limit is reached, RestWrapper will throw\n            // a network error with no status code (e.g. err:ERR_CONN_REFUSED or err:ERR_FAILED) and\n            // the error message will start with NetworkError as defined in restWrapper.ts\n            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.GenericNetworkError(errorMessage, errorMessage.startsWith(\"NetworkError\"), props);\n        case 401:\n        // The first 401 is manually retried in RouterliciousRestWrapper with a refreshed token,\n        // so we treat repeat 401s the same as 403.\n        case 403:\n            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.AuthorizationError(errorMessage, undefined, undefined, props);\n        case 404:\n            const errorType = R11sErrorType.fileNotFoundOrAccessDeniedError;\n            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.NonRetryableError(errorMessage, errorType, props);\n        case 429:\n            return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createGenericNetworkError)(errorMessage, { canRetry: true, retryAfterMs }, props);\n        case 500:\n        case 502:\n            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.GenericNetworkError(errorMessage, true, props);\n        default:\n            const retryInfo = { canRetry: retryAfterMs !== undefined, retryAfterMs };\n            return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createGenericNetworkError)(errorMessage, retryInfo, props);\n    }\n}\nfunction throwR11sNetworkError(errorMessage, statusCode, retryAfterMs) {\n    const networkError = createR11sNetworkError(errorMessage, statusCode, retryAfterMs);\n    // eslint-disable-next-line @typescript-eslint/no-throw-literal\n    throw networkError;\n}\n/**\n * Returns network error based on error object from R11s socket (IR11sSocketError)\n */\nfunction errorObjectFromSocketError(socketError, handler) {\n    // pre-0.58 error message prefix: R11sSocketError\n    const message = `R11s socket error (${handler}): ${socketError.message}`;\n    return createR11sNetworkError(message, socketError.code, socketError.retryAfterMs);\n}\n//# sourceMappingURL=errorUtils.js.map\n\n/***/ }),\n/* 397 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/routerlicious-driver\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 398 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromBase64ToUtf8\": () => (/* binding */ fromBase64ToUtf8),\n/* harmony export */   \"fromUtf8ToBase64\": () => (/* binding */ fromUtf8ToBase64),\n/* harmony export */   \"toUtf8\": () => (/* binding */ toUtf8)\n/* harmony export */ });\n/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(399);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nconst fromBase64ToUtf8 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, \"base64\").toString(\"utf-8\");\nconst fromUtf8ToBase64 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, \"utf8\").toString(\"base64\");\n/**\n * Convenience function to convert unknown encoding to utf8 that avoids\n * buffer copies/encode ops when no conversion is needed\n * @param input - The source string to convert\n * @param encoding - The source string's encoding\n */\nconst toUtf8 = (input, encoding) => {\n    switch (encoding) {\n        case \"utf8\":\n        case \"utf-8\":\n            return input;\n        default:\n            return _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, encoding).toString();\n    }\n};\n//# sourceMappingURL=base64Encoding.js.map\n\n/***/ }),\n/* 399 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(333);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 400 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Historian\": () => (/* binding */ Historian),\n/* harmony export */   \"getAuthorizationTokenFromCredentials\": () => (/* binding */ getAuthorizationTokenFromCredentials)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(398);\n/* harmony import */ var _restWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(344);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nfunction endsWith(value, endings) {\n    for (const ending of endings) {\n        if (value.endsWith(ending)) {\n            return true;\n        }\n    }\n    return false;\n}\nconst getAuthorizationTokenFromCredentials = (credentials) => `Basic ${(0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.fromUtf8ToBase64)(`${credentials.user}:${credentials.password}`)}`;\n/**\n * Implementation of the IHistorian interface that calls out to a REST interface\n */\nclass Historian {\n    constructor(endpoint, historianApi, disableCache, restWrapper) {\n        this.endpoint = endpoint;\n        this.historianApi = historianApi;\n        this.restWrapper = restWrapper;\n        this.defaultQueryString = {};\n        if (disableCache && this.historianApi) {\n            this.defaultQueryString.disableCache = disableCache;\n            this.cacheBust = false;\n        }\n        else {\n            this.cacheBust = disableCache;\n        }\n        if (this.restWrapper === undefined) {\n            this.restWrapper = new _restWrapper__WEBPACK_IMPORTED_MODULE_1__.BasicRestWrapper(this.endpoint);\n        }\n    }\n    async getHeader(sha) {\n        if (this.historianApi) {\n            return this.restWrapper.get(`/headers/${encodeURIComponent(sha)}`, this.getQueryString());\n        }\n        else {\n            return this.getHeaderDirect(sha);\n        }\n    }\n    async getFullTree(sha) {\n        return this.restWrapper.get(`/tree/${encodeURIComponent(sha)}`, this.getQueryString());\n    }\n    async getBlob(sha) {\n        return this.restWrapper.get(`/git/blobs/${encodeURIComponent(sha)}`, this.getQueryString());\n    }\n    async createBlob(blob) {\n        return this.restWrapper.post(`/git/blobs`, blob, this.getQueryString());\n    }\n    async getContent(path, ref) {\n        return this.restWrapper.get(`/contents/${path}`, this.getQueryString({ ref }));\n    }\n    async getCommits(sha, count) {\n        return this.restWrapper.get(`/commits`, this.getQueryString({ count, sha }))\n            .catch((error) => (error === 400 || error === 404) ?\n            [] : Promise.reject(error));\n    }\n    async getCommit(sha) {\n        return this.restWrapper.get(`/git/commits/${encodeURIComponent(sha)}`, this.getQueryString());\n    }\n    async createCommit(commit) {\n        return this.restWrapper.post(`/git/commits`, commit, this.getQueryString());\n    }\n    async getRefs() {\n        return this.restWrapper.get(`/git/refs`, this.getQueryString());\n    }\n    async getRef(ref) {\n        return this.restWrapper.get(`/git/refs/${ref}`, this.getQueryString());\n    }\n    async createRef(params) {\n        return this.restWrapper.post(`/git/refs`, params, this.getQueryString());\n    }\n    async updateRef(ref, params) {\n        return this.restWrapper.patch(`/git/refs/${ref}`, params, this.getQueryString());\n    }\n    async deleteRef(ref) {\n        await this.restWrapper.delete(`/git/refs/${ref}`, this.getQueryString());\n    }\n    async createTag(tag) {\n        return this.restWrapper.post(`/git/tags`, tag, this.getQueryString());\n    }\n    async getTag(tag) {\n        return this.restWrapper.get(`/git/tags/${tag}`, this.getQueryString());\n    }\n    async createTree(tree) {\n        return this.restWrapper.post(`/git/trees`, tree, this.getQueryString());\n    }\n    async getTree(sha, recursive) {\n        return this.restWrapper.get(`/git/trees/${encodeURIComponent(sha)}`, this.getQueryString({ recursive: recursive ? 1 : 0 }));\n    }\n    async createSummary(summary) {\n        return this.restWrapper.post(`/git/summaries`, summary, this.getQueryString());\n    }\n    async deleteSummary(softDelete) {\n        const headers = { \"Soft-Delete\": softDelete };\n        return this.restWrapper.delete(`/git/summaries`, this.getQueryString(), headers);\n    }\n    async getSummary(sha) {\n        return this.restWrapper.get(`/git/summaries/${sha}`, this.getQueryString());\n    }\n    async getHeaderDirect(sha) {\n        const tree = await this.getTree(sha, true);\n        const includeBlobs = [\".attributes\", \".blobs\", \".messages\", \"header\"];\n        const blobsP = [];\n        for (const entry of tree.tree) {\n            if (entry.type === \"blob\" && endsWith(entry.path, includeBlobs)) {\n                const blobP = this.getBlob(entry.sha);\n                blobsP.push(blobP);\n            }\n        }\n        const blobs = await Promise.all(blobsP);\n        return {\n            blobs,\n            tree,\n        };\n    }\n    getQueryString(queryString) {\n        if (this.cacheBust) {\n            return Object.assign(Object.assign({ cacheBust: Date.now() }, this.defaultQueryString), queryString);\n        }\n        return Object.assign(Object.assign({}, this.defaultQueryString), queryString);\n    }\n}\n//# sourceMappingURL=historian.js.map\n\n/***/ }),\n/* 401 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertSummaryToCreateNewSummary\": () => (/* binding */ convertSummaryToCreateNewSummary)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(399);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(402);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Utility api to convert ISummaryTree to a summary tree where blob contents are only utf8 strings.\n * @param summary - Summary supplied by the runtime to upload.\n * @returns - Modified summary tree where the blob contents could be utf8 string only.\n */\nfunction convertSummaryToCreateNewSummary(summary) {\n    const keys = Object.keys(summary.tree);\n    for (const key of keys) {\n        const summaryObject = summary.tree[key];\n        switch (summaryObject.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {\n                summary.tree[key] = convertSummaryToCreateNewSummary(summaryObject);\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {\n                summaryObject.content = typeof summaryObject.content === \"string\" ?\n                    summaryObject.content : (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayToString)(summaryObject.content, \"utf8\");\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {\n                throw new Error(\"No handle should be present for first summary!!\");\n            }\n            default: {\n                throw new Error(`Unknown tree type ${summaryObject.type}`);\n            }\n        }\n    }\n    return summary;\n}\n//# sourceMappingURL=createNewUtils.js.map\n\n/***/ }),\n/* 402 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 403 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DocumentService\": () => (/* binding */ DocumentService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(333);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(437);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(340);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(400);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(435);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(404);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(45);\n/* harmony import */ var _deltaStorageService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(453);\n/* harmony import */ var _documentStorageService__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(438);\n/* harmony import */ var _documentDeltaConnection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(458);\n/* harmony import */ var _nullBlobStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(434);\n/* harmony import */ var _restWrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(341);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Amount of time between discoveries within which we don't need to rediscover on re-connect.\n * Currently, R11s defines session length at 10 minutes. To avoid any weird unknown edge-cases though,\n * we set the limit to 5 minutes here.\n * In the future, we likely want to retrieve this information from service's \"inactive session\" definition.\n */\nconst RediscoverAfterTimeSinceDiscoveryMs = 5 * 60000; // 5 minute\n/**\n * The DocumentService manages the Socket.IO connection and manages routing requests to connected\n * clients.\n */\nclass DocumentService {\n    constructor(_resolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger, tokenProvider, tenantId, documentId, driverPolicies, blobCache, snapshotTreeCache, discoverFluidResolvedUrl) {\n        this._resolvedUrl = _resolvedUrl;\n        this.ordererUrl = ordererUrl;\n        this.deltaStorageUrl = deltaStorageUrl;\n        this.storageUrl = storageUrl;\n        this.logger = logger;\n        this.tokenProvider = tokenProvider;\n        this.tenantId = tenantId;\n        this.documentId = documentId;\n        this.driverPolicies = driverPolicies;\n        this.blobCache = blobCache;\n        this.snapshotTreeCache = snapshotTreeCache;\n        this.discoverFluidResolvedUrl = discoverFluidResolvedUrl;\n        this.lastDiscoveredAt = Date.now();\n    }\n    get resolvedUrl() {\n        return this._resolvedUrl;\n    }\n    dispose() { }\n    /**\n     * Connects to a storage endpoint for snapshot service.\n     *\n     * @returns returns the document storage service for routerlicious driver.\n     */\n    async connectToStorage() {\n        if (this.documentStorageService !== undefined) {\n            return this.documentStorageService;\n        }\n        if (this.storageUrl === undefined) {\n            return new _nullBlobStorageService__WEBPACK_IMPORTED_MODULE_1__.NullBlobStorageService();\n        }\n        const getStorageManager = async (disableCache) => {\n            const shouldUpdateDiscoveredSessionInfo = this.shouldUpdateDiscoveredSessionInfo();\n            if (shouldUpdateDiscoveredSessionInfo) {\n                await this.refreshDiscovery();\n            }\n            if (!this.storageManager || !this.noCacheStorageManager || shouldUpdateDiscoveredSessionInfo) {\n                const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.RateLimiter(this.driverPolicies.maxConcurrentStorageRequests);\n                const storageRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_3__.RouterliciousStorageRestWrapper.load(this.tenantId, this.documentId, this.tokenProvider, this.logger, rateLimiter, this.driverPolicies.enableRestLess, this.storageUrl);\n                const historian = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.Historian(this.storageUrl, true, false, storageRestWrapper);\n                this.storageManager = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_5__.GitManager(historian);\n                const noCacheHistorian = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.Historian(this.storageUrl, true, true, storageRestWrapper);\n                this.noCacheStorageManager = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_5__.GitManager(noCacheHistorian);\n            }\n            return disableCache ? this.noCacheStorageManager : this.storageManager;\n        };\n        // Initialize storageManager and noCacheStorageManager\n        const storageManager = await getStorageManager();\n        const noCacheStorageManager = await getStorageManager(true);\n        const documentStorageServicePolicies = {\n            caching: this.driverPolicies.enablePrefetch\n                ? _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__.LoaderCachingPolicy.Prefetch\n                : _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__.LoaderCachingPolicy.NoCaching,\n            minBlobSize: this.driverPolicies.aggregateBlobsSmallerThanBytes,\n        };\n        this.documentStorageService = new _documentStorageService__WEBPACK_IMPORTED_MODULE_7__.DocumentStorageService(this.documentId, storageManager, this.logger, documentStorageServicePolicies, this.driverPolicies, this.blobCache, this.snapshotTreeCache, noCacheStorageManager, getStorageManager);\n        return this.documentStorageService;\n    }\n    /**\n     * Connects to a delta storage endpoint for getting ops between a range.\n     *\n     * @returns returns the document delta storage service for routerlicious driver.\n     */\n    async connectToDeltaStorage() {\n        await this.connectToStorage();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!this.documentStorageService, 0x0b1 /* \"Storage service not initialized\" */);\n        const getRestWrapper = async () => {\n            const shouldUpdateDiscoveredSessionInfo = this.shouldUpdateDiscoveredSessionInfo();\n            if (shouldUpdateDiscoveredSessionInfo) {\n                await this.refreshDiscovery();\n            }\n            if (!this.ordererRestWrapper || shouldUpdateDiscoveredSessionInfo) {\n                const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);\n                this.ordererRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_3__.RouterliciousOrdererRestWrapper.load(this.tenantId, this.documentId, this.tokenProvider, this.logger, rateLimiter, this.driverPolicies.enableRestLess);\n            }\n            return this.ordererRestWrapper;\n        };\n        const restWrapper = await getRestWrapper();\n        const deltaStorageService = new _deltaStorageService__WEBPACK_IMPORTED_MODULE_9__.DeltaStorageService(this.deltaStorageUrl, restWrapper, this.logger, getRestWrapper, () => this.deltaStorageUrl);\n        return new _deltaStorageService__WEBPACK_IMPORTED_MODULE_9__.DocumentDeltaStorageService(this.tenantId, this.documentId, deltaStorageService, this.documentStorageService);\n    }\n    /**\n     * Connects to a delta stream endpoint for emitting ops.\n     *\n     * @returns returns the document delta stream service for routerlicious driver.\n     */\n    async connectToDeltaStream(client) {\n        const connect = async (refreshToken) => {\n            if (this.shouldUpdateDiscoveredSessionInfo()) {\n                await this.refreshDiscovery();\n            }\n            const ordererToken = await this.tokenProvider.fetchOrdererToken(this.tenantId, this.documentId, refreshToken);\n            return _documentDeltaConnection__WEBPACK_IMPORTED_MODULE_10__.R11sDocumentDeltaConnection.create(this.tenantId, this.documentId, ordererToken.jwt, socket_io_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"], client, this.ordererUrl, this.logger);\n        };\n        // Attempt to establish connection.\n        // Retry with new token on authorization error; otherwise, allow container layer to handle.\n        try {\n            const connection = await connect();\n            return connection;\n        }\n        catch (error) {\n            if ((error === null || error === void 0 ? void 0 : error.statusCode) === 401) {\n                // Fetch new token and retry once,\n                // otherwise 401 will be bubbled up as non-retriable AuthorizationError.\n                return connect(true /* refreshToken */);\n            }\n            throw error;\n        }\n    }\n    /**\n     * Re-discover session URLs if necessary.\n     */\n    async refreshDiscovery() {\n        if (!this.discoverP) {\n            this.discoverP = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_11__.PerformanceEvent.timedExecAsync(this.logger, {\n                eventName: \"refreshSessionDiscovery\",\n            }, async () => this.refreshDiscoveryCore());\n        }\n        return this.discoverP;\n    }\n    async refreshDiscoveryCore() {\n        const fluidResolvedUrl = await this.discoverFluidResolvedUrl();\n        this._resolvedUrl = fluidResolvedUrl;\n        this.storageUrl = fluidResolvedUrl.endpoints.storageUrl;\n        this.ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;\n        this.deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;\n    }\n    /**\n     * Whether enough time has passed since last disconnect to warrant a new discovery call on reconnect.\n     */\n    shouldUpdateDiscoveredSessionInfo() {\n        if (!this.driverPolicies.enableDiscovery) {\n            return false;\n        }\n        const now = Date.now();\n        // When connection is disconnected, we cannot know if session has moved or document has been deleted\n        // without re-doing discovery on the next attempt to connect.\n        // Disconnect event is not so reliable in local testing. To ensure re-discovery when necessary,\n        // re-discover if enough time has passed since last discovery.\n        const pastLastDiscoveryTimeThreshold = (now - this.lastDiscoveredAt) > RediscoverAfterTimeSinceDiscoveryMs;\n        if (pastLastDiscoveryTimeThreshold) {\n            // Reset discover promise and refresh discovery.\n            this.lastDiscoveredAt = Date.now();\n            this.discoverP = undefined;\n            this.refreshDiscovery().catch(() => {\n                // Undo discovery time set on failure, so that next check refreshes.\n                this.lastDiscoveredAt = 0;\n            });\n        }\n        return pastLastDiscoveryTimeThreshold;\n    }\n}\n//# sourceMappingURL=documentService.js.map\n\n/***/ }),\n/* 404 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Manager\": () => (/* reexport safe */ _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager),\n/* harmony export */   \"Socket\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket),\n/* harmony export */   \"connect\": () => (/* binding */ lookup),\n/* harmony export */   \"default\": () => (/* binding */ lookup),\n/* harmony export */   \"io\": () => (/* binding */ lookup),\n/* harmony export */   \"protocol\": () => (/* reexport safe */ socket_io_parser__WEBPACK_IMPORTED_MODULE_3__.protocol)\n/* harmony export */ });\n/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(405);\n/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(427);\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(428);\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(429);\n\n\n\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = (0,_url_js__WEBPACK_IMPORTED_MODULE_0__.url)(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager,\n    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\n\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\n\n\n\n/***/ }),\n/* 405 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"url\": () => (/* binding */ url)\n/* harmony export */ });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(406);\n\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.parse)(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n\n\n/***/ }),\n/* 406 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket),\n/* harmony export */   \"Transport\": () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.Transport),\n/* harmony export */   \"installTimerFunctions\": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.installTimerFunctions),\n/* harmony export */   \"nextTick\": () => (/* reexport safe */ _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__.nextTick),\n/* harmony export */   \"parse\": () => (/* reexport safe */ _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__.parse),\n/* harmony export */   \"protocol\": () => (/* binding */ protocol),\n/* harmony export */   \"transports\": () => (/* reexport safe */ _transports_index_js__WEBPACK_IMPORTED_MODULE_2__.transports)\n/* harmony export */ });\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(407);\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(410);\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(408);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(417);\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(426);\n/* harmony import */ var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(424);\n\n\nconst protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket.protocol;\n\n\n\n\n\n\n\n/***/ }),\n/* 407 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(408);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(417);\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(419);\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(426);\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(416);\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(411);\n/* harmony import */ var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(424);\n\n\n\n\n\n\n\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts = {}) {\n        super();\n        this.binaryType = _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_6__.defaultBinaryType;\n        this.writeBuffer = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(opts.host).host;\n        }\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.installTimerFunctions)(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\n            \"polling\",\n            \"websocket\",\n            \"webtransport\",\n        ];\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__.decode)(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        }, this.opts.transportOptions[name]);\n        return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__.transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this.upgrades.indexOf(\"webtransport\") !== -1 &&\n            name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(() => {\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        }\n        else {\n            transport.open();\n        }\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            this.resetPingTimeout();\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this.getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    getWritablePackets() {\n        const shouldCheckPayloadSize = this.maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.byteLength)(data);\n            }\n            if (i > 0 && payloadSize > this.maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    onError(err) {\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nSocket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n\n\n/***/ }),\n/* 408 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"transports\": () => (/* binding */ transports)\n/* harmony export */ });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(409);\n/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(423);\n/* harmony import */ var _webtransport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(425);\n\n\n\nconst transports = {\n    websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__.WS,\n    webtransport: _webtransport_js__WEBPACK_IMPORTED_MODULE_2__.WT,\n    polling: _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling,\n};\n\n\n/***/ }),\n/* 409 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polling\": () => (/* binding */ Polling),\n/* harmony export */   \"Request\": () => (/* binding */ Request)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(410);\n/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(420);\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(411);\n/* harmony import */ var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(421);\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(416);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(417);\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(418);\n\n\n\n\n\n\n\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__.XHR({\n        xdomain: false,\n    });\n    return null != xhr.responseType;\n})();\nclass Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        this.polling = false;\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n        if (this.opts.withCredentials) {\n            this.cookieJar = (0,_xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__.createCookieJar)();\n        }\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.encodePayload)(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__.yeast)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nclass Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(uri, opts) {\n        super();\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    create() {\n        var _a;\n        const opts = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        const xhr = (this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__.XHR(opts));\n        try {\n            xhr.open(this.method, this.uri, true);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);\n                }\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    onError(err) {\n        this.emitReserved(\"error\", err, this.xhr);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this.cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in _globalThis_js__WEBPACK_IMPORTED_MODULE_6__.globalThisShim ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n\n\n/***/ }),\n/* 410 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Transport\": () => (/* binding */ Transport)\n/* harmony export */ });\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(411);\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(416);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(417);\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(419);\n\n\n\n\nclass TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nclass Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_0__.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n    createUri(schema, query = {}) {\n        return (schema +\n            \"://\" +\n            this._hostname() +\n            this._port() +\n            this.opts.path +\n            this._query(query));\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port &&\n            ((this.opts.secure && Number(this.opts.port !== 443)) ||\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\n            return \":\" + this.opts.port;\n        }\n        else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__.encode)(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n\n\n/***/ }),\n/* 411 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createPacketDecoderStream\": () => (/* binding */ createPacketDecoderStream),\n/* harmony export */   \"createPacketEncoderStream\": () => (/* binding */ createPacketEncoderStream),\n/* harmony export */   \"decodePacket\": () => (/* reexport safe */ _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket),\n/* harmony export */   \"decodePayload\": () => (/* binding */ decodePayload),\n/* harmony export */   \"encodePacket\": () => (/* reexport safe */ _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacket),\n/* harmony export */   \"encodePayload\": () => (/* binding */ encodePayload),\n/* harmony export */   \"protocol\": () => (/* binding */ protocol)\n/* harmony export */ });\n/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(412);\n/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(414);\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(413);\n\n\n\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacket)(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = (0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket)(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nfunction createPacketEncoderStream() {\n    return new TransformStream({\n        transform(packet, controller) {\n            (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacketToBinary)(packet, encodedPacket => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        }\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nfunction createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* READ_PAYLOAD */;\n                }\n                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(_commons_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue((0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(_commons_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_PACKET);\n                    break;\n                }\n            }\n        }\n    });\n}\nconst protocol = 4;\n\n\n\n/***/ }),\n/* 412 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encodePacket\": () => (/* binding */ encodePacket),\n/* harmony export */   \"encodePacketToBinary\": () => (/* binding */ encodePacketToBinary)\n/* harmony export */ });\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);\n\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\nfunction toArray(data) {\n    if (data instanceof Uint8Array) {\n        return data;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nlet TEXT_ENCODER;\nfunction encodePacketToBinary(packet, callback) {\n    if (withNativeBlob && packet.data instanceof Blob) {\n        return packet.data\n            .arrayBuffer()\n            .then(toArray)\n            .then(callback);\n    }\n    else if (withNativeArrayBuffer &&\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\n        return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, encoded => {\n        if (!TEXT_ENCODER) {\n            TEXT_ENCODER = new TextEncoder();\n        }\n        callback(TEXT_ENCODER.encode(encoded));\n    });\n}\n\n\n\n/***/ }),\n/* 413 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ERROR_PACKET\": () => (/* binding */ ERROR_PACKET),\n/* harmony export */   \"PACKET_TYPES\": () => (/* binding */ PACKET_TYPES),\n/* harmony export */   \"PACKET_TYPES_REVERSE\": () => (/* binding */ PACKET_TYPES_REVERSE)\n/* harmony export */ });\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n\n\n\n/***/ }),\n/* 414 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decodePacket\": () => (/* binding */ decodePacket)\n/* harmony export */ });\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);\n/* harmony import */ var _contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(415);\n\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return _commons_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0,_contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            if (data instanceof Blob) {\n                // from WebSocket + binaryType \"blob\"\n                return data;\n            }\n            else {\n                // from HTTP long-polling or WebTransport\n                return new Blob([data]);\n            }\n        case \"arraybuffer\":\n        default:\n            if (data instanceof ArrayBuffer) {\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n            }\n            else {\n                // from WebTransport (Uint8Array)\n                return data.buffer;\n            }\n    }\n};\n\n\n/***/ }),\n/* 415 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nconst encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nconst decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\n\n/***/ }),\n/* 416 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Emitter\": () => (/* binding */ Emitter)\n/* harmony export */ });\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n/***/ }),\n/* 417 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"byteLength\": () => (/* binding */ byteLength),\n/* harmony export */   \"installTimerFunctions\": () => (/* binding */ installTimerFunctions),\n/* harmony export */   \"pick\": () => (/* binding */ pick)\n/* harmony export */ });\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(418);\n\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n    else {\n        obj.setTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nfunction byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n\n\n/***/ }),\n/* 418 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"globalThisShim\": () => (/* binding */ globalThisShim)\n/* harmony export */ });\nconst globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n\n\n/***/ }),\n/* 419 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nfunction encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nfunction decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n\n\n/***/ }),\n/* 420 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"yeast\": () => (/* binding */ yeast)\n/* harmony export */ });\n// imported from https://github.com/unshiftio/yeast\n\nconst alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n    let encoded = '';\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return seed = 0, prev = now;\n    return now + '.' + encode(seed++);\n}\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n\n\n/***/ }),\n/* 421 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XHR\": () => (/* binding */ XHR),\n/* harmony export */   \"createCookieJar\": () => (/* binding */ createCookieJar)\n/* harmony export */ });\n/* harmony import */ var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(422);\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(418);\n// browser shim for xmlhttprequest module\n\n\nfunction XHR(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__.hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__.globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\nfunction createCookieJar() { }\n\n\n/***/ }),\n/* 422 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasCORS\": () => (/* binding */ hasCORS)\n/* harmony export */ });\n// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nconst hasCORS = value;\n\n\n/***/ }),\n/* 423 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WS\": () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(410);\n/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(420);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(417);\n/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(424);\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(411);\n\n\n\n\n\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket(uri, protocols)\n                        : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket(uri)\n                    : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_4__.encodePacket)(packet, this.supportsBinary, (data) => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \n                        // @ts-ignore\n                        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0,_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__.yeast)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @private\n     */\n    check() {\n        return !!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket;\n    }\n}\n\n\n/***/ }),\n/* 424 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebSocket\": () => (/* binding */ WebSocket),\n/* harmony export */   \"defaultBinaryType\": () => (/* binding */ defaultBinaryType),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"usingBrowserWebSocket\": () => (/* binding */ usingBrowserWebSocket)\n/* harmony export */ });\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(418);\n\nconst nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nconst WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.MozWebSocket;\nconst usingBrowserWebSocket = true;\nconst defaultBinaryType = \"arraybuffer\";\n\n\n/***/ }),\n/* 425 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WT\": () => (/* binding */ WT)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(410);\n/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(424);\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(411);\n\n\n\nclass WT extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        // @ts-ignore\n        if (typeof WebTransport !== \"function\") {\n            return;\n        }\n        // @ts-ignore\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        this.transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this.transport.ready.then(() => {\n            this.transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketEncoderStream)();\n                encoderStream.readable.pipeTo(stream.writable);\n                this.writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this.writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this.writer.write(packet).then(() => {\n                if (lastPacket) {\n                    (0,_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n\n\n/***/ }),\n/* 426 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\n// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nfunction parse(str) {\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n\n\n/***/ }),\n/* 427 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Manager\": () => (/* binding */ Manager)\n/* harmony export */ });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(406);\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(428);\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(429);\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(432);\n/* harmony import */ var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(433);\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(416);\n\n\n\n\n\n\nclass Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__.Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.installTimerFunctions)(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__.Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__.Socket(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push((0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"ping\", this.onping.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"data\", this.ondata.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"error\", this.onerror.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"close\", this.onclose.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n\n\n/***/ }),\n/* 428 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(429);\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(432);\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(416);\n\n\n\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__.Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"open\", this.onopen.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"packet\", this.onpacket.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"error\", this.onerror.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n        }\n        else if (this.connected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks[id] = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, [null, ...args]);\n        };\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n\n\n/***/ }),\n/* 429 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Decoder\": () => (/* binding */ Decoder),\n/* harmony export */   \"Encoder\": () => (/* binding */ Encoder),\n/* harmony export */   \"PacketType\": () => (/* binding */ PacketType),\n/* harmony export */   \"protocol\": () => (/* binding */ protocol)\n/* harmony export */ });\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(416);\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(430);\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(431);\n\n\n\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nconst protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.hasBinary)(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.deconstructPacket)(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__.Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.isBinary)(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.reconstructPacket)(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n\n\n/***/ }),\n/* 430 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deconstructPacket\": () => (/* binding */ deconstructPacket),\n/* harmony export */   \"reconstructPacket\": () => (/* binding */ reconstructPacket)\n/* harmony export */ });\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(431);\n\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_0__.isBinary)(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n\n\n/***/ }),\n/* 431 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasBinary\": () => (/* binding */ hasBinary),\n/* harmony export */   \"isBinary\": () => (/* binding */ isBinary)\n/* harmony export */ });\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n/***/ }),\n/* 432 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"on\": () => (/* binding */ on)\n/* harmony export */ });\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n\n\n/***/ }),\n/* 433 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Backoff\": () => (/* binding */ Backoff)\n/* harmony export */ });\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nfunction Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n\n\n/***/ }),\n/* 434 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NullBlobStorageService\": () => (/* binding */ NullBlobStorageService)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Document access to underlying storage. It is default implementation of a storage service.\n * Does not read/write anything.\n */\nclass NullBlobStorageService {\n    get repositoryUrl() {\n        throw new Error(\"Invalid operation\");\n    }\n    async getSnapshotTree(version) {\n        return version ? Promise.reject(new Error(\"Invalid operation\")) : null;\n    }\n    async getVersions(versionId, count) {\n        return [];\n    }\n    async uploadSummaryWithContext(summary, context) {\n        return Promise.reject(new Error(\"Invalid operation\"));\n    }\n    async downloadSummary(handle) {\n        return Promise.reject(new Error(\"Invalid operation\"));\n    }\n    async createBlob(file) {\n        return Promise.reject(new Error(\"Null blob storage can not create blob\"));\n    }\n    async readBlob(blobId) {\n        return Promise.reject(new Error(\"Null blob storage can not read blob\"));\n    }\n}\n//# sourceMappingURL=nullBlobStorageService.js.map\n\n/***/ }),\n/* 435 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GitManager\": () => (/* binding */ GitManager)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(333);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(436);\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(388);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\nclass GitManager {\n    constructor(historian) {\n        this.historian = historian;\n        this.blobCache = new Map();\n        this.commitCache = new Map();\n        this.treeCache = new Map();\n        this.refCache = new Map();\n    }\n    async getHeader(id, sha) {\n        const header = await this.historian.getHeader(sha);\n        // Cache blobs that were sent in the header\n        for (const blob of header.blobs) {\n            this.blobCache.set(blob.sha, blob);\n        }\n        return (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.buildHierarchy)(header.tree);\n    }\n    async getFullTree(sha) {\n        return this.historian.getFullTree(sha);\n    }\n    async getCommit(sha) {\n        if (this.commitCache.has(sha)) {\n            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Cache hit on ${sha}`);\n            return this.commitCache.get(sha);\n        }\n        return this.historian.getCommit(sha);\n    }\n    /**\n     * Reads the object with the given ID. We defer to the client implementation to do the actual read.\n     */\n    async getCommits(shaOrRef, count) {\n        let sha = shaOrRef;\n        // See if the sha is really a ref and convert\n        if (this.refCache.has(shaOrRef)) {\n            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Commit cache hit on ${shaOrRef}`);\n            sha = this.refCache.get(shaOrRef);\n            // Delete refcache after first use\n            this.refCache.delete(shaOrRef);\n            // If null is stored for the ref then there are no commits - return an empty array\n            if (!sha) {\n                return [];\n            }\n        }\n        // See if the commit sha is hashed and return it if so\n        if (this.commitCache.has(sha)) {\n            const commit = this.commitCache.get(sha);\n            return [{\n                    commit: {\n                        author: commit.author,\n                        committer: commit.committer,\n                        message: commit.message,\n                        tree: commit.tree,\n                        url: commit.url,\n                    },\n                    parents: commit.parents,\n                    sha: commit.sha,\n                    url: commit.url,\n                }];\n        }\n        // Otherwise fall back to the historian\n        return this.historian.getCommits(sha, count);\n    }\n    /**\n     * Reads the object with the given ID. We defer to the client implementation to do the actual read.\n     */\n    async getTree(root, recursive = true) {\n        if (this.treeCache.has(root)) {\n            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Tree cache hit on ${root}`);\n            return this.treeCache.get(root);\n        }\n        return this.historian.getTree(root, recursive);\n    }\n    async getBlob(sha) {\n        if (this.blobCache.has(sha)) {\n            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Blob cache hit on ${sha}`);\n            return this.blobCache.get(sha);\n        }\n        return this.historian.getBlob(sha);\n    }\n    getRawUrl(sha) {\n        return `${this.historian.endpoint}/git/blobs/raw/${sha}`;\n    }\n    /**\n     * Retrieves the object at the given revision number\n     */\n    async getContent(commit, path) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.historian.getContent(path, commit);\n    }\n    async createBlob(content, encoding) {\n        const blob = {\n            content,\n            encoding,\n        };\n        return this.historian.createBlob(blob);\n    }\n    async createGitTree(params) {\n        const treeP = this.historian.createTree(params);\n        return treeP;\n    }\n    async createTree(files) {\n        return this.createTreeCore(files, 0);\n    }\n    async createCommit(commit) {\n        return this.historian.createCommit(commit);\n    }\n    async createSummary(summary) {\n        return this.historian.createSummary(summary);\n    }\n    async deleteSummary(softDelete) {\n        return this.historian.deleteSummary(softDelete);\n    }\n    async getSummary(sha) {\n        return this.historian.getSummary(sha);\n    }\n    async getRef(ref) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.historian\n            .getRef(`heads/${ref}`)\n            .catch((error) => {\n            if (error === 400 || error === 404) {\n                return null;\n            }\n            else {\n                throw error;\n            }\n        });\n    }\n    async createRef(branch, sha) {\n        const createRefParams = {\n            ref: `refs/heads/${branch}`,\n            sha,\n            config: { enabled: true },\n        };\n        return this.historian.createRef(createRefParams);\n    }\n    async upsertRef(branch, commitSha) {\n        // Update (force) the ref to the new commit\n        const ref = {\n            force: true,\n            sha: commitSha,\n            config: { enabled: true },\n        };\n        return this.historian.updateRef(`heads/${branch}`, ref);\n    }\n    addRef(ref, sha) {\n        this.refCache.set(ref, sha);\n    }\n    addCommit(commit) {\n        this.commitCache.set(commit.sha, commit);\n    }\n    addTree(tree) {\n        this.treeCache.set(tree.sha, tree);\n    }\n    addBlob(blob) {\n        this.blobCache.set(blob.sha, blob);\n    }\n    /**\n     * Writes to the object with the given ID\n     */\n    async write(branch, inputTree, parents, message) {\n        const tree = await this.createTree(inputTree);\n        // Construct a commit for the tree\n        const commitParams = {\n            author: {\n                date: new Date().toISOString(),\n                email: \"kurtb@microsoft.com\",\n                name: \"Kurt Berglund\",\n            },\n            message,\n            parents,\n            tree: tree.sha,\n        };\n        const commit = await this.historian.createCommit(commitParams);\n        // Create or update depending on if ref exists.\n        // TODO optimize the update to know up front if the ref exists\n        const existingRef = await this.getRef(branch);\n        if (existingRef) {\n            await this.upsertRef(branch, commit.sha);\n        }\n        else {\n            await this.createRef(branch, commit.sha);\n        }\n        return commit;\n    }\n    async createTreeCore(files, depth) {\n        // If a id is specified use it rather than creating new\n        if (files.id) {\n            return this.getTree(files.id);\n        }\n        // Kick off the work to create all the tree values\n        const entriesP = [];\n        for (const entry of files.entries) {\n            switch (_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry[entry.type]) {\n                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Blob: {\n                    const entryAsBlob = entry.value;\n                    // Symlinks currently directly references a folder off the root of the tree. We adjust\n                    // the path based on the depth of the tree\n                    if (entry.mode === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.FileMode.Symlink) {\n                        entryAsBlob.contents = this.translateSymlink(entryAsBlob.contents, depth);\n                    }\n                    const blobP = this.createBlob(entryAsBlob.contents, entryAsBlob.encoding);\n                    entriesP.push(blobP);\n                    break;\n                }\n                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Tree: {\n                    const entryAsTree = entry.value;\n                    const treeBlobP = this.createTreeCore(entryAsTree, depth + 1);\n                    entriesP.push(treeBlobP);\n                    break;\n                }\n                default:\n                    throw new Error(\"Unknown entry type\");\n            }\n        }\n        // Wait for them all to resolve\n        const entries = await Promise.all(entriesP);\n        const tree = [];\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(entries.length === files.entries.length, \"File entries length is not correct\");\n        // Construct a new tree from the collection of hashes\n        for (let i = 0; i < files.entries.length; i++) {\n            const type = files.entries[i].type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Tree\n                ? \"tree\"\n                : (files.entries[i].type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Blob ? \"blob\" : \"commit\");\n            tree.push({\n                mode: files.entries[i].mode,\n                path: files.entries[i].path,\n                sha: entries[i].sha,\n                type,\n            });\n        }\n        const requestBody = {\n            tree,\n        };\n        const treeP = this.historian.createTree(requestBody);\n        return treeP;\n    }\n    translateSymlink(link, depth) {\n        let prefix = \"\";\n        for (let i = 0; i <= depth; i++) {\n            prefix += \"../\";\n        }\n        return `${prefix}${link}`;\n    }\n}\n//# sourceMappingURL=gitManager.js.map\n\n/***/ }),\n/* 436 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FileMode\": () => (/* binding */ FileMode),\n/* harmony export */   \"TreeEntry\": () => (/* binding */ TreeEntry)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar FileMode;\n(function (FileMode) {\n    FileMode[\"File\"] = \"100644\";\n    FileMode[\"Executable\"] = \"100755\";\n    FileMode[\"Directory\"] = \"040000\";\n    FileMode[\"Symlink\"] = \"120000\";\n})(FileMode || (FileMode = {}));\n/**\n * Type of entries that can be stored in a tree\n */\nvar TreeEntry;\n(function (TreeEntry) {\n    TreeEntry[\"Blob\"] = \"Blob\";\n    TreeEntry[\"Tree\"] = \"Tree\";\n    TreeEntry[\"Attachment\"] = \"Attachment\";\n})(TreeEntry || (TreeEntry = {}));\n//# sourceMappingURL=storage.js.map\n\n/***/ }),\n/* 437 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoaderCachingPolicy\": () => (/* binding */ LoaderCachingPolicy)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar LoaderCachingPolicy;\n(function (LoaderCachingPolicy) {\n    /**\n     * The loader should not implement any prefetching or caching policy.\n     */\n    LoaderCachingPolicy[LoaderCachingPolicy[\"NoCaching\"] = 0] = \"NoCaching\";\n    /**\n     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.\n     */\n    LoaderCachingPolicy[LoaderCachingPolicy[\"Prefetch\"] = 1] = \"Prefetch\";\n})(LoaderCachingPolicy || (LoaderCachingPolicy = {}));\n//# sourceMappingURL=storage.js.map\n\n/***/ }),\n/* 438 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DocumentStorageService\": () => (/* binding */ DocumentStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(437);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(452);\n/* harmony import */ var _wholeSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(439);\n/* harmony import */ var _shreddedSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(444);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\nclass DocumentStorageService extends _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {\n    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) {\n        super(DocumentStorageService.loadInternalDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager));\n        this.id = id;\n        this.manager = manager;\n        this.noCacheGitManager = noCacheGitManager;\n        this._logTailSha = undefined;\n    }\n    get logTailSha() {\n        return this._logTailSha;\n    }\n    static loadInternalDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) {\n        const storageService = (driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableWholeSummaryUpload) ?\n            new _wholeSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_1__.WholeSummaryDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) :\n            new _shreddedSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_2__.ShreddedSummaryDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, getStorageManager);\n        // TODO: worth prefetching latest summary making version + snapshot call with WholeSummary storage?\n        if (!(driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableWholeSummaryUpload) && policies.caching === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_3__.LoaderCachingPolicy.Prefetch) {\n            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.PrefetchDocumentStorageService(storageService);\n        }\n        return storageService;\n    }\n    async getSnapshotTree(version) {\n        const tree = await this.internalStorageService.getSnapshotTree(version);\n        if (tree !== null) {\n            this._logTailSha = \".logTail\" in tree.trees ? tree.trees[\".logTail\"].blobs.logTail : undefined;\n        }\n        return tree;\n    }\n}\n//# sourceMappingURL=documentStorageService.js.map\n\n/***/ }),\n/* 439 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WholeSummaryDocumentStorageService\": () => (/* binding */ WholeSummaryDocumentStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(399);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(333);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(443);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(440);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(441);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\nconst latestSnapshotId = \"latest\";\nclass WholeSummaryDocumentStorageService {\n    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache(), snapshotTreeCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache(), noCacheGitManager, getStorageManager = async (disableCache) => disableCache && this.noCacheGitManager !== undefined ? this.noCacheGitManager : this.manager) {\n        this.id = id;\n        this.manager = manager;\n        this.logger = logger;\n        this.policies = policies;\n        this.driverPolicies = driverPolicies;\n        this.blobCache = blobCache;\n        this.snapshotTreeCache = snapshotTreeCache;\n        this.noCacheGitManager = noCacheGitManager;\n        this.getStorageManager = getStorageManager;\n        this.firstVersionsCall = true;\n    }\n    get repositoryUrl() {\n        return \"\";\n    }\n    async getSummaryUploadManager() {\n        const manager = await this.getStorageManager();\n        return new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__.WholeSummaryUploadManager(manager);\n    }\n    async getVersions(versionId, count) {\n        var _a;\n        if (versionId !== this.id && versionId !== null) {\n            // Blobs/Trees in this scenario will never have multiple versions, so return versionId as is\n            return [{\n                    id: versionId,\n                    treeId: undefined,\n                }];\n        }\n        // If this is the first versions call for the document, we know we will want the latest summary.\n        // Fetch latest summary, cache it, and return its id.\n        if (this.firstVersionsCall && count === 1) {\n            this.firstVersionsCall = false;\n            const { id: _id, snapshotTree } = !((_a = this.driverPolicies) === null || _a === void 0 ? void 0 : _a.enableDiscovery) ?\n                await this.fetchAndCacheSnapshotTree(latestSnapshotId, false) :\n                await this.fetchAndCacheSnapshotTree(latestSnapshotId, true);\n            return [{\n                    id: _id,\n                    treeId: snapshotTree.id,\n                }];\n        }\n        // Otherwise, get the latest version of the document as normal.\n        const id = versionId ? versionId : this.id;\n        const commits = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"getVersions\",\n            versionId: id,\n            count,\n        }, async () => {\n            const manager = await this.getStorageManager();\n            return manager.getCommits(id, count);\n        });\n        return commits.map((commit) => ({\n            date: commit.commit.author.date,\n            id: commit.sha,\n            treeId: commit.commit.tree.sha,\n        }));\n    }\n    async getSnapshotTree(version) {\n        let requestVersion = version;\n        if (!requestVersion) {\n            const versions = await this.getVersions(this.id, 1);\n            if (versions.length === 0) {\n                return null;\n            }\n            requestVersion = versions[0];\n        }\n        return (await this.fetchAndCacheSnapshotTree(requestVersion.id)).snapshotTree;\n    }\n    async readBlob(blobId) {\n        const cachedBlob = await this.blobCache.get(this.getCacheKey(blobId));\n        if (cachedBlob !== undefined) {\n            return cachedBlob;\n        }\n        const blob = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"readBlob\",\n            blobId,\n        }, async (event) => {\n            const manager = await this.getStorageManager();\n            const response = await manager.getBlob(blobId);\n            event.end({\n                size: response.size,\n            });\n            return response;\n        });\n        const bufferValue = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.stringToBuffer)(blob.content, blob.encoding);\n        await this.blobCache.put(this.getCacheKey(blob.sha), bufferValue);\n        return bufferValue;\n    }\n    async uploadSummaryWithContext(summary, context) {\n        const summaryHandle = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"uploadSummaryWithContext\",\n        }, async () => {\n            var _a;\n            const summaryUploadManager = await this.getSummaryUploadManager();\n            return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : \"\", \"channel\");\n        });\n        return summaryHandle;\n    }\n    async downloadSummary(summaryHandle) {\n        const wholeFlatSummary = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"getWholeFlatSummary\",\n            treeId: summaryHandle.handle,\n        }, async (event) => {\n            var _a;\n            const manager = await this.getStorageManager();\n            const response = await manager.getSummary(summaryHandle.handle);\n            event.end({\n                size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length,\n            });\n            return response;\n        });\n        const { blobs, snapshotTree } = (0,_fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.convertWholeFlatSummaryToSnapshotTreeAndBlobs)(wholeFlatSummary, \"\");\n        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.convertSnapshotAndBlobsToSummaryTree)(snapshotTree, blobs);\n    }\n    async createBlob(file) {\n        const uint8ArrayFile = new Uint8Array(file);\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"createBlob\",\n            size: uint8ArrayFile.length,\n        }, async (event) => {\n            const manager = await this.getStorageManager();\n            const response = await manager.createBlob((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Uint8ArrayToString)(uint8ArrayFile, \"base64\"), \"base64\").then((r) => ({ id: r.sha, url: r.url }));\n            event.end({\n                blobId: response.id,\n            });\n            return response;\n        });\n    }\n    async fetchAndCacheSnapshotTree(versionId, disableCache) {\n        const cachedSnapshotTreeVersion = await this.snapshotTreeCache.get(this.getCacheKey(versionId));\n        if (cachedSnapshotTreeVersion !== undefined) {\n            return { id: cachedSnapshotTreeVersion.id, snapshotTree: cachedSnapshotTreeVersion.snapshotTree };\n        }\n        const wholeFlatSummary = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"getWholeFlatSummary\",\n            treeId: versionId,\n        }, async (event) => {\n            var _a;\n            const manager = await this.getStorageManager(disableCache);\n            const response = await manager.getSummary(versionId);\n            event.end({\n                size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length,\n            });\n            return response;\n        });\n        const normalizedWholeSummary = (0,_fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.convertWholeFlatSummaryToSnapshotTreeAndBlobs)(wholeFlatSummary);\n        const wholeFlatSummaryId = wholeFlatSummary.id;\n        const snapshotTreeId = normalizedWholeSummary.snapshotTree.id;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(snapshotTreeId !== undefined, 0x275 /* \"Root tree should contain the id\" */);\n        const snapshotTreeVersion = { id: wholeFlatSummaryId, snapshotTree: normalizedWholeSummary.snapshotTree };\n        const cachePs = [\n            this.snapshotTreeCache.put(this.getCacheKey(snapshotTreeId), snapshotTreeVersion),\n            this.initBlobCache(normalizedWholeSummary.blobs),\n        ];\n        if (snapshotTreeId !== versionId) {\n            // versionId could be \"latest\". When summarizer checks cache for \"latest\", we want it to be available.\n            // TODO: For in-memory cache, <latest,snapshotTree> will be a shared pointer with <snapshotId,snapshotTree>,\n            // However, for something like Redis, this will cache the same value twice. Alternatively, could we simply\n            // cache with versionId?\n            cachePs.push(this.snapshotTreeCache.put(this.getCacheKey(versionId), snapshotTreeVersion));\n        }\n        await Promise.all(cachePs);\n        return snapshotTreeVersion;\n    }\n    async initBlobCache(blobs) {\n        const blobCachePutPs = [];\n        blobs.forEach((value, id) => {\n            const cacheKey = this.getCacheKey(id);\n            blobCachePutPs.push(this.blobCache.put(cacheKey, value));\n        });\n        await Promise.all(blobCachePutPs);\n    }\n    getCacheKey(blobId) {\n        return `${this.id}:${blobId}`;\n    }\n}\n//# sourceMappingURL=wholeSummaryDocumentStorageService.js.map\n\n/***/ }),\n/* 440 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WholeSummaryUploadManager\": () => (/* binding */ WholeSummaryUploadManager)\n/* harmony export */ });\n/* harmony import */ var _storageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(441);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Converts summary to snapshot tree and uploads with single snaphot tree payload.\n */\nclass WholeSummaryUploadManager {\n    constructor(manager) {\n        this.manager = manager;\n    }\n    async writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {\n        const id = await this.writeSummaryTreeCore(parentHandle, summaryTree, summaryType, sequenceNumber !== null && sequenceNumber !== void 0 ? sequenceNumber : 0);\n        if (!id) {\n            throw new Error(`Failed to write summary tree`);\n        }\n        return id;\n    }\n    async writeSummaryTreeCore(parentHandle, tree, type, sequenceNumber) {\n        const snapshotTree = (0,_storageUtils__WEBPACK_IMPORTED_MODULE_0__.convertSummaryTreeToWholeSummaryTree)(parentHandle, tree, \"\", type === \"channel\" ? \".app\" : \"\");\n        const snapshotPayload = {\n            entries: snapshotTree.entries,\n            message: undefined,\n            sequenceNumber,\n            type,\n        };\n        return this.manager.createSummary(snapshotPayload).then((response) => response.id);\n    }\n}\n//# sourceMappingURL=wholeSummaryUploadManager.js.map\n\n/***/ }),\n/* 441 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildTreePath\": () => (/* binding */ buildTreePath),\n/* harmony export */   \"convertSummaryTreeToWholeSummaryTree\": () => (/* binding */ convertSummaryTreeToWholeSummaryTree),\n/* harmony export */   \"convertWholeFlatSummaryToSnapshotTreeAndBlobs\": () => (/* binding */ convertWholeFlatSummaryToSnapshotTreeAndBlobs)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(399);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(442);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(333);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(402);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Convert a list of nodes to a tree path.\n * If a node is empty (blank) it will be removed.\n * If a node's name begins and/or ends with a \"/\", it will be removed.\n * @param nodeNames - node names in path\n */\nconst buildTreePath = (...nodeNames) => nodeNames\n    .map((nodeName) => nodeName.replace(/^\\//, \"\").replace(/\\/$/, \"\"))\n    .filter((nodeName) => !!nodeName)\n    .join(\"/\");\n/**\n * Converts the summary tree to a whole summary tree to be uploaded. Always upload full whole summary tree.\n * @param parentHandle - Handle of the last uploaded summary or detach new summary.\n * @param tree - Summary Tree which will be converted to whole summary tree to be uploaded.\n * @param path - Current path of node which is getting evaluated.\n */\nfunction convertSummaryTreeToWholeSummaryTree(parentHandle, tree, path = \"\", rootNodeName = \"\") {\n    const wholeSummaryTree = {\n        type: \"tree\",\n        entries: [],\n    };\n    const keys = Object.keys(tree.tree);\n    for (const key of keys) {\n        const summaryObject = tree.tree[key];\n        let id;\n        let value;\n        let unreferenced;\n        const currentPath = path === \"\"\n            ? buildTreePath(rootNodeName, key)\n            : buildTreePath(path, key);\n        switch (summaryObject.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {\n                const result = convertSummaryTreeToWholeSummaryTree(parentHandle, summaryObject, currentPath, rootNodeName);\n                value = result;\n                unreferenced = summaryObject.unreferenced || undefined;\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {\n                if (typeof summaryObject.content === \"string\") {\n                    value = {\n                        type: \"blob\",\n                        content: summaryObject.content,\n                        encoding: \"utf-8\",\n                    };\n                }\n                else {\n                    value = {\n                        type: \"blob\",\n                        content: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayToString)(summaryObject.content, \"base64\"),\n                        encoding: \"base64\",\n                    };\n                }\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {\n                const handleValue = summaryObject;\n                if (handleValue.embedded) {\n                    id = summaryObject.handle;\n                }\n                else {\n                    if (!parentHandle) {\n                        throw Error(\"Parent summary does not exist to reference by handle.\");\n                    }\n                    id = buildTreePath(parentHandle, rootNodeName, summaryObject.handle);\n                }\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment: {\n                id = summaryObject.id;\n                break;\n            }\n            default: {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(summaryObject, `Unknown type: ${summaryObject.type}`);\n            }\n        }\n        const baseEntry = {\n            path: encodeURIComponent(key),\n            type: (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.getGitType)(summaryObject),\n        };\n        let entry;\n        if (value) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(id === undefined, 0x0ad /* \"Snapshot entry has both a tree value and a referenced id!\" */);\n            entry = Object.assign({ value,\n                unreferenced }, baseEntry);\n        }\n        else if (id) {\n            entry = Object.assign(Object.assign({}, baseEntry), { id });\n        }\n        else {\n            throw new Error(`Invalid tree entry for ${summaryObject.type}`);\n        }\n        wholeSummaryTree.entries.push(entry);\n    }\n    return wholeSummaryTree;\n}\n/**\n * Build a tree heirarchy from a flat tree.\n *\n * @param flatTree - a flat tree\n * @param treePrefixToRemove - tree prefix to strip\n * @returns the heirarchical tree\n */\nfunction buildHierarchy(flatTree, treePrefixToRemove) {\n    const lookup = {};\n    // Root tree id will be used to determine which version was downloaded.\n    const root = { id: flatTree.id, blobs: {}, trees: {} };\n    lookup[\"\"] = root;\n    for (const entry of flatTree.entries) {\n        // Strip the `treePrefixToRemove` path from tree entries such that they are stored under root.\n        const entryPath = entry.path.replace(new RegExp(`^${treePrefixToRemove}/`), \"\");\n        const lastIndex = entryPath.lastIndexOf(\"/\");\n        const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));\n        const entryPathBase = entryPath.slice(lastIndex + 1);\n        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents\n        const node = lookup[entryPathDir];\n        // Add in either the blob or tree\n        if (entry.type === \"tree\") {\n            const newTree = { blobs: {}, trees: {}, unreferenced: entry.unreferenced };\n            node.trees[decodeURIComponent(entryPathBase)] = newTree;\n            lookup[entryPath] = newTree;\n        }\n        else if (entry.type === \"blob\") {\n            node.blobs[decodeURIComponent(entryPathBase)] = entry.id;\n        }\n        else {\n            throw new Error(`Unknown entry type!!`);\n        }\n    }\n    return root;\n}\n/**\n * Converts existing IWholeFlatSummary to snapshot tree, blob array, and sequence number.\n *\n * @param flatSummary - flat summary\n * @param treePrefixToRemove - tree prefix to strip. By default we are stripping \".app\" prefix\n * @returns snapshot tree, blob array, and sequence number\n */\nfunction convertWholeFlatSummaryToSnapshotTreeAndBlobs(flatSummary, treePrefixToRemove = \".app\") {\n    var _a;\n    const blobs = new Map();\n    if (flatSummary.blobs) {\n        flatSummary.blobs.forEach((blob) => {\n            var _a;\n            blobs.set(blob.id, (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.stringToBuffer)(blob.content, (_a = blob.encoding) !== null && _a !== void 0 ? _a : \"utf-8\"));\n        });\n    }\n    const flatSummaryTree = (_a = flatSummary.trees) === null || _a === void 0 ? void 0 : _a[0];\n    const sequenceNumber = flatSummaryTree === null || flatSummaryTree === void 0 ? void 0 : flatSummaryTree.sequenceNumber;\n    const snapshotTree = buildHierarchy(flatSummaryTree, treePrefixToRemove);\n    return {\n        blobs,\n        snapshotTree,\n        sequenceNumber,\n    };\n}\n//# sourceMappingURL=storageUtils.js.map\n\n/***/ }),\n/* 442 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 443 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryTreeAssembler\": () => (/* binding */ SummaryTreeAssembler),\n/* harmony export */   \"convertSnapshotAndBlobsToSummaryTree\": () => (/* binding */ convertSnapshotAndBlobsToSummaryTree)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Summary tree assembler (without stats collection).\n */\nclass SummaryTreeAssembler {\n    constructor(props) {\n        this.props = props;\n        this.attachmentCounter = 0;\n        this.summaryTree = {};\n    }\n    /**\n    * Get final summary\n    */\n    get summary() {\n        var _a;\n        return {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,\n            tree: Object.assign({}, this.summaryTree),\n            unreferenced: (_a = this.props) === null || _a === void 0 ? void 0 : _a.unreferenced,\n        };\n    }\n    /**\n    * Add blob to summary\n    */\n    addBlob(key, content) {\n        this.summaryTree[key] = {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob,\n            content,\n        };\n    }\n    /**\n    * Add handle to summary\n    */\n    addHandle(key, handleType, handle) {\n        this.summaryTree[key] = {\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle,\n            handleType,\n            handle,\n        };\n    }\n    /**\n    * Add tree to summary\n    */\n    addTree(key, summary) {\n        this.summaryTree[key] = summary;\n    }\n    /**\n    * Add attachment to summary\n    */\n    addAttachment(id) {\n        this.summaryTree[this.attachmentCounter++] = { id, type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment };\n    }\n}\n/**\n * Helper function that converts ISnapshotTree and blobs to ISummaryTree\n * @param snapshot - Source snapshot tree\n * @param blobs - Blobs cache\n * @returns Converted snapshot in ISummaryTree format\n */\nfunction convertSnapshotAndBlobsToSummaryTree(snapshot, blobs) {\n    const assembler = new SummaryTreeAssembler({\n        unreferenced: snapshot.unreferenced,\n    });\n    for (const [path, id] of Object.entries(snapshot.blobs)) {\n        const blob = blobs.get(id);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(blob !== undefined, 0x2dd /* \"Cannot find blob for a given id\" */);\n        assembler.addBlob(path, _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.IsoBuffer.from(blob).toString(\"utf-8\"));\n    }\n    for (const [key, tree] of Object.entries(snapshot.trees)) {\n        const subtree = convertSnapshotAndBlobsToSummaryTree(tree, blobs);\n        assembler.addTree(key, subtree);\n    }\n    return assembler.summary;\n}\n//# sourceMappingURL=treeUtils.js.map\n\n/***/ }),\n/* 444 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShreddedSummaryDocumentStorageService\": () => (/* binding */ ShreddedSummaryDocumentStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(399);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);\n/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(445);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);\n/* harmony import */ var _retriableGitManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(447);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\nconst isNode = typeof window === \"undefined\";\n/**\n * Document access to underlying storage for routerlicious driver.\n * Uploads summaries piece-by-piece traversing the tree recursively.\n * Downloads summaries piece-by-piece on-demand, or up-front when prefetch is enabled.\n */\nclass ShreddedSummaryDocumentStorageService {\n    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, getStorageManager = async () => this.manager) {\n        this.id = id;\n        this.manager = manager;\n        this.logger = logger;\n        this.policies = policies;\n        this.getStorageManager = getStorageManager;\n        // The values of this cache is useless. We only need the keys. So we are always putting\n        // empty strings as values.\n        this.blobsShaCache = new Map();\n        if ((driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableRestLess) === true || isNode) {\n            this.blobCache = blobCache !== null && blobCache !== void 0 ? blobCache : new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();\n            this.snapshotTreeCache = snapshotTreeCache !== null && snapshotTreeCache !== void 0 ? snapshotTreeCache : new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();\n        }\n    }\n    get repositoryUrl() {\n        return \"\";\n    }\n    async getSummaryUploadManager() {\n        const manager = await this.getStorageManager();\n        return new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeUploadManager(new _retriableGitManager__WEBPACK_IMPORTED_MODULE_2__.RetriableGitManager(manager, this.logger), this.blobsShaCache, this.getPreviousFullSnapshot.bind(this));\n    }\n    async getVersions(versionId, count) {\n        const id = versionId ? versionId : this.id;\n        const commits = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"getVersions\",\n            versionId: id,\n            count,\n        }, async () => {\n            const manager = await this.getStorageManager();\n            return manager.getCommits(id, count);\n        });\n        return commits.map((commit) => ({\n            date: commit.commit.author.date,\n            id: commit.sha,\n            treeId: commit.commit.tree.sha,\n        }));\n    }\n    async getSnapshotTree(version) {\n        var _a, _b;\n        let requestVersion = version;\n        if (!requestVersion) {\n            const versions = await this.getVersions(this.id, 1);\n            if (versions.length === 0) {\n                return null;\n            }\n            requestVersion = versions[0];\n        }\n        const cachedSnapshotTree = await ((_a = this.snapshotTreeCache) === null || _a === void 0 ? void 0 : _a.get(this.getCacheKey(requestVersion.treeId)));\n        if (cachedSnapshotTree) {\n            return cachedSnapshotTree.snapshotTree;\n        }\n        const rawTree = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"getSnapshotTree\",\n            treeId: requestVersion.treeId,\n        }, async (event) => {\n            const manager = await this.getStorageManager();\n            const response = await manager.getTree(requestVersion.treeId);\n            event.end({\n                size: response.tree.length,\n            });\n            return response;\n        });\n        const tree = (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.buildHierarchy)(rawTree, this.blobsShaCache, true);\n        await ((_b = this.snapshotTreeCache) === null || _b === void 0 ? void 0 : _b.put(this.getCacheKey(tree.id), { id: requestVersion.id, snapshotTree: tree }));\n        return tree;\n    }\n    async readBlob(blobId) {\n        var _a, _b;\n        const cachedBlob = await ((_a = this.blobCache) === null || _a === void 0 ? void 0 : _a.get(this.getCacheKey(blobId)));\n        if (cachedBlob) {\n            return cachedBlob;\n        }\n        const value = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"readBlob\",\n            blobId,\n        }, async (event) => {\n            const manager = await this.getStorageManager();\n            const response = await manager.getBlob(blobId);\n            event.end({\n                size: response.size,\n            });\n            return response;\n        });\n        this.blobsShaCache.set(value.sha, \"\");\n        const bufferContent = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.stringToBuffer)(value.content, value.encoding);\n        await ((_b = this.blobCache) === null || _b === void 0 ? void 0 : _b.put(this.getCacheKey(value.sha), bufferContent));\n        return bufferContent;\n    }\n    async uploadSummaryWithContext(summary, context) {\n        const summaryHandle = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"uploadSummaryWithContext\",\n        }, async () => {\n            var _a;\n            const summaryUploadManager = await this.getSummaryUploadManager();\n            return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : \"\", \"channel\");\n        });\n        return summaryHandle;\n    }\n    async downloadSummary(handle) {\n        throw new Error(\"NOT IMPLEMENTED!\");\n    }\n    async createBlob(file) {\n        const uint8ArrayFile = new Uint8Array(file);\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"createBlob\",\n            size: uint8ArrayFile.length,\n        }, async (event) => {\n            const manager = await this.getStorageManager();\n            const response = await manager.createBlob((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.Uint8ArrayToString)(uint8ArrayFile, \"base64\"), \"base64\").then((r) => ({ id: r.sha, url: r.url }));\n            event.end({\n                blobId: response.id,\n            });\n            return response;\n        });\n    }\n    async getPreviousFullSnapshot(parentHandle) {\n        return parentHandle\n            ? this.getVersions(parentHandle, 1)\n                .then(async (versions) => {\n                // Clear the cache as the getSnapshotTree call will fill the cache.\n                this.blobsShaCache.clear();\n                return this.getSnapshotTree(versions[0]);\n            })\n            : undefined;\n    }\n    getCacheKey(blobId) {\n        return `${this.id}:${blobId}`;\n    }\n}\n//# sourceMappingURL=shreddedSummaryDocumentStorageService.js.map\n\n/***/ }),\n/* 445 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryTreeUploadManager\": () => (/* binding */ SummaryTreeUploadManager)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(442);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(399);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(446);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(333);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(402);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Recursively writes summary tree as individual summary blobs.\n */\nclass SummaryTreeUploadManager {\n    constructor(manager, blobsShaCache, getPreviousFullSnapshot) {\n        this.manager = manager;\n        this.blobsShaCache = blobsShaCache;\n        this.getPreviousFullSnapshot = getPreviousFullSnapshot;\n    }\n    async writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {\n        const previousFullSnapshot = await this.getPreviousFullSnapshot(parentHandle);\n        return this.writeSummaryTreeCore(summaryTree, previousFullSnapshot !== null && previousFullSnapshot !== void 0 ? previousFullSnapshot : undefined);\n    }\n    async writeSummaryTreeCore(summaryTree, previousFullSnapshot) {\n        const entries = await Promise.all(Object.keys(summaryTree.tree).map(async (key) => {\n            const entry = summaryTree.tree[key];\n            const pathHandle = await this.writeSummaryTreeObject(entry, previousFullSnapshot);\n            const treeEntry = {\n                mode: (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.getGitMode)(entry),\n                path: encodeURIComponent(key),\n                sha: pathHandle,\n                type: (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.getGitType)(entry),\n            };\n            return treeEntry;\n        }));\n        const treeHandle = await this.manager.createGitTree({ tree: entries });\n        return treeHandle.sha;\n    }\n    async writeSummaryTreeObject(object, previousFullSnapshot) {\n        switch (object.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Blob: {\n                return this.writeSummaryBlob(object.content);\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Handle: {\n                if (previousFullSnapshot === undefined) {\n                    throw Error(\"Parent summary does not exist to reference by handle.\");\n                }\n                return this.getIdFromPath(object.handleType, object.handle, previousFullSnapshot);\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Tree: {\n                return this.writeSummaryTreeCore(object, previousFullSnapshot);\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Attachment: {\n                return object.id;\n            }\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(object, `Unknown type: ${object.type}`);\n        }\n    }\n    async writeSummaryBlob(content) {\n        const { parsedContent, encoding } = typeof content === \"string\"\n            ? { parsedContent: content, encoding: \"utf-8\" }\n            : { parsedContent: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Uint8ArrayToString)(content, \"base64\"), encoding: \"base64\" };\n        // The gitHashFile would return the same hash as returned by the server as blob.sha\n        const hash = await (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.gitHashFile)(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.IsoBuffer.from(parsedContent, encoding));\n        if (!this.blobsShaCache.has(hash)) {\n            this.blobsShaCache.set(hash, \"\");\n            const blob = await this.manager.createBlob(parsedContent, encoding);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(hash === blob.sha, 0x0b6 /* \"Blob.sha and hash do not match!!\" */);\n        }\n        return hash;\n    }\n    getIdFromPath(handleType, handlePath, previousFullSnapshot) {\n        const path = handlePath.split(\"/\").map((part) => decodeURIComponent(part));\n        if (path[0] === \"\") {\n            // root of tree should be unnamed\n            path.shift();\n        }\n        if (path.length === 0) {\n            return previousFullSnapshot.id;\n        }\n        return this.getIdFromPathCore(handleType, path, previousFullSnapshot);\n    }\n    getIdFromPathCore(handleType, path, \n    /** Previous snapshot, subtree relative to this path part */\n    previousSnapshot) {\n        var _a;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(path.length > 0, 0x0b3 /* \"Expected at least 1 path part\" */);\n        const key = path[0];\n        if (path.length === 1) {\n            switch (handleType) {\n                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Blob: {\n                    const tryId = previousSnapshot.blobs[key];\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!tryId, 0x0b4 /* \"Parent summary does not have blob handle for specified path.\" */);\n                    return tryId;\n                }\n                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Tree: {\n                    const tryId = (_a = previousSnapshot.trees[key]) === null || _a === void 0 ? void 0 : _a.id;\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!tryId, 0x0b5 /* \"Parent summary does not have tree handle for specified path.\" */);\n                    return tryId;\n                }\n                default:\n                    throw Error(`Unexpected handle summary object type: \"${handleType}\".`);\n            }\n        }\n        return this.getIdFromPathCore(handleType, path.slice(1), previousSnapshot.trees[key]);\n    }\n}\n//# sourceMappingURL=summaryTreeUploadManager.js.map\n\n/***/ }),\n/* 446 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"gitHashFile\": () => (/* binding */ gitHashFile),\n/* harmony export */   \"hashFile\": () => (/* binding */ hashFile)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _bufferBrowser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(399);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nasync function digestBuffer(file, algorithm) {\n    const hash = await crypto.subtle.digest(algorithm, file);\n    return new Uint8Array(hash);\n}\nfunction encodeDigest(hashArray, encoding) {\n    // eslint-disable-next-line default-case\n    switch (encoding) {\n        case \"hex\": {\n            const hashHex = Array.prototype.map.call(hashArray, (byte) => {\n                return byte.toString(16).padStart(2, \"0\");\n            }).join(\"\");\n            return hashHex;\n        }\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(hashArray);\n        }\n    }\n}\n/**\n * Hash a file. Consistent within a session, but should not be persisted and\n * is not consistent with git.\n * If called under an insecure context for a browser, this will fallback to\n * using the node implementation.\n *\n * @param file - The contents of the file in a buffer\n * @param algorithm - The hash algorithm to use, artificially constrained by what is used internally\n * @param hashEncoding - The encoding of the returned hash, also artificially constrained\n * @returns The hash of the content of the buffer\n */\nasync function hashFile(file, algorithm = \"SHA-1\", hashEncoding = \"hex\") {\n    // Handle insecure contexts (e.g. running with local services)\n    // by deferring to Node version, which uses a hash polyfill\n    // When packed, this chunk will show as \"FluidFramework-HashFallback\" separately\n    // from the main chunk and will be of non-trivial size.  It will not be served\n    // under normal circumstances.\n    if (crypto.subtle === undefined) {\n        return __webpack_require__.e(/* import() | FluidFramework-HashFallback */ 0).then(__webpack_require__.bind(__webpack_require__, 552)).then(async (m) => m.hashFile(file, algorithm, hashEncoding));\n    }\n    // This is split up this way to facilitate testing (see the test for more info)\n    const hashArray = await digestBuffer(file, algorithm);\n    return encodeDigest(hashArray, hashEncoding);\n}\n/**\n * Create a github hash (Github hashes the string with blob and size)\n * Must be called under secure context for browsers\n *\n * @param file - The contents of the file in a buffer\n * @returns The sha1 hash of the content of the buffer with the `blob` prefix and size\n */\nasync function gitHashFile(file) {\n    const size = file.byteLength;\n    const filePrefix = `blob ${size.toString()}${String.fromCharCode(0)}`;\n    const hashBuffer = _bufferBrowser__WEBPACK_IMPORTED_MODULE_1__.IsoBuffer.from(filePrefix + file.toString());\n    // hashFile uses sha1; if that changes this will need to change too\n    return hashFile(hashBuffer);\n}\n//# sourceMappingURL=hashFileBrowser.js.map\n\n/***/ }),\n/* 447 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RetriableGitManager\": () => (/* binding */ RetriableGitManager)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(448);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass RetriableGitManager {\n    constructor(internalGitManager, logger) {\n        this.internalGitManager = internalGitManager;\n        this.logger = logger;\n    }\n    async getHeader(id, sha) {\n        return this.runWithRetry(async () => this.internalGitManager.getHeader(id, sha), \"gitManager_getHeader\");\n    }\n    async getFullTree(sha) {\n        return this.runWithRetry(async () => this.internalGitManager.getFullTree(sha), \"gitManager_getFullTree\");\n    }\n    async getCommit(sha) {\n        return this.runWithRetry(async () => this.internalGitManager.getCommit(sha), \"gitManager_getCommit\");\n    }\n    async getCommits(sha, count) {\n        return this.runWithRetry(async () => this.internalGitManager.getCommits(sha, count), \"gitManager_getCommits\");\n    }\n    async getTree(root, recursive) {\n        return this.runWithRetry(async () => this.internalGitManager.getTree(root, recursive), \"gitManager_getTree\");\n    }\n    async getBlob(sha) {\n        return this.runWithRetry(async () => this.internalGitManager.getBlob(sha), \"gitManager_getBlob\");\n    }\n    getRawUrl(sha) {\n        return this.internalGitManager.getRawUrl(sha);\n    }\n    async getContent(commit, path) {\n        return this.runWithRetry(async () => this.internalGitManager.getContent(commit, path), \"gitManager_getContent\");\n    }\n    async createBlob(content, encoding) {\n        return this.runWithRetry(async () => this.internalGitManager.createBlob(content, encoding), \"gitManager_createBlob\");\n    }\n    async createGitTree(params) {\n        return this.runWithRetry(async () => this.internalGitManager.createGitTree(params), \"gitManager_createGitTree\");\n    }\n    async createTree(files) {\n        return this.runWithRetry(async () => this.internalGitManager.createTree(files), \"gitManager_createTree\");\n    }\n    async createCommit(commit) {\n        return this.runWithRetry(async () => this.internalGitManager.createCommit(commit), \"gitManager_createCommit\");\n    }\n    async getRef(ref) {\n        return this.runWithRetry(async () => this.internalGitManager.getRef(ref), \"gitManager_getRef\");\n    }\n    async createRef(branch, sha) {\n        return this.runWithRetry(async () => this.internalGitManager.createRef(branch, sha), \"gitManager_createRef\");\n    }\n    async upsertRef(branch, commitSha) {\n        return this.runWithRetry(async () => this.internalGitManager.upsertRef(branch, commitSha), \"gitManager_upsertRef\");\n    }\n    async write(branch, inputTree, parents, message) {\n        return this.runWithRetry(async () => this.internalGitManager.write(branch, inputTree, parents, message), \"gitManager_write\");\n    }\n    async createSummary(summary) {\n        return this.runWithRetry(async () => this.internalGitManager.createSummary(summary), \"gitManager_createSummary\");\n    }\n    async deleteSummary(softDelete) {\n        return this.runWithRetry(async () => this.internalGitManager.deleteSummary(softDelete), \"gitManager_deleteSummary\");\n    }\n    async getSummary(sha) {\n        return this.runWithRetry(async () => this.internalGitManager.getSummary(sha), \"gitManager_getSummary\");\n    }\n    async runWithRetry(api, callName) {\n        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.runWithRetry)(api, callName, this.logger, {});\n    }\n}\n//# sourceMappingURL=retriableGitManager.js.map\n\n/***/ }),\n/* 448 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"runWithRetry\": () => (/* binding */ runWithRetry)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(449);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(451);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);\n/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(450);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\nasync function runWithRetry(api, fetchCallName, logger, progress) {\n    var _a, _b;\n    let result;\n    let success = false;\n    let retryAfterMs = 1000; // has to be positive!\n    let numRetries = 0;\n    const startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();\n    let lastError;\n    do {\n        try {\n            result = await api(progress.cancel);\n            success = true;\n        }\n        catch (err) {\n            // If it is not retriable, then just throw the error.\n            if (!(0,_network__WEBPACK_IMPORTED_MODULE_1__.canRetryOnError)(err)) {\n                logger.sendTelemetryEvent({\n                    eventName: `${fetchCallName}_cancel`,\n                    retry: numRetries,\n                    duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - startTime,\n                    fetchCallName,\n                }, err);\n                throw err;\n            }\n            if (((_a = progress.cancel) === null || _a === void 0 ? void 0 : _a.aborted) === true) {\n                logger.sendTelemetryEvent({\n                    eventName: `${fetchCallName}_runWithRetryAborted`,\n                    retry: numRetries,\n                    duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - startTime,\n                    fetchCallName,\n                }, err);\n                throw new _network__WEBPACK_IMPORTED_MODULE_1__.NonRetryableError(\"runWithRetry was Aborted\", _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__.DriverErrorType.genericError, { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion, fetchCallName });\n            }\n            numRetries++;\n            lastError = err;\n            // If the error is throttling error, then wait for the specified time before retrying.\n            // If the waitTime is not specified, then we start with retrying immediately to max of 8s.\n            retryAfterMs = (_b = (0,_network__WEBPACK_IMPORTED_MODULE_1__.getRetryDelayFromError)(err)) !== null && _b !== void 0 ? _b : Math.min(retryAfterMs * 2, 8000);\n            if (progress.onRetry) {\n                progress.onRetry(retryAfterMs, err);\n            }\n            await (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.delay)(retryAfterMs);\n        }\n    } while (!success);\n    if (numRetries > 0) {\n        logger.sendTelemetryEvent({\n            eventName: `${fetchCallName}_lastError`,\n            retry: numRetries,\n            duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - startTime,\n            fetchCallName,\n        }, lastError);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return result;\n}\n//# sourceMappingURL=runWithRetry.js.map\n\n/***/ }),\n/* 449 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst performance = window.performance;\n//# sourceMappingURL=performanceBrowser.js.map\n\n/***/ }),\n/* 450 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/driver-utils\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 451 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"delay\": () => (/* binding */ delay)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Returns a promise that resolves after timeMs\n * @param timeMs - time in milliseconds to wait\n */\nconst delay = async (timeMs) => new Promise((resolve) => setTimeout(() => resolve(), timeMs));\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n/* 452 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrefetchDocumentStorageService\": () => (/* binding */ PrefetchDocumentStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(437);\n/* harmony import */ var _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);\n/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nclass PrefetchDocumentStorageService extends _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {\n    constructor() {\n        super(...arguments);\n        // BlobId -> blob prefetchCache cache\n        this.prefetchCache = new Map();\n        this.prefetchEnabled = true;\n    }\n    get policies() {\n        const policies = this.internalStorageService.policies;\n        if (policies) {\n            return Object.assign(Object.assign({}, policies), { caching: _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderCachingPolicy.NoCaching });\n        }\n    }\n    async getSnapshotTree(version) {\n        const p = this.internalStorageService.getSnapshotTree(version);\n        if (this.prefetchEnabled) {\n            // We don't care if the prefetch succeeds\n            void p.then((tree) => {\n                if (tree === null || tree === undefined) {\n                    return;\n                }\n                this.prefetchTree(tree);\n            });\n        }\n        return p;\n    }\n    async readBlob(blobId) {\n        return this.cachedRead(blobId);\n    }\n    stopPrefetch() {\n        this.prefetchEnabled = false;\n        this.prefetchCache.clear();\n    }\n    async cachedRead(blobId) {\n        if (this.prefetchEnabled) {\n            const prefetchedBlobP = this.prefetchCache.get(blobId);\n            if (prefetchedBlobP !== undefined) {\n                return prefetchedBlobP;\n            }\n            const prefetchedBlobPFromStorage = this.internalStorageService.readBlob(blobId);\n            this.prefetchCache.set(blobId, prefetchedBlobPFromStorage.catch((error) => {\n                if ((0,_network__WEBPACK_IMPORTED_MODULE_2__.canRetryOnError)(error)) {\n                    this.prefetchCache.delete(blobId);\n                }\n                throw error;\n            }));\n            return prefetchedBlobPFromStorage;\n        }\n        return this.internalStorageService.readBlob(blobId);\n    }\n    prefetchTree(tree) {\n        const secondary = [];\n        this.prefetchTreeCore(tree, secondary);\n        for (const blob of secondary) {\n            // We don't care if the prefetch succeeds\n            void this.cachedRead(blob);\n        }\n    }\n    prefetchTreeCore(tree, secondary) {\n        for (const blobKey of Object.keys(tree.blobs)) {\n            const blob = tree.blobs[blobKey];\n            if (blobKey.startsWith(\".\") || blobKey === \"header\" || blobKey.startsWith(\"quorum\")) {\n                if (blob !== null) {\n                    // We don't care if the prefetch succeeds\n                    void this.cachedRead(blob);\n                }\n            }\n            else if (!blobKey.startsWith(\"deltas\")) {\n                if (blob !== null) {\n                    secondary.push(blob);\n                }\n            }\n        }\n        for (const subTree of Object.keys(tree.trees)) {\n            this.prefetchTreeCore(tree.trees[subTree], secondary);\n        }\n    }\n}\n//# sourceMappingURL=prefetchDocumentStorageService.js.map\n\n/***/ }),\n/* 453 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeltaStorageService\": () => (/* binding */ DeltaStorageService),\n/* harmony export */   \"DocumentDeltaStorageService\": () => (/* binding */ DocumentDeltaStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(454);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(457);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nconst MaxBatchDeltas = 2000; // Maximum number of ops we can fetch at a time\n/**\n * Storage service limited to only being able to fetch documents for a specific document\n */\nclass DocumentDeltaStorageService {\n    constructor(tenantId, id, deltaStorageService, documentStorageService) {\n        this.tenantId = tenantId;\n        this.id = id;\n        this.deltaStorageService = deltaStorageService;\n        this.documentStorageService = documentStorageService;\n        this.logtailSha = this.documentStorageService.logTailSha;\n    }\n    fetchMessages(from, to, abortSignal, cachedOnly, fetchReason) {\n        if (cachedOnly) {\n            return _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.emptyMessageStream;\n        }\n        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.requestOps)(this.getCore.bind(this), \n        // Staging: starting with no concurrency, listening for feedback first.\n        // In future releases we will switch to actual concurrency\n        1, // concurrency\n        from, // inclusive\n        to, // exclusive\n        MaxBatchDeltas, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryNullLogger(), abortSignal, fetchReason);\n    }\n    async getCore(from, to) {\n        const opsFromLogTail = this.logtailSha\n            ? await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.readAndParse)(this.documentStorageService, this.logtailSha)\n            : [];\n        this.logtailSha = undefined;\n        if (opsFromLogTail.length > 0) {\n            const messages = opsFromLogTail.filter((op) => op.sequenceNumber >= from);\n            if (messages.length > 0) {\n                return { messages, partialResult: true };\n            }\n        }\n        return this.deltaStorageService.get(this.tenantId, this.id, from, to);\n    }\n}\n/**\n * Provides access to the underlying delta storage on the server for routerlicious driver.\n */\nclass DeltaStorageService {\n    constructor(url, restWrapper, logger, getRestWrapper = async () => this.restWrapper, getDeltaStorageUrl = () => this.url) {\n        this.url = url;\n        this.restWrapper = restWrapper;\n        this.logger = logger;\n        this.getRestWrapper = getRestWrapper;\n        this.getDeltaStorageUrl = getDeltaStorageUrl;\n    }\n    async get(tenantId, id, from, // inclusive\n    to) {\n        const ops = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {\n            eventName: \"getDeltas\",\n            from,\n            to,\n        }, async (event) => {\n            const restWrapper = await this.getRestWrapper();\n            const url = this.getDeltaStorageUrl();\n            const response = await restWrapper.get(url, { from: from - 1, to });\n            event.end({\n                count: response.length,\n            });\n            return response;\n        });\n        // It is assumed that server always returns all the ops that it has in the range that was requested.\n        // This may change in the future, if so, we need to adjust and receive \"end\" value from server in such case.\n        return { messages: ops, partialResult: false };\n    }\n}\n//# sourceMappingURL=deltaStorageService.js.map\n\n/***/ }),\n/* 454 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParallelRequests\": () => (/* binding */ ParallelRequests),\n/* harmony export */   \"Queue\": () => (/* binding */ Queue),\n/* harmony export */   \"emptyMessageStream\": () => (/* binding */ emptyMessageStream),\n/* harmony export */   \"requestOps\": () => (/* binding */ requestOps),\n/* harmony export */   \"streamFromMessages\": () => (/* binding */ streamFromMessages),\n/* harmony export */   \"streamObserver\": () => (/* binding */ streamObserver)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(455);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(449);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(45);\n/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(117);\n/* harmony import */ var _networkUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(456);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(450);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n// For now, this package is versioned and released in unison with the specific drivers\n\nconst MaxFetchDelayInMs = 10000;\nconst MissingFetchDelayInMs = 100;\n/**\n * Helper class to organize parallel fetching of data\n * It can be used to concurrently do many requests, while consuming\n * data in the right order. Take a look at UT for examples.\n * @param concurrency - level of concurrency\n * @param from - starting point of fetching data (inclusive)\n * @param to  - ending point of fetching data. exclusive, or undefined if unknown\n * @param payloadSize - batch size\n * @param logger - logger to use\n * @param requestCallback - callback to request batches\n * @returns - Queue that can be used to retrieve data\n */\nclass ParallelRequests {\n    constructor(from, to, payloadSize, logger, requestCallback, responseCallback) {\n        this.to = to;\n        this.payloadSize = payloadSize;\n        this.logger = logger;\n        this.requestCallback = requestCallback;\n        this.responseCallback = responseCallback;\n        this.results = new Map();\n        this.workingState = \"working\";\n        this.requestsInFlight = 0;\n        this.endEvent = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.requests = 0;\n        this.latestRequested = from;\n        this.nextToDeliver = from;\n        this.knewTo = (to !== undefined);\n    }\n    get working() { return this.workingState === \"working\"; }\n    get canceled() { return this.workingState === \"canceled\"; }\n    cancel() {\n        if (this.working) {\n            this.workingState = \"canceled\";\n            this.endEvent.resolve();\n        }\n    }\n    async run(concurrency) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(concurrency > 0, 0x102 /* \"invalid level of concurrency\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.working, 0x103 /* \"trying to parallel run while not working\" */);\n        let c = concurrency;\n        while (c > 0) {\n            c--;\n            this.addRequest();\n        }\n        this.dispatch(); // will recalculate and trigger this.endEvent if needed\n        return this.endEvent.promise;\n    }\n    done() {\n        // We should satisfy request fully.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.to !== undefined, 0x104 /* \"undefined end point for parallel fetch\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.nextToDeliver >= this.to, 0x105 /* \"unexpected end point for parallel fetch\" */);\n        if (this.working) {\n            this.workingState = \"done\";\n            this.endEvent.resolve();\n        }\n    }\n    fail(error) {\n        if (this.working) {\n            this.workingState = \"done\";\n            this.endEvent.reject(error);\n        }\n    }\n    dispatch() {\n        while (this.working) {\n            const value = this.results.get(this.nextToDeliver);\n            if (value === undefined) {\n                break;\n            }\n            this.results.delete(this.nextToDeliver);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(value.length <= this.payloadSize, 0x1d9 /* \"addRequestCore() should break into smaller chunks\" */);\n            this.nextToDeliver += value.length;\n            this.responseCallback(value);\n        }\n        // Account for cancellation - state might be not in consistent state on cancelling operation\n        if (this.working) {\n            if (this.requestsInFlight === 0) {\n                // we should have dispatched everything, no matter whether we knew about the end or not.\n                // see comment in addRequestCore() around throwing away chunk if it's above this.to\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.results.size === 0, 0x107 /* \"ending dispatch with remaining results to be sent\" */);\n                this.done();\n            }\n            else if (this.to !== undefined && this.nextToDeliver >= this.to) {\n                // Learned about the end and dispatched all the ops up to it.\n                // Ignore all the in-flight requests above boundary - unblock caller sooner.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x108 /* \"ending results dispatch but knew in advance about more requests\" */);\n                this.done();\n            }\n        }\n    }\n    getNextChunk() {\n        if (!this.working) {\n            return undefined;\n        }\n        const from = this.latestRequested;\n        if (this.to !== undefined) {\n            if (this.to <= from) {\n                return undefined;\n            }\n        }\n        // this.latestRequested\n        // inclusive on the right side! Exclusive on the left.\n        this.latestRequested += this.payloadSize;\n        if (this.to !== undefined) {\n            this.latestRequested = Math.min(this.to, this.latestRequested);\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(from < this.latestRequested, 0x109 /* \"unexpected next chunk position\" */);\n        return { from, to: this.latestRequested };\n    }\n    addRequest() {\n        const chunk = this.getNextChunk();\n        if (chunk === undefined) {\n            return;\n        }\n        this.addRequestCore(chunk.from, chunk.to).catch(this.fail.bind(this));\n    }\n    async addRequestCore(fromArg, toArg) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.working, 0x10a /* \"cannot add parallel request while not working\" */);\n        let from = fromArg;\n        let to = toArg;\n        // to & from are exclusive\n        this.requestsInFlight++;\n        while (this.working) {\n            const requestedLength = to - from;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(requestedLength > 0, 0x10b /* \"invalid parallel request range\" */);\n            // We should not be wasting time asking for something useless.\n            if (this.to !== undefined) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(from < this.to, 0x10c /* \"invalid parallel request start point\" */);\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(to <= this.to, 0x10d /* \"invalid parallel request end point\" */);\n            }\n            this.requests++;\n            const promise = this.requestCallback(this.requests, from, to, this.to !== undefined, {});\n            // dispatch any prior received data\n            this.dispatch();\n            const { payload, cancel, partial } = await promise;\n            if (cancel) {\n                this.cancel();\n            }\n            if (this.to !== undefined && from >= this.to) {\n                // while we were waiting for response, we learned on what is the boundary\n                // We can get here (with actual result!) if situation changed while this request was in\n                // flight, i.e. the end was extended over what we learn in some other request\n                // While it's useful not to throw this result, this is very corner cases and makes logic\n                // (including consistency checks) much harder to write correctly.\n                // So for now, we are throwing this result out the window.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x10e /* \"should not throw result if we knew about boundary in advance\" */);\n                // Learn how often it happens and if it's too wasteful to throw these chunks.\n                // If it pops into our view a lot, we would need to reconsider how we approach it.\n                // Note that this is not visible to user other than potentially not hitting 100% of\n                // what we can in perf domain.\n                if (payload.length !== 0) {\n                    this.logger.sendErrorEvent({\n                        eventName: \"ParallelRequests_GotExtra\",\n                        from,\n                        to,\n                        end: this.to,\n                        length: payload.length,\n                    });\n                }\n                break;\n            }\n            if (this.working) {\n                const fromOrig = from;\n                const length = payload.length;\n                let fullChunk = (requestedLength <= length); // we can possible get more than we asked.\n                if (length !== 0) {\n                    // We can get more than we asked for!\n                    // This can screw up logic in dispatch!\n                    // So push only batch size, and keep the rest for later - if conditions are favorable, we\n                    // will be able to use it. If not (parallel request overlapping these ops), it's easier to\n                    // discard them and wait for another (overlapping) request to come in later.\n                    if (requestedLength < length) {\n                        // This is error in a sense that it's not expected and likely points bug in other layer.\n                        // This layer copes with this situation just fine.\n                        this.logger.sendTelemetryEvent({\n                            eventName: \"ParallelRequests_Over\",\n                            from,\n                            to,\n                            length,\n                        });\n                    }\n                    const data = payload.splice(0, requestedLength);\n                    this.results.set(from, data);\n                    from += data.length;\n                }\n                else {\n                    // 1. empty (partial) chunks should not be returned by various caching / adapter layers -\n                    //    they should fall back to next layer. This might be important invariant to hold to ensure\n                    //    that we are less likely have bugs where such layer would keep returning empty partial\n                    //    result on each call.\n                    // 2. Current invariant is that callback does retries until it gets something,\n                    //    with the goal of failing if zero data is retrieved in given amount of time.\n                    //    This is very specific property of storage / ops, so this logic is not here, but given only\n                    //    one user of this class, we assert that to catch issues earlier.\n                    // These invariant can be relaxed if needed.\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!partial, 0x10f /* \"empty/partial chunks should not be returned by caching\" */);\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x110 /* \"callback should retry until valid fetch before it learns new boundary\" */);\n                }\n                if (!partial && !fullChunk) {\n                    if (!this.knewTo) {\n                        if (this.to === undefined || this.to > from) {\n                            // The END\n                            this.to = from;\n                        }\n                        break;\n                    }\n                    // We know that there are more items to be retrieved\n                    // Can we get partial chunk? Ideally storage indicates that's not a full chunk\n                    // Note that it's possible that not all ops hit storage yet.\n                    // We will come back to request more, and if we can't get any more ops soon, it's\n                    // catastrophic failure (see comment above on responsibility of callback to return something)\n                    // This layer will just keep trying until it gets full set.\n                    this.logger.sendPerformanceEvent({\n                        eventName: \"ParallelRequests_Partial\",\n                        from: fromOrig,\n                        to,\n                        length,\n                    });\n                }\n                if (to === this.latestRequested) {\n                    // we can go after full chunk at the end if we received partial chunk, or more than asked\n                    // Also if we got more than we asked to, we can actually use those ops!\n                    if (payload.length !== 0) {\n                        this.results.set(from, payload);\n                        from += payload.length;\n                    }\n                    this.latestRequested = from;\n                    fullChunk = true;\n                }\n                if (fullChunk) {\n                    const chunk = this.getNextChunk();\n                    if (chunk === undefined) {\n                        break;\n                    }\n                    from = chunk.from;\n                    to = chunk.to;\n                }\n            }\n        }\n        this.requestsInFlight--;\n        this.dispatch();\n    }\n}\n/**\n * Helper queue class to allow async push / pull\n * It's essentially a pipe allowing multiple writers, and single reader\n */\nclass Queue {\n    constructor() {\n        this.queue = [];\n        this.done = false;\n    }\n    pushValue(value) {\n        this.pushCore(Promise.resolve({ done: false, value }));\n    }\n    pushError(error) {\n        this.pushCore(Promise.reject(error));\n        this.done = true;\n    }\n    pushDone() {\n        this.pushCore(Promise.resolve({ done: true }));\n        this.done = true;\n    }\n    pushCore(value) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.done, 0x112 /* \"cannot push onto queue if done\" */);\n        if (this.deferred) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.queue.length === 0, 0x113 /* \"deferred queue should be empty\" */);\n            this.deferred.resolve(value);\n            this.deferred = undefined;\n        }\n        else {\n            this.queue.push(value);\n        }\n    }\n    async read() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.deferred === undefined, 0x114 /* \"cannot pop if deferred\" */);\n        const value = this.queue.shift();\n        if (value !== undefined) {\n            return value;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.done, 0x115 /* \"queue should not be done during pop\" */);\n        this.deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        return this.deferred.promise;\n    }\n}\n/**\n * Retrieve single batch of ops\n * @param request - request index\n * @param from - inclusive boundary\n * @param to - exclusive boundary\n * @param telemetryEvent - telemetry event used to track consecutive batch of requests\n * @param strongTo - tells if ops in range from...to have to be there and have to be retrieved.\n * If false, returning less ops would mean we reached end of file.\n * @param logger - logger object to use to log progress & errors\n * @param signal - cancelation signal\n * @param scenarioName - reason for fetching ops\n * @returns - an object with resulting ops and cancellation / partial result flags\n */\nasync function getSingleOpBatch(get, props, strongTo, logger, signal, scenarioName) {\n    let lastSuccessTime;\n    let retry = 0;\n    const deltas = [];\n    const nothing = { partial: false, cancel: true, payload: [] };\n    while ((signal === null || signal === void 0 ? void 0 : signal.aborted) !== true) {\n        retry++;\n        let delay = Math.min(MaxFetchDelayInMs, MissingFetchDelayInMs * Math.pow(2, retry));\n        const startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now();\n        try {\n            // Issue async request for deltas - limit the number fetched to MaxBatchDeltas\n            const deltasP = get(Object.assign(Object.assign({}, props), { retry }));\n            const { messages, partialResult } = await deltasP;\n            deltas.push(...messages);\n            const deltasRetrievedLast = messages.length;\n            if (deltasRetrievedLast !== 0 || !strongTo) {\n                return { payload: deltas, cancel: false, partial: partialResult };\n            }\n            // Storage does not have ops we need.\n            // Attempt to fetch more deltas. If we didn't receive any in the previous call we up our retry\n            // count since something prevented us from seeing those deltas\n            if (lastSuccessTime === undefined) {\n                lastSuccessTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now();\n            }\n            else if (_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now() - lastSuccessTime > 30000) {\n                // If we are connected and receiving proper responses from server, but can't get any ops back,\n                // then give up after some time. This likely indicates the issue with ordering service not flushing\n                // ops to storage quick enough, and possibly waiting for summaries, while summarizer can't get\n                // current as it can't get ops.\n                throw (0,_network__WEBPACK_IMPORTED_MODULE_3__.createGenericNetworkError)(\n                // pre-0.58 error message: failedToRetrieveOpsFromStorage:TooManyRetries\n                \"Failed to retrieve ops from storage (Too Many Retries)\", { canRetry: false }, Object.assign({ retry,\n                    driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_4__.pkgVersion }, props));\n            }\n        }\n        catch (error) {\n            const canRetry = (0,_network__WEBPACK_IMPORTED_MODULE_3__.canRetryOnError)(error);\n            lastSuccessTime = undefined;\n            const retryAfter = (0,_network__WEBPACK_IMPORTED_MODULE_3__.getRetryDelayFromError)(error);\n            // This will log to error table only if the error is non-retryable\n            (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.logNetworkFailure)(logger, Object.assign(Object.assign({ eventName: \"GetDeltas_Error\" }, props), { retry, duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now() - startTime, retryAfter, reason: scenarioName }), error);\n            if (!canRetry) {\n                // It's game over scenario.\n                throw error;\n            }\n            if (retryAfter !== undefined && retryAfter >= 0) {\n                delay = retryAfter;\n            }\n        }\n        await (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.waitForConnectedState)(delay);\n    }\n    return nothing;\n}\n/**\n * Request ops from storage\n * @param get - Getter callback to get individual batches\n * @param concurrency - Number of concurrent requests to make\n * @param fromTotal - starting sequence number to fetch (inclusive)\n * @param toTotal - max (exclusive) sequence number to fetch\n * @param payloadSize - Payload size\n * @param logger - Logger to log progress and errors\n * @param signal - Cancelation signal\n * @param scenarioName - Reason for fetching ops\n * @returns - Messages fetched\n */\nfunction requestOps(get, concurrency, fromTotal, toTotal, payloadSize, logger, signal, scenarioName) {\n    let requests = 0;\n    let lastFetch;\n    let length = 0;\n    const queue = new Queue();\n    const propsTotal = {\n        fromTotal,\n        toTotal,\n    };\n    const telemetryEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.start(logger, Object.assign(Object.assign({ eventName: \"GetDeltas\" }, propsTotal), { reason: scenarioName }));\n    const manager = new ParallelRequests(fromTotal, toTotal, payloadSize, logger, async (request, from, to, strongTo, propsPerRequest) => {\n        requests++;\n        return getSingleOpBatch(async (propsAll) => get(from, to, propsAll), Object.assign(Object.assign({ request, from, to }, propsTotal), propsPerRequest), strongTo, logger, signal, scenarioName);\n    }, (deltas) => {\n        // Assert continuing and right start.\n        if (lastFetch === undefined) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(deltas[0].sequenceNumber === fromTotal, 0x26d /* \"wrong start\" */);\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(deltas[0].sequenceNumber === lastFetch + 1, 0x26e /* \"wrong start\" */);\n        }\n        lastFetch = deltas[deltas.length - 1].sequenceNumber;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(lastFetch - deltas[0].sequenceNumber + 1 === deltas.length, 0x26f /* \"continuous and no duplicates\" */);\n        length += deltas.length;\n        queue.pushValue(deltas);\n    });\n    // Implement faster cancellation. getSingleOpBatch() checks signal, but only in between\n    // waits (up to 10 seconds) and fetches (can take infinite amount of time).\n    // While every such case should be improved and take into account signal (and thus cancel immediately),\n    // it is beneficial to have catch-all\n    const listener = (event) => { manager.cancel(); };\n    if (signal !== undefined) {\n        signal.addEventListener(\"abort\", listener);\n    }\n    manager.run(concurrency)\n        .finally(() => {\n        if (signal !== undefined) {\n            signal.removeEventListener(\"abort\", listener);\n        }\n    }).then(() => {\n        const props = {\n            lastFetch,\n            length,\n            requests,\n        };\n        if (manager.canceled) {\n            telemetryEvent.cancel(Object.assign(Object.assign({}, props), { error: \"ops request cancelled by client\" }));\n        }\n        else {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(toTotal === undefined || lastFetch !== undefined && lastFetch >= toTotal - 1, 0x270 /* \"All requested ops fetched\" */);\n            telemetryEvent.end(props);\n        }\n        queue.pushDone();\n    })\n        .catch((error) => {\n        telemetryEvent.cancel({\n            lastFetch,\n            length,\n            requests,\n        }, error);\n        queue.pushError(error);\n    });\n    return queue;\n}\nconst emptyMessageStream = {\n    read: async () => { return { done: true }; },\n};\nfunction streamFromMessages(messagesArg) {\n    let messages = messagesArg;\n    return {\n        read: async () => {\n            if (messages === undefined) {\n                return { done: true };\n            }\n            const value = await messages;\n            messages = undefined;\n            return value.length === 0 ? { done: true } : { done: false, value };\n        },\n    };\n}\nfunction streamObserver(stream, handler) {\n    return {\n        read: async () => {\n            const value = await stream.read();\n            handler(value);\n            return value;\n        },\n    };\n}\n//# sourceMappingURL=parallelRequests.js.map\n\n/***/ }),\n/* 455 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"LazyPromise\": () => (/* binding */ LazyPromise)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nclass Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nclass LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map\n\n/***/ }),\n/* 456 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"logNetworkFailure\": () => (/* binding */ logNetworkFailure),\n/* harmony export */   \"waitForConnectedState\": () => (/* binding */ waitForConnectedState)\n/* harmony export */ });\n/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nfunction logNetworkFailure(logger, event, error) {\n    var _a, _b;\n    const newEvent = Object.assign({}, event);\n    const errorOnlineProp = error.online;\n    newEvent.online = typeof errorOnlineProp === \"string\"\n        ? errorOnlineProp\n        : _network__WEBPACK_IMPORTED_MODULE_0__.OnlineStatus[(0,_network__WEBPACK_IMPORTED_MODULE_0__.isOnline)()];\n    if (typeof navigator === \"object\" && navigator !== null) {\n        const nav = navigator;\n        const connection = (_b = (_a = nav.connection) !== null && _a !== void 0 ? _a : nav.mozConnection) !== null && _b !== void 0 ? _b : nav.webkitConnection;\n        if (connection !== null && typeof connection === \"object\") {\n            newEvent.connectionType = connection.type;\n        }\n    }\n    // non-retryable errors are fatal and should be logged as errors\n    newEvent.category = (0,_network__WEBPACK_IMPORTED_MODULE_0__.canRetryOnError)(error) ? \"generic\" : \"error\";\n    logger.sendTelemetryEvent(newEvent, error);\n}\n/**\n * Wait for browser to get to connected state.\n * If connected, waits minimum of minDelay anyway (between network retries)\n * If disconnected, polls every 30 seconds anyway, to make sure we are not getting stuck because of wrong signal\n * Note that browsers will have false positives (like having Hyper-V adapter on machine,\n * or machine connected to router that is not connected to internet)\n * But there should be no false negatives.\n * The only exception - Opera returns false when user enters \"Work Offline\" mode, regardless of actual connectivity.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async\nfunction waitForConnectedState(minDelay) {\n    // Use this frequency to poll even when we are offline and able to setup online/offline listener\n    // This is mostly safety net\n    const offlinePollFrequency = 30000;\n    return new Promise((resolve) => {\n        let listener = resolve;\n        let delay = minDelay;\n        if ((0,_network__WEBPACK_IMPORTED_MODULE_0__.isOnline)() === _network__WEBPACK_IMPORTED_MODULE_0__.OnlineStatus.Offline) {\n            if ((window === null || window === void 0 ? void 0 : window.addEventListener) !== undefined) {\n                listener = () => {\n                    resolve();\n                    window.removeEventListener(\"online\", listener);\n                };\n                window.addEventListener(\"online\", listener, false);\n                delay = Math.max(minDelay, offlinePollFrequency);\n            }\n        }\n        setTimeout(listener, delay);\n    });\n}\n//# sourceMappingURL=networkUtils.js.map\n\n/***/ }),\n/* 457 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTelemetryNullLogger\": () => (/* binding */ BaseTelemetryNullLogger),\n/* harmony export */   \"TelemetryNullLogger\": () => (/* binding */ TelemetryNullLogger),\n/* harmony export */   \"extractLogSafeErrorProperties\": () => (/* binding */ extractLogSafeErrorProperties)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass BaseTelemetryNullLogger {\n    /**\n     * Send an event with the logger\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        return;\n    }\n}\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass TelemetryNullLogger {\n    send(event) {\n    }\n    sendTelemetryEvent(event, error) {\n    }\n    sendErrorEvent(event, error) {\n    }\n    sendPerformanceEvent(event, error) {\n    }\n}\nfunction extractLogSafeErrorProperties(error) {\n    const isRegularObject = (value) => {\n        return value !== null && !Array.isArray(value) && typeof value === \"object\";\n    };\n    const removeMessageFromStack = (stack, errorName) => {\n        const stackFrames = stack.split(\"\\n\");\n        stackFrames.shift(); // Remove \"[ErrorName]: [ErrorMessage]\"\n        if (errorName !== undefined) {\n            stackFrames.unshift(errorName); // Add \"[ErrorName]\"\n        }\n        return stackFrames.join(\"\\n\");\n    };\n    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\")\n        ? error.message\n        : String(error);\n    const safeProps = {\n        message,\n    };\n    if (isRegularObject(error)) {\n        const { errorType, stack, name } = error;\n        if (typeof errorType === \"string\") {\n            safeProps.errorType = errorType;\n        }\n        if (typeof stack === \"string\") {\n            const errorName = (typeof name === \"string\") ? name : undefined;\n            safeProps.stack = removeMessageFromStack(stack, errorName);\n        }\n    }\n    return safeProps;\n}\n//# sourceMappingURL=logger.js.map\n\n/***/ }),\n/* 458 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"R11sDocumentDeltaConnection\": () => (/* binding */ R11sDocumentDeltaConnection)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(459);\n/* harmony import */ var _errorUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(396);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(397);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nconst protocolVersions = [\"^0.4.0\", \"^0.3.0\", \"^0.2.0\", \"^0.1.0\"];\n/**\n * Wrapper over the shared one for driver specific translation.\n */\nclass R11sDocumentDeltaConnection extends _fluidframework_driver_base__WEBPACK_IMPORTED_MODULE_0__.DocumentDeltaConnection {\n    static async create(tenantId, id, token, io, client, url, logger, timeoutMs = 20000) {\n        const socket = io(url, {\n            query: {\n                documentId: id,\n                tenantId,\n            },\n            reconnection: false,\n            // Default to websocket connection, with long-polling disabled\n            transports: [\"websocket\"],\n            timeout: timeoutMs,\n        });\n        const connectMessage = {\n            client,\n            id,\n            mode: client.mode,\n            tenantId,\n            token,\n            versions: protocolVersions,\n            relayUserAgent: [client.details.environment, ` driverVersion:${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`].join(\";\"),\n        };\n        // TODO: expose to host at factory level\n        const enableLongPollingDowngrades = true;\n        const deltaConnection = new R11sDocumentDeltaConnection(socket, id, logger, enableLongPollingDowngrades);\n        await deltaConnection.initialize(connectMessage, timeoutMs);\n        return deltaConnection;\n    }\n    /**\n     * Error raising for socket.io issues\n     */\n    createErrorObject(handler, error, canRetry = true) {\n        // Note: we suspect the incoming error object is either:\n        // - a socketError: add it to the R11sError object for driver to be able to parse it and reason over it.\n        // - anything else: let base class handle it\n        if (canRetry && Number.isInteger(error === null || error === void 0 ? void 0 : error.code) && typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\") {\n            return (0,_errorUtils__WEBPACK_IMPORTED_MODULE_2__.errorObjectFromSocketError)(error, handler);\n        }\n        else {\n            return super.createErrorObject(handler, error, canRetry);\n        }\n    }\n}\n//# sourceMappingURL=documentDeltaConnection.js.map\n\n/***/ }),\n/* 459 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DocumentDeltaConnection\": () => (/* binding */ DocumentDeltaConnection)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(460);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(463);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(462);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(461);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n// For now, this package is versioned and released in unison with the specific drivers\n\n/**\n * Represents a connection to a stream of delta updates\n */\nclass DocumentDeltaConnection extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitterWithErrorHandling {\n    /**\n     * @param socket - websocket to be used\n     * @param documentId - ID of the document\n     * @param logger - for reporting telemetry events\n     * @param enableLongPollingDowngrades - allow connection to be downgraded to long-polling on websocket failure\n     */\n    constructor(socket, documentId, logger, enableLongPollingDowngrades = false) {\n        super((name, error) => {\n            logger.sendErrorEvent({\n                eventName: \"DeltaConnection:EventException\",\n                name,\n            }, error);\n        });\n        this.socket = socket;\n        this.documentId = documentId;\n        this.enableLongPollingDowngrades = enableLongPollingDowngrades;\n        // Listen for ops sent before we receive a response to connect_document\n        this.queuedMessages = [];\n        this.queuedSignals = [];\n        /**\n         * A flag to indicate whether we have our handler attached.  If it's attached, we're queueing incoming ops\n         * to later be retrieved via initialMessages.\n         */\n        this.earlyOpHandlerAttached = false;\n        // Listeners only needed while the connection is in progress\n        this.connectionListeners = new Map();\n        // Listeners used throughout the lifetime of the DocumentDeltaConnection\n        this.trackedListeners = new Map();\n        /**\n         * Flag to indicate whether the DocumentDeltaConnection is expected to still be capable of sending messages.\n         * After disconnection, we flip this to prevent any stale messages from being emitted.\n         */\n        this._disposed = false;\n        this.earlyOpHandler = (documentId, msgs) => {\n            this.queuedMessages.push(...msgs);\n        };\n        this.earlySignalHandler = (msg) => {\n            this.queuedSignals.push(msg);\n        };\n        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(logger, \"DeltaConnection\"));\n        this.on(\"newListener\", (event, listener) => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.disposed, 0x20a /* \"register for event on disposed object\" */);\n            // Some events are already forwarded - see this.addTrackedListener() calls in initialize().\n            if (DocumentDeltaConnection.eventsAlwaysForwarded.includes(event)) {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.trackedListeners.has(event), 0x245 /* \"tracked listener\" */);\n                return;\n            }\n            if (!DocumentDeltaConnection.eventsToForward.includes(event)) {\n                throw new Error(`DocumentDeltaConnection: Registering for unknown event: ${event}`);\n            }\n            // Whenever listener is added, we should subscribe on same event on socket, so these two things\n            // should be in sync. This currently assumes that nobody unregisters and registers back listeners,\n            // and that there are no \"internal\" listeners installed (like \"error\" case we skip above)\n            // Better flow might be to always unconditionally register all handlers on successful connection,\n            // though some logic (naming assert in initialMessages getter) might need to be adjusted (it becomes noop)\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)((this.listeners(event).length !== 0) === this.trackedListeners.has(event), 0x20b /* \"mismatch\" */);\n            if (!this.trackedListeners.has(event)) {\n                this.addTrackedListener(event, (...args) => {\n                    this.emit(event, ...args);\n                });\n            }\n        });\n    }\n    get hasDetails() {\n        return !!this._details;\n    }\n    get disposed() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._disposed || this.socket.connected, 0x244 /* \"Socket is closed, but connection is not!\" */);\n        return this._disposed;\n    }\n    /**\n     * @deprecated - Implementors should manage their own logger or monitoring context\n     */\n    get logger() {\n        return this.mc.logger;\n    }\n    get details() {\n        if (!this._details) {\n            throw new Error(\"Internal error: calling method before _details is initialized!\");\n        }\n        return this._details;\n    }\n    /**\n     * Get the ID of the client who is sending the message\n     *\n     * @returns the client ID\n     */\n    get clientId() {\n        return this.details.clientId;\n    }\n    /**\n     * Get the mode of the client\n     *\n     * @returns the client mode\n     */\n    get mode() {\n        return this.details.mode;\n    }\n    /**\n     * Get the claims of the client who is sending the message\n     *\n     * @returns client claims\n     */\n    get claims() {\n        return this.details.claims;\n    }\n    /**\n     * Get whether or not this is an existing document\n     *\n     * @returns true if the document exists\n     */\n    get existing() {\n        return this.details.existing;\n    }\n    /**\n     * Get the maximum size of a message before chunking is required\n     *\n     * @returns the maximum size of a message before chunking is required\n     */\n    get maxMessageSize() {\n        return this.details.serviceConfiguration.maxMessageSize;\n    }\n    /**\n     * Semver of protocol being used with the service\n     */\n    get version() {\n        return this.details.version;\n    }\n    /**\n     * Configuration details provided by the service\n     */\n    get serviceConfiguration() {\n        return this.details.serviceConfiguration;\n    }\n    checkNotClosed() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.disposed, 0x20c /* \"connection disposed\" */);\n    }\n    /**\n     * Get messages sent during the connection\n     *\n     * @returns messages sent during the connection\n     */\n    get initialMessages() {\n        this.checkNotClosed();\n        // If we call this when the earlyOpHandler is not attached, then the queuedMessages may not include the\n        // latest ops.  This could possibly indicate that initialMessages was called twice.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.earlyOpHandlerAttached, 0x08e /* \"Potentially missed initial messages\" */);\n        // We will lose ops and perf will tank as we need to go to storage to become current!\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.listeners(\"op\").length !== 0, 0x08f /* \"No op handler is setup!\" */);\n        this.removeEarlyOpHandler();\n        if (this.queuedMessages.length > 0) {\n            // Some messages were queued.\n            // add them to the list of initialMessages to be processed\n            this.details.initialMessages.push(...this.queuedMessages);\n            this.details.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n            this.queuedMessages.length = 0;\n        }\n        return this.details.initialMessages;\n    }\n    /**\n     * Get signals sent during the connection\n     *\n     * @returns signals sent during the connection\n     */\n    get initialSignals() {\n        this.checkNotClosed();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.listeners(\"signal\").length !== 0, 0x090 /* \"No signal handler is setup!\" */);\n        this.removeEarlySignalHandler();\n        if (this.queuedSignals.length > 0) {\n            // Some signals were queued.\n            // add them to the list of initialSignals to be processed\n            this.details.initialSignals.push(...this.queuedSignals);\n            this.queuedSignals.length = 0;\n        }\n        return this.details.initialSignals;\n    }\n    /**\n     * Get initial client list\n     *\n     * @returns initial client list sent during the connection\n     */\n    get initialClients() {\n        this.checkNotClosed();\n        return this.details.initialClients;\n    }\n    emitMessages(type, messages) {\n        // Although the implementation here disconnects the socket and does not reuse it, other subclasses\n        // (e.g. OdspDocumentDeltaConnection) may reuse the socket.  In these cases, we need to avoid emitting\n        // on the still-live socket.\n        if (!this.disposed) {\n            this.socket.emit(type, this.clientId, messages);\n        }\n    }\n    submitCore(type, messages) {\n        this.emitMessages(type, [messages]);\n    }\n    /**\n     * Submits a new delta operation to the server\n     *\n     * @param message - delta operation to submit\n     */\n    submit(messages) {\n        this.checkNotClosed();\n        this.submitCore(\"submitOp\", messages);\n    }\n    /**\n     * Submits a new signal to the server\n     *\n     * @param message - signal to submit\n     */\n    submitSignal(message) {\n        this.checkNotClosed();\n        this.submitCore(\"submitSignal\", [message]);\n    }\n    /**\n     * Disconnect from the websocket, and permanently disable this DocumentDeltaConnection.\n     */\n    dispose() {\n        this.disposeCore(false, // socketProtocolError\n        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.createGenericNetworkError)(\n        // pre-0.58 error message: clientClosingConnection\n        \"Client closing delta connection\", { canRetry: true }, { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_5__.pkgVersion }));\n    }\n    disposeCore(socketProtocolError, err) {\n        // Can't check this.disposed here, as we get here on socket closure,\n        // so _disposed & socket.connected might be not in sync while processing\n        // \"dispose\" event.\n        if (this._disposed) {\n            return;\n        }\n        // We set the disposed flag as a part of the contract for overriding the disconnect method. This is used by\n        // DocumentDeltaConnection to determine if emitting messages (ops) on the socket is allowed, which is\n        // important since OdspDocumentDeltaConnection reuses the socket rather than truly disconnecting it. Note that\n        // OdspDocumentDeltaConnection may still send disconnect_document which is allowed; this is only intended\n        // to prevent normal messages from being emitted.\n        this._disposed = true;\n        this.removeTrackedListeners();\n        this.disconnect(socketProtocolError, err);\n    }\n    /**\n     * Disconnect from the websocket.\n     * @param socketProtocolError - true if error happened on socket / socket.io protocol level\n     *  (not on Fluid protocol level)\n     * @param reason - reason for disconnect\n     */\n    disconnect(socketProtocolError, reason) {\n        this.socket.disconnect();\n    }\n    async initialize(connectMessage, timeout) {\n        this.socket.on(\"op\", this.earlyOpHandler);\n        this.socket.on(\"signal\", this.earlySignalHandler);\n        this.earlyOpHandlerAttached = true;\n        // Socket.io's reconnect_attempt event is unreliable, so we track connect_error count instead.\n        let internalSocketConnectionFailureCount = 0;\n        const isInternalSocketReconnectionEnabled = () => this.socket.io.reconnection();\n        const getMaxInternalSocketReconnectionAttempts = () => isInternalSocketReconnectionEnabled()\n            ? this.socket.io.reconnectionAttempts()\n            : 0;\n        const getMaxAllowedInternalSocketConnectionFailures = () => getMaxInternalSocketReconnectionAttempts() + 1;\n        this._details = await new Promise((resolve, reject) => {\n            const fail = (socketProtocolError, err) => {\n                this.disposeCore(socketProtocolError, err);\n                reject(err);\n            };\n            // Listen for connection issues\n            this.addConnectionListener(\"connect_error\", (error) => {\n                var _a;\n                internalSocketConnectionFailureCount++;\n                let isWebSocketTransportError = false;\n                try {\n                    const description = error === null || error === void 0 ? void 0 : error.description;\n                    if (description && typeof description === \"object\") {\n                        if (error.type === \"TransportError\") {\n                            isWebSocketTransportError = true;\n                        }\n                        // That's a WebSocket. Clear it as we can't log it.\n                        description.target = undefined;\n                    }\n                }\n                catch (_e) { }\n                // Handle socket transport downgrading when not offline.\n                if (isWebSocketTransportError &&\n                    this.enableLongPollingDowngrades &&\n                    ((_a = this.socket.io.opts.transports) === null || _a === void 0 ? void 0 : _a[0]) !== \"polling\") {\n                    // Downgrade transports to polling upgrade mechanism.\n                    this.socket.io.opts.transports = [\"polling\", \"websocket\"];\n                    // Don't alter reconnection behavior if already enabled.\n                    if (!isInternalSocketReconnectionEnabled()) {\n                        // Allow single reconnection attempt using polling upgrade mechanism.\n                        this.socket.io.reconnection(true);\n                        this.socket.io.reconnectionAttempts(1);\n                    }\n                }\n                // Allow built-in socket.io reconnection handling.\n                if (isInternalSocketReconnectionEnabled() &&\n                    internalSocketConnectionFailureCount < getMaxAllowedInternalSocketConnectionFailures()) {\n                    // Reconnection is enabled and maximum reconnect attempts have not been reached.\n                    return;\n                }\n                fail(true, this.createErrorObject(\"connect_error\", error));\n            });\n            // Listen for timeouts\n            this.addConnectionListener(\"connect_timeout\", () => {\n                fail(true, this.createErrorObject(\"connect_timeout\"));\n            });\n            this.addConnectionListener(\"connect_document_success\", (response) => {\n                // If we sent a nonce and the server supports nonces, check that the nonces match\n                if (connectMessage.nonce !== undefined &&\n                    response.nonce !== undefined &&\n                    response.nonce !== connectMessage.nonce) {\n                    return;\n                }\n                const requestedMode = connectMessage.mode;\n                const actualMode = response.mode;\n                const writingPermitted = response.claims.scopes.includes(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.ScopeType.DocWrite);\n                if (writingPermitted) {\n                    // The only time we expect a mismatch in requested/actual is if we lack write permissions\n                    // In this case we will get \"read\", even if we requested \"write\"\n                    if (actualMode !== requestedMode) {\n                        fail(false, this.createErrorObject(\"connect_document_success\", \"Connected in a different mode than was requested\", false));\n                        return;\n                    }\n                }\n                else {\n                    if (actualMode === \"write\") {\n                        fail(false, this.createErrorObject(\"connect_document_success\", \"Connected in write mode without write permissions\", false));\n                        return;\n                    }\n                }\n                this.checkpointSequenceNumber = response.checkpointSequenceNumber;\n                this.removeConnectionListeners();\n                resolve(response);\n            });\n            // Socket can be disconnected while waiting for Fluid protocol messages\n            // (connect_document_error / connect_document_success), as well as before DeltaManager\n            // had a chance to register its handlers.\n            this.addTrackedListener(\"disconnect\", (reason) => {\n                const err = this.createErrorObject(\"disconnect\", reason);\n                this.emit(\"disconnect\", err);\n                fail(true, err);\n            });\n            this.addTrackedListener(\"error\", ((error) => {\n                // First, raise an error event, to give clients a chance to observe error contents\n                // This includes \"Invalid namespace\" error, which we consider critical (reconnecting will not help)\n                const err = this.createErrorObject(\"error\", error, error !== \"Invalid namespace\");\n                this.emit(\"error\", err);\n                // Disconnect socket - required if happened before initial handshake\n                fail(true, err);\n            }));\n            this.addConnectionListener(\"connect_document_error\", ((error) => {\n                // If we sent a nonce and the server supports nonces, check that the nonces match\n                if (connectMessage.nonce !== undefined &&\n                    error.nonce !== undefined &&\n                    error.nonce !== connectMessage.nonce) {\n                    return;\n                }\n                // This is not an socket.io error - it's Fluid protocol error.\n                // In this case fail connection and indicate that we were unable to create connection\n                fail(false, this.createErrorObject(\"connect_document_error\", error));\n            }));\n            this.socket.emit(\"connect_document\", connectMessage);\n            // Give extra 2 seconds for handshake on top of socket connection timeout\n            this.socketConnectionTimeout = setTimeout(() => {\n                fail(false, this.createErrorObject(\"orderingServiceHandshakeTimeout\"));\n            }, timeout + 2000);\n        });\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.disposed, 0x246 /* \"checking consistency of socket & _disposed flags\" */);\n    }\n    removeEarlyOpHandler() {\n        this.socket.removeListener(\"op\", this.earlyOpHandler);\n        this.earlyOpHandlerAttached = false;\n    }\n    removeEarlySignalHandler() {\n        this.socket.removeListener(\"signal\", this.earlySignalHandler);\n    }\n    addConnectionListener(event, listener) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!DocumentDeltaConnection.eventsAlwaysForwarded.includes(event), 0x247 /* \"Use addTrackedListener instead\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!DocumentDeltaConnection.eventsToForward.includes(event), 0x248 /* \"should not subscribe to forwarded events\" */);\n        this.socket.on(event, listener);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.connectionListeners.has(event), 0x20d /* \"double connection listener\" */);\n        this.connectionListeners.set(event, listener);\n    }\n    addTrackedListener(event, listener) {\n        this.socket.on(event, listener);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.trackedListeners.has(event), 0x20e /* \"double tracked listener\" */);\n        this.trackedListeners.set(event, listener);\n    }\n    removeTrackedListeners() {\n        for (const [event, listener] of this.trackedListeners.entries()) {\n            this.socket.off(event, listener);\n        }\n        // removeTrackedListeners removes all listeners, including connection listeners\n        this.removeConnectionListeners();\n        this.removeEarlyOpHandler();\n        this.removeEarlySignalHandler();\n        this.trackedListeners.clear();\n    }\n    removeConnectionListeners() {\n        if (this.socketConnectionTimeout !== undefined) {\n            clearTimeout(this.socketConnectionTimeout);\n        }\n        for (const [event, listener] of this.connectionListeners.entries()) {\n            this.socket.off(event, listener);\n        }\n        this.connectionListeners.clear();\n    }\n    /**\n     * Error raising for socket.io issues\n     */\n    createErrorObject(handler, error, canRetry = true) {\n        // Note: we suspect the incoming error object is either:\n        // - a string: log it in the message (if not a string, it may contain PII but will print as [object Object])\n        // - an Error object thrown by socket.io engine. Be careful with not recording PII!\n        let message;\n        if ((error === null || error === void 0 ? void 0 : error.type) === \"TransportError\") {\n            // JSON.stringify drops Error.message\n            const messagePrefix = ((error === null || error === void 0 ? void 0 : error.message) !== undefined)\n                ? `${error.message}: `\n                : \"\";\n            // Websocket errors reported by engine.io-client.\n            // They are Error objects with description containing WS error and description = \"TransportError\"\n            // Please see https://github.com/socketio/engine.io-client/blob/7245b80/lib/transport.ts#L44,\n            message = `${messagePrefix}${JSON.stringify(error, (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.getCircularReplacer)())}`;\n        }\n        else {\n            message = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.extractLogSafeErrorProperties)(error).message;\n        }\n        const errorObj = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.createGenericNetworkError)(`socket.io (${handler}): ${message}`, { canRetry }, { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_5__.pkgVersion });\n        return errorObj;\n    }\n}\nDocumentDeltaConnection.eventsToForward = [\"nack\", \"op\", \"signal\", \"pong\"];\n// WARNING: These are critical events that we can't miss, so registration for them has to be in place at all times!\n// Including before handshake is over, and after that (but before DeltaManager had a chance to put its own handlers)\nDocumentDeltaConnection.eventsAlwaysForwarded = [\"disconnect\", \"error\"];\n//# sourceMappingURL=documentDeltaConnection.js.map\n\n/***/ }),\n/* 460 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 461 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/driver-base\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 462 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScopeType\": () => (/* binding */ ScopeType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar ScopeType;\n(function (ScopeType) {\n    ScopeType[\"DocRead\"] = \"doc:read\";\n    ScopeType[\"DocWrite\"] = \"doc:write\";\n    ScopeType[\"SummaryWrite\"] = \"summary:write\";\n})(ScopeType || (ScopeType = {}));\n//# sourceMappingURL=scopes.js.map\n\n/***/ }),\n/* 463 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTelemetryNullLogger\": () => (/* binding */ BaseTelemetryNullLogger),\n/* harmony export */   \"TelemetryNullLogger\": () => (/* binding */ TelemetryNullLogger),\n/* harmony export */   \"extractLogSafeErrorProperties\": () => (/* binding */ extractLogSafeErrorProperties)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass BaseTelemetryNullLogger {\n    /**\n     * Send an event with the logger\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        return;\n    }\n}\n/**\n * Null logger\n * It can be used in places where logger instance is required, but events should be not send over.\n */\nclass TelemetryNullLogger {\n    send(event) {\n    }\n    sendTelemetryEvent(event, error) {\n    }\n    sendErrorEvent(event, error) {\n    }\n    sendPerformanceEvent(event, error) {\n    }\n}\nfunction extractLogSafeErrorProperties(error) {\n    const isRegularObject = (value) => {\n        return value !== null && !Array.isArray(value) && typeof value === \"object\";\n    };\n    const removeMessageFromStack = (stack, errorName) => {\n        const stackFrames = stack.split(\"\\n\");\n        stackFrames.shift(); // Remove \"[ErrorName]: [ErrorMessage]\"\n        if (errorName !== undefined) {\n            stackFrames.unshift(errorName); // Add \"[ErrorName]\"\n        }\n        return stackFrames.join(\"\\n\");\n    };\n    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\")\n        ? error.message\n        : String(error);\n    const safeProps = {\n        message,\n    };\n    if (isRegularObject(error)) {\n        const { errorType, stack, name } = error;\n        if (typeof errorType === \"string\") {\n            safeProps.errorType = errorType;\n        }\n        if (typeof stack === \"string\") {\n            const errorName = (typeof name === \"string\") ? name : undefined;\n            safeProps.stack = removeMessageFromStack(stack, errorName);\n        }\n    }\n    return safeProps;\n}\n//# sourceMappingURL=logger.js.map\n\n/***/ }),\n/* 464 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     * Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 465 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loader\": () => (/* binding */ Loader),\n/* harmony export */   \"RelativeLoader\": () => (/* binding */ RelativeLoader)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(546);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(547);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(548);\n/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(466);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(495);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(536);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\nfunction canUseCache(request) {\n    if (request.headers === undefined) {\n        return true;\n    }\n    return request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.cache] !== false;\n}\nclass RelativeLoader {\n    constructor(container, loader) {\n        this.container = container;\n        this.loader = loader;\n    }\n    get IFluidRouter() { return this; }\n    async resolve(request) {\n        var _a, _b, _c, _d, _e;\n        if (request.url.startsWith(\"/\")) {\n            if (canUseCache(request)) {\n                return this.container;\n            }\n            else {\n                const resolvedUrl = this.container.resolvedUrl;\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);\n                const container = await _container__WEBPACK_IMPORTED_MODULE_2__.Container.load(this.loader, {\n                    canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.reconnect],\n                    clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.clientDetails],\n                    resolvedUrl: Object.assign({}, resolvedUrl),\n                    version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,\n                    loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.loadMode],\n                });\n                return container;\n            }\n        }\n        if (this.loader === undefined) {\n            throw new Error(\"Cannot resolve external containers\");\n        }\n        return this.loader.resolve(request);\n    }\n    async request(request) {\n        if (request.url.startsWith(\"/\")) {\n            const container = await this.resolve(request);\n            return container.request(request);\n        }\n        if (this.loader === undefined) {\n            return {\n                status: 404,\n                value: \"Cannot request external containers\",\n                mimeType: \"plain/text\",\n            };\n        }\n        return this.loader.request(request);\n    }\n}\nfunction createCachedResolver(resolver) {\n    const cacheResolver = Object.create(resolver);\n    const resolveCache = new Map();\n    cacheResolver.resolve = async (request) => {\n        if (!canUseCache(request)) {\n            return resolver.resolve(request);\n        }\n        if (!resolveCache.has(request.url)) {\n            resolveCache.set(request.url, resolver.resolve(request));\n        }\n        return resolveCache.get(request.url);\n    };\n    return cacheResolver;\n}\n/**\n * Manages Fluid resource loading\n */\nclass Loader {\n    constructor(loaderProps) {\n        var _a, _b;\n        this.containers = new Map();\n        const scope = Object.assign({}, loaderProps.scope);\n        if (((_a = loaderProps.options) === null || _a === void 0 ? void 0 : _a.provideScopeLoader) !== false) {\n            scope.ILoader = this;\n        }\n        const telemetryProps = {\n            loaderId: (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(),\n            loaderVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_4__.pkgVersion,\n        };\n        const subMc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.mixinMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.DebugLogger.mixinDebugLogger(\"fluid:telemetry\", loaderProps.logger, { all: telemetryProps }), _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.sessionStorageConfigProvider.value, loaderProps.configProvider);\n        this.services = {\n            urlResolver: createCachedResolver(_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__.MultiUrlResolver.create(loaderProps.urlResolver)),\n            documentServiceFactory: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_8__.MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),\n            codeLoader: loaderProps.codeLoader,\n            options: (_b = loaderProps.options) !== null && _b !== void 0 ? _b : {},\n            scope,\n            subLogger: subMc.logger,\n            detachedBlobStorage: loaderProps.detachedBlobStorage,\n        };\n        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.services.subLogger, \"Loader\"));\n    }\n    get IFluidRouter() { return this; }\n    async createDetachedContainer(codeDetails) {\n        const container = await _container__WEBPACK_IMPORTED_MODULE_2__.Container.createDetached(this, codeDetails);\n        if (this.cachingEnabled) {\n            container.once(\"attached\", () => {\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(container.resolvedUrl);\n                const parsedUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.parseUrl)(container.resolvedUrl.url);\n                if (parsedUrl !== undefined) {\n                    this.addToContainerCache(parsedUrl.id, Promise.resolve(container));\n                }\n            });\n        }\n        return container;\n    }\n    async rehydrateDetachedContainerFromSnapshot(snapshot) {\n        return _container__WEBPACK_IMPORTED_MODULE_2__.Container.rehydrateDetachedFromSnapshot(this, snapshot);\n    }\n    async resolve(request, pendingLocalState) {\n        const eventName = pendingLocalState === undefined ? \"Resolve\" : \"ResolveWithPendingState\";\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName }, async () => {\n            const resolved = await this.resolveCore(request, pendingLocalState !== undefined ? JSON.parse(pendingLocalState) : undefined);\n            return resolved.container;\n        });\n    }\n    async request(request) {\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: \"Request\" }, async () => {\n            const resolved = await this.resolveCore(request);\n            return resolved.container.request(Object.assign(Object.assign({}, request), { url: `${resolved.parsed.path}${resolved.parsed.query}` }));\n        });\n    }\n    getKeyForContainerCache(request, parsedUrl) {\n        var _a;\n        const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]) !== undefined\n            ? `${parsedUrl.id}@${request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]}`\n            : parsedUrl.id;\n        return key;\n    }\n    addToContainerCache(key, containerP) {\n        this.containers.set(key, containerP);\n        containerP.then((container) => {\n            // If the container is closed or becomes closed after we resolve it, remove it from the cache.\n            if (container.closed) {\n                this.containers.delete(key);\n            }\n            else {\n                container.once(\"closed\", () => {\n                    this.containers.delete(key);\n                });\n            }\n        }).catch((error) => { });\n    }\n    async resolveCore(request, pendingLocalState) {\n        const resolvedAsFluid = await this.services.urlResolver.resolve(request);\n        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedAsFluid);\n        // Parse URL into data stores\n        const parsed = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.parseUrl)(resolvedAsFluid.url);\n        if (parsed === undefined) {\n            throw new Error(`Invalid URL ${resolvedAsFluid.url}`);\n        }\n        if (pendingLocalState !== undefined) {\n            const parsedPendingUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.parseUrl)(pendingLocalState.url);\n            if ((parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.id) !== parsed.id ||\n                (parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.path.replace(/\\/$/, \"\")) !== parsed.path.replace(/\\/$/, \"\")) {\n                const message = `URL ${resolvedAsFluid.url} does not match pending state URL ${pendingLocalState.url}`;\n                throw new Error(message);\n            }\n        }\n        const { canCache, fromSequenceNumber } = this.parseHeader(parsed, request);\n        const shouldCache = pendingLocalState !== undefined ? false : canCache;\n        let container;\n        if (shouldCache) {\n            const key = this.getKeyForContainerCache(request, parsed);\n            const maybeContainer = await this.containers.get(key);\n            if (maybeContainer !== undefined) {\n                container = maybeContainer;\n            }\n            else {\n                const containerP = this.loadContainer(request, resolvedAsFluid);\n                this.addToContainerCache(key, containerP);\n                container = await containerP;\n            }\n        }\n        else {\n            container =\n                await this.loadContainer(request, resolvedAsFluid, pendingLocalState);\n        }\n        if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {\n            await new Promise((resolve, reject) => {\n                function opHandler(message) {\n                    if (message.sequenceNumber > fromSequenceNumber) {\n                        resolve();\n                        container.removeListener(\"op\", opHandler);\n                    }\n                }\n                container.on(\"op\", opHandler);\n            });\n        }\n        return { container, parsed };\n    }\n    get cachingEnabled() {\n        return this.services.options.cache !== false;\n    }\n    canCacheForRequest(headers) {\n        return this.cachingEnabled && headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.cache] !== false;\n    }\n    parseHeader(parsed, request) {\n        var _a, _b;\n        let fromSequenceNumber = -1;\n        request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};\n        const headerSeqNum = request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.sequenceNumber];\n        if (headerSeqNum !== undefined) {\n            fromSequenceNumber = headerSeqNum;\n        }\n        // If set in both query string and headers, use query string\n        request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version] = (_b = parsed.version) !== null && _b !== void 0 ? _b : request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version];\n        const canCache = this.canCacheForRequest(request.headers);\n        return {\n            canCache,\n            fromSequenceNumber,\n        };\n    }\n    async loadContainer(request, resolved, pendingLocalState) {\n        var _a, _b, _c, _d, _e;\n        return _container__WEBPACK_IMPORTED_MODULE_2__.Container.load(this, {\n            canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.reconnect],\n            clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.clientDetails],\n            resolvedUrl: resolved,\n            version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,\n            loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.loadMode],\n        }, pendingLocalState);\n    }\n}\n//# sourceMappingURL=loader.js.map\n\n/***/ }),\n/* 466 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Container\": () => (/* binding */ Container),\n/* harmony export */   \"waitContainerToCatchUp\": () => (/* binding */ waitContainerToCatchUp)\n/* harmony export */ });\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(467);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(27);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(488);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(521);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(523);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(338);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(332);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(448);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(78);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(117);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(64);\n/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(530);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(494);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(535);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(132);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(45);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(46);\n/* harmony import */ var _audience__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(489);\n/* harmony import */ var _containerContext__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(544);\n/* harmony import */ var _contracts__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(522);\n/* harmony import */ var _deltaManager__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(537);\n/* harmony import */ var _deltaManagerProxy__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(545);\n/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(465);\n/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(536);\n/* harmony import */ var _connectionStateHandler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(490);\n/* harmony import */ var _retriableDocumentStorageService__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(528);\n/* harmony import */ var _protocolTreeDocumentStorageService__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(529);\n/* harmony import */ var _containerStorageAdapter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(493);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(495);\n/* harmony import */ var _quorum__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(524);\n/* harmony import */ var _collabWindowTracker__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(543);\n/* harmony import */ var _connectionManager__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(541);\n/* harmony import */ var _connectionState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst detachedContainerRefSeqNumber = 0;\nconst dirtyContainerEvent = \"dirty\";\nconst savedContainerEvent = \"saved\";\n/**\n * Waits until container connects to delta storage and gets up-to-date\n * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being\n * up to date. Host may chose to wait in such case and retry resolving URI.\n * Warning: Will wait infinitely for connection to establish if there is no connection.\n * May result in deadlock if Container.disconnect() is called and never followed by a call to Container.connect().\n * @returns true: container is up to date, it processed all the ops that were know at the time of first connection\n *          false: storage does not provide indication of how far the client is. Container processed\n *          all the ops known to it, but it maybe still behind.\n * @throws an error beginning with `\"Container closed\"` if the container is closed before it catches up.\n */\nasync function waitContainerToCatchUp(container) {\n    // Make sure we stop waiting if container is closed.\n    if (container.closed) {\n        throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(\"waitContainerToCatchUp: Container closed\");\n    }\n    return new Promise((resolve, reject) => {\n        const deltaManager = container.deltaManager;\n        const closedCallback = (err) => {\n            container.off(\"closed\", closedCallback);\n            const baseMessage = \"Container closed while waiting to catch up\";\n            reject(err !== undefined\n                ? (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.wrapError)(err, (innerMessage) => new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(`${baseMessage}: ${innerMessage}`))\n                : new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(baseMessage));\n        };\n        container.on(\"closed\", closedCallback);\n        const waitForOps = () => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.CatchingUp\n                || container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected, 0x0cd /* \"Container disconnected while waiting for ops!\" */);\n            const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;\n            const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(deltaManager.lastSequenceNumber <= connectionOpSeqNumber, 0x266 /* \"lastKnownSeqNumber should never be below last processed sequence number\" */);\n            if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {\n                container.off(\"closed\", closedCallback);\n                resolve(hasCheckpointSequenceNumber);\n                return;\n            }\n            const callbackOps = (message) => {\n                if (connectionOpSeqNumber <= message.sequenceNumber) {\n                    container.off(\"closed\", closedCallback);\n                    resolve(hasCheckpointSequenceNumber);\n                    deltaManager.off(\"op\", callbackOps);\n                }\n            };\n            deltaManager.on(\"op\", callbackOps);\n        };\n        // We can leverage DeltaManager's \"connect\" event here and test for ConnectionState.Disconnected\n        // But that works only if service provides us checkPointSequenceNumber\n        // Our internal testing is based on R11S that does not, but almost all tests connect as \"write\" and\n        // use this function to catch up, so leveraging our own join op as a fence/barrier\n        if (container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {\n            waitForOps();\n            return;\n        }\n        const callback = () => {\n            container.off(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.connectedEventName, callback);\n            waitForOps();\n        };\n        container.on(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.connectedEventName, callback);\n        if (container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected) {\n            container.connect();\n        }\n    });\n}\nconst getCodeProposal = \n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n(quorum) => { var _a; return (_a = quorum.get(\"code\")) !== null && _a !== void 0 ? _a : quorum.get(\"code2\"); };\n/**\n * Helper function to report to telemetry cases where operation takes longer than expected (1s)\n * @param logger - logger to use\n * @param eventName - event name\n * @param action - functor to call and measure\n */\nasync function ReportIfTooLong(logger, eventName, action) {\n    const event = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.start(logger, { eventName });\n    const props = await action();\n    if (event.duration > 1000) {\n        event.end(props);\n    }\n}\nconst summarizerClientType = \"summarizer\";\nclass Container extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.EventEmitterWithErrorHandling {\n    constructor(loader, config) {\n        var _a, _b;\n        super((name, error) => {\n            this.mc.logger.sendErrorEvent({\n                eventName: \"ContainerEventHandlerException\",\n                name: typeof name === \"string\" ? name : undefined,\n            }, error);\n        });\n        this.loader = loader;\n        // Tells if container can reconnect on losing fist connection\n        // If false, container gets closed on loss of connection.\n        this._canReconnect = true;\n        this._lifecycleState = \"loading\";\n        this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached;\n        /** During initialization we pause the inbound queues. We track this state to ensure we only call resume once */\n        this.inboundQueuePausedFromInit = true;\n        this.firstConnection = true;\n        this.connectionTransitionTimes = [];\n        this.messageCountAfterDisconnection = 0;\n        this.attachStarted = false;\n        this._dirtyContainer = false;\n        this.setAutoReconnectTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();\n        this._audience = new _audience__WEBPACK_IMPORTED_MODULE_10__.Audience();\n        this.clientDetailsOverride = config.clientDetailsOverride;\n        this._resolvedUrl = config.resolvedUrl;\n        if (config.canReconnect !== undefined) {\n            this._canReconnect = config.canReconnect;\n        }\n        // Create logger for data stores to use\n        const type = this.client.details.type;\n        const interactive = this.client.details.capabilities.interactive;\n        const clientType = `${interactive ? \"interactive\" : \"noninteractive\"}${type !== undefined && type !== \"\" ? `/${type}` : \"\"}`;\n        // Need to use the property getter for docId because for detached flow we don't have the docId initially.\n        // We assign the id later so property getter is used.\n        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(loader.services.subLogger, undefined, {\n            all: {\n                clientType,\n                containerId: (0,uuid__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(),\n                docId: () => { var _a, _b; return (_b = (_a = this._resolvedUrl) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : undefined; },\n                containerAttachState: () => this._attachState,\n                containerLifecycleState: () => this._lifecycleState,\n                containerConnectionState: () => _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[this.connectionState],\n                serializedContainer: config.serializedContainerState !== undefined,\n            },\n            // we need to be judicious with our logging here to avoid generating too much data\n            // all data logged here should be broadly applicable, and not specific to a\n            // specific error or class of errors\n            error: {\n                // load information to associate errors with the specific load point\n                dmInitialSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.initialSequenceNumber; },\n                dmLastProcessedSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastSequenceNumber; },\n                dmLastKnownSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastKnownSeqNumber; },\n                containerLoadedFromVersionId: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.id; },\n                containerLoadedFromVersionDate: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.date; },\n                // message information to associate errors with the specific execution state\n                // dmLastMsqSeqNumber: if present, same as dmLastProcessedSeqNumber\n                dmLastMsqSeqNumber: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber; },\n                dmLastMsqSeqTimestamp: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp; },\n                dmLastMsqSeqClientId: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.clientId; },\n                connectionStateDuration: () => _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - this.connectionTransitionTimes[this.connectionState],\n            },\n        });\n        // Prefix all events in this file with container-loader\n        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, \"Container\"));\n        const summarizeProtocolTree = (_a = this.mc.config.getBoolean(\"Fluid.Container.summarizeProtocolTree\")) !== null && _a !== void 0 ? _a : this.loader.services.options.summarizeProtocolTree;\n        this.options = Object.assign(Object.assign({}, this.loader.services.options), { summarizeProtocolTree });\n        this.connectionStateHandler = new _connectionStateHandler__WEBPACK_IMPORTED_MODULE_13__.ConnectionStateHandler({\n            quorumClients: () => { var _a; return (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum; },\n            logConnectionStateChangeTelemetry: (value, oldState, reason) => this.logConnectionStateChangeTelemetry(value, oldState, reason),\n            shouldClientJoinWrite: () => this._deltaManager.connectionManager.shouldJoinWrite(),\n            maxClientLeaveWaitTime: this.loader.services.options.maxClientLeaveWaitTime,\n            logConnectionIssue: (eventName, details) => {\n                // We get here when socket does not receive any ops on \"write\" connection, including\n                // its own join op. Attempt recovery option.\n                this._deltaManager.logConnectionIssue(Object.assign({ eventName, duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.CatchingUp] }, (details === undefined ? {} : { details: JSON.stringify(details) })));\n            },\n            connectionStateChanged: () => {\n                // Fire events only if container is fully loaded and not closed\n                if (this._lifecycleState === \"loaded\") {\n                    this.propagateConnectionState();\n                }\n            },\n        }, this.mc.logger, (_b = config.serializedContainerState) === null || _b === void 0 ? void 0 : _b.clientId);\n        this.on(savedContainerEvent, () => {\n            this.connectionStateHandler.containerSaved();\n        });\n        this._deltaManager = this.createDeltaManager();\n        this._storage = new _containerStorageAdapter__WEBPACK_IMPORTED_MODULE_14__.ContainerStorageAdapter(() => {\n            if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached) {\n                if (this.loader.services.detachedBlobStorage !== undefined) {\n                    return new _containerStorageAdapter__WEBPACK_IMPORTED_MODULE_14__.BlobOnlyStorage(this.loader.services.detachedBlobStorage, this.mc.logger);\n                }\n                this.mc.logger.sendErrorEvent({\n                    eventName: \"NoRealStorageInDetachedContainer\",\n                });\n                throw new Error(\"Real storage calls not allowed in Unattached container\");\n            }\n            return this.storageService;\n        });\n        const isDomAvailable = typeof document === \"object\" &&\n            document !== null &&\n            typeof document.addEventListener === \"function\" &&\n            document.addEventListener !== null;\n        // keep track of last time page was visible for telemetry\n        if (isDomAvailable) {\n            this.lastVisible = document.hidden ? _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() : undefined;\n            this.visibilityEventHandler = () => {\n                if (document.hidden) {\n                    this.lastVisible = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();\n                }\n                else {\n                    // settimeout so this will hopefully fire after disconnect event if being hidden caused it\n                    setTimeout(() => { this.lastVisible = undefined; }, 0);\n                }\n            };\n            document.addEventListener(\"visibilitychange\", this.visibilityEventHandler);\n        }\n        // We observed that most users of platform do not check Container.connected event on load, causing bugs.\n        // As such, we are raising events when new listener pops up.\n        // Note that we can raise both \"disconnected\" & \"connect\" events at the same time,\n        // if we are in connecting stage.\n        this.on(\"newListener\", (event, listener) => {\n            // Fire events on the end of JS turn, giving a chance for caller to be in consistent state.\n            Promise.resolve().then(() => {\n                switch (event) {\n                    case dirtyContainerEvent:\n                        if (this._dirtyContainer) {\n                            listener();\n                        }\n                        break;\n                    case savedContainerEvent:\n                        if (!this._dirtyContainer) {\n                            listener();\n                        }\n                        break;\n                    case _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.connectedEventName:\n                        if (this.connected) {\n                            listener(this.clientId);\n                        }\n                        break;\n                    case _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.disconnectedEventName:\n                        if (!this.connected) {\n                            listener();\n                        }\n                        break;\n                    default:\n                }\n            }).catch((error) => {\n                this.mc.logger.sendErrorEvent({ eventName: \"RaiseConnectedEventError\" }, error);\n            });\n        });\n    }\n    /**\n     * Load an existing container.\n     */\n    static async load(loader, loadOptions, pendingLocalState) {\n        const container = new Container(loader, {\n            clientDetailsOverride: loadOptions.clientDetailsOverride,\n            resolvedUrl: loadOptions.resolvedUrl,\n            canReconnect: loadOptions.canReconnect,\n            serializedContainerState: pendingLocalState,\n        });\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: \"Load\" }, async (event) => new Promise((resolve, reject) => {\n            var _a, _b;\n            const version = loadOptions.version;\n            const defaultMode = { opsBeforeReturn: \"cached\" };\n            // if we have pendingLocalState, anything we cached is not useful and we shouldn't wait for connection\n            // to return container, so ignore this value and use undefined for opsBeforeReturn\n            const mode = pendingLocalState\n                ? Object.assign(Object.assign({}, ((_a = loadOptions.loadMode) !== null && _a !== void 0 ? _a : defaultMode)), { opsBeforeReturn: undefined }) : (_b = loadOptions.loadMode) !== null && _b !== void 0 ? _b : defaultMode;\n            const onClosed = (err) => {\n                // pre-0.58 error message: containerClosedWithoutErrorDuringLoad\n                reject(err !== null && err !== void 0 ? err : new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(\"Container closed without error during load\"));\n            };\n            container.on(\"closed\", onClosed);\n            container.load(version, mode, pendingLocalState)\n                .finally(() => {\n                container.removeListener(\"closed\", onClosed);\n            })\n                .then((props) => {\n                event.end(Object.assign(Object.assign({}, props), loadOptions.loadMode));\n                resolve(container);\n            }, (error) => {\n                const err = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeError)(error);\n                // Depending where error happens, we can be attempting to connect to web socket\n                // and continuously retrying (consider offline mode)\n                // Host has no container to close, so it's prudent to do it here\n                container.close(err);\n                onClosed(err);\n            });\n        }), { start: true, end: true, cancel: \"generic\" });\n    }\n    /**\n     * Create a new container in a detached state.\n     */\n    static async createDetached(loader, codeDetails) {\n        const container = new Container(loader, {});\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: \"CreateDetached\" }, async (_event) => {\n            await container.createDetached(codeDetails);\n            return container;\n        }, { start: true, end: true, cancel: \"generic\" });\n    }\n    /**\n     * Create a new container in a detached state that is initialized with a\n     * snapshot from a previous detached container.\n     */\n    static async rehydrateDetachedFromSnapshot(loader, snapshot) {\n        const container = new Container(loader, {});\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: \"RehydrateDetachedFromSnapshot\" }, async (_event) => {\n            const deserializedSummary = JSON.parse(snapshot);\n            await container.rehydrateDetachedFromSnapshot(deserializedSummary);\n            return container;\n        }, { start: true, end: true, cancel: \"generic\" });\n    }\n    setLoaded() {\n        // It's conceivable the container could be closed when this is called\n        // Only transition states if currently loading\n        if (this._lifecycleState === \"loading\") {\n            // Propagate current connection state through the system.\n            this.propagateConnectionState();\n            this._lifecycleState = \"loaded\";\n        }\n    }\n    get closed() {\n        return (this._lifecycleState === \"closing\" || this._lifecycleState === \"closed\");\n    }\n    get storage() {\n        return this._storage;\n    }\n    get storageService() {\n        if (this._storageService === undefined) {\n            throw new Error(\"Attempted to access storageService before it was defined\");\n        }\n        return this._storageService;\n    }\n    get context() {\n        if (this._context === undefined) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(\"Attempted to access context before it was defined\");\n        }\n        return this._context;\n    }\n    get protocolHandler() {\n        if (this._protocolHandler === undefined) {\n            throw new Error(\"Attempted to access protocolHandler before it was defined\");\n        }\n        return this._protocolHandler;\n    }\n    get connectionMode() { return this._deltaManager.connectionManager.connectionMode; }\n    get IFluidRouter() { return this; }\n    get resolvedUrl() {\n        return this._resolvedUrl;\n    }\n    get loadedFromVersion() {\n        return this._loadedFromVersion;\n    }\n    get readOnlyInfo() {\n        return this._deltaManager.readOnlyInfo;\n    }\n    get closeSignal() {\n        return this._deltaManager.closeAbortController.signal;\n    }\n    /**\n     * Tracks host requiring read-only mode.\n     */\n    forceReadonly(readonly) {\n        this._deltaManager.connectionManager.forceReadonly(readonly);\n    }\n    get deltaManager() {\n        return this._deltaManager;\n    }\n    get connectionState() {\n        return this.connectionStateHandler.connectionState;\n    }\n    get connected() {\n        return this.connectionStateHandler.connected;\n    }\n    /**\n     * Service configuration details. If running in offline mode will be undefined otherwise will contain service\n     * configuration details returned as part of the initial connection.\n     */\n    get serviceConfiguration() {\n        return this._deltaManager.serviceConfiguration;\n    }\n    /**\n     * The server provided id of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n    get clientId() {\n        return this.connectionStateHandler.clientId;\n    }\n    /**\n     * The server provided claims of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n    get scopes() {\n        return this._deltaManager.connectionManager.scopes;\n    }\n    get clientDetails() {\n        return this._deltaManager.clientDetails;\n    }\n    /**\n     * Get the code details that are currently specified for the container.\n     * @returns The current code details if any are specified, undefined if none are specified.\n     */\n    getSpecifiedCodeDetails() {\n        return this.getCodeDetailsFromQuorum();\n    }\n    /**\n     * Get the code details that were used to load the container.\n     * @returns The code details that were used to load the container if it is loaded, undefined if it is not yet\n     * loaded.\n     */\n    getLoadedCodeDetails() {\n        var _a;\n        return (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails;\n    }\n    /**\n     * Retrieves the audience associated with the document\n     */\n    get audience() {\n        return this._audience;\n    }\n    /**\n     * Returns true if container is dirty.\n     * Which means data loss if container is closed at that same moment\n     * Most likely that happens when there is no network connection to ordering service\n     */\n    get isDirty() {\n        return this._dirtyContainer;\n    }\n    get serviceFactory() { return this.loader.services.documentServiceFactory; }\n    get urlResolver() { return this.loader.services.urlResolver; }\n    get scope() { return this.loader.services.scope; }\n    get codeLoader() { return this.loader.services.codeLoader; }\n    /**\n     * Retrieves the quorum associated with the document\n     */\n    getQuorum() {\n        return this.protocolHandler.quorum;\n    }\n    close(error) {\n        // 1. Ensure that close sequence is exactly the same no matter if it's initiated by host or by DeltaManager\n        // 2. We need to ensure that we deliver disconnect event to runtime properly. See connectionStateChanged\n        //    handler. We only deliver events if container fully loaded. Transitioning from \"loading\" ->\n        //    \"closing\" will lose that info (can also solve by tracking extra state).\n        this._deltaManager.close(error);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected, 0x0cf /* \"disconnect event was not raised!\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._lifecycleState === \"closed\", 0x314 /* Container properly closed */);\n    }\n    closeCore(error) {\n        var _a, _b, _c, _d;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x315 /* re-entrancy */);\n        try {\n            // Ensure that we raise all key events even if one of these throws\n            try {\n                // Raise event first, to ensure we capture _lifecycleState before transition.\n                // This gives us a chance to know what errors happened on open vs. on fully loaded container.\n                this.mc.logger.sendTelemetryEvent({\n                    eventName: \"ContainerClose\",\n                    category: error === undefined ? \"generic\" : \"error\",\n                }, error);\n                this._lifecycleState = \"closing\";\n                (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();\n                this.connectionStateHandler.dispose();\n                (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);\n                (_c = this._storageService) === null || _c === void 0 ? void 0 : _c.dispose();\n                // Notify storage about critical errors. They may be due to disconnect between client & server knowledge\n                // about file, like file being overwritten in storage, but client having stale local cache.\n                // Driver need to ensure all caches are cleared on critical errors\n                (_d = this.service) === null || _d === void 0 ? void 0 : _d.dispose(error);\n            }\n            catch (exception) {\n                this.mc.logger.sendErrorEvent({ eventName: \"ContainerCloseException\" }, exception);\n            }\n            this.emit(\"closed\", error);\n            this.removeAllListeners();\n            if (this.visibilityEventHandler !== undefined) {\n                document.removeEventListener(\"visibilitychange\", this.visibilityEventHandler);\n            }\n        }\n        finally {\n            this._lifecycleState = \"closed\";\n        }\n    }\n    closeAndGetPendingLocalState() {\n        // runtime matches pending ops to successful ones by clientId and client seq num, so we need to close the\n        // container at the same time we get pending state, otherwise this container could reconnect and resubmit with\n        // a new clientId and a future container using stale pending state without the new clientId would resubmit them\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached, 0x0d1 /* \"Container should be attached before close\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.resolvedUrl !== undefined && this.resolvedUrl.type === \"fluid\", 0x0d2 /* \"resolved url should be valid Fluid url\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this._protocolHandler, 0x2e3 /* \"Must have a valid protocol handler instance\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._protocolHandler.attributes.term !== undefined, 0x30b /* Must have a valid protocol handler instance */);\n        const pendingState = {\n            pendingRuntimeState: this.context.getPendingLocalState(),\n            url: this.resolvedUrl.url,\n            protocol: this.protocolHandler.getProtocolState(),\n            term: this._protocolHandler.attributes.term,\n            clientId: this.clientId,\n        };\n        this.close();\n        return JSON.stringify(pendingState);\n    }\n    get attachState() {\n        return this._attachState;\n    }\n    serialize() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached, 0x0d3 /* \"Should only be called in detached container\" */);\n        const appSummary = this.context.createSummary();\n        const protocolSummary = this.captureProtocolSummary();\n        const combinedSummary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);\n        if (this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0) {\n            combinedSummary.tree[\".hasAttachmentBlobs\"] = { type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob, content: \"true\" };\n        }\n        return JSON.stringify(combinedSummary);\n    }\n    async attach(request) {\n        await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: \"Attach\" }, async () => {\n            if (this._lifecycleState !== \"loaded\") {\n                // pre-0.58 error message: containerNotValidForAttach\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is not in a valid state for attach [${this._lifecycleState}]`);\n            }\n            // If container is already attached or attach is in progress, throw an error.\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached && !this.attachStarted, 0x205 /* \"attach() called more than once\" */);\n            this.attachStarted = true;\n            // If attachment blobs were uploaded in detached state we will go through a different attach flow\n            const hasAttachmentBlobs = this.loader.services.detachedBlobStorage !== undefined\n                && this.loader.services.detachedBlobStorage.size > 0;\n            try {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.deltaManager.inbound.length === 0, 0x0d6 /* \"Inbound queue should be empty when attaching\" */);\n                let summary;\n                if (!hasAttachmentBlobs) {\n                    // Get the document state post attach - possibly can just call attach but we need to change the\n                    // semantics around what the attach means as far as async code goes.\n                    const appSummary = this.context.createSummary();\n                    const protocolSummary = this.captureProtocolSummary();\n                    summary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);\n                    // Set the state as attaching as we are starting the process of attaching container.\n                    // This should be fired after taking the summary because it is the place where we are\n                    // starting to attach the container to storage.\n                    // Also, this should only be fired in detached container.\n                    this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attaching;\n                    this.context.notifyAttaching((0,_utils__WEBPACK_IMPORTED_MODULE_17__.getSnapshotTreeFromSerializedContainer)(summary));\n                }\n                // Actually go and create the resolved document\n                const createNewResolvedUrl = await this.urlResolver.resolve(request);\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.ensureFluidResolvedUrl)(createNewResolvedUrl);\n                if (this.service === undefined) {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.client.details.type !== summarizerClientType, 0x2c4 /* \"client should not be summarizer before container is created\" */);\n                    this.service = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_19__.runWithRetry)(async () => this.serviceFactory.createContainer(summary, createNewResolvedUrl, this.subLogger, false), \"containerAttach\", this.mc.logger, {\n                        cancel: this.closeSignal,\n                    });\n                }\n                const resolvedUrl = this.service.resolvedUrl;\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.ensureFluidResolvedUrl)(resolvedUrl);\n                this._resolvedUrl = resolvedUrl;\n                await this.connectStorageService();\n                if (hasAttachmentBlobs) {\n                    // upload blobs to storage\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.loader.services.detachedBlobStorage, 0x24e /* \"assertion for type narrowing\" */);\n                    // build a table mapping IDs assigned locally to IDs assigned by storage and pass it to runtime to\n                    // support blob handles that only know about the local IDs\n                    const redirectTable = new Map();\n                    // if new blobs are added while uploading, upload them too\n                    while (redirectTable.size < this.loader.services.detachedBlobStorage.size) {\n                        const newIds = this.loader.services.detachedBlobStorage.getBlobIds().filter((id) => !redirectTable.has(id));\n                        for (const id of newIds) {\n                            const blob = await this.loader.services.detachedBlobStorage.readBlob(id);\n                            const response = await this.storageService.createBlob(blob);\n                            redirectTable.set(id, response.id);\n                        }\n                    }\n                    // take summary and upload\n                    const appSummary = this.context.createSummary(redirectTable);\n                    const protocolSummary = this.captureProtocolSummary();\n                    summary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);\n                    this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attaching;\n                    this.context.notifyAttaching((0,_utils__WEBPACK_IMPORTED_MODULE_17__.getSnapshotTreeFromSerializedContainer)(summary));\n                    await this.storageService.uploadSummaryWithContext(summary, {\n                        referenceSequenceNumber: 0,\n                        ackHandle: undefined,\n                        proposalHandle: undefined,\n                    });\n                }\n                this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached;\n                this.emit(\"attached\");\n                // Propagate current connection state through the system.\n                this.propagateConnectionState();\n                if (!this.closed) {\n                    this.resumeInternal({ fetchOpsFromStorage: false, reason: \"createDetached\" });\n                }\n            }\n            catch (error) {\n                // add resolved URL on error object so that host has the ability to find this document and delete it\n                const newError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeError)(error);\n                const resolvedUrl = this.resolvedUrl;\n                if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.isFluidResolvedUrl)(resolvedUrl)) {\n                    newError.addTelemetryProperties({ resolvedUrl: resolvedUrl.url });\n                }\n                this.close(newError);\n                throw newError;\n            }\n        }, { start: true, end: true, cancel: \"generic\" });\n    }\n    async request(path) {\n        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: \"Request\" }, async () => this.context.request(path), { end: true, cancel: \"error\" });\n    }\n    setAutoReconnectInternal(mode) {\n        const currentMode = this._deltaManager.connectionManager.reconnectMode;\n        if (currentMode === mode) {\n            return;\n        }\n        const now = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();\n        const duration = now - this.setAutoReconnectTime;\n        this.setAutoReconnectTime = now;\n        this.mc.logger.sendTelemetryEvent({\n            eventName: mode === _contracts__WEBPACK_IMPORTED_MODULE_20__.ReconnectMode.Enabled ? \"AutoReconnectEnabled\" : \"AutoReconnectDisabled\",\n            connectionMode: this.connectionMode,\n            connectionState: _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[this.connectionState],\n            duration,\n        });\n        this._deltaManager.connectionManager.setAutoReconnect(mode);\n    }\n    connect() {\n        if (this.closed) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is closed and cannot be connected`);\n        }\n        else if (this._attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is not attached and cannot be connected`);\n        }\n        else if (!this.connected) {\n            // Note: no need to fetch ops as we do it preemptively as part of DeltaManager.attachOpHandler().\n            // If there is gap, we will learn about it once connected, but the gap should be small (if any),\n            // assuming that connect() is called quickly after initial container boot.\n            this.connectInternal({ reason: \"DocumentConnect\", fetchOpsFromStorage: false });\n        }\n    }\n    connectInternal(args) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x2c5 /* \"Attempting to connect() a closed Container\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached, 0x2c6 /* \"Attempting to connect() a container that is not attached\" */);\n        // Resume processing ops and connect to delta stream\n        this.resumeInternal(args);\n        // Set Auto Reconnect Mode\n        const mode = _contracts__WEBPACK_IMPORTED_MODULE_20__.ReconnectMode.Enabled;\n        this.setAutoReconnectInternal(mode);\n    }\n    disconnect() {\n        if (this.closed) {\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is closed and cannot be disconnected`);\n        }\n        else {\n            this.disconnectInternal();\n        }\n    }\n    disconnectInternal() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x2c7 /* \"Attempting to disconnect() a closed Container\" */);\n        // Set Auto Reconnect Mode\n        const mode = _contracts__WEBPACK_IMPORTED_MODULE_20__.ReconnectMode.Disabled;\n        this.setAutoReconnectInternal(mode);\n    }\n    resumeInternal(args) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x0d9 /* \"Attempting to connect() a closed DeltaManager\" */);\n        // Resume processing ops\n        if (this.inboundQueuePausedFromInit) {\n            this.inboundQueuePausedFromInit = false;\n            this._deltaManager.inbound.resume();\n            this._deltaManager.inboundSignal.resume();\n        }\n        // Ensure connection to web socket\n        this.connectToDeltaStream(args);\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        var _a;\n        if (this.resolvedUrl === undefined) {\n            return undefined;\n        }\n        return this.urlResolver.getAbsoluteUrl(this.resolvedUrl, relativeUrl, (0,_contracts__WEBPACK_IMPORTED_MODULE_20__.getPackageName)((_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails));\n    }\n    async proposeCodeDetails(codeDetails) {\n        if (!(0,_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.isFluidCodeDetails)(codeDetails)) {\n            throw new Error(\"Provided codeDetails are not IFluidCodeDetails\");\n        }\n        if (this.codeLoader.IFluidCodeDetailsComparer) {\n            const comparison = await this.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, this.getCodeDetailsFromQuorum());\n            if (comparison !== undefined && comparison <= 0) {\n                throw new Error(\"Proposed code details should be greater than the current\");\n            }\n        }\n        return this.protocolHandler.quorum.propose(\"code\", codeDetails)\n            .then(() => true)\n            .catch(() => false);\n    }\n    async processCodeProposal() {\n        const codeDetails = this.getCodeDetailsFromQuorum();\n        await Promise.all([\n            this.deltaManager.inbound.pause(),\n            this.deltaManager.inboundSignal.pause()\n        ]);\n        if ((await this.context.satisfies(codeDetails) === true)) {\n            this.deltaManager.inbound.resume();\n            this.deltaManager.inboundSignal.resume();\n            return;\n        }\n        // pre-0.58 error message: existingContextDoesNotSatisfyIncomingProposal\n        this.close(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(\"Existing context does not satisfy incoming proposal\"));\n    }\n    async getVersion(version) {\n        const versions = await this.storageService.getVersions(version, 1);\n        return versions[0];\n    }\n    recordConnectStartTime() {\n        if (this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected] === undefined) {\n            this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected] = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();\n        }\n    }\n    connectToDeltaStream(args) {\n        this.recordConnectStartTime();\n        // All agents need \"write\" access, including summarizer.\n        if (!this._canReconnect || !this.client.details.capabilities.interactive) {\n            args.mode = \"write\";\n        }\n        this._deltaManager.connect(args);\n    }\n    /**\n     * Load container.\n     *\n     * @param specifiedVersion - one of the following\n     *   - undefined - fetch latest snapshot\n     *   - otherwise, version sha to load snapshot\n     */\n    async load(specifiedVersion, loadMode, pendingLocalState) {\n        if (this._resolvedUrl === undefined) {\n            throw new Error(\"Attempting to load without a resolved url\");\n        }\n        this.service = await this.serviceFactory.createDocumentService(this._resolvedUrl, this.subLogger, this.client.details.type === summarizerClientType);\n        // Ideally we always connect as \"read\" by default.\n        // Currently that works with SPO & r11s, because we get \"write\" connection when connecting to non-existing file.\n        // We should not rely on it by (one of them will address the issue, but we need to address both)\n        // 1) switching create new flow to one where we create file by posting snapshot\n        // 2) Fixing quorum workflows (have retry logic)\n        // That all said, \"read\" does not work with memorylicious workflows (that opens two simultaneous\n        // connections to same file) in two ways:\n        // A) creation flow breaks (as one of the clients \"sees\" file as existing, and hits #2 above)\n        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.\n        const connectionArgs = { reason: \"DocumentOpen\", mode: \"write\", fetchOpsFromStorage: false };\n        // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the\n        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.\n        if (loadMode.deltaConnection === undefined) {\n            this.connectToDeltaStream(connectionArgs);\n        }\n        if (!pendingLocalState) {\n            await this.connectStorageService();\n        }\n        else {\n            // if we have pendingLocalState we can load without storage; don't wait for connection\n            this.connectStorageService().catch((error) => this.close(error));\n        }\n        this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached;\n        // Fetch specified snapshot.\n        const { snapshot, versionId } = pendingLocalState === undefined\n            ? await this.fetchSnapshotTree(specifiedVersion)\n            : { snapshot: undefined, versionId: undefined };\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(snapshot !== undefined || pendingLocalState !== undefined, 0x237 /* \"Snapshot should exist\" */);\n        const attributes = pendingLocalState === undefined\n            ? await this.getDocumentAttributes(this.storageService, snapshot)\n            : {\n                sequenceNumber: pendingLocalState.protocol.sequenceNumber,\n                minimumSequenceNumber: pendingLocalState.protocol.minimumSequenceNumber,\n                term: pendingLocalState.term,\n            };\n        let opsBeforeReturnP;\n        // Attach op handlers to finish initialization and be able to start processing ops\n        // Kick off any ops fetching if required.\n        switch (loadMode.opsBeforeReturn) {\n            case undefined:\n                // Start prefetch, but not set opsBeforeReturnP - boot is not blocked by it!\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this.attachDeltaManagerOpHandler(attributes, loadMode.deltaConnection !== \"none\" ? \"all\" : \"none\");\n                break;\n            case \"cached\":\n                opsBeforeReturnP = this.attachDeltaManagerOpHandler(attributes, \"cached\");\n                break;\n            case \"all\":\n                opsBeforeReturnP = this.attachDeltaManagerOpHandler(attributes, \"all\");\n                break;\n            default:\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_22__.unreachableCase)(loadMode.opsBeforeReturn);\n        }\n        // ...load in the existing quorum\n        // Initialize the protocol handler\n        this._protocolHandler = pendingLocalState === undefined\n            ? await this.initializeProtocolStateFromSnapshot(attributes, this.storageService, snapshot)\n            : await this.initializeProtocolState(attributes, pendingLocalState.protocol.members, pendingLocalState.protocol.proposals, pendingLocalState.protocol.values);\n        const codeDetails = this.getCodeDetailsFromQuorum();\n        await this.instantiateContext(true, // existing\n        codeDetails, snapshot, pendingLocalState === null || pendingLocalState === void 0 ? void 0 : pendingLocalState.pendingRuntimeState);\n        // We might have hit some failure that did not manifest itself in exception in this flow,\n        // do not start op processing in such case - static version of Container.load() will handle it correctly.\n        if (!this.closed) {\n            if (opsBeforeReturnP !== undefined) {\n                this._deltaManager.inbound.resume();\n                await ReportIfTooLong(this.mc.logger, \"WaitOps\", async () => { await opsBeforeReturnP; return {}; });\n                await ReportIfTooLong(this.mc.logger, \"WaitOpProcessing\", async () => this._deltaManager.inbound.waitTillProcessingDone());\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this._deltaManager.inbound.pause();\n            }\n            switch (loadMode.deltaConnection) {\n                case undefined:\n                case \"delayed\":\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.inboundQueuePausedFromInit, 0x346 /* inboundQueuePausedFromInit should be true */);\n                    this.inboundQueuePausedFromInit = false;\n                    this._deltaManager.inbound.resume();\n                    this._deltaManager.inboundSignal.resume();\n                    break;\n                case \"none\":\n                    break;\n                default:\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_22__.unreachableCase)(loadMode.deltaConnection);\n            }\n        }\n        // Safety net: static version of Container.load() should have learned about it through \"closed\" handler.\n        // But if that did not happen for some reason, fail load for sure.\n        // Otherwise we can get into situations where container is closed and does not try to connect to ordering\n        // service, but caller does not know that (callers do expect container to be not closed on successful path\n        // and listen only on \"closed\" event)\n        if (this.closed) {\n            throw new Error(\"Container was closed while load()\");\n        }\n        // Internal context is fully loaded at this point\n        this.setLoaded();\n        return {\n            sequenceNumber: attributes.sequenceNumber,\n            version: versionId,\n            dmLastProcessedSeqNumber: this._deltaManager.lastSequenceNumber,\n            dmLastKnownSeqNumber: this._deltaManager.lastKnownSeqNumber,\n        };\n    }\n    async createDetached(source) {\n        const attributes = {\n            sequenceNumber: detachedContainerRefSeqNumber,\n            term: 1,\n            minimumSequenceNumber: 0,\n        };\n        await this.attachDeltaManagerOpHandler(attributes);\n        // Need to just seed the source data in the code quorum. Quorum itself is empty\n        const qValues = (0,_quorum__WEBPACK_IMPORTED_MODULE_23__.initQuorumValuesFromCodeDetails)(source);\n        this._protocolHandler = await this.initializeProtocolState(attributes, [], // members\n        [], // proposals\n        qValues);\n        // The load context - given we seeded the quorum - will be great\n        await this.instantiateContextDetached(false);\n        this.setLoaded();\n    }\n    async rehydrateDetachedFromSnapshot(detachedContainerSnapshot) {\n        if (detachedContainerSnapshot.tree[\".hasAttachmentBlobs\"] !== undefined) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0, 0x250 /* \"serialized container with attachment blobs must be rehydrated with detached blob storage\" */);\n            delete detachedContainerSnapshot.tree[\".hasAttachmentBlobs\"];\n        }\n        const snapshotTree = (0,_utils__WEBPACK_IMPORTED_MODULE_17__.getSnapshotTreeFromSerializedContainer)(detachedContainerSnapshot);\n        this._storage.loadSnapshotForRehydratingContainer(snapshotTree);\n        const attributes = await this.getDocumentAttributes(this._storage, snapshotTree);\n        await this.attachDeltaManagerOpHandler(attributes);\n        // Initialize the protocol handler\n        const baseTree = (0,_utils__WEBPACK_IMPORTED_MODULE_17__.getProtocolSnapshotTree)(snapshotTree);\n        const qValues = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(this._storage, baseTree.blobs.quorumValues);\n        const codeDetails = (0,_quorum__WEBPACK_IMPORTED_MODULE_23__.getCodeDetailsFromQuorumValues)(qValues);\n        this._protocolHandler =\n            await this.initializeProtocolState(attributes, [], // members\n            [], // proposals\n            codeDetails !== undefined ? (0,_quorum__WEBPACK_IMPORTED_MODULE_23__.initQuorumValuesFromCodeDetails)(codeDetails) : []);\n        await this.instantiateContextDetached(true, // existing\n        snapshotTree);\n        this.setLoaded();\n    }\n    async connectStorageService() {\n        var _a, _b;\n        if (this._storageService !== undefined) {\n            return;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.service !== undefined, 0x1ef /* \"services must be defined\" */);\n        const storageService = await this.service.connectToStorage();\n        this._storageService =\n            new _retriableDocumentStorageService__WEBPACK_IMPORTED_MODULE_25__.RetriableDocumentStorageService(storageService, this.mc.logger);\n        if (this.options.summarizeProtocolTree === true) {\n            this.mc.logger.sendTelemetryEvent({ eventName: \"summarizeProtocolTreeEnabled\" });\n            this._storageService =\n                new _protocolTreeDocumentStorageService__WEBPACK_IMPORTED_MODULE_26__.ProtocolTreeStorageService(this._storageService, () => this.captureProtocolSummary());\n        }\n        // ensure we did not lose that policy in the process of wrapping\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(((_a = storageService.policies) === null || _a === void 0 ? void 0 : _a.minBlobSize) === ((_b = this.storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize), 0x0e0 /* \"lost minBlobSize policy\" */);\n    }\n    async getDocumentAttributes(storage, tree) {\n        if (tree === undefined) {\n            return {\n                minimumSequenceNumber: 0,\n                sequenceNumber: 0,\n                term: 1,\n            };\n        }\n        // Backward compatibility: old docs would have \".attributes\" instead of \"attributes\"\n        const attributesHash = \".protocol\" in tree.trees\n            ? tree.trees[\".protocol\"].blobs.attributes\n            : tree.blobs[\".attributes\"];\n        const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, attributesHash);\n        // Backward compatibility for older summaries with no term\n        if (attributes.term === undefined) {\n            attributes.term = 1;\n        }\n        return attributes;\n    }\n    async initializeProtocolStateFromSnapshot(attributes, storage, snapshot) {\n        let members = [];\n        let proposals = [];\n        let values = [];\n        if (snapshot !== undefined) {\n            const baseTree = (0,_utils__WEBPACK_IMPORTED_MODULE_17__.getProtocolSnapshotTree)(snapshot);\n            [members, proposals, values] = await Promise.all([\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, baseTree.blobs.quorumMembers),\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, baseTree.blobs.quorumProposals),\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, baseTree.blobs.quorumValues),\n            ]);\n        }\n        const protocolHandler = await this.initializeProtocolState(attributes, members, proposals, values);\n        return protocolHandler;\n    }\n    async initializeProtocolState(attributes, members, proposals, values) {\n        const protocol = new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_27__.ProtocolOpHandlerWithClientValidation(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => this.submitMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.Propose, { key, value }));\n        const protocolLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, \"ProtocolHandler\");\n        protocol.quorum.on(\"error\", (error) => {\n            protocolLogger.sendErrorEvent(error);\n        });\n        // Track membership changes and update connection state accordingly\n        this.connectionStateHandler.initProtocol(protocol);\n        protocol.quorum.on(\"addProposal\", (proposal) => {\n            if (proposal.key === \"code\" || proposal.key === \"code2\") {\n                this.emit(\"codeDetailsProposed\", proposal.value, proposal);\n            }\n        });\n        protocol.quorum.on(\"approveProposal\", (sequenceNumber, key, value) => {\n            if (key === \"code\" || key === \"code2\") {\n                if (!(0,_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.isFluidCodeDetails)(value)) {\n                    this.mc.logger.sendErrorEvent({\n                        eventName: \"CodeProposalNotIFluidCodeDetails\",\n                    });\n                }\n                this.processCodeProposal().catch((error) => {\n                    this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeError)(error));\n                    throw error;\n                });\n            }\n        });\n        return protocol;\n    }\n    captureProtocolSummary() {\n        const quorumSnapshot = this.protocolHandler.snapshot();\n        const summary = {\n            tree: {\n                attributes: {\n                    content: JSON.stringify(this.protocolHandler.attributes),\n                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,\n                },\n                quorumMembers: {\n                    content: JSON.stringify(quorumSnapshot.members),\n                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,\n                },\n                quorumProposals: {\n                    content: JSON.stringify(quorumSnapshot.proposals),\n                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,\n                },\n                quorumValues: {\n                    content: JSON.stringify(quorumSnapshot.values),\n                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,\n                },\n            },\n            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Tree,\n        };\n        return summary;\n    }\n    getCodeDetailsFromQuorum() {\n        const quorum = this.protocolHandler.quorum;\n        const pkg = getCodeProposal(quorum);\n        return pkg;\n    }\n    get client() {\n        var _a;\n        const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined\n            ? this.options.client\n            : {\n                details: {\n                    capabilities: { interactive: true },\n                },\n                mode: \"read\",\n                permission: [],\n                scopes: [],\n                user: { id: \"\" },\n            };\n        if (this.clientDetailsOverride !== undefined) {\n            lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()(client.details, this.clientDetailsOverride);\n        }\n        client.details.environment = [client.details.environment, ` loaderVersion:${_packageVersion__WEBPACK_IMPORTED_MODULE_29__.pkgVersion}`].join(\";\");\n        return client;\n    }\n    /**\n     * Returns true if connection is active, i.e. it's \"write\" connection and\n     * container runtime was notified about this connection (i.e. we are up-to-date and could send ops).\n     * This happens after client received its own joinOp and thus is in the quorum.\n     * If it's not true, runtime is not in position to send ops.\n     */\n    activeConnection() {\n        return this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected &&\n            this.connectionMode === \"write\";\n    }\n    createDeltaManager() {\n        const serviceProvider = () => this.service;\n        const deltaManager = new _deltaManager__WEBPACK_IMPORTED_MODULE_30__.DeltaManager(serviceProvider, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, \"DeltaManager\"), () => this.activeConnection(), (props) => new _connectionManager__WEBPACK_IMPORTED_MODULE_31__.ConnectionManager(serviceProvider, this.client, this._canReconnect, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, \"ConnectionManager\"), props));\n        // Disable inbound queues as Container is not ready to accept any ops until we are fully loaded!\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        deltaManager.inbound.pause();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        deltaManager.inboundSignal.pause();\n        deltaManager.on(\"connect\", (details, opsBehind) => {\n            var _a;\n            // Back-compat for new client and old server.\n            this._audience.clear();\n            for (const priorClient of (_a = details.initialClients) !== null && _a !== void 0 ? _a : []) {\n                this._audience.addMember(priorClient.clientId, priorClient.client);\n            }\n            this.connectionStateHandler.receivedConnectEvent(this.connectionMode, details);\n        });\n        deltaManager.on(\"disconnect\", (reason) => {\n            var _a;\n            (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();\n            this.connectionStateHandler.receivedDisconnectEvent(reason);\n        });\n        deltaManager.on(\"throttled\", (warning) => {\n            const warn = warning;\n            // Some \"warning\" events come from outside the container and are logged\n            // elsewhere (e.g. summarizing container). We shouldn't log these here.\n            if (warn.logged !== true) {\n                this.logContainerError(warn);\n            }\n            this.emit(\"warning\", warn);\n        });\n        deltaManager.on(\"readonly\", (readonly) => {\n            this.emit(\"readonly\", readonly);\n        });\n        deltaManager.on(\"closed\", (error) => {\n            this.closeCore(error);\n        });\n        return deltaManager;\n    }\n    async attachDeltaManagerOpHandler(attributes, prefetchType) {\n        var _a;\n        return this._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term) !== null && _a !== void 0 ? _a : 1, {\n            process: (message) => this.processRemoteMessage(message),\n            processSignal: (message) => {\n                this.processSignal(message);\n            },\n        }, prefetchType);\n    }\n    logConnectionStateChangeTelemetry(value, oldState, reason) {\n        var _a;\n        // Log actual event\n        const time = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();\n        this.connectionTransitionTimes[value] = time;\n        const duration = time - this.connectionTransitionTimes[oldState];\n        let durationFromDisconnected;\n        let connectionInitiationReason;\n        let autoReconnect;\n        let checkpointSequenceNumber;\n        let opsBehind;\n        if (value === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected) {\n            autoReconnect = this._deltaManager.connectionManager.reconnectMode;\n        }\n        else {\n            if (value === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {\n                durationFromDisconnected = time - this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected];\n                durationFromDisconnected = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.TelemetryLogger.formatTick(durationFromDisconnected);\n            }\n            else {\n                // This info is of most interest on establishing connection only.\n                checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;\n                if (this.deltaManager.hasCheckpointSequenceNumber) {\n                    opsBehind = checkpointSequenceNumber - this.deltaManager.lastSequenceNumber;\n                }\n            }\n            if (this.firstConnection) {\n                connectionInitiationReason = \"InitialConnect\";\n            }\n            else {\n                connectionInitiationReason = \"AutoReconnect\";\n            }\n        }\n        this.mc.logger.sendPerformanceEvent(Object.assign({ eventName: `ConnectionStateChange_${_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[value]}`, from: _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[oldState], duration,\n            durationFromDisconnected,\n            reason,\n            connectionInitiationReason, pendingClientId: this.connectionStateHandler.pendingClientId, clientId: this.clientId, autoReconnect,\n            opsBehind, online: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_32__.OnlineStatus[(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_32__.isOnline)()], lastVisible: this.lastVisible !== undefined ? _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - this.lastVisible : undefined, checkpointSequenceNumber, quorumSize: (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum.getMembers().size }, this._deltaManager.connectionProps));\n        if (value === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {\n            this.firstConnection = false;\n        }\n    }\n    propagateConnectionState() {\n        var _a;\n        const logOpsOnReconnect = this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected &&\n            !this.firstConnection &&\n            this.connectionMode === \"write\";\n        if (logOpsOnReconnect) {\n            this.messageCountAfterDisconnection = 0;\n        }\n        const state = this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected;\n        // Both protocol and context should not be undefined if we got so far.\n        if (((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) === false) {\n            this.context.setConnectionState(state, this.clientId);\n        }\n        this.protocolHandler.setConnectionState(state, this.clientId);\n        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.raiseConnectedEvent)(this.mc.logger, this, state, this.clientId);\n        if (logOpsOnReconnect) {\n            this.mc.logger.sendTelemetryEvent({ eventName: \"OpsSentOnReconnect\", count: this.messageCountAfterDisconnection });\n        }\n    }\n    submitContainerMessage(type, contents, batch, metadata) {\n        const outboundMessageType = type;\n        switch (outboundMessageType) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.Operation:\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.RemoteHelp:\n                break;\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.Summarize: {\n                // github #6451: this is only needed for staging so the server\n                // know when the protocol tree is included\n                // this can be removed once all clients send\n                // protocol tree by default\n                const summary = contents;\n                if (summary.details === undefined) {\n                    summary.details = {};\n                }\n                summary.details.includesProtocolTree =\n                    this.options.summarizeProtocolTree === true;\n                break;\n            }\n            default:\n                this.close(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(\"invalidContainerSubmitOpType\", undefined /* error */, { messageType: type }));\n                return -1;\n        }\n        return this.submitMessage(type, contents, batch, metadata);\n    }\n    submitMessage(type, contents, batch, metadata) {\n        var _a;\n        if (this.connectionState !== _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {\n            this.mc.logger.sendErrorEvent({ eventName: \"SubmitMessageWithNoConnection\", type });\n            return -1;\n        }\n        this.messageCountAfterDisconnection += 1;\n        (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();\n        return this._deltaManager.submit(type, contents, batch, metadata);\n    }\n    processRemoteMessage(message) {\n        const local = this.clientId === message.clientId;\n        // Allow the protocol handler to process the message\n        let result = { immediateNoOp: false };\n        try {\n            result = this.protocolHandler.processMessage(message, local);\n        }\n        catch (error) {\n            this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.wrapError)(error, (errorMessage) => new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataCorruptionError(errorMessage, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.extractSafePropertiesFromMessage)(message))));\n        }\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isUnpackedRuntimeMessage)(message) && !(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isRuntimeMessage)(message)) {\n            this.mc.logger.sendTelemetryEvent({ eventName: \"UnpackedRuntimeMessage\", type: message.type });\n        }\n        // Forward non system messages to the loaded runtime for processing\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isRuntimeMessage)(message) || (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isUnpackedRuntimeMessage)(message)) {\n            this.context.process(message, local, undefined);\n        }\n        // Inactive (not in quorum or not writers) clients don't take part in the minimum sequence number calculation.\n        if (this.activeConnection()) {\n            if (this.collabWindowTracker === undefined) {\n                // Note that config from first connection will be used for this container's lifetime.\n                // That means that if relay service changes settings, such changes will impact only newly booted\n                // clients.\n                // All existing will continue to use settings they got earlier.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.serviceConfiguration !== undefined, 0x2e4 /* \"there should be service config for active connection\" */);\n                this.collabWindowTracker = new _collabWindowTracker__WEBPACK_IMPORTED_MODULE_34__.CollabWindowTracker((type, contents) => {\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.activeConnection(), 0x241 /* \"disconnect should result in stopSequenceNumberUpdate() call\" */);\n                    this.submitMessage(type, contents);\n                }, this.serviceConfiguration.noopTimeFrequency, this.serviceConfiguration.noopCountFrequency);\n            }\n            this.collabWindowTracker.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);\n        }\n        this.emit(\"op\", message);\n        return result;\n    }\n    submitSignal(message) {\n        this._deltaManager.submitSignal(JSON.stringify(message));\n    }\n    processSignal(message) {\n        // No clientId indicates a system signal message.\n        if (message.clientId === null) {\n            const innerContent = message.content;\n            if (innerContent.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.ClientJoin) {\n                const newClient = innerContent.content;\n                this._audience.addMember(newClient.clientId, newClient.client);\n            }\n            else if (innerContent.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.ClientLeave) {\n                const leftClientId = innerContent.content;\n                this._audience.removeMember(leftClientId);\n            }\n        }\n        else {\n            const local = this.clientId === message.clientId;\n            this.context.processSignal(message, local);\n        }\n    }\n    /**\n     * Get the most recent snapshot, or a specific version.\n     * @param specifiedVersion - The specific version of the snapshot to retrieve\n     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID\n     */\n    async fetchSnapshotTree(specifiedVersion) {\n        var _a;\n        const version = await this.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : null);\n        if (version === undefined && specifiedVersion !== undefined) {\n            // We should have a defined version to load from if specified version requested\n            this.mc.logger.sendErrorEvent({ eventName: \"NoVersionFoundWhenSpecified\", id: specifiedVersion });\n        }\n        this._loadedFromVersion = version;\n        const snapshot = (_a = await this.storageService.getSnapshotTree(version)) !== null && _a !== void 0 ? _a : undefined;\n        if (snapshot === undefined && version !== undefined) {\n            this.mc.logger.sendErrorEvent({ eventName: \"getSnapshotTreeFailed\", id: version.id });\n        }\n        return { snapshot, versionId: version === null || version === void 0 ? void 0 : version.id };\n    }\n    async instantiateContextDetached(existing, snapshot) {\n        const codeDetails = this.getCodeDetailsFromQuorum();\n        if (codeDetails === undefined) {\n            throw new Error(\"pkg should be provided in create flow!!\");\n        }\n        await this.instantiateContext(existing, codeDetails, snapshot);\n    }\n    async instantiateContext(existing, codeDetails, snapshot, pendingLocalState) {\n        var _a;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, 0x0dd /* \"Existing context not disposed\" */);\n        // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags\n        // are set. Global requests will still go directly to the loader\n        const loader = new _loader__WEBPACK_IMPORTED_MODULE_35__.RelativeLoader(this, this.loader);\n        this._context = await _containerContext__WEBPACK_IMPORTED_MODULE_36__.ContainerContext.createOrLoad(this, this.scope, this.codeLoader, codeDetails, snapshot, new _deltaManagerProxy__WEBPACK_IMPORTED_MODULE_37__.DeltaManagerProxy(this._deltaManager), new _quorum__WEBPACK_IMPORTED_MODULE_23__.QuorumProxy(this.protocolHandler.quorum), loader, (type, contents, batch, metadata) => this.submitContainerMessage(type, contents, batch, metadata), (message) => this.submitSignal(message), (error) => this.close(error), Container.version, (dirty) => this.updateDirtyContainerState(dirty), existing, pendingLocalState);\n        this.emit(\"contextChanged\", codeDetails);\n    }\n    updateDirtyContainerState(dirty) {\n        if (this._dirtyContainer === dirty) {\n            return;\n        }\n        this._dirtyContainer = dirty;\n        this.emit(dirty ? dirtyContainerEvent : savedContainerEvent);\n    }\n    logContainerError(warning) {\n        this.mc.logger.sendErrorEvent({ eventName: \"ContainerWarning\" }, warning);\n    }\n}\nContainer.version = \"^0.1.0\";\n//# sourceMappingURL=container.js.map\n\n/***/ }),\n/* 467 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseMerge = __webpack_require__(468),\n    createAssigner = __webpack_require__(477);\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n\n\n/***/ }),\n/* 468 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Stack = __webpack_require__(160),\n    assignMergeValue = __webpack_require__(469),\n    baseFor = __webpack_require__(470),\n    baseMergeDeep = __webpack_require__(472),\n    isObject = __webpack_require__(184),\n    keysIn = __webpack_require__(231),\n    safeGet = __webpack_require__(475);\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n\n\n/***/ }),\n/* 469 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseAssignValue = __webpack_require__(206),\n    eq = __webpack_require__(165);\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n\n\n/***/ }),\n/* 470 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar createBaseFor = __webpack_require__(471);\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n/***/ }),\n/* 471 */\n/***/ ((module) => {\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n/***/ }),\n/* 472 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assignMergeValue = __webpack_require__(469),\n    cloneBuffer = __webpack_require__(234),\n    cloneTypedArray = __webpack_require__(259),\n    copyArray = __webpack_require__(235),\n    initCloneObject = __webpack_require__(260),\n    isArguments = __webpack_require__(213),\n    isArray = __webpack_require__(216),\n    isArrayLikeObject = __webpack_require__(473),\n    isBuffer = __webpack_require__(217),\n    isFunction = __webpack_require__(177),\n    isObject = __webpack_require__(184),\n    isPlainObject = __webpack_require__(474),\n    isTypedArray = __webpack_require__(220),\n    safeGet = __webpack_require__(475),\n    toPlainObject = __webpack_require__(476);\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n\n\n/***/ }),\n/* 473 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isArrayLike = __webpack_require__(229),\n    isObjectLike = __webpack_require__(215);\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n\n\n/***/ }),\n/* 474 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetTag = __webpack_require__(178),\n    getPrototype = __webpack_require__(243),\n    isObjectLike = __webpack_require__(215);\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n/***/ }),\n/* 475 */\n/***/ ((module) => {\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n\n\n/***/ }),\n/* 476 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar copyObject = __webpack_require__(209),\n    keysIn = __webpack_require__(231);\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n\n\n/***/ }),\n/* 477 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseRest = __webpack_require__(478),\n    isIterateeCall = __webpack_require__(486);\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n/***/ }),\n/* 478 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar identity = __webpack_require__(479),\n    overRest = __webpack_require__(480),\n    setToString = __webpack_require__(482);\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n\n/***/ }),\n/* 479 */\n/***/ ((module) => {\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n/***/ }),\n/* 480 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar apply = __webpack_require__(481);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n\n/***/ }),\n/* 481 */\n/***/ ((module) => {\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n\n/***/ }),\n/* 482 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseSetToString = __webpack_require__(483),\n    shortOut = __webpack_require__(485);\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n\n\n/***/ }),\n/* 483 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar constant = __webpack_require__(484),\n    defineProperty = __webpack_require__(207),\n    identity = __webpack_require__(479);\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n\n\n/***/ }),\n/* 484 */\n/***/ ((module) => {\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n/***/ }),\n/* 485 */\n/***/ ((module) => {\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n\n/***/ }),\n/* 486 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar eq = __webpack_require__(165),\n    isArrayLike = __webpack_require__(229),\n    isIndex = __webpack_require__(219),\n    isObject = __webpack_require__(184);\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n/***/ }),\n/* 487 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 488 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nconst performance = window.performance;\n//# sourceMappingURL=performanceBrowser.js.map\n\n/***/ }),\n/* 489 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Audience\": () => (/* binding */ Audience)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Audience represents all clients connected to the op stream.\n */\nclass Audience extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.members = new Map();\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    /**\n     * Adds a new client to the audience\n     */\n    addMember(clientId, details) {\n        this.members.set(clientId, details);\n        this.emit(\"addMember\", clientId, details);\n    }\n    /**\n     * Removes a client from the audience. Only emits an event if a client is actually removed\n     * @returns if a client was removed from the audience\n     */\n    removeMember(clientId) {\n        const removedClient = this.members.get(clientId);\n        if (removedClient !== undefined) {\n            this.members.delete(clientId);\n            this.emit(\"removeMember\", clientId, removedClient);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Retrieves all the members in the audience\n     */\n    getMembers() {\n        return new Map(this.members);\n    }\n    /**\n     * Retrieves a specific member of the audience\n     */\n    getMember(clientId) {\n        return this.members.get(clientId);\n    }\n    /**\n     * Clears the audience\n     */\n    clear() {\n        const clientIds = this.members.keys();\n        for (const clientId of clientIds) {\n            this.removeMember(clientId);\n        }\n    }\n}\n//# sourceMappingURL=audience.js.map\n\n/***/ }),\n/* 490 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConnectionStateHandler\": () => (/* binding */ ConnectionStateHandler)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(491);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/* harmony import */ var _connectionState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nconst JoinOpTimeoutMs = 45000;\n/**\n * In the lifetime of a container, the connection will likely disconnect and reconnect periodically.\n * This class ensures that any ops sent by this container instance on previous connection are either\n * sequenced or blocked by the server before emitting the new \"connected\" event and allowing runtime to resubmit ops.\n *\n * Each connection is assigned a clientId by the service, and the connection is book-ended by a Join and a Leave op\n * generated by the service. Due to the distributed nature of the ordering service, in the case of reconnect we cannot\n * make any assumptions about ordering of operations between the old and new connections - i.e. new Join op could\n * be sequenced before old Leave op (and some acks from pending ops that were in flight when we disconnected).\n *\n * The job of this class is to encapsulate the transition period during reconnect, which is identified by\n * ConnectionState.CatchingUp. Specifically, before moving to Connected state with the new clientId, it ensures that:\n * (A) We process the Leave op for the previous clientId. This allows us to properly handle any acks from in-flight ops\n *     that got sequenced with the old clientId (we'll recognize them as local ops). After the Leave op, any other\n *     pending ops can safely be submitted with the new clientId without fear of duplication in the sequenced op stream.\n * (B) We process the Join op for the new clientId (identified when the underlying connection was first established),\n *     indicating the service is ready to sequence ops sent with the new clientId.\n *\n * For (A) we give up waiting after some time (same timeout as server uses), and go ahead and transition to Connected.\n * For (B) we log telemetry if it takes too long, but still only transition to Connected when the Join op is processed\n * and we are added to the Quorum.\n */\nclass ConnectionStateHandler {\n    constructor(handler, logger, _clientId) {\n        var _a;\n        this.handler = handler;\n        this.logger = logger;\n        this._clientId = _clientId;\n        this._connectionState = _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Disconnected;\n        this.prevClientLeftTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Timer(\n        // Default is 5 min for which we are going to wait for its own \"leave\" message. This is same as\n        // the max time on server after which leave op is sent.\n        (_a = this.handler.maxClientLeaveWaitTime) !== null && _a !== void 0 ? _a : 300000, () => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.connected, 0x2ac /* \"Connected when timeout waiting for leave from previous session fired!\" */);\n            this.applyForConnectedState(\"timeout\");\n        });\n        // Based on recent data, it looks like majority of cases where we get stuck are due to really slow or\n        // timing out ops fetches. So attempt recovery infrequently. Also fetch uses 30 second timeout, so\n        // if retrying fixes the problem, we should not see these events.\n        this.joinOpTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Timer(JoinOpTimeoutMs, () => {\n            var _a;\n            // I've observed timer firing within couple ms from disconnect event, looks like\n            // queued timer callback is not cancelled if timer is cancelled while callback sits in the queue.\n            if (this.connectionState !== _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp) {\n                return;\n            }\n            const quorumClients = this.handler.quorumClients();\n            const details = {\n                quorumInitialized: quorumClients !== undefined,\n                hasPendingClientId: this.pendingClientId !== undefined,\n                inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_a = this.pendingClientId) !== null && _a !== void 0 ? _a : \"\")) !== undefined,\n                waitingForLeaveOp: this.waitingForLeaveOp,\n            };\n            this.handler.logConnectionIssue(\"NoJoinOp\", details);\n        });\n    }\n    get connectionState() {\n        return this._connectionState;\n    }\n    get connected() {\n        return this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected;\n    }\n    get clientId() {\n        return this._clientId;\n    }\n    get pendingClientId() {\n        return this._pendingClientId;\n    }\n    startJoinOpTimer() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.joinOpTimer.hasTimer, 0x234 /* \"has joinOpTimer\" */);\n        this.joinOpTimer.start();\n    }\n    stopJoinOpTimer() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.joinOpTimer.hasTimer, 0x235 /* \"no joinOpTimer\" */);\n        this.joinOpTimer.clear();\n    }\n    get waitingForLeaveOp() {\n        return this.prevClientLeftTimer.hasTimer;\n    }\n    dispose() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.joinOpTimer.hasTimer, 0x2a5 /* \"join timer\" */);\n        this.prevClientLeftTimer.clear();\n    }\n    containerSaved() {\n        // If we were waiting for moving to Connected state, then only apply for state change. Since the container\n        // is now saved and we don't have any ops to roundtrip, we can clear the timer and apply for connected state.\n        if (this.waitingForLeaveOp) {\n            this.prevClientLeftTimer.clear();\n            this.applyForConnectedState(\"containerSaved\");\n        }\n    }\n    receivedAddMemberEvent(clientId) {\n        // This is the only one that requires the pending client ID\n        if (clientId === this.pendingClientId) {\n            if (this.joinOpTimer.hasTimer) {\n                this.stopJoinOpTimer();\n            }\n            else {\n                // timer has already fired, meaning it took too long to get join on.\n                // Record how long it actually took to recover.\n                this.handler.logConnectionIssue(\"ReceivedJoinOp\");\n            }\n            // Start the event in case we are waiting for leave or timeout.\n            if (this.waitingForLeaveOp) {\n                this.waitEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.start(this.logger, {\n                    eventName: \"WaitBeforeClientLeave\",\n                    details: JSON.stringify({\n                        waitOnClientId: this._clientId,\n                        hadOutstandingOps: this.handler.shouldClientJoinWrite(),\n                    }),\n                });\n            }\n            this.applyForConnectedState(\"addMemberEvent\");\n        }\n    }\n    applyForConnectedState(source) {\n        var _a, _b;\n        const quorumClients = this.handler.quorumClients();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(quorumClients !== undefined, 0x236 /* \"In all cases it should be already installed\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.waitingForLeaveOp === false ||\n            (this.clientId !== undefined && quorumClients.getMember(this.clientId) !== undefined), 0x2e2 /* \"Must only wait for leave message when clientId in quorum\" */);\n        // Move to connected state only if we are in Connecting state, we have seen our join op\n        // and there is no timer running which means we are not waiting for previous client to leave\n        // or timeout has occurred while doing so.\n        if (this.pendingClientId !== this.clientId\n            && this.pendingClientId !== undefined\n            && quorumClients.getMember(this.pendingClientId) !== undefined\n            && !this.waitingForLeaveOp) {\n            (_a = this.waitEvent) === null || _a === void 0 ? void 0 : _a.end({ source });\n            this.setConnectionState(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected);\n        }\n        else {\n            // Adding this event temporarily so that we can get help debugging if something goes wrong.\n            this.logger.sendTelemetryEvent({\n                eventName: \"connectedStateRejected\",\n                category: source === \"timeout\" ? \"error\" : \"generic\",\n                details: JSON.stringify({\n                    source,\n                    pendingClientId: this.pendingClientId,\n                    clientId: this.clientId,\n                    waitingForLeaveOp: this.waitingForLeaveOp,\n                    inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_b = this.pendingClientId) !== null && _b !== void 0 ? _b : \"\")) !== undefined,\n                }),\n            });\n        }\n    }\n    receivedRemoveMemberEvent(clientId) {\n        // If the client which has left was us, then finish the timer.\n        if (this.clientId === clientId) {\n            this.prevClientLeftTimer.clear();\n            this.applyForConnectedState(\"removeMemberEvent\");\n        }\n    }\n    receivedDisconnectEvent(reason) {\n        if (this.joinOpTimer.hasTimer) {\n            this.stopJoinOpTimer();\n        }\n        this.setConnectionState(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Disconnected, reason);\n    }\n    /**\n     * The \"connect\" event indicates the connection to the Relay Service is live.\n     * However, some additional conditions must be met before we can fully transition to\n     * \"Connected\" state. This function handles that interim period, known as \"Connecting\" state.\n     * @param connectionMode - Read or Write connection\n     * @param details - Connection details returned from the ordering service\n     */\n    receivedConnectEvent(connectionMode, details) {\n        const oldState = this._connectionState;\n        this._connectionState = _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp;\n        const writeConnection = connectionMode === \"write\";\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(writeConnection || !this.handler.shouldClientJoinWrite(), 0x30a /* shouldClientJoinWrite should imply this is a writeConnection */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(writeConnection || !this.waitingForLeaveOp, 0x2a6 /* \"waitingForLeaveOp should imply writeConnection (we need to be ready to flush pending ops)\" */);\n        // Note that this may be undefined since the connection is established proactively on load\n        // and the quorum may still be under initialization.\n        const quorumClients = this.handler.quorumClients();\n        // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected\n        // (have received the join message for the client ID)\n        // This is especially important in the reconnect case. It's possible there could be outstanding\n        // ops sent by this client, so we should keep the old client id until we see our own client's\n        // join message. after we see the join message for our new connection with our new client id,\n        // we know there can no longer be outstanding ops that we sent with the previous client id.\n        this._pendingClientId = details.clientId;\n        // IMPORTANT: Report telemetry after we set _pendingClientId, but before transitioning to Connected state\n        this.handler.logConnectionStateChangeTelemetry(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp, oldState);\n        // For write connections, this pending clientId could be in the quorum already (i.e. join op already processed).\n        // We are fetching ops from storage in parallel to connecting to Relay Service,\n        // and given async processes, it's possible that we have already processed our own join message before\n        // connection was fully established.\n        // If quorumClients itself is undefined, we expect it will process the join op after it's initialized.\n        const waitingForJoinOp = writeConnection && (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._pendingClientId)) === undefined;\n        if (waitingForJoinOp) {\n            // Previous client left, and we are waiting for our own join op. When it is processed we'll join the quorum\n            // and attempt to transition to Connected state via receivedAddMemberEvent.\n            this.startJoinOpTimer();\n        }\n        else if (!this.waitingForLeaveOp) {\n            // We're not waiting for Join or Leave op (if read-only connection those don't even apply),\n            // go ahead and declare the state to be Connected!\n            // If we are waiting for Leave op still, do nothing for now, we will transition to Connected later.\n            this.setConnectionState(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected);\n        }\n    }\n    setConnectionState(value, reason) {\n        if (this.connectionState === value) {\n            // Already in the desired state - exit early\n            this.logger.sendErrorEvent({ eventName: \"setConnectionStateSame\", value });\n            return;\n        }\n        const oldState = this._connectionState;\n        this._connectionState = value;\n        const quorumClients = this.handler.quorumClients();\n        let client;\n        if (this._clientId !== undefined) {\n            client = quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._clientId);\n        }\n        if (value === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(oldState === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp, 0x1d8 /* \"Should only transition from Connecting state\" */);\n            // Mark our old client should have left in the quorum if it's still there\n            if (client !== undefined) {\n                client.shouldHaveLeft = true;\n            }\n            this._clientId = this.pendingClientId;\n        }\n        else if (value === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Disconnected) {\n            // Important as we process our own joinSession message through delta request\n            this._pendingClientId = undefined;\n            // Only wait for \"leave\" message if the connected client exists in the quorum because only the write\n            // client will exist in the quorum and only for those clients we will receive \"removeMember\" event and\n            // the client has some unacked ops.\n            // Also server would not accept ops from read client. Also check if the timer is not already running as\n            // we could receive \"Disconnected\" event multiple times without getting connected and in that case we\n            // don't want to reset the timer as we still want to wait on original client which started this timer.\n            if (client !== undefined\n                && this.handler.shouldClientJoinWrite()\n                && this.prevClientLeftTimer.hasTimer === false) {\n                this.prevClientLeftTimer.restart();\n            }\n            else {\n                // Adding this event temporarily so that we can get help debugging if something goes wrong.\n                this.logger.sendTelemetryEvent({\n                    eventName: \"noWaitOnDisconnected\",\n                    details: JSON.stringify({\n                        inQuorum: client !== undefined,\n                        waitingForLeaveOp: this.waitingForLeaveOp,\n                        hadOutstandingOps: this.handler.shouldClientJoinWrite(),\n                    }),\n                });\n            }\n        }\n        // Report transition before we propagate event across layers\n        this.handler.logConnectionStateChangeTelemetry(this._connectionState, oldState, reason);\n        // Propagate event across layers\n        this.handler.connectionStateChanged();\n    }\n    initProtocol(protocol) {\n        protocol.quorum.on(\"addMember\", (clientId, _details) => {\n            this.receivedAddMemberEvent(clientId);\n        });\n        protocol.quorum.on(\"removeMember\", (clientId) => {\n            this.receivedRemoveMemberEvent(clientId);\n        });\n        // if we have a clientId from a previous container we need to wait for its leave message\n        if (this.clientId !== undefined && protocol.quorum.getMember(this.clientId) !== undefined) {\n            this.prevClientLeftTimer.restart();\n        }\n    }\n}\n//# sourceMappingURL=connectionStateHandler.js.map\n\n/***/ }),\n/* 491 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PromiseTimer\": () => (/* binding */ PromiseTimer),\n/* harmony export */   \"Timer\": () => (/* binding */ Timer)\n/* harmony export */ });\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(487);\n/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(492);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * This class is a thin wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the same\n * or similar handlers and timeouts.\n */\nclass Timer {\n    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {\n        this.defaultTimeout = defaultTimeout;\n        this.defaultHandler = defaultHandler;\n        this.getCurrentTick = getCurrentTick;\n    }\n    /**\n     * Returns true if the timer is running.\n     */\n    get hasTimer() {\n        return !!this.runningState;\n    }\n    /**\n     * Calls setTimeout and tracks the resulting timeout.\n     * @param ms - overrides default timeout in ms\n     * @param handler - overrides default handler\n     */\n    start(ms = this.defaultTimeout, handler = this.defaultHandler) {\n        this.startCore(ms, handler, ms);\n    }\n    /**\n     * Calls clearTimeout on the underlying timeout if running.\n     */\n    clear() {\n        if (!this.runningState) {\n            return;\n        }\n        clearTimeout(this.runningState.timeout);\n        this.runningState = undefined;\n    }\n    /**\n     * Restarts the timer with the new handler and duration.\n     * If a new handler is passed, the original handler may\n     * never execute.\n     * This is a potentially more efficient way to clear and start\n     * a new timer.\n     * @param ms - overrides previous or default timeout in ms\n     * @param handler - overrides previous or default handler\n     */\n    restart(ms, handler) {\n        var _a, _b;\n        if (!this.runningState) {\n            // If restart is called first, it behaves as a call to start\n            this.start(ms, handler);\n        }\n        else {\n            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;\n            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;\n            const remainingTime = this.calculateRemainingTime(this.runningState);\n            if (duration < remainingTime) {\n                // If remaining time exceeds restart duration, do a hard restart.\n                // The existing timeout time is too long.\n                this.start(duration, handlerToUse);\n            }\n            else if (duration === remainingTime) {\n                // The existing timeout time is perfect, just update handler and data.\n                this.runningState.handler = handlerToUse;\n                this.runningState.restart = undefined;\n                this.runningState.intendedDuration = duration;\n            }\n            else {\n                // If restart duration exceeds remaining time, set restart info.\n                // Existing timeout will start a new timeout for remaining time.\n                this.runningState.restart = {\n                    startTick: this.getCurrentTick(),\n                    duration,\n                    handler: handlerToUse,\n                };\n            }\n        }\n    }\n    startCore(duration, handler, intendedDuration) {\n        this.clear();\n        this.runningState = {\n            startTick: this.getCurrentTick(),\n            duration,\n            intendedDuration,\n            handler,\n            timeout: setTimeout(() => this.handler(), duration),\n        };\n    }\n    handler() {\n        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.runningState, 0x00a /* \"Running timer missing handler\" */);\n        const restart = this.runningState.restart;\n        if (restart !== undefined) {\n            // Restart with remaining time\n            const remainingTime = this.calculateRemainingTime(restart);\n            this.startCore(remainingTime, () => restart.handler(), restart.duration);\n        }\n        else {\n            // Run clear first, in case the handler decides to start again\n            const handler = this.runningState.handler;\n            this.clear();\n            handler();\n        }\n    }\n    calculateRemainingTime(runningTimeout) {\n        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;\n        return runningTimeout.duration - elapsedTime;\n    }\n}\n/**\n * This class is a wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the\n * same handlers and timeouts, while also providing a promise that\n * resolves when it times out.\n */\nclass PromiseTimer {\n    constructor(defaultTimeout, defaultHandler) {\n        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));\n    }\n    get hasTimer() {\n        return this.timer.hasTimer;\n    }\n    async start(ms, handler) {\n        this.clear();\n        this.deferred = new _promises__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);\n        return this.deferred.promise;\n    }\n    clear() {\n        this.timer.clear();\n        if (this.deferred) {\n            this.deferred.resolve({ timerResult: \"cancel\" });\n            this.deferred = undefined;\n        }\n    }\n    wrapHandler(handler) {\n        handler();\n        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.deferred, 0x00b /* \"Handler executed without deferred\" */);\n        this.deferred.resolve({ timerResult: \"timeout\" });\n        this.deferred = undefined;\n    }\n}\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n/* 492 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"LazyPromise\": () => (/* binding */ LazyPromise)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nclass Deferred {\n    constructor() {\n        this.completed = false;\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Returns whether the underlying promise has been completed\n     */\n    get isCompleted() {\n        return this.completed;\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     *\n     * @returns the underlying promise\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     *\n     * @param value - the value to resolve the promise with\n     */\n    resolve(value) {\n        if (this.res !== undefined) {\n            this.completed = true;\n            this.res(value);\n        }\n    }\n    /**\n     * Rejects the promise\n     *\n     * @param value - the value to reject the promise with\n     */\n    reject(error) {\n        if (this.rej !== undefined) {\n            this.completed = true;\n            this.rej(error);\n        }\n    }\n}\n/**\n * A lazy evaluated promise. The execute function is delayed until\n * the promise is used, e.g. await, then, catch ...\n * The execute function is only called once.\n * All calls are then proxied to the promise returned by the execute method.\n */\nclass LazyPromise {\n    constructor(execute) {\n        this.execute = execute;\n    }\n    get [Symbol.toStringTag]() {\n        return this.getPromise()[Symbol.toStringTag];\n    }\n    async then(onfulfilled, onrejected) {\n        return this.getPromise().then(...arguments);\n    }\n    async catch(onrejected) {\n        return this.getPromise().catch(...arguments);\n    }\n    async finally(onfinally) {\n        return this.getPromise().finally(...arguments);\n    }\n    async getPromise() {\n        if (this.result === undefined) {\n            this.result = this.execute();\n        }\n        return this.result;\n    }\n}\n//# sourceMappingURL=promises.js.map\n\n/***/ }),\n/* 493 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlobOnlyStorage\": () => (/* binding */ BlobOnlyStorage),\n/* harmony export */   \"ContainerStorageAdapter\": () => (/* binding */ ContainerStorageAdapter)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class wraps the actual storage and make sure no wrong apis are called according to\n * container attach state.\n */\nclass ContainerStorageAdapter {\n    constructor(storageGetter) {\n        this.storageGetter = storageGetter;\n        this.blobContents = {};\n    }\n    loadSnapshotForRehydratingContainer(snapshotTree) {\n        this.getBlobContents(snapshotTree);\n    }\n    getBlobContents(snapshotTree) {\n        for (const [id, value] of Object.entries(snapshotTree.blobsContents)) {\n            this.blobContents[id] = value;\n        }\n        for (const [_, tree] of Object.entries(snapshotTree.trees)) {\n            this.getBlobContents(tree);\n        }\n    }\n    get policies() {\n        // back-compat 0.40 containerRuntime requests policies even in detached container if storage is present\n        // and storage is always present in >=0.41.\n        try {\n            return this.storageGetter().policies;\n        }\n        catch (e) { }\n        return undefined;\n    }\n    get repositoryUrl() {\n        return this.storageGetter().repositoryUrl;\n    }\n    async getSnapshotTree(version, scenarioName) {\n        return this.storageGetter().getSnapshotTree(version, scenarioName);\n    }\n    async readBlob(id) {\n        const blob = this.blobContents[id];\n        if (blob !== undefined) {\n            return blob;\n        }\n        return this.storageGetter().readBlob(id);\n    }\n    async getVersions(versionId, count, scenarioName) {\n        return this.storageGetter().getVersions(versionId, count, scenarioName);\n    }\n    async uploadSummaryWithContext(summary, context) {\n        return this.storageGetter().uploadSummaryWithContext(summary, context);\n    }\n    async downloadSummary(handle) {\n        return this.storageGetter().downloadSummary(handle);\n    }\n    async createBlob(file) {\n        return this.storageGetter().createBlob(file);\n    }\n}\n/**\n * Storage which only supports createBlob() and readBlob(). This is used with IDetachedBlobStorage to support\n * blobs in detached containers.\n */\nclass BlobOnlyStorage {\n    constructor(blobStorage, logger) {\n        this.blobStorage = blobStorage;\n        this.logger = logger;\n        /* eslint-disable @typescript-eslint/unbound-method */\n        this.getSnapshotTree = this.notCalled;\n        this.getVersions = this.notCalled;\n        this.write = this.notCalled;\n        this.uploadSummaryWithContext = this.notCalled;\n        this.downloadSummary = this.notCalled;\n    }\n    async createBlob(content) {\n        return this.blobStorage.createBlob(content);\n    }\n    async readBlob(blobId) {\n        return this.blobStorage.readBlob(blobId);\n    }\n    get policies() {\n        return this.notCalled();\n    }\n    get repositoryUrl() {\n        return this.notCalled();\n    }\n    /* eslint-enable @typescript-eslint/unbound-method */\n    notCalled() {\n        try {\n            // some browsers may not populate stack unless exception is thrown\n            throw new Error(\"BlobOnlyStorage not implemented method used\");\n        }\n        catch (err) {\n            this.logger.sendErrorEvent({ eventName: \"BlobOnlyStorageWrongCall\" }, err);\n            throw err;\n        }\n    }\n}\n//# sourceMappingURL=containerStorageAdapter.js.map\n\n/***/ }),\n/* 494 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SummaryType\": () => (/* binding */ SummaryType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar SummaryType;\n(function (SummaryType) {\n    /**\n     *  Represents a sub-tree in the summary.\n     */\n    SummaryType.Tree = 1;\n    /**\n     * Represents a blob of data that is added to the summary.\n     * Such as the user data that is added to the DDS or metadata added by runtime\n     * such as data store / channel attributes.\n     */\n    SummaryType.Blob = 2;\n    /**\n     * Path to a summary tree object from the last successful summary.\n     */\n    SummaryType.Handle = 3;\n    /**\n     * Unique identifier to larger blobs uploaded outside of the summary.\n     * Ex. DDS has large images or video that will be uploaded by the BlobManager and\n     * receive an Id that can be used in the summary.\n     */\n    SummaryType.Attachment = 4;\n})(SummaryType || (SummaryType = {}));\n//# sourceMappingURL=summary.js.map\n\n/***/ }),\n/* 495 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertProtocolAndAppSummaryToSnapshotTree\": () => (/* binding */ convertProtocolAndAppSummaryToSnapshotTree),\n/* harmony export */   \"getProtocolSnapshotTree\": () => (/* binding */ getProtocolSnapshotTree),\n/* harmony export */   \"getSnapshotTreeFromSerializedContainer\": () => (/* binding */ getSnapshotTreeFromSerializedContainer),\n/* harmony export */   \"parseUrl\": () => (/* binding */ parseUrl)\n/* harmony export */ });\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(496);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(519);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(520);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(521);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(494);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\nfunction parseUrl(url) {\n    var _a;\n    const parsed = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(url, true);\n    if (typeof parsed.pathname !== \"string\") {\n        throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError(\"Failed to parse pathname\");\n    }\n    const query = (_a = parsed.search) !== null && _a !== void 0 ? _a : \"\";\n    const regex = /^\\/([^/]*\\/[^/]*)(\\/?.*)$/;\n    const match = regex.exec(parsed.pathname);\n    return ((match === null || match === void 0 ? void 0 : match.length) === 3)\n        ? { id: match[1], path: match[2], query, version: parsed.query.version }\n        : undefined;\n}\n/**\n * Converts summary tree (for upload) to snapshot tree (for download).\n * Summary tree blobs contain contents, but snapshot tree blobs normally\n * contain IDs pointing to storage. This will create 2 blob entries in the\n * snapshot tree for each blob in the summary tree. One will be the regular\n * path pointing to a uniquely generated ID. Then there will be another\n * entry with the path as that uniquely generated ID, and value as the\n * blob contents as a base-64 string.\n * @param summary - summary to convert\n */\nfunction convertSummaryToSnapshotWithEmbeddedBlobContents(summary) {\n    const treeNode = {\n        blobs: {},\n        blobsContents: {},\n        trees: {},\n        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),\n        unreferenced: summary.unreferenced,\n    };\n    const keys = Object.keys(summary.tree);\n    for (const key of keys) {\n        const summaryObject = summary.tree[key];\n        switch (summaryObject.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Tree: {\n                treeNode.trees[key] = convertSummaryToSnapshotWithEmbeddedBlobContents(summaryObject);\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Attachment:\n                treeNode.blobs[key] = summaryObject.id;\n                break;\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Blob: {\n                const blobId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n                treeNode.blobs[key] = blobId;\n                const contentBuffer = typeof summaryObject.content === \"string\" ?\n                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.stringToBuffer)(summaryObject.content, \"utf8\") : (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.Uint8ArrayToArrayBuffer)(summaryObject.content);\n                treeNode.blobsContents[blobId] = contentBuffer;\n                break;\n            }\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Handle:\n                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError(\"No handles should be there in summary in detached container!!\");\n                break;\n            default: {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.unreachableCase)(summaryObject, `Unknown tree type ${summaryObject.type}`);\n            }\n        }\n    }\n    return treeNode;\n}\n/**\n * Combine and convert protocol and app summary tree to format which is readable by container while rehydrating.\n * @param protocolSummaryTree - Protocol Summary Tree\n * @param appSummaryTree - App Summary Tree\n */\nfunction convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree) {\n    // Shallow copy is fine, since we are doing a deep clone below.\n    const combinedSummary = {\n        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Tree,\n        tree: Object.assign({}, appSummaryTree.tree),\n    };\n    combinedSummary.tree[\".protocol\"] = protocolSummaryTree;\n    const snapshotTreeWithBlobContents = convertSummaryToSnapshotWithEmbeddedBlobContents(combinedSummary);\n    return snapshotTreeWithBlobContents;\n}\n// This function converts the snapshot taken in detached container(by serialize api) to snapshotTree with which\n// a detached container can be rehydrated.\nconst getSnapshotTreeFromSerializedContainer = (detachedContainerSnapshot) => {\n    const protocolSummaryTree = detachedContainerSnapshot.tree[\".protocol\"];\n    const appSummaryTree = detachedContainerSnapshot.tree[\".app\"];\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(protocolSummaryTree !== undefined && appSummaryTree !== undefined, 0x1e0 /* \"Protocol and App summary trees should be present\" */);\n    const snapshotTreeWithBlobContents = convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree);\n    return snapshotTreeWithBlobContents;\n};\nfunction getProtocolSnapshotTree(snapshot) {\n    return \".protocol\" in snapshot.trees ? snapshot.trees[\".protocol\"] : snapshot;\n}\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 496 */\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\n\"use strict\";\n/*\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\nvar punycode = __webpack_require__(497);\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n/*\n * define these here so at least they only have to be\n * compiled once on the first module load.\n */\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/,\n\n  /*\n   * RFC 2396: characters reserved for delimiting URLs.\n   * We actually just auto-escape these.\n   */\n  delims = [\n    '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'\n  ],\n\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = [\n    '{', '}', '|', '\\\\', '^', '`'\n  ].concat(delims),\n\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  /*\n   * Characters that are never ever allowed in a hostname.\n   * Note that any invalid chars are also handled, but these\n   * are the ones that are *expected* to be seen, so we fast-path\n   * them.\n   */\n  nonHostChars = [\n    '%', '/', '?', ';', '#'\n  ].concat(autoEscape),\n  hostEndingChars = [\n    '/', '?', '#'\n  ],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    http: true,\n    https: true,\n    ftp: true,\n    gopher: true,\n    file: true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = __webpack_require__(498);\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === 'object' && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  /*\n   * Copy chrome, IE, opera backslash-handling behavior.\n   * Back slashes before the query string get converted to forward slashes\n   * See: https://code.google.com/p/chromium/issues/detail?id=25916\n   */\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  /*\n   * trim before proceeding.\n   * This is to support parse stuff like \"  http://foo.com  \\n\"\n   */\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  /*\n   * figure out if it's got a host\n   * user@server is *always* interpreted as a hostname, and url\n   * resolution will treat //foo/bar as host=foo,path=bar because that's\n   * how the browser resolves relative URLs.\n   */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {\n\n    /*\n     * there's a hostname.\n     * the first instance of /, ?, ;, or # ends the host.\n     *\n     * If there is an @ in the hostname, then non-host chars *are* allowed\n     * to the left of the last @ sign, unless some host-ending character\n     * comes *before* the @-sign.\n     * URLs are obnoxious.\n     *\n     * ex:\n     * http://a@b@c/ => user:a@b host:c\n     * http://a@b?@c => user:a host:c path:/?@c\n     */\n\n    /*\n     * v0.12 TODO(isaacs): This is not quite how Chrome does things.\n     * Review our test case against browsers more comprehensively.\n     */\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n\n    /*\n     * at this point, either we have an explicit point where the\n     * auth portion cannot go past, or the last @ char is the decider.\n     */\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      /*\n       * atSign must be in auth portion.\n       * http://a@b/c@d => host:b auth:a path:/c@d\n       */\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    /*\n     * Now we have a portion which is definitely the auth.\n     * Pull that off.\n     */\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) { hostEnd = rest.length; }\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    /*\n     * we've indicated that there is a hostname,\n     * so even if it's empty, it has to be present.\n     */\n    this.hostname = this.hostname || '';\n\n    /*\n     * if hostname begins with [ and ends with ]\n     * assume that it's an IPv6 address.\n     */\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              /*\n               * we replace non-ASCII char with a temporary placeholder\n               * we need this to make sure size of hostname is not\n               * broken by replacing non-ASCII by nothing\n               */\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      /*\n       * IDNA Support: Returns a punycoded representation of \"domain\".\n       * It only converts parts of the domain name that\n       * have non-ASCII characters, i.e. it doesn't matter if\n       * you call it with a domain that already is ASCII-only.\n       */\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    /*\n     * strip [ and ] from the hostname\n     * the host field still retains them, though\n     */\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  /*\n   * now rest is set to the post-host stuff.\n   * chop off any delim chars.\n   */\n  if (!unsafeProtocol[lowerProto]) {\n\n    /*\n     * First, make 100% sure that any \"autoEscape\" chars get\n     * escaped, even if encodeURIComponent doesn't think they\n     * need to be.\n     */\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) { continue; }\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  /*\n   * ensure it's an object, and not a string url.\n   * If it's an obj, this is a no-op.\n   * this way, you can call url_format() on strings\n   * to clean up potentially wonky urls.\n   */\n  if (typeof obj === 'string') { obj = urlParse(obj); }\n  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query, {\n      arrayFormat: 'repeat',\n      addQueryPrefix: false\n    });\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n  /*\n   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n   * unless they had them to begin with.\n   */\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n  if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) { return relative; }\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  /*\n   * hash is always overridden, no matter what.\n   * even href=\"\" will remove it.\n   */\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.pathname = '/';\n      result.path = result.pathname;\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    /*\n     * if it's a known url protocol, then changing\n     * the protocol does weird things\n     * first, if it's not file:, then we MUST have a host,\n     * and if there was a path\n     * to begin with, then we MUST have a path.\n     * if it is file:, then the host is dropped,\n     * because that's known to be hostless.\n     * anything else is assumed to be absolute.\n     */\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift())) { }\n      if (!relative.host) { relative.host = ''; }\n      if (!relative.hostname) { relative.hostname = ''; }\n      if (relPath[0] !== '') { relPath.unshift(''); }\n      if (relPath.length < 2) { relPath.unshift(''); }\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  /*\n   * if the url is a non-slashed url, then relative\n   * links like ../.. should be able\n   * to crawl up to the hostname, as well.  This is strange.\n   * result.protocol has already been set by now.\n   * Later on, put the first path part into the host field.\n   */\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    /*\n     * it's relative\n     * throw away the existing file, and take the new path instead.\n     */\n    if (!srcPath) { srcPath = []; }\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search != null) {\n    /*\n     * just pull out the search.\n     * like href='?foo'.\n     * Put this after the other two cases because it simplifies the booleans\n     */\n    if (psychotic) {\n      result.host = srcPath.shift();\n      result.hostname = result.host;\n      /*\n       * occationaly the auth can get stuck only in host\n       * this especially happens in cases like\n       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n       */\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.hostname = authInHost.shift();\n        result.host = result.hostname;\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    /*\n     * no path at all.  easy.\n     * we've already handled the other stuff above.\n     */\n    result.pathname = null;\n    // to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  /*\n   * if a url ENDs in . or .., then it must get a trailing slash.\n   * however, if it ends in anything else non-slashy,\n   * then it must NOT get a trailing slash.\n   */\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  /*\n   * strip single dots, resolve double dots to parent dir\n   * if the path tries to go above the root, `up` ends up > 0\n   */\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    result.host = result.hostname;\n    /*\n     * occationaly the auth can get stuck only in host\n     * this especially happens in cases like\n     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n     */\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.hostname = authInHost.shift();\n      result.host = result.hostname;\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (srcPath.length > 0) {\n    result.pathname = srcPath.join('/');\n  } else {\n    result.pathname = null;\n    result.path = null;\n  }\n\n  // to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\n\n/***/ }),\n/* 497 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n\n/***/ }),\n/* 498 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar stringify = __webpack_require__(499);\nvar parse = __webpack_require__(518);\nvar formats = __webpack_require__(517);\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n\n\n/***/ }),\n/* 499 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar getSideChannel = __webpack_require__(500);\nvar utils = __webpack_require__(516);\nvar formats = __webpack_require__(517);\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar sentinel = {};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    commaRoundTrip,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    format,\n    formatter,\n    encodeValuesOnly,\n    charset,\n    sideChannel\n) {\n    var obj = object;\n\n    var tmpSc = sideChannel;\n    var step = 0;\n    var findFlag = false;\n    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n        // Where object last appeared in the ref tree\n        var pos = tmpSc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            } else {\n                findFlag = true; // Break while\n            }\n        }\n        if (typeof tmpSc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = utils.maybeMap(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            return value;\n        });\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            obj = utils.maybeMap(obj, encoder);\n        }\n        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    } else if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;\n\n    for (var j = 0; j < objKeys.length; ++j) {\n        var key = objKeys[j];\n        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n\n        if (skipNulls && value === null) {\n            continue;\n        }\n\n        var keyPrefix = isArray(obj)\n            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix\n            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');\n\n        sideChannel.set(object, step);\n        var valueSideChannel = getSideChannel();\n        valueSideChannel.set(sentinel, sideChannel);\n        pushToArray(values, stringify(\n            value,\n            keyPrefix,\n            generateArrayPrefix,\n            commaRoundTrip,\n            strictNullHandling,\n            skipNulls,\n            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            format,\n            formatter,\n            encodeValuesOnly,\n            charset,\n            valueSideChannel\n        ));\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    var sideChannel = getSideChannel();\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            commaRoundTrip,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.format,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset,\n            sideChannel\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n\n\n/***/ }),\n/* 500 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar GetIntrinsic = __webpack_require__(501);\nvar callBound = __webpack_require__(508);\nvar inspect = __webpack_require__(514);\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\n\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n\n/*\n * This function traverses the list returning the node corresponding to the\n * given key.\n *\n * That node is also moved to the head of the list, so that if it's accessed\n * again we don't need to traverse the whole list. By doing so, all the recently\n * used nodes can be accessed relatively quickly.\n */\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tcurr.next = list.next;\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\nvar listGet = function (objects, key) {\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t};\n\t}\n};\nvar listHas = function (objects, key) {\n\treturn !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n\tvar $wm;\n\tvar $m;\n\tvar $o;\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapGet($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listGet($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapHas($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listHas($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif (!$wm) {\n\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t}\n\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t} else if ($Map) {\n\t\t\t\tif (!$m) {\n\t\t\t\t\t$m = new $Map();\n\t\t\t\t}\n\t\t\t\t$mapSet($m, key, value);\n\t\t\t} else {\n\t\t\t\tif (!$o) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\n\t\t\t\t\t */\n\t\t\t\t\t$o = { key: {}, next: null };\n\t\t\t\t}\n\t\t\t\tlistSet($o, key, value);\n\t\t\t}\n\t\t}\n\t};\n\treturn channel;\n};\n\n\n/***/ }),\n/* 501 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(502)();\nvar hasProto = __webpack_require__(504)();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(505);\nvar hasOwn = __webpack_require__(507);\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n/***/ }),\n/* 502 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(503);\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n/***/ }),\n/* 503 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n/***/ }),\n/* 504 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nvar test = {\n\tfoo: {}\n};\n\nvar $Object = Object;\n\nmodule.exports = function hasProto() {\n\treturn { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);\n};\n\n\n/***/ }),\n/* 505 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar implementation = __webpack_require__(506);\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n/***/ }),\n/* 506 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n/***/ }),\n/* 507 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = __webpack_require__(505);\n\n/** @type {(o: {}, p: PropertyKey) => p is keyof o} */\nmodule.exports = bind.call(call, $hasOwn);\n\n\n/***/ }),\n/* 508 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar GetIntrinsic = __webpack_require__(501);\n\nvar callBind = __webpack_require__(509);\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n\n/***/ }),\n/* 509 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar bind = __webpack_require__(505);\nvar GetIntrinsic = __webpack_require__(501);\nvar setFunctionLength = __webpack_require__(510);\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tif (typeof originalFunction !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\tvar func = $reflectApply(bind, $call, arguments);\n\treturn setFunctionLength(\n\t\tfunc,\n\t\t1 + $max(0, originalFunction.length - (arguments.length - 1)),\n\t\ttrue\n\t);\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n\n/***/ }),\n/* 510 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar GetIntrinsic = __webpack_require__(501);\nvar define = __webpack_require__(511);\nvar hasDescriptors = __webpack_require__(512)();\nvar gOPD = __webpack_require__(513);\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $floor = GetIntrinsic('%Math.floor%');\n\nmodule.exports = function setFunctionLength(fn, length) {\n\tif (typeof fn !== 'function') {\n\t\tthrow new $TypeError('`fn` is not a function');\n\t}\n\tif (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {\n\t\tthrow new $TypeError('`length` must be a positive 32-bit integer');\n\t}\n\n\tvar loose = arguments.length > 2 && !!arguments[2];\n\n\tvar functionLengthIsConfigurable = true;\n\tvar functionLengthIsWritable = true;\n\tif ('length' in fn && gOPD) {\n\t\tvar desc = gOPD(fn, 'length');\n\t\tif (desc && !desc.configurable) {\n\t\t\tfunctionLengthIsConfigurable = false;\n\t\t}\n\t\tif (desc && !desc.writable) {\n\t\t\tfunctionLengthIsWritable = false;\n\t\t}\n\t}\n\n\tif (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n\t\tif (hasDescriptors) {\n\t\t\tdefine(fn, 'length', length, true, true);\n\t\t} else {\n\t\t\tdefine(fn, 'length', length);\n\t\t}\n\t}\n\treturn fn;\n};\n\n\n/***/ }),\n/* 511 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar hasPropertyDescriptors = __webpack_require__(512)();\n\nvar GetIntrinsic = __webpack_require__(501);\n\nvar $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar gopd = __webpack_require__(513);\n\n/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n\n\n/***/ }),\n/* 512 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar GetIntrinsic = __webpack_require__(501);\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\tif ($defineProperty) {\n\t\ttry {\n\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// IE 8 has a broken defineProperty\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!hasPropertyDescriptors()) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n\n\n/***/ }),\n/* 513 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar GetIntrinsic = __webpack_require__(501);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n/***/ }),\n/* 514 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = __webpack_require__(515);\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        if (mapForEach) {\n            mapForEach.call(obj, function (value, key) {\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n            });\n        }\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        if (setForEach) {\n            setForEach.call(obj, function (value) {\n                setParts.push(inspect(value, obj));\n            });\n        }\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other\n    /* eslint-env browser */\n    if (typeof window !== 'undefined' && obj === window) {\n        return '{ [object Window] }';\n    }\n    if (obj === __webpack_require__.g) {\n        return '{ [object globalThis] }';\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '\"' : \"'\";\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, /(['\\\\])/g, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n\n\n/***/ }),\n/* 515 */\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n/* 516 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar formats = __webpack_require__(517);\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    /* eslint no-param-reassign: 0 */\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset, kind, format) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        /* eslint operator-linebreak: [2, \"before\"] */\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nvar maybeMap = function maybeMap(val, fn) {\n    if (isArray(val)) {\n        var mapped = [];\n        for (var i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    maybeMap: maybeMap,\n    merge: merge\n};\n\n\n/***/ }),\n/* 517 */\n/***/ ((module) => {\n\n\"use strict\";\n\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = {\n    'default': Format.RFC3986,\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return String(value);\n        }\n    },\n    RFC1738: Format.RFC1738,\n    RFC3986: Format.RFC3986\n};\n\n\n/***/ }),\n/* 518 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(516);\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    allowSparse: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\nvar parseArrayValue = function (val, options) {\n    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n        return val.split(',');\n    }\n\n    return val;\n};\n\n// This is what browsers will submit when the  character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the  character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = { __proto__: null };\n\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n            val = utils.maybeMap(\n                parseArrayValue(part.slice(pos + 1), options),\n                function (encodedVal) {\n                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');\n                }\n            );\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (part.indexOf('[]=') > -1) {\n            val = isArray(val) ? [val] : val;\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options, valuesParsed) {\n    var leaf = valuesParsed ? val : parseArrayValue(val, options);\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else if (cleanRoot !== '__proto__') {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = options.depth > 0 && brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options, valuesParsed);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    if (options.allowSparse === true) {\n        return obj;\n    }\n\n    return utils.compact(obj);\n};\n\n\n/***/ }),\n/* 519 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsoBuffer\": () => (/* binding */ IsoBuffer),\n/* harmony export */   \"Uint8ArrayToString\": () => (/* binding */ Uint8ArrayToString),\n/* harmony export */   \"bufferToString\": () => (/* binding */ bufferToString),\n/* harmony export */   \"isArrayBuffer\": () => (/* binding */ isArrayBuffer),\n/* harmony export */   \"stringToBuffer\": () => (/* binding */ stringToBuffer)\n/* harmony export */ });\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);\n/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(487);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\nfunction Uint8ArrayToString(arr, encoding) {\n    switch (encoding) {\n        case \"base64\": {\n            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);\n        }\n        case \"utf8\":\n        case \"utf-8\":\n        case undefined: {\n            return new TextDecoder().decode(arr);\n        }\n        default: {\n            throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\nconst stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\nconst bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\nfunction isArrayBuffer(obj) {\n    const maybe = obj;\n    return obj instanceof ArrayBuffer\n        || (typeof maybe === \"object\"\n            && maybe !== null\n            && typeof maybe.byteLength === \"number\"\n            && typeof maybe.slice === \"function\"\n            && maybe.byteOffset === undefined\n            && maybe.buffer === undefined);\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\nclass IsoBuffer extends Uint8Array {\n    /**\n     * Convert the buffer to a string.\n     * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n     * and only utf8 and base64 encodings\n     * @param encoding\n     */\n    toString(encoding) {\n        return Uint8ArrayToString(this, encoding);\n    }\n    /**\n     * @param value - string | ArrayBuffer\n     * @param encodingOrOffset - string | number\n     * @param length - number\n     */\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n            return IsoBuffer.fromString(value, encodingOrOffset);\n            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n        }\n        else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n            // Support currently for full array, no view ports! (though it can be added in future)\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* \"nonzero isobuffer byte offset\" */);\n            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* \"unexpected isobuffer byte length\" */);\n            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n        }\n        else if (isArrayBuffer(value)) {\n            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        else {\n            throw new TypeError();\n        }\n    }\n    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n        if (offset < 0 ||\n            offset > arrayBuffer.byteLength ||\n            validLength < 0 ||\n            validLength + offset > arrayBuffer.byteLength) {\n            throw new RangeError();\n        }\n        return new IsoBuffer(arrayBuffer, offset, validLength);\n    }\n    static fromString(str, encoding) {\n        switch (encoding) {\n            case \"base64\": {\n                const sanitizedString = this.sanitizeBase64(str);\n                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);\n                return new IsoBuffer(encoded.buffer);\n            }\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined: {\n                const encoded = new TextEncoder().encode(str);\n                return new IsoBuffer(encoded.buffer);\n            }\n            default: {\n                throw new Error(\"invalid/unsupported encoding\");\n            }\n        }\n    }\n    static isBuffer(obj) {\n        throw new Error(\"unimplemented\");\n    }\n    /**\n     * Sanitize a base64 string to provide to base64-js library.  base64-js\n     * is not as tolerant of the same malformed base64 as Node's Buffer is.\n     * @param str\n     */\n    static sanitizeBase64(str) {\n        let sanitizedStr = str;\n        // Remove everything after padding - Node buffer ignores everything\n        // after any padding whereas base64-js does not\n        sanitizedStr = sanitizedStr.split(\"=\")[0];\n        // Remove invalid characters - Node buffer strips invalid characters\n        // whereas base64-js replaces them with \"A\"\n        sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\");\n        // Check for missing padding - Node buffer tolerates missing padding\n        // whereas base64-js does not\n        if (sanitizedStr.length % 4 !== 0) {\n            const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n            sanitizedStr += paddingArray[sanitizedStr.length % 4];\n        }\n        return sanitizedStr;\n    }\n}\n//# sourceMappingURL=bufferBrowser.js.map\n\n/***/ }),\n/* 520 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Uint8ArrayToArrayBuffer\": () => (/* binding */ Uint8ArrayToArrayBuffer)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Convert Uint8Array array to ArrayBuffer\n * @param array - array to convert to ArrayBuffer\n */\nfunction Uint8ArrayToArrayBuffer(array) {\n    if (array.byteOffset === 0 && array.byteLength === array.buffer.byteLength) {\n        return array.buffer;\n    }\n    return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);\n}\n//# sourceMappingURL=bufferShared.js.map\n\n/***/ }),\n/* 521 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unreachableCase\": () => (/* binding */ unreachableCase)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This function can be used to assert at compile time that a given value has type never.\n * One common usage is in the default case of a switch block,\n * to ensure that all cases are explicitly handled.\n */\nfunction unreachableCase(_, message = \"Unreachable Case\") {\n    throw new Error(message);\n}\n//# sourceMappingURL=unreachable.js.map\n\n/***/ }),\n/* 522 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReconnectMode\": () => (/* binding */ ReconnectMode),\n/* harmony export */   \"getPackageName\": () => (/* binding */ getPackageName)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(523);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar ReconnectMode;\n(function (ReconnectMode) {\n    ReconnectMode[\"Never\"] = \"Never\";\n    ReconnectMode[\"Disabled\"] = \"Disabled\";\n    ReconnectMode[\"Enabled\"] = \"Enabled\";\n})(ReconnectMode || (ReconnectMode = {}));\n/**\n *\n * @param codeDetails- - Data structure used to describe the code to load on the Fluid document\n * @returns The name of the Fluid package\n */\nconst getPackageName = (codeDetails) => {\n    let containerPackageName;\n    if (codeDetails && \"name\" in codeDetails) {\n        containerPackageName = codeDetails;\n    }\n    else if ((0,_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.isFluidPackage)(codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package)) {\n        containerPackageName = codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package.name;\n    }\n    else {\n        containerPackageName = codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package;\n    }\n    return { name: containerPackageName };\n};\n//# sourceMappingURL=contracts.js.map\n\n/***/ }),\n/* 523 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IFluidCodeDetailsComparer\": () => (/* binding */ IFluidCodeDetailsComparer),\n/* harmony export */   \"isFluidCodeDetails\": () => (/* binding */ isFluidCodeDetails),\n/* harmony export */   \"isFluidPackage\": () => (/* binding */ isFluidPackage)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Check if the package.json defines a Fluid package\n * @param pkg - the package json data to check if it is a Fluid package.\n */\nconst isFluidPackage = (pkg) => typeof pkg === \"object\"\n    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.name) === \"string\"\n    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.fluid) === \"object\";\nconst isFluidCodeDetails = (details) => {\n    const maybeCodeDetails = details;\n    return typeof maybeCodeDetails === \"object\"\n        && (typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package) === \"string\" || isFluidPackage(maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package))\n        && ((maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === undefined || typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === \"object\");\n};\nconst IFluidCodeDetailsComparer = \"IFluidCodeDetailsComparer\";\n//# sourceMappingURL=fluidPackage.js.map\n\n/***/ }),\n/* 524 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QuorumProxy\": () => (/* binding */ QuorumProxy),\n/* harmony export */   \"getCodeDetailsFromQuorumValues\": () => (/* binding */ getCodeDetailsFromQuorumValues),\n/* harmony export */   \"initQuorumValuesFromCodeDetails\": () => (/* binding */ initQuorumValuesFromCodeDetails)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(525);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(527);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(487);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Proxies Quorum events.\n */\nclass QuorumProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {\n    constructor(quorum) {\n        super(quorum);\n        // This is heavily used object, increase limit at which Node prints warnings.\n        super.setMaxListeners(50);\n        this.propose = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.propose.bind(quorum));\n        this.has = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.has.bind(quorum));\n        this.get = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.get.bind(quorum));\n        this.getMembers = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.getMembers.bind(quorum));\n        this.getMember = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.getMember.bind(quorum));\n    }\n}\nfunction getCodeDetailsFromQuorumValues(quorumValues) {\n    const qValuesMap = new Map(quorumValues);\n    const proposal = qValuesMap.get(\"code\");\n    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(proposal !== undefined, 0x2dc /* \"Cannot find code proposal\" */);\n    return proposal === null || proposal === void 0 ? void 0 : proposal.value;\n}\nfunction initQuorumValuesFromCodeDetails(source) {\n    // Seed the base quorum to be an empty list with a code quorum set\n    const committedCodeProposal = {\n        key: \"code\",\n        value: source,\n        approvalSequenceNumber: 0,\n        commitSequenceNumber: 0,\n        sequenceNumber: 0,\n    };\n    return [[\"code\", committedCodeProposal]];\n}\n//# sourceMappingURL=quorum.js.map\n\n/***/ }),\n/* 525 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventForwarder\": () => (/* binding */ EventForwarder)\n/* harmony export */ });\n/* harmony import */ var _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(526);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Base class used for forwarding events from a source EventEmitter.\n * This can be useful when all arbitrary listeners need to be removed,\n * but the primary source needs to stay intact.\n */\nclass EventForwarder extends _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {\n    constructor(source) {\n        super();\n        this.isDisposed = false;\n        this.forwardingEvents = new Map();\n        if (source !== undefined) {\n            // NewListener event is raised whenever someone starts listening to this events, so\n            // we keep track of events being listened to, and start forwarding from the source\n            // event emitter per event listened to on this\n            const removeListenerHandler = (event) => this.unforwardEvent(source, event);\n            const newListenerHandler = (event) => this.forwardEvent(source, event);\n            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);\n            this.on(EventForwarder.newListenerEvent, newListenerHandler);\n        }\n    }\n    static isEmitterEvent(event) {\n        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;\n    }\n    get disposed() { return this.isDisposed; }\n    dispose() {\n        this.isDisposed = true;\n        for (const listenerRemovers of this.forwardingEvents.values()) {\n            for (const listenerRemover of listenerRemovers.values()) {\n                try {\n                    listenerRemover();\n                }\n                catch (_a) {\n                    // Should be fine because of removeAllListeners below\n                }\n            }\n        }\n        this.removeAllListeners();\n        this.forwardingEvents.clear();\n    }\n    forwardEvent(source, ...events) {\n        for (const event of events) {\n            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n                let sources = this.forwardingEvents.get(event);\n                if (sources === undefined) {\n                    sources = new Map();\n                    this.forwardingEvents.set(event, sources);\n                }\n                if (!sources.has(source)) {\n                    const listener = (...args) => this.emit(event, ...args);\n                    sources.set(source, () => source.off(event, listener));\n                    source.on(event, listener);\n                }\n            }\n        }\n    }\n    unforwardEvent(source, ...events) {\n        for (const event of events) {\n            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n                const sources = this.forwardingEvents.get(event);\n                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {\n                    if (this.listenerCount(event) === 0) {\n                        const listenerRemover = sources.get(source);\n                        if (listenerRemover !== undefined) {\n                            listenerRemover();\n                        }\n                        sources.delete(source);\n                        if (sources.size === 0) {\n                            this.forwardingEvents.delete(event);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nEventForwarder.newListenerEvent = \"newListener\";\nEventForwarder.removeListenerEvent = \"removeListener\";\n//# sourceMappingURL=eventForwarder.js.map\n\n/***/ }),\n/* 526 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 527 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doIfNotDisposed\": () => (/* binding */ doIfNotDisposed)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction doIfNotDisposed(disposable, f) {\n    return (...args) => {\n        if (disposable.disposed) {\n            throw new Error(\"Already disposed\");\n        }\n        else {\n            return f(...args);\n        }\n    };\n}\n//# sourceMappingURL=disposal.js.map\n\n/***/ }),\n/* 528 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RetriableDocumentStorageService\": () => (/* binding */ RetriableDocumentStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(448);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nclass RetriableDocumentStorageService {\n    constructor(internalStorageService, logger) {\n        this.internalStorageService = internalStorageService;\n        this.logger = logger;\n        this._disposed = false;\n    }\n    get policies() {\n        return this.internalStorageService.policies;\n    }\n    get disposed() { return this._disposed; }\n    dispose() {\n        this._disposed = true;\n    }\n    get repositoryUrl() {\n        return this.internalStorageService.repositoryUrl;\n    }\n    async getSnapshotTree(version, scenarioName) {\n        return this.runWithRetry(async () => this.internalStorageService.getSnapshotTree(version, scenarioName), \"storage_getSnapshotTree\");\n    }\n    async readBlob(id) {\n        return this.runWithRetry(async () => this.internalStorageService.readBlob(id), \"storage_readBlob\");\n    }\n    async getVersions(versionId, count, scenarioName) {\n        return this.runWithRetry(async () => this.internalStorageService.getVersions(versionId, count, scenarioName), \"storage_getVersions\");\n    }\n    async uploadSummaryWithContext(summary, context) {\n        // Not using retry loop here. Couple reasons:\n        // 1. If client lost connectivity, then retry loop will result in uploading stale summary\n        //    by stale summarizer after connectivity comes back. It will cause failures for this client and for\n        //    real (new) summarizer. This problem in particular should be solved in future by supplying abort handle\n        //    on all APIs and caller (ContainerRuntime.submitSummary) aborting call on loss of connectivity\n        // 2. Similar, if we get 429 with retryAfter = 10 minutes, it's likely not the right call to retry summary\n        //    upload in 10 minutes - it's better to keep processing ops and retry later. Though caller needs to take\n        //    retryAfter into account!\n        // But retry loop is required for creation flow (Container.attach)\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((context.referenceSequenceNumber === 0) === (context.ackHandle === undefined), 0x251 /* \"creation summary has to have seq=0 && handle === undefined\" */);\n        if (context.referenceSequenceNumber !== 0) {\n            return this.internalStorageService.uploadSummaryWithContext(summary, context);\n        }\n        // Creation flow with attachment blobs - need to do retries!\n        return this.runWithRetry(async () => this.internalStorageService.uploadSummaryWithContext(summary, context), \"storage_uploadSummaryWithContext\");\n    }\n    async downloadSummary(handle) {\n        return this.runWithRetry(async () => this.internalStorageService.downloadSummary(handle), \"storage_downloadSummary\");\n    }\n    async createBlob(file) {\n        return this.runWithRetry(async () => this.internalStorageService.createBlob(file), \"storage_createBlob\");\n    }\n    checkStorageDisposed() {\n        if (this._disposed) {\n            // pre-0.58 error message: storageServiceDisposedCannotRetry\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(\"Storage Service is disposed. Cannot retry\", { canRetry: false });\n        }\n        return undefined;\n    }\n    async runWithRetry(api, callName) {\n        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.runWithRetry)(api, callName, this.logger, {\n            onRetry: () => this.checkStorageDisposed(),\n        });\n    }\n}\n//# sourceMappingURL=retriableDocumentStorageService.js.map\n\n/***/ }),\n/* 529 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProtocolTreeStorageService\": () => (/* binding */ ProtocolTreeStorageService)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(338);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nclass ProtocolTreeStorageService {\n    constructor(internalStorageService, generateProtocolTree) {\n        this.internalStorageService = internalStorageService;\n        this.generateProtocolTree = generateProtocolTree;\n        this.getSnapshotTree = this.internalStorageService.getSnapshotTree.bind(this.internalStorageService);\n        this.getVersions = this.internalStorageService.getVersions.bind(this.internalStorageService);\n        this.createBlob = this.internalStorageService.createBlob.bind(this.internalStorageService);\n        this.readBlob = this.internalStorageService.readBlob.bind(this.internalStorageService);\n        this.downloadSummary = this.internalStorageService.downloadSummary.bind(this.internalStorageService);\n        this.dispose = this.internalStorageService.dispose.bind(this.internalStorageService);\n    }\n    get policies() {\n        return this.internalStorageService.policies;\n    }\n    get repositoryUrl() {\n        return this.internalStorageService.repositoryUrl;\n    }\n    get disposed() {\n        return this.internalStorageService.disposed;\n    }\n    async uploadSummaryWithContext(summary, context) {\n        return this.internalStorageService.uploadSummaryWithContext((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.combineAppAndProtocolSummary)(summary, this.generateProtocolTree()), context);\n    }\n}\n//# sourceMappingURL=protocolTreeDocumentStorageService.js.map\n\n/***/ }),\n/* 530 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProtocolOpHandler\": () => (/* binding */ ProtocolOpHandler),\n/* harmony export */   \"ProtocolOpHandlerWithClientValidation\": () => (/* binding */ ProtocolOpHandlerWithClientValidation),\n/* harmony export */   \"isSystemMessage\": () => (/* binding */ isSystemMessage)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(531);\n/* harmony import */ var _quorum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(532);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nfunction isSystemMessage(message) {\n    switch (message.type) {\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoClient:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Summarize:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.SummaryAck:\n        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.SummaryNack:\n            return true;\n        default:\n            return false;\n    }\n}\n/**\n * Handles protocol specific ops.\n */\nclass ProtocolOpHandler {\n    constructor(minimumSequenceNumber, sequenceNumber, term, members, proposals, values, sendProposal) {\n        this.minimumSequenceNumber = minimumSequenceNumber;\n        this.sequenceNumber = sequenceNumber;\n        this.term = term !== null && term !== void 0 ? term : 1;\n        this._quorum = new _quorum__WEBPACK_IMPORTED_MODULE_1__.Quorum(members, proposals, values, sendProposal);\n    }\n    get quorum() {\n        return this._quorum;\n    }\n    get attributes() {\n        return {\n            minimumSequenceNumber: this.minimumSequenceNumber,\n            sequenceNumber: this.sequenceNumber,\n            term: this.term,\n        };\n    }\n    setConnectionState(connected, clientId) {\n        this._quorum.setConnectionState(connected, clientId);\n    }\n    snapshot() {\n        return this._quorum.snapshot();\n    }\n    close() {\n        this._quorum.close();\n    }\n    processMessage(message, local) {\n        // verify it's moving sequentially\n        if (message.sequenceNumber !== this.sequenceNumber + 1) {\n            throw new Error(`Protocol state is not moving sequentially. ` +\n                `Current is ${this.sequenceNumber}. Next is ${message.sequenceNumber}`);\n        }\n        // Update tracked sequence numbers\n        this.sequenceNumber = message.sequenceNumber;\n        this.minimumSequenceNumber = message.minimumSequenceNumber;\n        let immediateNoOp = false;\n        switch (message.type) {\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin:\n                const systemJoinMessage = message;\n                const join = JSON.parse(systemJoinMessage.data);\n                const member = {\n                    client: join.detail,\n                    sequenceNumber: systemJoinMessage.sequenceNumber,\n                };\n                this._quorum.addMember(join.clientId, member);\n                break;\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave:\n                const systemLeaveMessage = message;\n                const clientId = JSON.parse(systemLeaveMessage.data);\n                this._quorum.removeMember(clientId);\n                break;\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:\n                const proposal = message.contents;\n                this._quorum.addProposal(proposal.key, proposal.value, message.sequenceNumber, local, message.clientSequenceNumber);\n                // On a quorum proposal, immediately send a response to expedite the approval.\n                immediateNoOp = true;\n                break;\n            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:\n                throw new Error(\"Quorum rejection is removed.\");\n            default:\n        }\n        // Notify the quorum of the MSN from the message. We rely on it to handle duplicate values but may\n        // want to move that logic to this class.\n        this._quorum.updateMinimumSequenceNumber(message);\n        return { immediateNoOp };\n    }\n    /**\n     * Gets the scribe protocol state\n     */\n    getProtocolState() {\n        // return a new object every time\n        // this ensures future state changes will not affect outside callers\n        return Object.assign({ sequenceNumber: this.sequenceNumber, minimumSequenceNumber: this.minimumSequenceNumber }, this._quorum.snapshot());\n    }\n}\nclass ProtocolOpHandlerWithClientValidation extends ProtocolOpHandler {\n    processMessage(message, local) {\n        const client = this._quorum.getMember(message.clientId);\n        // Check and report if we're getting messages from a clientId that we previously\n        // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be\n        if (message.clientId != null) {\n            if (client === undefined && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin) {\n                // pre-0.58 error message: messageClientIdMissingFromQuorum\n                throw new Error(\"Remote message's clientId is missing from the quorum\");\n            }\n            if ((client === null || client === void 0 ? void 0 : client.shouldHaveLeft) === true && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp) {\n                // pre-0.58 error message: messageClientIdShouldHaveLeft\n                throw new Error(\"Remote message's clientId already should have left\");\n            }\n        }\n        return super.processMessage(message, local);\n    }\n}\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 531 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 532 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Quorum\": () => (/* binding */ Quorum),\n/* harmony export */   \"QuorumClients\": () => (/* binding */ QuorumClients),\n/* harmony export */   \"QuorumProposals\": () => (/* binding */ QuorumProposals)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(158);\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(533);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(534);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// eslint-disable-next-line import/no-internal-modules\n\n\n/**\n * Structure for tracking proposals that have been sequenced but not approved yet.\n */\nclass PendingProposal {\n    constructor(sequenceNumber, key, value, local) {\n        this.sequenceNumber = sequenceNumber;\n        this.key = key;\n        this.value = value;\n        this.local = local;\n    }\n}\n/**\n * The QuorumClients is used to track members joining and leaving the collaboration session.\n */\nclass QuorumClients extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    constructor(snapshot) {\n        super();\n        this.isDisposed = false;\n        this.members = new Map(snapshot);\n        this.snapshotCache = snapshot;\n    }\n    get disposed() { return this.isDisposed; }\n    /**\n     * Snapshots the current state of the QuorumClients\n     * @returns a snapshot of the clients in the quorum\n     */\n    snapshot() {\n        var _a;\n        (_a = this.snapshotCache) !== null && _a !== void 0 ? _a : (this.snapshotCache = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(Array.from(this.members)));\n        return this.snapshotCache;\n    }\n    /**\n     * Adds a new client to the quorum\n     */\n    addMember(clientId, details) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.members.has(clientId), 0x1ce /* clientId not found */);\n        this.members.set(clientId, details);\n        this.emit(\"addMember\", clientId, details);\n        // clear the cache\n        this.snapshotCache = undefined;\n    }\n    /**\n     * Removes a client from the quorum\n     */\n    removeMember(clientId) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.members.has(clientId), 0x1cf /* clientId not found */);\n        this.members.delete(clientId);\n        this.emit(\"removeMember\", clientId);\n        // clear the cache\n        this.snapshotCache = undefined;\n    }\n    /**\n     * Retrieves all the members in the quorum\n     */\n    getMembers() {\n        return new Map(this.members);\n    }\n    /**\n     * Retrieves a specific member of the quorum\n     */\n    getMember(clientId) {\n        return this.members.get(clientId);\n    }\n    dispose() {\n        this.isDisposed = true;\n    }\n}\n/**\n * The QuorumProposals holds a key/value store.  Proposed values become finalized in the store once all connected\n * clients have seen the proposal.\n */\nclass QuorumProposals extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    constructor(snapshot, sendProposal) {\n        super();\n        this.sendProposal = sendProposal;\n        this.isDisposed = false;\n        // Event emitter for changes to the environment that affect pending proposal promises.\n        this.stateEvents = new events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this.proposals = new Map(snapshot.proposals.map(([, proposal]) => {\n            return [\n                proposal.sequenceNumber,\n                new PendingProposal(proposal.sequenceNumber, proposal.key, proposal.value, false),\n            ];\n        }));\n        this.values = new Map(snapshot.values);\n        this.proposalsSnapshotCache = snapshot.proposals;\n        this.valuesSnapshotCache = snapshot.values;\n    }\n    get disposed() { return this.isDisposed; }\n    /**\n     * Snapshots the current state of the QuorumProposals\n     * @returns deep cloned arrays of proposals and values\n     */\n    snapshot() {\n        var _a, _b;\n        (_a = this.proposalsSnapshotCache) !== null && _a !== void 0 ? _a : (this.proposalsSnapshotCache = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [\n            sequenceNumber,\n            { sequenceNumber, key: proposal.key, value: proposal.value },\n            [], // rejections, which has been removed\n        ]));\n        (_b = this.valuesSnapshotCache) !== null && _b !== void 0 ? _b : (this.valuesSnapshotCache = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(Array.from(this.values)));\n        return {\n            proposals: this.proposalsSnapshotCache,\n            values: this.valuesSnapshotCache,\n        };\n    }\n    /**\n     * Returns whether the quorum has achieved a consensus for the given key.\n     */\n    has(key) {\n        return this.values.has(key);\n    }\n    /**\n     * Returns the consensus value for the given key\n     */\n    get(key) {\n        var _a;\n        return (_a = this.values.get(key)) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    /**\n     * Returns additional data about the approved consensus value\n     * @deprecated Removed in recent protocol-definitions.  Use get() instead.\n     */\n    getApprovalData(key) {\n        const proposal = this.values.get(key);\n        return proposal ? lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(proposal) : undefined;\n    }\n    /**\n     * Proposes a new value. Returns a promise that will either:\n     * - Resolve when the proposal is accepted\n     * - Reject if the proposal fails to send or if the QuorumProposals is disposed\n     */\n    async propose(key, value) {\n        const clientSequenceNumber = this.sendProposal(key, value);\n        if (clientSequenceNumber < 0) {\n            this.emit(\"error\", { eventName: \"ProposalInDisconnectedState\", key });\n            throw new Error(\"Can't propose in disconnected state\");\n        }\n        return new Promise((resolve, reject) => {\n            // The sequence number that our proposal was assigned and went pending.\n            // If undefined, then it's not sequenced yet.\n            let thisProposalSequenceNumber;\n            // A proposal goes through two phases before this promise resolves:\n            // 1. Sequencing - waiting for the proposal to be ack'd by the server.\n            // 2. Approval - waiting for the proposal to be approved by connected clients.\n            const localProposalSequencedHandler = (sequencedCSN, sequenceNumber) => {\n                if (sequencedCSN === clientSequenceNumber) {\n                    thisProposalSequenceNumber = sequenceNumber;\n                    this.stateEvents.off(\"localProposalSequenced\", localProposalSequencedHandler);\n                    this.stateEvents.off(\"disconnected\", disconnectedHandler);\n                    this.stateEvents.on(\"localProposalApproved\", localProposalApprovedHandler);\n                }\n            };\n            const localProposalApprovedHandler = (sequenceNumber) => {\n                // Proposals can be uniquely identified by the sequenceNumber they were assigned.\n                if (sequenceNumber === thisProposalSequenceNumber) {\n                    resolve();\n                    removeListeners();\n                }\n            };\n            // There are two error flows we consider:  disconnect and disposal.\n            // If we get disconnected before the proposal is sequenced, it has one of two possible futures:\n            // 1. We reconnect and see the proposal was sequenced in the meantime.\n            //    -> The promise can still resolve, once it is approved.\n            // 2. We reconnect and see the proposal was not sequenced in the meantime, so it will never sequence.\n            //    -> The promise rejects.\n            const disconnectedHandler = () => {\n                // If we haven't seen the ack by the time we disconnect, we hope to see it by the time we reconnect.\n                if (thisProposalSequenceNumber === undefined) {\n                    this.stateEvents.once(\"connected\", () => {\n                        // If we don't see the ack by the time reconnection finishes, it failed to send.\n                        if (thisProposalSequenceNumber === undefined) {\n                            reject(new Error(\"Client disconnected without successfully sending proposal\"));\n                            removeListeners();\n                        }\n                    });\n                }\n            };\n            // If the QuorumProposals is disposed of, we assume something catastrophic has happened\n            // All outstanding proposals are considered rejected.\n            const disposedHandler = () => {\n                reject(new Error(\"QuorumProposals was disposed\"));\n                removeListeners();\n            };\n            // Convenience function to clean up our listeners.\n            const removeListeners = () => {\n                this.stateEvents.off(\"localProposalSequenced\", localProposalSequencedHandler);\n                this.stateEvents.off(\"localProposalApproved\", localProposalApprovedHandler);\n                this.stateEvents.off(\"disconnected\", disconnectedHandler);\n                this.stateEvents.off(\"disposed\", disposedHandler);\n            };\n            this.stateEvents.on(\"localProposalSequenced\", localProposalSequencedHandler);\n            this.stateEvents.on(\"disconnected\", disconnectedHandler);\n            this.stateEvents.on(\"disposed\", disposedHandler);\n        });\n    }\n    /**\n     * Begins tracking a new proposal\n     */\n    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.proposals.has(sequenceNumber), 0x1d0 /* sequenceNumber not found */);\n        const proposal = new PendingProposal(sequenceNumber, key, value, local);\n        this.proposals.set(sequenceNumber, proposal);\n        // Legacy event, from rejection support.  May still have some use for clients to learn that a proposal is\n        // likely to be approved soon.\n        this.emit(\"addProposal\", proposal);\n        if (local) {\n            this.stateEvents.emit(\"localProposalSequenced\", clientSequenceNumber, sequenceNumber);\n        }\n        // clear the proposal cache\n        this.proposalsSnapshotCache = undefined;\n    }\n    /**\n     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it\n     * becomes an approved value.\n     */\n    updateMinimumSequenceNumber(message) {\n        const msn = message.minimumSequenceNumber;\n        // Accept proposals proposals whose sequenceNumber is <= the minimumSequenceNumber\n        // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order\n        // TODO this can be optimized if necessary to avoid the linear search+sort\n        const completed = [];\n        for (const [sequenceNumber, proposal] of this.proposals) {\n            if (sequenceNumber <= msn) {\n                completed.push(proposal);\n            }\n        }\n        completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        for (const proposal of completed) {\n            const committedProposal = {\n                approvalSequenceNumber: message.sequenceNumber,\n                // No longer used.  We still stamp a -1 for compat with older versions of the quorum.\n                // Can be removed after 0.1035 and higher is ubiquitous.\n                commitSequenceNumber: -1,\n                key: proposal.key,\n                sequenceNumber: proposal.sequenceNumber,\n                value: proposal.value,\n            };\n            this.values.set(committedProposal.key, committedProposal);\n            // clear the values cache\n            this.valuesSnapshotCache = undefined;\n            this.emit(\"approveProposal\", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);\n            this.proposals.delete(proposal.sequenceNumber);\n            // clear the proposals cache\n            this.proposalsSnapshotCache = undefined;\n            if (proposal.local) {\n                this.stateEvents.emit(\"localProposalApproved\", proposal.sequenceNumber);\n            }\n        }\n    }\n    setConnectionState(connected) {\n        if (connected) {\n            this.stateEvents.emit(\"connected\");\n        }\n        else {\n            this.stateEvents.emit(\"disconnected\");\n        }\n    }\n    dispose() {\n        this.isDisposed = true;\n        this.stateEvents.emit(\"disposed\");\n    }\n}\n/**\n * A quorum represents all clients currently within the collaboration window. As well as the values\n * they have agreed upon and any pending proposals.\n */\nclass Quorum extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    constructor(members, proposals, values, sendProposal) {\n        super();\n        this.isDisposed = false;\n        this.quorumClients = new QuorumClients(members);\n        this.quorumClients.on(\"addMember\", (clientId, details) => {\n            this.emit(\"addMember\", clientId, details);\n        });\n        this.quorumClients.on(\"removeMember\", (clientId) => {\n            this.emit(\"removeMember\", clientId);\n        });\n        this.quorumProposals = new QuorumProposals({ proposals, values }, sendProposal);\n        this.quorumProposals.on(\"addProposal\", (proposal) => {\n            this.emit(\"addProposal\", proposal);\n        });\n        this.quorumProposals.on(\"approveProposal\", (sequenceNumber, key, value, approvalSequenceNumber) => {\n            this.emit(\"approveProposal\", sequenceNumber, key, value, approvalSequenceNumber);\n        });\n    }\n    get disposed() { return this.isDisposed; }\n    close() {\n        this.removeAllListeners();\n    }\n    /**\n     * Snapshots the entire quorum\n     * @returns a quorum snapshot\n     */\n    snapshot() {\n        const members = this.quorumClients.snapshot();\n        const { proposals, values } = this.quorumProposals.snapshot();\n        return {\n            members,\n            proposals,\n            values,\n        };\n    }\n    /**\n     * Returns whether the quorum has achieved a consensus for the given key.\n     */\n    has(key) {\n        return this.quorumProposals.has(key);\n    }\n    /**\n     * Returns the consensus value for the given key\n     */\n    get(key) {\n        return this.quorumProposals.get(key);\n    }\n    /**\n     * Returns additional data about the approved consensus value\n     * @deprecated Removed in recent protocol-definitions.  Use get() instead.\n     */\n    getApprovalData(key) {\n        return this.quorumProposals.getApprovalData(key);\n    }\n    /**\n     * Adds a new client to the quorum\n     */\n    addMember(clientId, details) {\n        this.quorumClients.addMember(clientId, details);\n    }\n    /**\n     * Removes a client from the quorum\n     */\n    removeMember(clientId) {\n        this.quorumClients.removeMember(clientId);\n    }\n    /**\n     * Retrieves all the members in the quorum\n     */\n    getMembers() {\n        return this.quorumClients.getMembers();\n    }\n    /**\n     * Retrieves a specific member of the quorum\n     */\n    getMember(clientId) {\n        return this.quorumClients.getMember(clientId);\n    }\n    /**\n     * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted, or reject if\n     * the proposal fails to send.\n     */\n    async propose(key, value) {\n        return this.quorumProposals.propose(key, value);\n    }\n    /**\n     * Begins tracking a new proposal\n     */\n    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {\n        return this.quorumProposals.addProposal(key, value, sequenceNumber, local, clientSequenceNumber);\n    }\n    /**\n     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it\n     * becomes an approved value.\n     */\n    updateMinimumSequenceNumber(message) {\n        this.quorumProposals.updateMinimumSequenceNumber(message);\n    }\n    setConnectionState(connected, clientId) {\n        this.quorumProposals.setConnectionState(connected);\n    }\n    dispose() {\n        throw new Error(\"Not implemented.\");\n        this.isDisposed = true;\n    }\n}\n//# sourceMappingURL=quorum.js.map\n\n/***/ }),\n/* 533 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TypedEventEmitter\": () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Event Emitter helper class the supports emitting typed events\n */\nclass TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.addListener = super.addListener.bind(this);\n        this.on = super.on.bind(this);\n        this.once = super.once.bind(this);\n        this.prependListener = super.prependListener.bind(this);\n        this.prependOnceListener = super.prependOnceListener.bind(this);\n        this.removeListener = super.removeListener.bind(this);\n        this.off = super.off.bind(this);\n    }\n}\n//# sourceMappingURL=typedEventEmitter.js.map\n\n/***/ }),\n/* 534 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big\n * impact on bundle sizes.\n * @param condition - The condition that should be true, if the condition is false an error will be thrown.\n * @param message - The message to include in the error when the condition does not hold.\n *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(typeof message === \"number\" ? `0x${message.toString(16).padStart(3, \"0\")}` : message);\n    }\n}\n//# sourceMappingURL=assert.js.map\n\n/***/ }),\n/* 535 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MessageType\": () => (/* binding */ MessageType),\n/* harmony export */   \"NackErrorType\": () => (/* binding */ NackErrorType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Summary op\n    MessageType[\"Summarize\"] = \"summarize\";\n    // Summary op written\n    MessageType[\"SummaryAck\"] = \"summaryAck\";\n    // Summary op write failure\n    MessageType[\"SummaryNack\"] = \"summaryNack\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n    // Message to indicate that no active clients are present.\n    MessageType[\"NoClient\"] = \"noClient\";\n    // Message to indicate successful round trip.\n    MessageType[\"RoundTrip\"] = \"tripComplete\";\n    // Service specific control messages that are never sequenced.\n    MessageType[\"Control\"] = \"control\";\n})(MessageType || (MessageType = {}));\n/**\n * Type of the Nack.\n * InvalidScopeError: Client's token is not valid for the intended op.\n * ThrottlingError: Retryable after retryAfter number.\n * BadRequestError: Clients op is invalid and should retry immediately with a valid op.\n * LimitExceededError: Service is having issues. Client should not retry.\n */\nvar NackErrorType;\n(function (NackErrorType) {\n    NackErrorType[\"ThrottlingError\"] = \"ThrottlingError\";\n    NackErrorType[\"InvalidScopeError\"] = \"InvalidScopeError\";\n    NackErrorType[\"BadRequestError\"] = \"BadRequestError\";\n    NackErrorType[\"LimitExceededError\"] = \"LimitExceededError\";\n})(NackErrorType || (NackErrorType = {}));\n//# sourceMappingURL=protocol.js.map\n\n/***/ }),\n/* 536 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pkgName\": () => (/* binding */ pkgName),\n/* harmony export */   \"pkgVersion\": () => (/* binding */ pkgVersion)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n *\n * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n */\nconst pkgName = \"@fluidframework/container-loader\";\nconst pkgVersion = \"1.3.7\";\n//# sourceMappingURL=packageVersion.js.map\n\n/***/ }),\n/* 537 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeltaManager\": () => (/* binding */ DeltaManager)\n/* harmony export */ });\n/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(538);\n/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(abort_controller__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(526);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(132);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(540);\n/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(535);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(117);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(64);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);\n/* harmony import */ var _deltaQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(539);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta\n * messages in order regardless of possible network conditions or timings causing out of order delivery.\n */\nclass DeltaManager extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TypedEventEmitter {\n    constructor(serviceProvider, logger, _active, createConnectionManager) {\n        super();\n        this.serviceProvider = serviceProvider;\n        this.logger = logger;\n        this._active = _active;\n        this.pending = [];\n        // The minimum sequence number and last sequence number received from the server\n        this.minSequenceNumber = 0;\n        // There are three numbers we track\n        // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number\n        //   is not updated until we cover that gap, so it increases each time by 1.\n        // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially\n        //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.\n        //   It's never less than lastQueuedSequenceNumber\n        // * lastProcessedSequenceNumber - last processed sequence number\n        this.lastQueuedSequenceNumber = 0;\n        this.lastObservedSeqNumber = 0;\n        this.lastProcessedSequenceNumber = 0;\n        this.baseTerm = 0;\n        /**\n         * Track down the ops size.\n        */\n        this.opsSize = 0;\n        // The sequence number we initially loaded from\n        this.initSequenceNumber = 0;\n        this.closed = false;\n        this.throttlingIdSet = new Set();\n        this.timeTillThrottling = 0;\n        this.closeAbortController = new (abort_controller__WEBPACK_IMPORTED_MODULE_0___default())();\n        this.deltaStorageDelayId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n        this.deltaStreamDelayId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n        this.messageBuffer = [];\n        const props = {\n            incomingOpHandler: (messages, reason) => {\n                try {\n                    this.enqueueMessages(messages, reason);\n                }\n                catch (error) {\n                    this.logger.sendErrorEvent({ eventName: \"EnqueueMessages_Exception\" }, error);\n                    this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeError)(error));\n                }\n            },\n            signalHandler: (message) => this._inboundSignal.push(message),\n            reconnectionDelayHandler: (delayMs, error) => this.emitDelayInfo(this.deltaStreamDelayId, delayMs, error),\n            closeHandler: (error) => this.close(error),\n            disconnectHandler: (reason) => this.disconnectHandler(reason),\n            connectHandler: (connection) => this.connectHandler(connection),\n            pongHandler: (latency) => this.emit(\"pong\", latency),\n            readonlyChangeHandler: (readonly) => (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.safeRaiseEvent)(this, this.logger, \"readonly\", readonly),\n        };\n        this.connectionManager = createConnectionManager(props);\n        this._inbound = new _deltaQueue__WEBPACK_IMPORTED_MODULE_5__.DeltaQueue((op) => {\n            this.processInboundMessage(op);\n        });\n        this._inbound.on(\"error\", (error) => {\n            this.close(_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataProcessingError.wrapIfUnrecognized(error, \"deltaManagerInboundErrorHandler\", this.lastMessage));\n        });\n        // Inbound signal queue\n        this._inboundSignal = new _deltaQueue__WEBPACK_IMPORTED_MODULE_5__.DeltaQueue((message) => {\n            if (this.handler === undefined) {\n                throw new Error(\"Attempted to process an inbound signal without a handler attached\");\n            }\n            this.handler.processSignal({\n                clientId: message.clientId,\n                content: JSON.parse(message.content),\n            });\n        });\n        this._inboundSignal.on(\"error\", (error) => {\n            this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeError)(error));\n        });\n        // Initially, all queues are created paused.\n        // - outbound is flipped back and forth in setupNewSuccessfulConnection / disconnectFromDeltaStream\n        // - inbound & inboundSignal are resumed in attachOpHandler() when we have handler setup\n    }\n    get active() { return this._active(); }\n    get disposed() { return this.closed; }\n    get IDeltaSender() { return this; }\n    get inbound() {\n        return this._inbound;\n    }\n    get inboundSignal() {\n        return this._inboundSignal;\n    }\n    get initialSequenceNumber() {\n        return this.initSequenceNumber;\n    }\n    get lastSequenceNumber() {\n        return this.lastProcessedSequenceNumber;\n    }\n    get lastMessage() {\n        return this.lastProcessedMessage;\n    }\n    get lastKnownSeqNumber() {\n        return this.lastObservedSeqNumber;\n    }\n    get referenceTerm() {\n        return this.baseTerm;\n    }\n    get minimumSequenceNumber() {\n        return this.minSequenceNumber;\n    }\n    /**\n     * Tells if  current connection has checkpoint information.\n     * I.e. we know how far behind the client was at the time of establishing connection\n     */\n    get hasCheckpointSequenceNumber() {\n        // Valid to be called only if we have active connection.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connectionManager.connected, 0x0df /* \"Missing active connection\" */);\n        return this._checkpointSequenceNumber !== undefined;\n    }\n    // Forwarding connection manager properties / IDeltaManager implementation\n    get maxMessageSize() { return this.connectionManager.maxMessageSize; }\n    get version() { return this.connectionManager.version; }\n    get serviceConfiguration() { return this.connectionManager.serviceConfiguration; }\n    get outbound() { return this.connectionManager.outbound; }\n    get readOnlyInfo() { return this.connectionManager.readOnlyInfo; }\n    get clientDetails() { return this.connectionManager.clientDetails; }\n    submit(type, contents, batch = false, metadata) {\n        const messagePartial = {\n            contents: JSON.stringify(contents),\n            metadata,\n            referenceSequenceNumber: this.lastProcessedSequenceNumber,\n            type,\n        };\n        if (!batch) {\n            this.flush();\n        }\n        const message = this.connectionManager.prepareMessageToSend(messagePartial);\n        if (message === undefined) {\n            return -1;\n        }\n        this.opsSize += message.contents.length;\n        this.messageBuffer.push(message);\n        this.emit(\"submitOp\", message);\n        if (!batch) {\n            this.flush();\n        }\n        return message.clientSequenceNumber;\n    }\n    submitSignal(content) { return this.connectionManager.submitSignal(content); }\n    flush() {\n        if (this.messageBuffer.length === 0) {\n            return;\n        }\n        // The prepareFlush event allows listeners to append metadata to the batch prior to submission.\n        this.emit(\"prepareSend\", this.messageBuffer);\n        this.connectionManager.sendMessages(this.messageBuffer);\n        this.messageBuffer = [];\n    }\n    get connectionProps() {\n        return Object.assign({ sequenceNumber: this.lastSequenceNumber, opsSize: this.opsSize > 0 ? this.opsSize : undefined }, this.connectionManager.connectionProps);\n    }\n    /**\n     * Log error event with a bunch of internal to DeltaManager information about state of op processing\n     * Used to diagnose connectivity issues related to op processing (i.e. cases where for some reason\n     * we stop processing ops that results in no processing join op and thus moving to connected state)\n     * @param event - Event to log.\n     */\n    logConnectionIssue(event) {\n        var _a;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connectionManager.connected, 0x238 /* \"called only in connected state\" */);\n        const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        this.logger.sendErrorEvent(Object.assign(Object.assign(Object.assign(Object.assign({}, event), { \n            // This directly tells us if fetching ops is in flight, and thus likely the reason of\n            // stalled op processing\n            fetchReason: this.fetchReason, \n            // A bunch of useful sequence numbers to understand if we are holding some ops from processing\n            lastQueuedSequenceNumber: this.lastQueuedSequenceNumber, lastProcessedSequenceNumber: this.lastProcessedSequenceNumber, lastObserved: this.lastObservedSeqNumber }), this.connectionManager.connectionVerboseProps), { pendingOps: this.pending.length, pendingFirst: (_a = pendingSorted[0]) === null || _a === void 0 ? void 0 : _a.sequenceNumber, haveHandler: this.handler !== undefined, inboundLength: this.inbound.length, inboundPaused: this.inbound.paused }));\n    }\n    connectHandler(connection) {\n        this.refreshDelayInfo(this.deltaStreamDelayId);\n        const props = this.connectionManager.connectionVerboseProps;\n        props.connectionLastQueuedSequenceNumber = this.lastQueuedSequenceNumber;\n        props.connectionLastObservedSeqNumber = this.lastObservedSeqNumber;\n        const checkpointSequenceNumber = connection.checkpointSequenceNumber;\n        this._checkpointSequenceNumber = checkpointSequenceNumber;\n        if (checkpointSequenceNumber !== undefined) {\n            this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);\n        }\n        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n        // but it's safe to assume (until better design is put into place) that batches should not exist\n        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n        // state. As requirements change, so should these checks.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.messageBuffer.length === 0, 0x0e9 /* \"messageBuffer is not empty on new connection\" */);\n        this.opsSize = 0;\n        this.emit(\"connect\", connection, checkpointSequenceNumber !== undefined ?\n            this.lastObservedSeqNumber - this.lastSequenceNumber : undefined);\n        // If we got some initial ops, then we know the gap and call above fetched ops to fill it.\n        // Same is true for \"write\" mode even if we have no ops - we will get \"join\" own op very very soon.\n        // However if we are connecting as view-only, then there is no good signal to realize if client is behind.\n        // Thus we have to hit storage to see if any ops are there.\n        if (checkpointSequenceNumber !== undefined) {\n            // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.\n            if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {\n                this.fetchMissingDeltas(\"AfterConnection\");\n            }\n            // we do not know the gap, and we will not learn about it if socket is quite - have to ask.\n        }\n        else if (connection.mode === \"read\") {\n            this.fetchMissingDeltas(\"AfterReadConnection\");\n        }\n    }\n    dispose() {\n        throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Sets the sequence number from which inbound messages should be returned\n     */\n    async attachOpHandler(minSequenceNumber, sequenceNumber, term, handler, prefetchType = \"none\") {\n        this.initSequenceNumber = sequenceNumber;\n        this.lastProcessedSequenceNumber = sequenceNumber;\n        this.baseTerm = term;\n        this.minSequenceNumber = minSequenceNumber;\n        this.lastQueuedSequenceNumber = sequenceNumber;\n        this.lastObservedSeqNumber = sequenceNumber;\n        // We will use same check in other places to make sure all the seq number above are set properly.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.handler === undefined, 0x0e2 /* \"DeltaManager already has attached op handler!\" */);\n        this.handler = handler;\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this.handler, 0x0e3 /* \"Newly set op handler is null/undefined!\" */);\n        // There should be no pending fetch!\n        // This API is called right after attachOpHandler by Container.load().\n        // We might have connection already and it might have called fetchMissingDeltas() from\n        // setupNewSuccessfulConnection. But it should do nothing, because there is no way to fetch ops before\n        // we know snapshot sequence number that is set in attachOpHandler. So all such calls should be noop.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.fetchReason === undefined, 0x268 /* \"There can't be pending fetch that early in boot sequence!\" */);\n        if (this.closed) {\n            return;\n        }\n        this._inbound.resume();\n        this._inboundSignal.resume();\n        if (prefetchType !== \"none\") {\n            const cacheOnly = prefetchType === \"cached\";\n            await this.fetchMissingDeltasCore(`DocumentOpen_${prefetchType}`, cacheOnly);\n            // Keep going with fetching ops from storage once we have all cached ops in.\n            // But do not block load and make this request async / not blocking this api.\n            // Ops processing will start once cached ops are in and and will stop when queue is empty\n            // (which in most cases will happen when we are done processing cached ops)\n            if (cacheOnly) {\n                // fire and forget\n                this.fetchMissingDeltas(\"PostDocumentOpen\");\n            }\n        }\n        // Ensure there is no need to call this.processPendingOps() at the end of boot sequence\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.fetchReason !== undefined || this.pending.length === 0, 0x269 /* \"pending ops are not dropped\" */);\n    }\n    connect(args) {\n        var _a;\n        const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;\n        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__.logIfFalse)(this.handler !== undefined || !fetchOpsFromStorage, this.logger, \"CantFetchWithoutBaseline\"); // can't fetch if no baseline\n        // Note: There is race condition here.\n        // We want to issue request to storage as soon as possible, to\n        // reduce latency of becoming current, thus this code here.\n        // But there is no ordering between fetching OPs and connection to delta stream\n        // As result, we might be behind by the time we connect to delta stream\n        // In case of r/w connection, that's not an issue, because we will hear our\n        // own \"join\" message and realize any gap client has in ops.\n        // But for view-only connection, we have no such signal, and with no traffic\n        // on the wire, we might be always behind.\n        // See comment at the end of \"connect\" handler\n        if (fetchOpsFromStorage) {\n            this.fetchMissingDeltas(args.reason);\n        }\n        this.connectionManager.connect(args.mode);\n    }\n    async getDeltas(from, // inclusive\n    to, // exclusive\n    fetchReason, callback, cacheOnly) {\n        const docService = this.serviceProvider();\n        if (docService === undefined) {\n            throw new Error(\"Delta manager is not attached\");\n        }\n        if (this.deltaStorage === undefined) {\n            this.deltaStorage = await docService.connectToDeltaStorage();\n        }\n        let cancelFetch;\n        if (to !== undefined) {\n            const lastExpectedOp = to - 1; // make it inclusive!\n            // It is possible that due to asynchrony (including await above), required ops were already\n            // received through delta stream. Validate that before moving forward.\n            if (this.lastQueuedSequenceNumber >= lastExpectedOp) {\n                this.logger.sendPerformanceEvent(Object.assign({ reason: fetchReason, eventName: \"ExtraStorageCall\", early: true, from,\n                    to }, this.connectionManager.connectionVerboseProps));\n                return;\n            }\n            // Be prepared for the case where webSocket would receive the ops that we are trying to fill through\n            // storage. Ideally it should never happen (i.e. ops on socket are always ordered, and thus once we\n            // detected gap, this gap can't be filled in later on through websocket).\n            // And in practice that does look like the case. The place where this code gets hit is if we lost\n            // connection and reconnected (likely to another box), and new socket's initial ops contains these ops.\n            cancelFetch = (op) => op.sequenceNumber >= lastExpectedOp;\n        }\n        else {\n            // Unbound requests are made to proactively fetch ops, but also get up to date in cases where socket\n            // is silent (and connection is \"read\", thus we might not have any data on how far client is behind).\n            // Once we have any op coming in from socket, we can cancel it as it's not needed any more.\n            // That said, if we have socket connection, make sure we got ops up to checkpointSequenceNumber!\n            cancelFetch = (op) => op.sequenceNumber >= this.lastObservedSeqNumber;\n        }\n        const controller = new (abort_controller__WEBPACK_IMPORTED_MODULE_0___default())();\n        let opsFromFetch = false;\n        const opListener = (op) => {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(op.sequenceNumber === this.lastQueuedSequenceNumber, 0x23a /* \"seq#'s\" */);\n            // Ops that are coming from this request should not cancel itself.\n            // This is useless for known ranges (to is defined) as it means request is over either way.\n            // And it will cancel unbound request too early, not allowing us to learn where the end of the file is.\n            if (!opsFromFetch && cancelFetch(op)) {\n                controller.abort();\n                this._inbound.off(\"push\", opListener);\n            }\n        };\n        try {\n            this._inbound.on(\"push\", opListener);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.closeAbortController.signal.onabort === null, 0x1e8 /* \"reentrancy\" */);\n            this.closeAbortController.signal.onabort = () => controller.abort();\n            const stream = this.deltaStorage.fetchMessages(from, // inclusive\n            to, // exclusive\n            controller.signal, cacheOnly, fetchReason);\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const result = await stream.read();\n                if (result.done) {\n                    break;\n                }\n                try {\n                    opsFromFetch = true;\n                    callback(result.value);\n                }\n                finally {\n                    opsFromFetch = false;\n                }\n            }\n        }\n        finally {\n            this.closeAbortController.signal.onabort = null;\n            this._inbound.off(\"push\", opListener);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!opsFromFetch, 0x289 /* \"logic error\" */);\n        }\n    }\n    /**\n     * Closes the connection and clears inbound & outbound queues.\n     */\n    close(error) {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        this.connectionManager.dispose(error);\n        this.closeAbortController.abort();\n        this._inbound.clear();\n        this._inboundSignal.clear();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._inbound.pause();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._inboundSignal.pause();\n        // Drop pending messages - this will ensure catchUp() does not go into infinite loop\n        this.pending = [];\n        // This needs to be the last thing we do (before removing listeners), as it causes\n        // Container to dispose context and break ability of data stores / runtime to \"hear\"\n        // from delta manager, including notification (above) about readonly state.\n        this.emit(\"closed\", error);\n        this.removeAllListeners();\n    }\n    refreshDelayInfo(id) {\n        this.throttlingIdSet.delete(id);\n        if (this.throttlingIdSet.size === 0) {\n            this.timeTillThrottling = 0;\n        }\n    }\n    disconnectHandler(reason) {\n        this.messageBuffer.length = 0;\n        this.emit(\"disconnect\", reason);\n    }\n    /**\n     * Emit info about a delay in service communication on account of throttling.\n     * @param id - Id of the connection that is delayed\n     * @param delayMs - Duration of the delay\n     * @param error - error object indicating the throttling\n     */\n    emitDelayInfo(id, delayMs, error) {\n        const timeNow = Date.now();\n        this.throttlingIdSet.add(id);\n        if (delayMs > 0 && (timeNow + delayMs > this.timeTillThrottling)) {\n            this.timeTillThrottling = timeNow + delayMs;\n            const throttlingWarning = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.ThrottlingWarning.wrap(error, delayMs / 1000 /* retryAfterSeconds */, this.logger);\n            this.emit(\"throttled\", throttlingWarning);\n        }\n    }\n    // returns parts of message (in string format) that should never change for a given message.\n    // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.\n    // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.\n    // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number\n    // reuse.\n    // Also payload goes to telemetry, so no PII, including content!!\n    // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.\n    comparableMessagePayload(m) {\n        return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;\n    }\n    enqueueMessages(messages, reason, allowGaps = false) {\n        var _a, _b;\n        if (this.handler === undefined) {\n            // We did not setup handler yet.\n            // This happens when we connect to web socket faster than we get attributes for container\n            // and thus faster than attachOpHandler() is called\n            // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()\n            // to do the right thing.\n            this.pending = this.pending.concat(messages);\n            return;\n        }\n        // Pending ops should never just hang around for nothing.\n        // This invariant will stay true through this function execution,\n        // so there is no need to process pending ops here.\n        // It's responsibility of\n        // - attachOpHandler()\n        // - fetchMissingDeltas() after it's done with querying storage\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pending.length === 0 || this.fetchReason !== undefined, 0x1e9 /* \"Pending ops\" */);\n        if (messages.length === 0) {\n            return;\n        }\n        const from = messages[0].sequenceNumber;\n        const last = messages[messages.length - 1].sequenceNumber;\n        // Report stats about missing and duplicate ops\n        // This helps better understand why we fetch ops from storage, and thus may delay\n        // getting current / sending ops\n        // It's possible that this batch is already too late - do not bother\n        if (last > this.lastQueuedSequenceNumber) {\n            let prev = from - 1;\n            const initialGap = prev - this.lastQueuedSequenceNumber;\n            let firstMissing;\n            let duplicate = 0;\n            let gap = 0;\n            // Count all gaps and duplicates\n            for (const message of messages) {\n                if (message.sequenceNumber === prev) {\n                    duplicate++;\n                }\n                else if (message.sequenceNumber !== prev + 1) {\n                    gap++;\n                    if (firstMissing === undefined) {\n                        firstMissing = prev + 1;\n                    }\n                }\n                prev = message.sequenceNumber;\n            }\n            let eventName;\n            // Report if we found some issues\n            if (duplicate !== 0 || gap !== 0 && !allowGaps || initialGap > 0 && this.fetchReason === undefined) {\n                eventName = \"enqueueMessages\";\n                // Also report if we are fetching ops, and same range comes in, thus making this fetch obsolete.\n            }\n            else if (this.fetchReason !== undefined && this.fetchReason !== reason &&\n                (from <= this.lastQueuedSequenceNumber + 1 && last > this.lastQueuedSequenceNumber)) {\n                eventName = \"enqueueMessagesExtraFetch\";\n            }\n            // Report if there is something to report\n            // Do not report when pending fetch is in progress, as such reporting will not\n            // correctly take into account pending ops.\n            if (eventName !== undefined) {\n                this.logger.sendPerformanceEvent(Object.assign({ eventName,\n                    reason, previousReason: this.prevEnqueueMessagesReason, from, to: last + 1, length: messages.length, fetchReason: this.fetchReason, duplicate: duplicate > 0 ? duplicate : undefined, initialGap: initialGap !== 0 ? initialGap : undefined, gap: gap > 0 ? gap : undefined, firstMissing, dmInitialSeqNumber: this.initialSequenceNumber }, this.connectionManager.connectionVerboseProps));\n            }\n        }\n        this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);\n        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec /* \"Unexpected value for previously processed message's sequence number\" */);\n        for (const message of messages) {\n            // Check that the messages are arriving in the expected order\n            if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {\n                // Validate that we do not have data loss, i.e. sequencing is reset and started again\n                // with numbers that this client already observed before.\n                if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {\n                    const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);\n                    const message2 = this.comparableMessagePayload(message);\n                    if (message1 !== message2) {\n                        const error = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__.NonRetryableError(\n                        // This looks like a data corruption but the culprit was that the file was overwritten\n                        // in storage.  See PR #5882.\n                        // Likely to be an issue with Fluid Services. Content does not match previous client\n                        // knowledge about this file. If the file is overwritten for any reason, this error can be\n                        // hit. One example is that some clients could be submitting ops to two different service\n                        // instances such that the same sequence number is reused for two different ops.\n                        // pre-0.58 error message: twoMessagesWithSameSeqNumAndDifferentPayload\n                        \"Found two messages with the same sequenceNumber but different payloads. Likely to be a \"\n                            + \"service issue\", _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_10__.DriverErrorType.fileOverwrittenInStorage, {\n                            clientId: this.connectionManager.clientId,\n                            sequenceNumber: message.sequenceNumber,\n                            message1,\n                            message2,\n                            driverVersion: undefined,\n                        });\n                        this.close(error);\n                    }\n                }\n            }\n            else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {\n                this.pending.push(message);\n                this.fetchMissingDeltas(reason, message.sequenceNumber);\n            }\n            else {\n                this.lastQueuedSequenceNumber = message.sequenceNumber;\n                this.previouslyProcessedMessage = message;\n                this._inbound.push(message);\n            }\n        }\n        // When / if we report a gap in ops in the future, we want telemetry to correctly reflect source\n        // of prior ops. But if we have some out of order ops (this.pending), then reporting current reason\n        // becomes not accurate, as the gap existed before current batch, so we should just report \"unknown\".\n        this.prevEnqueueMessagesReason = this.pending.length > 0 ? \"unknown\" : reason;\n    }\n    processInboundMessage(message) {\n        const startTime = Date.now();\n        this.lastProcessedMessage = message;\n        // All non-system messages are coming from some client, and should have clientId\n        // System messages may have no clientId (but some do, like propose, noop, summarize)\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(message.clientId !== undefined\n            || !((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.isClientMessage)(message)), 0x0ed /* \"non-system message have to have clientId\" */);\n        // TODO Remove after SPO picks up the latest build.\n        if (typeof message.contents === \"string\"\n            && message.contents !== \"\"\n            && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.MessageType.ClientLeave) {\n            message.contents = JSON.parse(message.contents);\n        }\n        this.connectionManager.beforeProcessingIncomingOp(message);\n        // Watch the minimum sequence number and be ready to update as needed\n        if (this.minSequenceNumber > message.minimumSequenceNumber) {\n            // pre-0.58 error message: msnMovesBackwards\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError(\"Found a lower minimumSequenceNumber (msn) than previously recorded\", Object.assign(Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.extractSafePropertiesFromMessage)(message)), { clientId: this.connectionManager.clientId }));\n        }\n        this.minSequenceNumber = message.minimumSequenceNumber;\n        if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {\n            // pre-0.58 error message: nonSequentialSequenceNumber\n            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError(\"Found a non-Sequential sequenceNumber\", Object.assign(Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.extractSafePropertiesFromMessage)(message)), { clientId: this.connectionManager.clientId }));\n        }\n        this.lastProcessedSequenceNumber = message.sequenceNumber;\n        // a bunch of code assumes that this is true\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.lastProcessedSequenceNumber <= this.lastObservedSeqNumber, 0x267 /* \"lastObservedSeqNumber should be updated first\" */);\n        // Back-compat for older server with no term\n        if (message.term === undefined) {\n            message.term = 1;\n        }\n        this.baseTerm = message.term;\n        if (this.handler === undefined) {\n            throw new Error(\"Attempted to process an inbound message without a handler attached\");\n        }\n        this.handler.process(message);\n        const endTime = Date.now();\n        // Should be last, after changing this.lastProcessedSequenceNumber above, as many callers\n        // test this.lastProcessedSequenceNumber instead of using op.sequenceNumber itself.\n        this.emit(\"op\", message, endTime - startTime);\n    }\n    /**\n     * Retrieves the missing deltas between the given sequence numbers\n     */\n    fetchMissingDeltas(reasonArg, to) {\n        this.fetchMissingDeltasCore(reasonArg, false /* cacheOnly */, to).catch((error) => {\n            this.logger.sendErrorEvent({ eventName: \"fetchMissingDeltasException\" }, error);\n        });\n    }\n    /**\n    * Retrieves the missing deltas between the given sequence numbers\n    */\n    async fetchMissingDeltasCore(reason, cacheOnly, to) {\n        var _a;\n        // Exit out early if we're already fetching deltas\n        if (this.fetchReason !== undefined) {\n            return;\n        }\n        if (this.closed) {\n            this.logger.sendTelemetryEvent({ eventName: \"fetchMissingDeltasClosedConnection\", reason });\n            return;\n        }\n        if (this.handler === undefined) {\n            // We do not poses yet any information\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.lastQueuedSequenceNumber === 0, 0x26b /* \"initial state\" */);\n            return;\n        }\n        try {\n            let from = this.lastQueuedSequenceNumber + 1;\n            const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n            if (n !== undefined) {\n                // If we already processed at least one op, then we have this.previouslyProcessedMessage populated\n                // and can use it to validate that we are operating on same file, i.e. it was not overwritten.\n                // Knowing about this mechanism, we could ask for op we already observed to increase validation.\n                // This is especially useful when coming out of offline mode or loading from\n                // very old cached (by client / driver) snapshot.\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(n === this.lastQueuedSequenceNumber, 0x0f2 /* \"previouslyProcessedMessage\" */);\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(from > 1, 0x0f3 /* \"not positive\" */);\n                from--;\n            }\n            const fetchReason = `${reason}_fetch`;\n            this.fetchReason = fetchReason;\n            await this.getDeltas(from, to, fetchReason, (messages) => {\n                this.refreshDelayInfo(this.deltaStorageDelayId);\n                this.enqueueMessages(messages, fetchReason);\n            }, cacheOnly);\n        }\n        catch (error) {\n            this.logger.sendErrorEvent({ eventName: \"GetDeltas_Exception\" }, error);\n            this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeError)(error));\n        }\n        finally {\n            this.refreshDelayInfo(this.deltaStorageDelayId);\n            this.fetchReason = undefined;\n            this.processPendingOps(reason);\n        }\n    }\n    /**\n     * Sorts pending ops and attempts to apply them\n     */\n    processPendingOps(reason) {\n        if (this.closed) {\n            return;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.handler !== undefined, 0x26c /* \"handler should be installed\" */);\n        const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        this.pending = [];\n        // Given that we do not track where these ops came from any more, it's not very\n        // actionably to report gaps in this range.\n        this.enqueueMessages(pendingSorted, `${reason}_pending`, true /* allowGaps */);\n        // Re-entrancy is ignored by fetchMissingDeltas, execution will come here when it's over\n        if (this.fetchReason === undefined) {\n            // See issue #7312 for more details\n            // We observe cases where client gets into situation where it is not aware of missing ops\n            // (i.e. client being behind), and as such, does not attempt to fetch them.\n            // In some cases client may not have enough signal (example - \"read\" connection that is silent -\n            // there is no easy way for client to realize it's behind, see a bit of commentary / logic at the\n            // end of setupNewSuccessfulConnection). In other cases it should be able to learn that info (\"write\"\n            // connection, learn by receiving its own join op), but data suggest it does not happen.\n            // In 50% of these cases we do know we are behind through checkpointSequenceNumber on connection object\n            // and thus can leverage that to trigger recovery. But this is not going to solve all the problems\n            // (the other 50%), and thus these errors below should be looked at even if code below results in\n            // recovery.\n            if (this.lastQueuedSequenceNumber < this.lastObservedSeqNumber) {\n                this.fetchMissingDeltas(\"OpsBehind\");\n            }\n        }\n    }\n    updateLatestKnownOpSeqNumber(seq) {\n        if (this.lastObservedSeqNumber < seq) {\n            this.lastObservedSeqNumber = seq;\n        }\n    }\n}\n//# sourceMappingURL=deltaManager.js.map\n\n/***/ }),\n/* 538 */\n/***/ ((module) => {\n\n\"use strict\";\n/*globals self, window */\n\n\n/*eslint-disable @mysticatea/prettier */\nconst { AbortController, AbortSignal } =\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    /* otherwise */ undefined\n/*eslint-enable @mysticatea/prettier */\n\nmodule.exports = AbortController\nmodule.exports.AbortSignal = AbortSignal\nmodule.exports[\"default\"] = AbortController\n\n\n/***/ }),\n/* 539 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeltaQueue\": () => (/* binding */ DeltaQueue)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(526);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(488);\n/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);\n/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(double_ended_queue__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass DeltaQueue extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TypedEventEmitter {\n    /**\n     * @param worker - A callback to process a delta.\n     * @param logger - For logging telemetry.\n     */\n    constructor(worker) {\n        super();\n        this.worker = worker;\n        this.isDisposed = false;\n        this.q = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())();\n        /**\n         * Tracks the number of pause requests for the queue\n         * The DeltaQueue is create initially paused.\n         */\n        this.pauseCount = 1;\n    }\n    get disposed() {\n        return this.isDisposed;\n    }\n    /**\n     * @returns True if the queue is paused, false if not.\n     */\n    get paused() {\n        return this.pauseCount !== 0;\n    }\n    get length() {\n        return this.q.length;\n    }\n    get idle() {\n        return this.processingPromise === undefined && this.q.length === 0;\n    }\n    async waitTillProcessingDone() {\n        var _a;\n        return (_a = this.processingPromise) !== null && _a !== void 0 ? _a : { count: 0, duration: 0 };\n    }\n    dispose() {\n        throw new Error(\"Not implemented.\");\n        this.isDisposed = true;\n    }\n    clear() {\n        this.q.clear();\n    }\n    peek() {\n        return this.q.peekFront();\n    }\n    toArray() {\n        return this.q.toArray();\n    }\n    push(task) {\n        try {\n            this.q.push(task);\n            this.emit(\"push\", task);\n            this.ensureProcessing();\n        }\n        catch (error) {\n            this.emit(\"error\", error);\n        }\n    }\n    async pause() {\n        this.pauseCount++;\n        // If called from within the processing loop, we are in the middle of processing an op. Return a promise\n        // that will resolve when processing has actually stopped.\n        await this.waitTillProcessingDone();\n    }\n    resume() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseCount > 0, 0x0f4 /* \"Nonzero pause-count on resume()\" */);\n        this.pauseCount--;\n        this.ensureProcessing();\n    }\n    /**\n     * There are several actions that may need to kick off delta processing, so we want to guard against\n     * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is\n     * not already started.\n     */\n    ensureProcessing() {\n        if (this.anythingToProcess() && this.processingPromise === undefined) {\n            // Use a resolved promise to start the processing on a separate stack.\n            this.processingPromise = Promise.resolve().then(() => {\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.processingPromise !== undefined, \"reentrancy?\");\n                const result = this.processDeltas();\n                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.processingPromise !== undefined, \"reentrancy?\");\n                // WARNING: Do not move next line to .finally() clause!\n                // It runs async and creates a race condition where incoming ensureProcessing() call observes\n                // from previous run while previous run is over (but finally clause was not scheduled yet)\n                this.processingPromise = undefined;\n                return result;\n            }).catch((error) => {\n                this.error = error;\n                this.processingPromise = undefined;\n                this.emit(\"error\", error);\n                return { count: 0, duration: 0 };\n            });\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.processingPromise !== undefined, \"processDeltas() should run async\");\n        }\n    }\n    anythingToProcess() {\n        return this.q.length !== 0 && !this.paused && this.error === undefined;\n    }\n    /**\n     * Executes the delta processing loop until a stop condition is reached.\n     */\n    processDeltas() {\n        const start = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now();\n        let count = 0;\n        // For grouping to work we must process all local messages immediately and in the single turn.\n        // So loop over them until no messages to process, we have become paused, or hit an error.\n        while (this.anythingToProcess()) {\n            // Get the next message in the queue\n            const next = this.q.shift();\n            count++;\n            // Process the message.\n            // We know next is defined since we did a length check just prior to shifting.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.worker(next);\n            this.emit(\"op\", next);\n        }\n        const duration = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now() - start;\n        if (this.q.length === 0) {\n            this.emit(\"idle\", count, duration);\n        }\n        return { count, duration };\n    }\n}\n//# sourceMappingURL=deltaQueue.js.map\n\n/***/ }),\n/* 540 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"logIfFalse\": () => (/* binding */ logIfFalse)\n/* harmony export */ });\n/**\n * Like assert, but logs only if the condition is false, rather than throwing\n * @param condition - The condition to attest too\n * @param logger - The logger to log with\n * @param event - The string or event to log\n * @returns - The outcome of the condition\n */\nfunction logIfFalse(condition, logger, event) {\n    if (condition) {\n        return true;\n    }\n    const newEvent = typeof event === \"string\"\n        ? { eventName: event, category: \"error\" }\n        : Object.assign({ category: \"error\" }, event);\n    logger.send(newEvent);\n    return false;\n}\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 541 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConnectionManager\": () => (/* binding */ ConnectionManager)\n/* harmony export */ });\n/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(538);\n/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(abort_controller__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(526);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(488);\n/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(456);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(542);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(535);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(45);\n/* harmony import */ var _contracts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(522);\n/* harmony import */ var _deltaQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(539);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\n\n\n\n\nconst MaxReconnectDelayInMs = 8000;\nconst InitialReconnectDelayInMs = 1000;\nconst DefaultChunkSize = 16 * 1024;\nconst fatalConnectErrorProp = { fatalConnectError: true };\nfunction getNackReconnectInfo(nackContent) {\n    const message = `Nack (${nackContent.type}): ${nackContent.message}`;\n    const canRetry = nackContent.code !== 403;\n    const retryAfterMs = nackContent.retryAfter !== undefined ? nackContent.retryAfter * 1000 : undefined;\n    return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createGenericNetworkError)(message, { canRetry, retryAfterMs }, { statusCode: nackContent.code, driverVersion: undefined });\n}\n/**\n * Implementation of IDocumentDeltaConnection that does not support submitting\n * or receiving ops. Used in storage-only mode.\n */\nclass NoDeltaStream extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    constructor() {\n        super(...arguments);\n        this.clientId = \"storage-only client\";\n        this.claims = {\n            scopes: [_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType.DocRead],\n        };\n        this.mode = \"read\";\n        this.existing = true;\n        this.maxMessageSize = 0;\n        this.version = \"\";\n        this.initialMessages = [];\n        this.initialSignals = [];\n        this.initialClients = [];\n        this.serviceConfiguration = {\n            maxMessageSize: 0,\n            blockSize: 0,\n            summary: undefined,\n        };\n        this.checkpointSequenceNumber = undefined;\n        this._disposed = false;\n    }\n    submit(messages) {\n        this.emit(\"nack\", this.clientId, messages.map((operation) => {\n            return {\n                operation,\n                content: { message: \"Cannot submit with storage-only connection\", code: 403 },\n            };\n        }));\n    }\n    submitSignal(message) {\n        this.emit(\"nack\", this.clientId, {\n            operation: message,\n            content: { message: \"Cannot submit signal with storage-only connection\", code: 403 },\n        });\n    }\n    get disposed() { return this._disposed; }\n    dispose() { this._disposed = true; }\n}\n/**\n * Implementation of IConnectionManager, used by Container class\n * Implements constant connectivity to relay service, by reconnecting in case of loast connection or error.\n * Exposes various controls to influecen this process, including manual reconnects, forced read-only mode, etc.\n */\nclass ConnectionManager {\n    constructor(serviceProvider, client, reconnectAllowed, logger, props) {\n        this.serviceProvider = serviceProvider;\n        this.client = client;\n        this.logger = logger;\n        this.props = props;\n        /** tracks host requiring read-only mode. */\n        this._forceReadonly = false;\n        /** True if there is pending (async) reconnection from \"read\" to \"write\" */\n        this.pendingReconnect = false;\n        this.clientSequenceNumber = 0;\n        this.clientSequenceNumberObserved = 0;\n        /** Counts the number of noops sent by the client which may not be acked. */\n        this.trailingNoopCount = 0;\n        this.connectFirstConnection = true;\n        this._connectionVerboseProps = {};\n        this._connectionProps = {};\n        this.closed = false;\n        this.opHandler = (documentId, messagesArg) => {\n            const messages = Array.isArray(messagesArg) ? messagesArg : [messagesArg];\n            this.props.incomingOpHandler(messages, \"opHandler\");\n        };\n        // Always connect in write mode after getting nacked.\n        this.nackHandler = (documentId, messages) => {\n            const message = messages[0];\n            if (this._readonlyPermissions === true) {\n                this.props.closeHandler((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createWriteError)(\"writeOnReadOnlyDocument\", { driverVersion: undefined }));\n                return;\n            }\n            const reconnectInfo = getNackReconnectInfo(message.content);\n            // If the nack indicates we cannot retry, then close the container outright\n            if (!reconnectInfo.canRetry) {\n                this.props.closeHandler(reconnectInfo);\n                return;\n            }\n            this.reconnectOnError(\"write\", reconnectInfo);\n        };\n        // Connection mode is always read on disconnect/error unless the system mode was write.\n        this.disconnectHandlerInternal = (disconnectReason) => {\n            // Note: we might get multiple disconnect calls on same socket, as early disconnect notification\n            // (\"server_disconnect\", ODSP-specific) is mapped to \"disconnect\"\n            this.reconnectOnError(this.defaultReconnectionMode, disconnectReason);\n        };\n        this.errorHandler = (error) => {\n            this.reconnectOnError(this.defaultReconnectionMode, error);\n        };\n        this.clientDetails = this.client.details;\n        this.defaultReconnectionMode = this.client.mode;\n        this._reconnectMode = reconnectAllowed ? _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled : _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never;\n        // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained\n        // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.\n        this._outbound = new _deltaQueue__WEBPACK_IMPORTED_MODULE_5__.DeltaQueue((messages) => {\n            if (this.connection === undefined) {\n                throw new Error(\"Attempted to submit an outbound message without connection\");\n            }\n            this.connection.submit(messages);\n        });\n        this._outbound.on(\"error\", (error) => {\n            this.props.closeHandler((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.normalizeError)(error));\n        });\n    }\n    get connectionVerboseProps() { return this._connectionVerboseProps; }\n    /**\n     * The current connection mode, initially read.\n     */\n    get connectionMode() {\n        var _a, _b;\n        return (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : \"read\";\n    }\n    get connected() { return this.connection !== undefined; }\n    get clientId() { var _a; return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId; }\n    /**\n     * Automatic reconnecting enabled or disabled.\n     * If set to Never, then reconnecting will never be allowed.\n     */\n    get reconnectMode() {\n        return this._reconnectMode;\n    }\n    get maxMessageSize() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize) !== null && _c !== void 0 ? _c : DefaultChunkSize;\n    }\n    get version() {\n        if (this.connection === undefined) {\n            throw new Error(\"Cannot check version without a connection\");\n        }\n        return this.connection.version;\n    }\n    get serviceConfiguration() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;\n    }\n    get scopes() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;\n    }\n    get outbound() {\n        return this._outbound;\n    }\n    /**\n     * Returns set of props that can be logged in telemetry that provide some insights / statistics\n     * about current or last connection (if there is no connection at the moment)\n    */\n    get connectionProps() {\n        if (this.connection !== undefined) {\n            return this._connectionProps;\n        }\n        else {\n            return Object.assign(Object.assign({}, this._connectionProps), { \n                // Report how many ops this client sent in last disconnected session\n                sentOps: this.clientSequenceNumber });\n        }\n    }\n    shouldJoinWrite() {\n        // We don't have to wait for ack for topmost NoOps. So subtract those.\n        return this.clientSequenceNumberObserved < (this.clientSequenceNumber - this.trailingNoopCount);\n    }\n    /**\n     * Tells if container is in read-only mode.\n     * Data stores should listen for \"readonly\" notifications and disallow user\n     * making changes to data stores.\n     * Readonly state can be because of no storage write permission,\n     * or due to host forcing readonly mode for container.\n     * It is undefined if we have not yet established websocket connection\n     * and do not know if user has write access to a file.\n     */\n    get readonly() {\n        if (this._forceReadonly) {\n            return true;\n        }\n        return this._readonlyPermissions;\n    }\n    get readOnlyInfo() {\n        const storageOnly = this.connection !== undefined && this.connection instanceof NoDeltaStream;\n        if (storageOnly || this._forceReadonly || this._readonlyPermissions === true) {\n            return {\n                readonly: true,\n                forced: this._forceReadonly,\n                permissions: this._readonlyPermissions,\n                storageOnly,\n            };\n        }\n        return { readonly: this._readonlyPermissions };\n    }\n    static detailsFromConnection(connection) {\n        return {\n            claims: connection.claims,\n            clientId: connection.clientId,\n            existing: connection.existing,\n            checkpointSequenceNumber: connection.checkpointSequenceNumber,\n            get initialClients() { return connection.initialClients; },\n            mode: connection.mode,\n            serviceConfiguration: connection.serviceConfiguration,\n            version: connection.version,\n        };\n    }\n    dispose(error) {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        this.pendingConnection = undefined;\n        // Ensure that things like triggerConnect() will short circuit\n        this._reconnectMode = _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never;\n        this._outbound.clear();\n        const disconnectReason = error !== undefined\n            ? `Closing DeltaManager (${error.message})`\n            : \"Closing DeltaManager\";\n        // This raises \"disconnect\" event if we have active connection.\n        this.disconnectFromDeltaStream(disconnectReason);\n        // Notify everyone we are in read-only state.\n        // Useful for data stores in case we hit some critical error,\n        // to switch to a mode where user edits are not accepted\n        this.set_readonlyPermissions(true);\n    }\n    /**\n     * Enables or disables automatic reconnecting.\n     * Will throw an error if reconnectMode set to Never.\n    */\n    setAutoReconnect(mode) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(mode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never && this._reconnectMode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never, 0x278 /* \"API is not supported for non-connecting or closed container\" */);\n        this._reconnectMode = mode;\n        if (mode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled) {\n            // immediately disconnect - do not rely on service eventually dropping connection.\n            this.disconnectFromDeltaStream(\"setAutoReconnect\");\n        }\n    }\n    /**\n     * Sends signal to runtime (and data stores) to be read-only.\n     * Hosts may have read only views, indicating to data stores that no edits are allowed.\n     * This is independent from this._readonlyPermissions (permissions) and this.connectionMode\n     * (server can return \"write\" mode even when asked for \"read\")\n     * Leveraging same \"readonly\" event as runtime & data stores should behave the same in such case\n     * as in read-only permissions.\n     * But this.active can be used by some DDSes to figure out if ops can be sent\n     * (for example, read-only view still participates in code proposals / upgrades decisions)\n     *\n     * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour\n     * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If\n     * there are pending in the outbound queue, it will stop sending until force readonly is\n     * cleared.\n     *\n     * @param readonly - set or clear force readonly.\n     */\n    forceReadonly(readonly) {\n        if (readonly !== this._forceReadonly) {\n            this.logger.sendTelemetryEvent({\n                eventName: \"ForceReadOnly\",\n                value: readonly,\n            });\n        }\n        const oldValue = this.readonly;\n        this._forceReadonly = readonly;\n        if (oldValue !== this.readonly) {\n            if (this._reconnectMode === _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never) {\n                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.UsageError(\"API is not supported for non-connecting or closed container\");\n            }\n            let reconnect = false;\n            if (this.readonly === true) {\n                // If we switch to readonly while connected, we should disconnect first\n                // See comment in the \"readonly\" event handler to deltaManager set up by\n                // the ContainerRuntime constructor\n                if (this.shouldJoinWrite()) {\n                    // If we have pending changes, then we will never send them - it smells like\n                    // host logic error.\n                    this.logger.sendErrorEvent({ eventName: \"ForceReadonlyPendingChanged\" });\n                }\n                reconnect = this.disconnectFromDeltaStream(\"Force readonly\");\n            }\n            this.props.readonlyChangeHandler(this.readonly);\n            if (reconnect) {\n                // reconnect if we disconnected from before.\n                this.triggerConnect(\"read\");\n            }\n        }\n    }\n    set_readonlyPermissions(readonly) {\n        const oldValue = this.readonly;\n        this._readonlyPermissions = readonly;\n        if (oldValue !== this.readonly) {\n            this.props.readonlyChangeHandler(this.readonly);\n        }\n    }\n    connect(connectionMode) {\n        this.connectCore(connectionMode).catch((error) => {\n            const normalizedError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.normalizeError)(error, { props: fatalConnectErrorProp });\n            this.props.closeHandler(normalizedError);\n        });\n    }\n    async connectCore(connectionMode) {\n        var _a, _b;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!this.closed, 0x26a /* \"not closed\" */);\n        if (this.connection !== undefined) {\n            return; // Connection attempt already completed successfully\n        }\n        let pendingConnectionMode;\n        if (this.pendingConnection !== undefined) {\n            pendingConnectionMode = this.pendingConnection.connectionMode;\n            this.cancelConnection(); // Throw out in-progress connection attempt in favor of new attempt\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection === undefined, 0x344 /* this.pendingConnection should be undefined */);\n        }\n        // If there is no specified ConnectionMode, try the previous mode, if there is no previous mode use default\n        let requestedMode = (_a = connectionMode !== null && connectionMode !== void 0 ? connectionMode : pendingConnectionMode) !== null && _a !== void 0 ? _a : this.defaultReconnectionMode;\n        // if we have any non-acked ops from last connection, reconnect as \"write\".\n        // without that we would connect in view-only mode, which will result in immediate\n        // firing of \"connected\" event from Container and switch of current clientId (as tracked\n        // by all DDSes). This will make it impossible to figure out if ops actually made it through,\n        // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document\n        if (this.shouldJoinWrite()) {\n            requestedMode = \"write\";\n        }\n        const docService = this.serviceProvider();\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(docService !== undefined, 0x2a7 /* \"Container is not attached\" */);\n        let connection;\n        if (((_b = docService.policies) === null || _b === void 0 ? void 0 : _b.storageOnly) === true) {\n            connection = new NoDeltaStream();\n            this.setupNewSuccessfulConnection(connection, \"read\");\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection === undefined, 0x2b3 /* \"logic error\" */);\n            return;\n        }\n        let delayMs = InitialReconnectDelayInMs;\n        let connectRepeatCount = 0;\n        const connectStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();\n        let lastError;\n        const abortController = new (abort_controller__WEBPACK_IMPORTED_MODULE_0___default())();\n        const abortSignal = abortController.signal;\n        this.pendingConnection = { abort: () => { abortController.abort(); }, connectionMode: requestedMode };\n        // This loop will keep trying to connect until successful, with a delay between each iteration.\n        while (connection === undefined) {\n            if (this.closed) {\n                throw new Error(\"Attempting to connect a closed DeltaManager\");\n            }\n            if (abortSignal.aborted === true) {\n                this.logger.sendTelemetryEvent({\n                    eventName: \"ConnectionAttemptCancelled\",\n                    attempts: connectRepeatCount,\n                    duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),\n                    connectionEstablished: false,\n                });\n                return;\n            }\n            connectRepeatCount++;\n            try {\n                this.client.mode = requestedMode;\n                connection = await docService.connectToDeltaStream(Object.assign(Object.assign({}, this.client), { mode: requestedMode }));\n                if (connection.disposed) {\n                    // Nobody observed this connection, so drop it on the floor and retry.\n                    this.logger.sendTelemetryEvent({ eventName: \"ReceivedClosedConnection\" });\n                    connection = undefined;\n                }\n            }\n            catch (origError) {\n                if (typeof origError === \"object\" && origError !== null &&\n                    (origError === null || origError === void 0 ? void 0 : origError.errorType) === _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.DeltaStreamConnectionForbiddenError.errorType) {\n                    connection = new NoDeltaStream();\n                    requestedMode = \"read\";\n                    break;\n                }\n                // Socket.io error when we connect to wrong socket, or hit some multiplexing bug\n                if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.canRetryOnError)(origError)) {\n                    const error = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.normalizeError)(origError, { props: fatalConnectErrorProp });\n                    this.props.closeHandler(error);\n                    throw error;\n                }\n                // Since the error is retryable this will not log to the error table\n                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.logNetworkFailure)(this.logger, {\n                    attempts: connectRepeatCount,\n                    delay: delayMs,\n                    eventName: \"DeltaConnectionFailureToConnect\",\n                    duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),\n                }, origError);\n                lastError = origError;\n                const retryDelayFromError = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.getRetryDelayFromError)(origError);\n                delayMs = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delayMs * 2, MaxReconnectDelayInMs);\n                if (retryDelayFromError !== undefined) {\n                    this.props.reconnectionDelayHandler(retryDelayFromError, origError);\n                }\n                await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.waitForConnectedState)(delayMs);\n            }\n        }\n        // If we retried more than once, log an event about how long it took (this will not log to error table)\n        if (connectRepeatCount > 1) {\n            (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.logNetworkFailure)(this.logger, {\n                eventName: \"MultipleDeltaConnectionFailures\",\n                attempts: connectRepeatCount,\n                duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),\n            }, lastError);\n        }\n        // Check for abort signal after while loop as well\n        if (abortSignal.aborted === true) {\n            connection.dispose();\n            this.logger.sendTelemetryEvent({\n                eventName: \"ConnectionAttemptCancelled\",\n                attempts: connectRepeatCount,\n                duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),\n                connectionEstablished: true,\n            });\n            return;\n        }\n        this.setupNewSuccessfulConnection(connection, requestedMode);\n    }\n    /**\n     * Start the connection. Any error should result in container being close.\n     * And report the error if it excape for any reason.\n     * @param args - The connection arguments\n     */\n    triggerConnect(connectionMode) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection === undefined, 0x239 /* \"called only in disconnected state\" */);\n        if (this.reconnectMode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled) {\n            return;\n        }\n        this.connect(connectionMode);\n    }\n    /**\n     * Disconnect the current connection.\n     * @param reason - Text description of disconnect reason to emit with disconnect event\n     * @returns A boolean that indicates if there was an existing connection (or pending connection) to disconnect\n     */\n    disconnectFromDeltaStream(reason) {\n        this.pendingReconnect = false;\n        if (this.connection === undefined) {\n            if (this.pendingConnection !== undefined) {\n                this.cancelConnection();\n                return true;\n            }\n            return false;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection === undefined, 0x27b /* \"reentrancy may result in incorrect behavior\" */);\n        const connection = this.connection;\n        // Avoid any re-entrancy - clear object reference\n        this.connection = undefined;\n        // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError\n        connection.off(\"op\", this.opHandler);\n        connection.off(\"signal\", this.props.signalHandler);\n        connection.off(\"nack\", this.nackHandler);\n        connection.off(\"disconnect\", this.disconnectHandlerInternal);\n        connection.off(\"error\", this.errorHandler);\n        connection.off(\"pong\", this.props.pongHandler);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._outbound.pause();\n        this._outbound.clear();\n        this.props.disconnectHandler(reason);\n        connection.dispose();\n        this._connectionVerboseProps = {};\n        return true;\n    }\n    /**\n     * Cancel in-progress connection attempt.\n     */\n    cancelConnection() {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection !== undefined, 0x345 /* this.pendingConnection is undefined when trying to cancel */);\n        this.pendingConnection.abort();\n        this.pendingConnection = undefined;\n        this.logger.sendTelemetryEvent({ eventName: \"ConnectionCancelReceived\" });\n    }\n    /**\n     * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process\n     * initial messages.\n     * @param connection - The newly established connection\n     */\n    setupNewSuccessfulConnection(connection, requestedMode) {\n        // Old connection should have been cleaned up before establishing a new one\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection === undefined, 0x0e6 /* \"old connection exists on new connection setup\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!connection.disposed, 0x28a /* \"can't be disposed - Callers need to ensure that!\" */);\n        this.pendingConnection = undefined;\n        this.connection = connection;\n        // Does information in scopes & mode matches?\n        // If we asked for \"write\" and got \"read\", then file is read-only\n        // But if we ask read, server can still give us write.\n        const readonly = !connection.claims.scopes.includes(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType.DocWrite);\n        // This connection mode validation logic is moving to the driver layer in 0.44.  These two asserts can be\n        // removed after those packages have released and become ubiquitous.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(requestedMode === \"read\" || readonly === (this.connectionMode === \"read\"), 0x0e7 /* \"claims/connectionMode mismatch\" */);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!readonly || this.connectionMode === \"read\", 0x0e8 /* \"readonly perf with write connection\" */);\n        this.set_readonlyPermissions(readonly);\n        if (this.closed) {\n            // Raise proper events, Log telemetry event and close connection.\n            this.disconnectFromDeltaStream(\"ConnectionManager already closed\");\n            return;\n        }\n        this._outbound.resume();\n        connection.on(\"op\", this.opHandler);\n        connection.on(\"signal\", this.props.signalHandler);\n        connection.on(\"nack\", this.nackHandler);\n        connection.on(\"disconnect\", this.disconnectHandlerInternal);\n        connection.on(\"error\", this.errorHandler);\n        connection.on(\"pong\", this.props.pongHandler);\n        // Initial messages are always sorted. However, due to early op handler installed by drivers and appending those\n        // ops to initialMessages, resulting set is no longer sorted, which would result in client hitting storage to\n        // fill in gap. We will recover by cancelling this request once we process remaining ops, but it's a waste that\n        // we could avoid\n        const initialMessages = connection.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        // Some storages may provide checkpointSequenceNumber to identify how far client is behind.\n        let checkpointSequenceNumber = connection.checkpointSequenceNumber;\n        this._connectionVerboseProps = {\n            clientId: connection.clientId,\n            mode: connection.mode,\n        };\n        // reset connection props\n        this._connectionProps = {};\n        if (connection.relayServiceAgent !== undefined) {\n            this._connectionVerboseProps.relayServiceAgent = connection.relayServiceAgent;\n            this._connectionProps.relayServiceAgent = connection.relayServiceAgent;\n        }\n        this._connectionProps.socketDocumentId = connection.claims.documentId;\n        this._connectionProps.connectionMode = connection.mode;\n        let last = -1;\n        if (initialMessages.length !== 0) {\n            this._connectionVerboseProps.connectionInitialOpsFrom = initialMessages[0].sequenceNumber;\n            last = initialMessages[initialMessages.length - 1].sequenceNumber;\n            this._connectionVerboseProps.connectionInitialOpsTo = last + 1;\n            // Update knowledge of how far we are behind, before raising \"connect\" event\n            // This is duplication of what incomingOpHandler() does, but we have to raise event before we get there,\n            // so duplicating update logic here as well.\n            if (checkpointSequenceNumber === undefined || checkpointSequenceNumber < last) {\n                checkpointSequenceNumber = last;\n            }\n        }\n        this.props.incomingOpHandler(initialMessages, this.connectFirstConnection ? \"InitialOps\" : \"ReconnectOps\");\n        if (connection.initialSignals !== undefined) {\n            for (const signal of connection.initialSignals) {\n                this.props.signalHandler(signal);\n            }\n        }\n        const details = ConnectionManager.detailsFromConnection(connection);\n        details.checkpointSequenceNumber = checkpointSequenceNumber;\n        this.props.connectHandler(details);\n        this.connectFirstConnection = false;\n    }\n    /**\n     * Disconnect the current connection and reconnect. Closes the container if it fails.\n     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection\n     * @param requestedMode - Read or write\n     * @param error - Error reconnect information including whether or not to reconnect\n     * @returns A promise that resolves when the connection is reestablished or we stop trying\n     */\n    reconnectOnError(requestedMode, error) {\n        this.reconnect(requestedMode, error.message, error)\n            .catch(this.props.closeHandler);\n    }\n    /**\n     * Disconnect the current connection and reconnect.\n     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection\n     * @param requestedMode - Read or write\n     * @param error - Error reconnect information including whether or not to reconnect\n     * @returns A promise that resolves when the connection is reestablished or we stop trying\n     */\n    async reconnect(requestedMode, disconnectMessage, error) {\n        // We quite often get protocol errors before / after observing nack/disconnect\n        // we do not want to run through same sequence twice.\n        // If we're already disconnected/disconnecting it's not appropriate to call this again.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection !== undefined, 0x0eb /* \"Missing connection for reconnect\" */);\n        this.disconnectFromDeltaStream(disconnectMessage);\n        // We will always trigger reconnect, even if canRetry is false.\n        // Any truly fatal error state will result in container close upon attempted reconnect,\n        // which is a preferable to closing abruptly when a live connection fails.\n        if (error !== undefined && !error.canRetry) {\n            this.logger.sendTelemetryEvent({\n                eventName: \"reconnectingDespiteFatalError\",\n                reconnectMode: this.reconnectMode,\n            }, error);\n        }\n        if (this.reconnectMode === _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never) {\n            // Do not raise container error if we are closing just because we lost connection.\n            // Those errors (like IdleDisconnect) would show up in telemetry dashboards and\n            // are very misleading, as first initial reaction - some logic is broken.\n            this.props.closeHandler();\n        }\n        // If closed then we can't reconnect\n        if (this.closed || this.reconnectMode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled) {\n            return;\n        }\n        const delayMs = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.getRetryDelayFromError)(error);\n        if (error !== undefined && delayMs !== undefined) {\n            this.props.reconnectionDelayHandler(delayMs, error);\n            await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.waitForConnectedState)(delayMs);\n        }\n        this.triggerConnect(requestedMode);\n    }\n    prepareMessageToSend(message) {\n        var _a, _b;\n        if (this.readonly === true) {\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.readOnlyInfo.readonly === true, 0x1f0 /* \"Unexpected mismatch in readonly\" */);\n            const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.GenericError(\"deltaManagerReadonlySubmit\", undefined /* error */, {\n                readonly: this.readOnlyInfo.readonly,\n                forcedReadonly: this.readOnlyInfo.forced,\n                readonlyPermissions: this.readOnlyInfo.permissions,\n                storageOnly: this.readOnlyInfo.storageOnly,\n            });\n            this.props.closeHandler(error);\n            return undefined;\n        }\n        // reset clientSequenceNumber if we are using new clientId.\n        // we keep info about old connection as long as possible to be able to account for all non-acked ops\n        // that we pick up on next connection.\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this.connection, 0x0e4 /* \"Lost old connection!\" */);\n        if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {\n            this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;\n            this.clientSequenceNumber = 0;\n            this.clientSequenceNumberObserved = 0;\n        }\n        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.MessageType.NoOp) {\n            this.trailingNoopCount++;\n        }\n        else {\n            this.trailingNoopCount = 0;\n        }\n        return Object.assign(Object.assign({}, message), { clientSequenceNumber: ++this.clientSequenceNumber });\n    }\n    submitSignal(content) {\n        if (this.connection !== undefined) {\n            this.connection.submitSignal(content);\n        }\n        else {\n            this.logger.sendErrorEvent({ eventName: \"submitSignalDisconnected\" });\n        }\n    }\n    sendMessages(messages) {\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connected, 0x2b4 /* \"not connected on sending ops!\" */);\n        // If connection is \"read\" or implicit \"read\" (got leave op for \"write\" connection),\n        // then op can't make it through - we will get a nack if op is sent.\n        // We can short-circuit this process.\n        // Note that we also want nacks to be rare and be treated as catastrophic failures.\n        // Be careful with reentrancy though - disconnected event should not be be raised in the\n        // middle of the current workflow, but rather on clean stack!\n        if (this.connectionMode === \"read\") {\n            if (!this.pendingReconnect) {\n                this.pendingReconnect = true;\n                Promise.resolve().then(async () => {\n                    if (this.pendingReconnect) { // still valid?\n                        await this.reconnect(\"write\", // connectionMode\n                        \"Switch to write\");\n                    }\n                })\n                    .catch(() => { });\n            }\n            return;\n        }\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!this.pendingReconnect, 0x2b5 /* \"logic error\" */);\n        this._outbound.push(messages);\n    }\n    beforeProcessingIncomingOp(message) {\n        // if we have connection, and message is local, then we better treat is as local!\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.clientId !== message.clientId || this.lastSubmittedClientId === message.clientId, 0x0ee /* \"Not accounting local messages correctly\" */);\n        if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {\n            const clientSequenceNumber = message.clientSequenceNumber;\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.clientSequenceNumberObserved < clientSequenceNumber, 0x0ef /* \"client seq# not growing\" */);\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(clientSequenceNumber <= this.clientSequenceNumber, 0x0f0 /* \"Incoming local client seq# > generated by this client\" */);\n            this.clientSequenceNumberObserved = clientSequenceNumber;\n        }\n        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.MessageType.ClientLeave) {\n            const systemLeaveMessage = message;\n            const clientId = JSON.parse(systemLeaveMessage.data);\n            if (clientId === this.clientId) {\n                // We have been kicked out from quorum\n                this.logger.sendPerformanceEvent({ eventName: \"ReadConnectionTransition\" });\n                // Please see #8483 for more details on why maintaining connection further as is would not work.\n                // Short story - connection properties are immutable, and many processes (consensus DDSes, summarizer)\n                // assume that connection stays \"write\" connection until disconnect, and act accordingly, which may\n                // not work well with de-facto \"read\" connection we are in after receiving own leave op on timeout.\n                // Clients need to be able to transition to \"read\" state after some time of inactivity!\n                // Note - this may close container!\n                this.reconnect(\"read\", // connectionMode\n                \"Switch to read\").catch((error) => {\n                    this.logger.sendErrorEvent({ eventName: \"SwitchToReadConnection\" }, error);\n                });\n            }\n        }\n    }\n}\n//# sourceMappingURL=connectionManager.js.map\n\n/***/ }),\n/* 542 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScopeType\": () => (/* binding */ ScopeType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar ScopeType;\n(function (ScopeType) {\n    ScopeType[\"DocRead\"] = \"doc:read\";\n    ScopeType[\"DocWrite\"] = \"doc:write\";\n    ScopeType[\"SummaryWrite\"] = \"summary:write\";\n})(ScopeType || (ScopeType = {}));\n//# sourceMappingURL=scopes.js.map\n\n/***/ }),\n/* 543 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CollabWindowTracker\": () => (/* binding */ CollabWindowTracker)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(491);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(535);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\nconst defaultNoopTimeFrequency = 2000;\nconst defaultNoopCountFrequency = 50;\n// Here are key considerations when deciding conditions for when to send non-immediate noops:\n// 1. Sending them too often results in increase in file size and bandwidth, as well as catch up performance\n// 2. Sending too infrequently ensures that collab window is large, and as result Sequence DDS would have\n//    large catchUp blobs - see Issue #6364\n// 3. Similarly, processes that rely on \"core\" snapshot (and can't parse trailing ops, including above), like search\n//    parser in SPO, will result in non-accurate results due to presence of catch up blobs.\n// 4. Ordering service used 250ms timeout to coalesce non-immediate noops. It was changed to 2000 ms to allow more\n//    aggressive noop sending from client side.\n// 5. Number of ops sent by all clients is proportional to number of \"write\" clients (every client sends noops),\n//    but number of sequenced noops is a function of time (one op per 2 seconds at most).\n//    We should consider impact to both outbound traffic (might be huge, depends on number of clients) and file size.\n// Please also see Issue #5629 for more discussions.\n//\n// With that, the current algorithm is as follows:\n// 1. Sent noop 2000 ms of receiving an op if no ops were sent by this client within this timeframe.\n//    This will ensure that MSN moves forward with reasonable speed. If that results in too many sequenced noops,\n//    server timeout of 2000ms should be reconsidered to be increased.\n// 2. If there are more than 50 ops received without sending any ops, send noop to keep collab window small.\n//    Note that system ops (including noops themselves) are excluded, so it's 1 noop per 50 real ops.\nclass CollabWindowTracker {\n    constructor(submit, NoopTimeFrequency = defaultNoopTimeFrequency, NoopCountFrequency = defaultNoopCountFrequency) {\n        this.submit = submit;\n        this.NoopCountFrequency = NoopCountFrequency;\n        this.opsCountSinceNoop = 0;\n        if (NoopTimeFrequency !== Infinity) {\n            this.timer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Timer(NoopTimeFrequency, () => {\n                // Can get here due to this.stopSequenceNumberUpdate() not resetting timer.\n                // Also timer callback can fire even after timer cancellation if it was queued before cancellation.\n                if (this.opsCountSinceNoop !== 0) {\n                    this.submitNoop(false /* immediate */);\n                }\n            });\n        }\n    }\n    /**\n     * Schedules as ack to the server to update the reference sequence number\n     */\n    scheduleSequenceNumberUpdate(message, immediateNoOp) {\n        // While processing a message, an immediate no-op can be requested.\n        // i.e. to expedite approve or commit phase of quorum.\n        if (immediateNoOp) {\n            this.submitNoop(true /* immediate */);\n            return;\n        }\n        // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN\n        // update, which updates the MSN, then ack the update, etc...).\n        // Intent here is for runtime (and DDSes) not to keep too much tracking state / memory\n        // due to runtime ops from other clients.\n        if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.isRuntimeMessage)(message)) {\n            return;\n        }\n        this.opsCountSinceNoop++;\n        if (this.opsCountSinceNoop >= this.NoopCountFrequency) {\n            this.submitNoop(false /* immediate */);\n            return;\n        }\n        if (this.timer !== undefined) {\n            if (this.opsCountSinceNoop === 1) {\n                this.timer.restart();\n            }\n            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.timer.hasTimer, 0x242 /* \"has timer\" */);\n        }\n    }\n    submitNoop(immediate) {\n        // Anything other than null is immediate noop\n        this.submit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.NoOp, immediate ? \"\" : null);\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.opsCountSinceNoop === 0, 0x243 /* \"stopSequenceNumberUpdate should be called as result of sending any op!\" */);\n    }\n    stopSequenceNumberUpdate() {\n        this.opsCountSinceNoop = 0;\n        // Ideally, we cancel timer here. But that will result in too often set/reset cycle if this client\n        // keeps sending ops. In most cases it's actually better to let it expire (at most - 4 times per second)\n        // for nothing, then have a ton of set/reset cycles.\n        // Note that Timer.restart() is smart and will not change timer expiration if we keep extending timer\n        // expiration - it will restart the timer instead when it fires with adjusted expiration.\n        // this.timer.clear();\n    }\n}\n//# sourceMappingURL=collabWindowTracker.js.map\n\n/***/ }),\n/* 544 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContainerContext\": () => (/* binding */ ContainerContext)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(492);\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(487);\n/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);\n/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);\n/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n\nconst PackageNotFactoryError = \"Code package does not implement IRuntimeFactory\";\nclass ContainerContext {\n    constructor(container, scope, codeLoader, _codeDetails, _baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {\n        this.container = container;\n        this.scope = scope;\n        this.codeLoader = codeLoader;\n        this._codeDetails = _codeDetails;\n        this._baseSnapshot = _baseSnapshot;\n        this.deltaManager = deltaManager;\n        this.loader = loader;\n        this.submitFn = submitFn;\n        this.submitSignalFn = submitSignalFn;\n        this.closeFn = closeFn;\n        this.version = version;\n        this.updateDirtyContainerState = updateDirtyContainerState;\n        this.existing = existing;\n        this.pendingLocalState = pendingLocalState;\n        this._disposed = false;\n        this._quorum = quorum;\n        this.taggedLogger = container.subLogger;\n        this._fluidModuleP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.LazyPromise(async () => this.loadCodeModule(_codeDetails));\n        this.attachListener();\n    }\n    static async createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {\n        const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState);\n        await context.instantiateRuntime(existing);\n        return context;\n    }\n    get clientId() {\n        return this.container.clientId;\n    }\n    /**\n     * DISCLAIMER: this id is only for telemetry purposes. Not suitable for any other usages.\n     */\n    get id() {\n        const resolvedUrl = this.container.resolvedUrl;\n        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.isFluidResolvedUrl)(resolvedUrl)) {\n            return resolvedUrl.id;\n        }\n        return \"\";\n    }\n    get clientDetails() {\n        return this.container.clientDetails;\n    }\n    get connected() {\n        return this.container.connected;\n    }\n    get canSummarize() {\n        return \"summarize\" in this.runtime;\n    }\n    get serviceConfiguration() {\n        return this.container.serviceConfiguration;\n    }\n    get audience() {\n        return this.container.audience;\n    }\n    get options() {\n        return this.container.options;\n    }\n    get baseSnapshot() {\n        return this._baseSnapshot;\n    }\n    get storage() {\n        return this.container.storage;\n    }\n    get runtime() {\n        if (this._runtime === undefined) {\n            throw new Error(\"Attempted to access runtime before it was defined\");\n        }\n        return this._runtime;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    get codeDetails() { return this._codeDetails; }\n    get quorum() { return this._quorum; }\n    /**\n     * @deprecated - Temporary migratory API, to be removed when customers no longer need it.  When removed,\n     * ContainerContext should only take an IQuorumClients rather than an IQuorum.  See IContainerContext for more\n     * details.\n     */\n    getSpecifiedCodeDetails() {\n        var _a;\n        return ((_a = this._quorum.get(\"code\")) !== null && _a !== void 0 ? _a : this._quorum.get(\"code2\"));\n    }\n    dispose(error) {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this.runtime.dispose(error);\n        this._quorum.dispose();\n        this.deltaManager.dispose();\n    }\n    getLoadedFromVersion() {\n        return this.container.loadedFromVersion;\n    }\n    get attachState() {\n        return this.container.attachState;\n    }\n    /**\n     * Create a summary. Used when attaching or serializing a detached container.\n     *\n     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported\n     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the\n     * new storage IDs so requests can be redirected.\n     */\n    createSummary(blobRedirectTable) {\n        return this.runtime.createSummary(blobRedirectTable);\n    }\n    setConnectionState(connected, clientId) {\n        const runtime = this.runtime;\n        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(connected === this.connected, 0x0de /* \"Mismatch in connection state while setting\" */);\n        runtime.setConnectionState(connected, clientId);\n    }\n    process(message, local, context) {\n        this.runtime.process(message, local, context);\n    }\n    processSignal(message, local) {\n        this.runtime.processSignal(message, local);\n    }\n    async request(path) {\n        return this.runtime.request(path);\n    }\n    async getAbsoluteUrl(relativeUrl) {\n        return this.container.getAbsoluteUrl(relativeUrl);\n    }\n    getPendingLocalState() {\n        return this.runtime.getPendingLocalState();\n    }\n    /**\n     * Determines if the current code details of the context\n     * satisfy the incoming constraint code details\n     */\n    async satisfies(constraintCodeDetails) {\n        var _a;\n        const comparers = [];\n        const maybeCompareCodeLoader = this.codeLoader;\n        if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {\n            comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);\n        }\n        const moduleWithDetails = await this._fluidModuleP;\n        const maybeCompareExport = (_a = moduleWithDetails.module) === null || _a === void 0 ? void 0 : _a.fluidExport;\n        if ((maybeCompareExport === null || maybeCompareExport === void 0 ? void 0 : maybeCompareExport.IFluidCodeDetailsComparer) !== undefined) {\n            comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);\n        }\n        // if there are not comparers it is not possible to know\n        // if the current satisfy the incoming, so return false,\n        // as assuming they do not satisfy is safer .e.g we will\n        // reload, rather than potentially running with\n        // incompatible code\n        if (comparers.length === 0) {\n            return false;\n        }\n        for (const comparer of comparers) {\n            const satisfies = await comparer.satisfies(moduleWithDetails.details, constraintCodeDetails);\n            if (satisfies === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    notifyAttaching(snapshot) {\n        var _a, _b;\n        this._baseSnapshot = snapshot;\n        (_b = (_a = this.runtime).notifyAttaching) === null || _b === void 0 ? void 0 : _b.call(_a, snapshot);\n        this.runtime.setAttachState(_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching);\n    }\n    // #region private\n    async getRuntimeFactory() {\n        var _a;\n        const fluidExport = (_a = (await this._fluidModuleP).module) === null || _a === void 0 ? void 0 : _a.fluidExport;\n        const runtimeFactory = fluidExport === null || fluidExport === void 0 ? void 0 : fluidExport.IRuntimeFactory;\n        if (runtimeFactory === undefined) {\n            throw new Error(PackageNotFactoryError);\n        }\n        return runtimeFactory;\n    }\n    async instantiateRuntime(existing) {\n        const runtimeFactory = await this.getRuntimeFactory();\n        this._runtime = await runtimeFactory.instantiateRuntime(this, existing);\n    }\n    attachListener() {\n        this.container.once(\"attached\", () => {\n            this.runtime.setAttachState(_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached);\n        });\n    }\n    async loadCodeModule(codeDetails) {\n        const loadCodeResult = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.PerformanceEvent.timedExecAsync(this.taggedLogger, { eventName: \"CodeLoad\" }, async () => this.codeLoader.load(codeDetails));\n        if (\"module\" in loadCodeResult) {\n            const { module, details } = loadCodeResult;\n            return {\n                module,\n                details: details !== null && details !== void 0 ? details : codeDetails,\n            };\n        }\n        else {\n            // If \"module\" is not in the result, we are using a legacy ICodeLoader.  Fix the result up with details.\n            // Once usage drops to 0 we can remove this compat path.\n            this.taggedLogger.sendTelemetryEvent({ eventName: \"LegacyCodeLoader\" });\n            return loadCodeResult;\n        }\n    }\n}\n//# sourceMappingURL=containerContext.js.map\n\n/***/ }),\n/* 545 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DeltaManagerProxy\": () => (/* binding */ DeltaManagerProxy),\n/* harmony export */   \"DeltaQueueProxy\": () => (/* binding */ DeltaQueueProxy)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(525);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Proxy to the real IDeltaQueue - used to restrict access\n */\nclass DeltaQueueProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {\n    constructor(queue) {\n        super(queue);\n        this.queue = queue;\n    }\n    get paused() {\n        return this.queue.paused;\n    }\n    get length() {\n        return this.queue.length;\n    }\n    get idle() {\n        return this.queue.idle;\n    }\n    peek() {\n        return this.queue.peek();\n    }\n    toArray() {\n        return this.queue.toArray();\n    }\n    // back-compat: usage removed in 0.33, remove in future versions\n    async systemPause() {\n        return this.pause();\n    }\n    async pause() {\n        return this.queue.pause();\n    }\n    // back-compat: usage removed in 0.33, remove in future versions\n    async systemResume() {\n        return this.resume();\n    }\n    async resume() {\n        this.queue.resume();\n    }\n    async waitTillProcessingDone() {\n        return this.queue.waitTillProcessingDone();\n    }\n}\n/**\n * Proxy to the real IDeltaManager - used to restrict access\n */\nclass DeltaManagerProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {\n    constructor(deltaManager) {\n        super(deltaManager);\n        this.deltaManager = deltaManager;\n        this.inbound = new DeltaQueueProxy(deltaManager.inbound);\n        this.outbound = new DeltaQueueProxy(deltaManager.outbound);\n        this.inboundSignal = new DeltaQueueProxy(deltaManager.inboundSignal);\n    }\n    get IDeltaSender() {\n        return this;\n    }\n    get minimumSequenceNumber() {\n        return this.deltaManager.minimumSequenceNumber;\n    }\n    get lastSequenceNumber() {\n        return this.deltaManager.lastSequenceNumber;\n    }\n    get lastMessage() {\n        return this.deltaManager.lastMessage;\n    }\n    get lastKnownSeqNumber() {\n        return this.deltaManager.lastKnownSeqNumber;\n    }\n    get initialSequenceNumber() {\n        return this.deltaManager.initialSequenceNumber;\n    }\n    get hasCheckpointSequenceNumber() {\n        return this.deltaManager.hasCheckpointSequenceNumber;\n    }\n    get clientDetails() {\n        return this.deltaManager.clientDetails;\n    }\n    get version() {\n        return this.deltaManager.version;\n    }\n    get maxMessageSize() {\n        return this.deltaManager.maxMessageSize;\n    }\n    get serviceConfiguration() {\n        return this.deltaManager.serviceConfiguration;\n    }\n    get active() {\n        return this.deltaManager.active;\n    }\n    get readOnlyInfo() {\n        return this.deltaManager.readOnlyInfo;\n    }\n    dispose() {\n        this.inbound.dispose();\n        this.outbound.dispose();\n        this.inboundSignal.dispose();\n        super.dispose();\n    }\n    submitSignal(content) {\n        return this.deltaManager.submitSignal(content);\n    }\n    flush() {\n        return this.deltaManager.flush();\n    }\n}\n//# sourceMappingURL=deltaManagerProxy.js.map\n\n/***/ }),\n/* 546 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DebugLogger\": () => (/* binding */ DebugLogger)\n/* harmony export */ });\n/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(389);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Implementation of debug logger\n */\nclass DebugLogger extends _logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger {\n    constructor(debug, debugErr, properties) {\n        super(undefined, properties);\n        this.debug = debug;\n        this.debugErr = debugErr;\n    }\n    /**\n     * Create debug logger - all events are output to debug npm library\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     */\n    static create(namespace, properties) {\n        // Setup base logger upfront, such that host can disable it (if needed)\n        const debug = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(namespace);\n        const debugErr = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(namespace);\n        debugErr.log = console.error.bind(console);\n        debugErr.enabled = true;\n        return new DebugLogger(debug, debugErr, properties);\n    }\n    /**\n     * Mix in debug logger with another logger.\n     * Returned logger will output events to both newly created debug logger, as well as base logger\n     * @param namespace - Telemetry event name prefix to add to all events\n     * @param properties - Base properties to add to all events\n     * @param propertyGetters - Getters to add additional properties to all events\n     * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.\n     */\n    static mixinDebugLogger(namespace, baseLogger, properties) {\n        if (!baseLogger) {\n            return DebugLogger.create(namespace, properties);\n        }\n        const multiSinkLogger = new _logger__WEBPACK_IMPORTED_MODULE_1__.MultiSinkLogger(undefined, properties);\n        multiSinkLogger.addLogger(DebugLogger.create(namespace, this.tryGetBaseLoggerProps(baseLogger)));\n        multiSinkLogger.addLogger(_logger__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger, namespace));\n        return multiSinkLogger;\n    }\n    static tryGetBaseLoggerProps(baseLogger) {\n        if (baseLogger instanceof _logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger) {\n            return baseLogger.properties;\n        }\n        return undefined;\n    }\n    /**\n     * Send an event to debug loggers\n     *\n     * @param event - the event to send\n     */\n    send(event) {\n        const newEvent = this.prepareEvent(event);\n        const isError = newEvent.category === \"error\";\n        let logger = isError ? this.debugErr : this.debug;\n        // Use debug's coloring schema for base of the event\n        const index = event.eventName.lastIndexOf(_logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.eventNamespaceSeparator);\n        const name = event.eventName.substring(index + 1);\n        if (index > 0) {\n            logger = logger.extend(event.eventName.substring(0, index));\n        }\n        newEvent.eventName = undefined;\n        let tick = \"\";\n        tick = `tick=${_logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now())}`;\n        // Extract stack to put it last, but also to avoid escaping '\\n' in it by JSON.stringify below\n        const stack = newEvent.stack ? newEvent.stack : \"\";\n        newEvent.stack = undefined;\n        // Watch out for circular references - they can come from two sources\n        // 1) error object - we do not control it and should remove it and retry\n        // 2) properties supplied by telemetry caller - that's a bug that should be addressed!\n        let payload;\n        try {\n            payload = JSON.stringify(newEvent);\n        }\n        catch (error) {\n            newEvent.error = undefined;\n            payload = JSON.stringify(newEvent);\n        }\n        if (payload === \"{}\") {\n            payload = \"\";\n        }\n        // Force errors out, to help with diagnostics\n        if (isError) {\n            logger.enabled = true;\n        }\n        // Print multi-line.\n        logger(`${name} ${payload} ${tick} ${stack}`);\n    }\n}\n//# sourceMappingURL=debugLogger.js.map\n\n/***/ }),\n/* 547 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiUrlResolver\": () => (/* binding */ MultiUrlResolver),\n/* harmony export */   \"configurableUrlResolver\": () => (/* binding */ configurableUrlResolver)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Resolver that takes a list of url resolvers and then try each of them to resolve the url.\n * @param resolversList - List of url resolvers to be used to resolve the request.\n * @param request - Request to be resolved.\n */\nasync function configurableUrlResolver(resolversList, request) {\n    let resolved;\n    for (const resolver of resolversList) {\n        resolved = await resolver.resolve(Object.assign({}, request));\n        if (resolved !== undefined) {\n            return resolved;\n        }\n    }\n    return undefined;\n}\nclass MultiUrlResolver {\n    constructor(urlResolvers) {\n        this.urlResolvers = urlResolvers;\n    }\n    static create(urlResolver) {\n        if (Array.isArray(urlResolver)) {\n            if (urlResolver.length === 1) {\n                return urlResolver[0];\n            }\n            return new MultiUrlResolver(urlResolver);\n        }\n        return urlResolver;\n    }\n    async resolve(request) {\n        return configurableUrlResolver(this.urlResolvers, request);\n    }\n    async getAbsoluteUrl(resolvedUrl, relativeUrl) {\n        throw new Error(\"Not implmented\");\n    }\n}\n//# sourceMappingURL=multiUrlResolver.js.map\n\n/***/ }),\n/* 548 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiDocumentServiceFactory\": () => (/* binding */ MultiDocumentServiceFactory)\n/* harmony export */ });\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(496);\n/* harmony import */ var _fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nclass MultiDocumentServiceFactory {\n    constructor(documentServiceFactories) {\n        this.protocolName = \"none:\";\n        this.protocolToDocumentFactoryMap = new Map();\n        documentServiceFactories.forEach((factory) => {\n            this.protocolToDocumentFactoryMap.set(factory.protocolName, factory);\n        });\n    }\n    static create(documentServiceFactory) {\n        if (Array.isArray(documentServiceFactory)) {\n            const factories = [];\n            documentServiceFactory.forEach((factory) => {\n                const maybeMulti = factory;\n                if (maybeMulti.protocolToDocumentFactoryMap !== undefined) {\n                    factories.push(...maybeMulti.protocolToDocumentFactoryMap.values());\n                }\n                else {\n                    factories.push(factory);\n                }\n            });\n            if (factories.length === 1) {\n                return factories[0];\n            }\n            return new MultiDocumentServiceFactory(factories);\n        }\n        return documentServiceFactory;\n    }\n    async createDocumentService(resolvedUrl, logger, clientIsSummarizer) {\n        (0,_fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);\n        const urlObj = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(resolvedUrl.url);\n        if (urlObj.protocol === undefined || urlObj.protocol === null) {\n            throw new Error(\"No protocol provided\");\n        }\n        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);\n        if (factory === undefined) {\n            throw new Error(\"Unknown Fluid protocol\");\n        }\n        return factory.createDocumentService(resolvedUrl, logger, clientIsSummarizer);\n    }\n    async createContainer(createNewSummary, createNewResolvedUrl, logger, clientIsSummarizer) {\n        (0,_fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(createNewResolvedUrl);\n        const urlObj = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(createNewResolvedUrl.url);\n        if (urlObj.protocol === undefined || urlObj.protocol === null) {\n            throw new Error(\"No protocol provided\");\n        }\n        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);\n        if (factory === undefined) {\n            throw new Error(\"Unknown Fluid protocol\");\n        }\n        return factory.createContainer(createNewSummary, createNewResolvedUrl, logger, clientIsSummarizer);\n    }\n}\n//# sourceMappingURL=multiDocumentServiceFactory.js.map\n\n/***/ }),\n/* 549 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AzureFunctionTokenProvider\": () => (/* binding */ AzureFunctionTokenProvider)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(348);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Token Provider implementation for connecting to an Azure Function endpoint for\n * Azure Fluid Relay token resolution.\n */\nclass AzureFunctionTokenProvider {\n    /**\n     * Creates a new instance using configuration parameters.\n     * @param azFunctionUrl - URL to Azure Function endpoint\n     * @param user - User object\n     */\n    constructor(azFunctionUrl, user) {\n        this.azFunctionUrl = azFunctionUrl;\n        this.user = user;\n    }\n    async fetchOrdererToken(tenantId, documentId) {\n        return {\n            jwt: await this.getToken(tenantId, documentId),\n        };\n    }\n    async fetchStorageToken(tenantId, documentId) {\n        return {\n            jwt: await this.getToken(tenantId, documentId),\n        };\n    }\n    async getToken(tenantId, documentId) {\n        var _a, _b, _c;\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().get(this.azFunctionUrl, {\n            params: {\n                tenantId,\n                documentId,\n                userId: (_a = this.user) === null || _a === void 0 ? void 0 : _a.userId,\n                userName: (_b = this.user) === null || _b === void 0 ? void 0 : _b.userName,\n                additionalDetails: (_c = this.user) === null || _c === void 0 ? void 0 : _c.additionalDetails,\n            },\n        });\n        return response.data;\n    }\n}\n//# sourceMappingURL=AzureFunctionTokenProvider.js.map\n\n/***/ }),\n/* 550 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScopeType\": () => (/* binding */ ScopeType)\n/* harmony export */ });\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Defines scope access for a Container/Document\n */\nvar ScopeType;\n(function (ScopeType) {\n    /**\n     * Read access is supported on the Container/Document\n     */\n    ScopeType[\"DocRead\"] = \"doc:read\";\n    /**\n     * Write access is supported on the Container/Document\n     */\n    ScopeType[\"DocWrite\"] = \"doc:write\";\n    /**\n     * User can generate new summaries operations\n     */\n    ScopeType[\"SummaryWrite\"] = \"summary:write\";\n})(ScopeType || (ScopeType = {}));\n//# sourceMappingURL=scopes.js.map\n\n/***/ }),\n/* 551 */\n/***/ (function(module, exports) {\n\n\"use strict\";\n\r\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nmodule.exports = class DataverseTokenProvider {\r\n    constructor(accessToken, fetchAccessToken) {\r\n        this.cachedAccessToken = accessToken;\r\n        this.fetchAccessToken = fetchAccessToken;\r\n    }\r\n    fetchOrdererToken(tenantId, documentId, refresh) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (refresh) {\r\n                this.cachedAccessToken = yield this.fetchAccessToken();\r\n            }\r\n            return {\r\n                jwt: this.cachedAccessToken,\r\n            };\r\n        });\r\n    }\r\n    fetchStorageToken(tenantId, documentId, refresh) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (refresh) {\r\n                this.cachedAccessToken = yield this.fetchAccessToken();\r\n            }\r\n            return {\r\n                jwt: this.cachedAccessToken,\r\n            };\r\n        });\r\n    }\r\n};\r\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = __webpack_modules__;\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/ensure chunk */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.f = {};\n/******/ \t\t// This file contains only the entry chunk.\n/******/ \t\t// The chunk loading function for additional chunks\n/******/ \t\t__webpack_require__.e = (chunkId) => {\n/******/ \t\t\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n/******/ \t\t\t\t__webpack_require__.f[key](chunkId, promises);\n/******/ \t\t\t\treturn promises;\n/******/ \t\t\t}, []));\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/get javascript chunk filename */\n/******/ \t(() => {\n/******/ \t\t// This function allow to reference async chunks\n/******/ \t\t__webpack_require__.u = (chunkId) => {\n/******/ \t\t\t// return url for filenames based on template\n/******/ \t\t\treturn \"\" + \"FluidFramework-HashFallback\" + \".worker.js\";\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/node module decorator */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.nmd = (module) => {\n/******/ \t\t\tmodule.paths = [];\n/******/ \t\t\tif (!module.children) module.children = [];\n/******/ \t\t\treturn module;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\tvar scriptUrl;\n/******/ \t\tif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\n/******/ \t\tvar document = __webpack_require__.g.document;\n/******/ \t\tif (!scriptUrl && document) {\n/******/ \t\t\tif (document.currentScript)\n/******/ \t\t\t\tscriptUrl = document.currentScript.src\n/******/ \t\t\tif (!scriptUrl) {\n/******/ \t\t\t\tvar scripts = document.getElementsByTagName(\"script\");\n/******/ \t\t\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\t// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n/******/ \t\t// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\n/******/ \t\tif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\n/******/ \t\tscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n/******/ \t\t__webpack_require__.p = scriptUrl;\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/importScripts chunk loading */\n/******/ \t(() => {\n/******/ \t\t// no baseURI\n/******/ \t\t\n/******/ \t\t// object to store loaded chunks\n/******/ \t\t// \"1\" means \"already loaded\"\n/******/ \t\tvar installedChunks = {\n/******/ \t\t\t1: 1\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// importScripts chunk loading\n/******/ \t\tvar installChunk = (data) => {\n/******/ \t\t\tvar [chunkIds, moreModules, runtime] = data;\n/******/ \t\t\tfor(var moduleId in moreModules) {\n/******/ \t\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n/******/ \t\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t\tif(runtime) runtime(__webpack_require__);\n/******/ \t\t\twhile(chunkIds.length)\n/******/ \t\t\t\tinstalledChunks[chunkIds.pop()] = 1;\n/******/ \t\t\tparentChunkLoadingFunction(data);\n/******/ \t\t};\n/******/ \t\t__webpack_require__.f.i = (chunkId, promises) => {\n/******/ \t\t\t// \"1\" is the signal for \"already loaded\"\n/******/ \t\t\tif(!installedChunks[chunkId]) {\n/******/ \t\t\t\tif(true) { // all chunks have JS\n/******/ \t\t\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\tvar chunkLoadingGlobal = self[\"webpackChunkpowerplatform_vscode\"] = self[\"webpackChunkpowerplatform_vscode\"] || [];\n/******/ \t\tvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\n/******/ \t\tchunkLoadingGlobal.push = installChunk;\n/******/ \t\t\n/******/ \t\t// no HMR\n/******/ \t\t\n/******/ \t\t// no HMR manifest\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n */\r\n\r\n// eslint-disable-next-line no-undef\r\nself.window = self;\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst fluid = __webpack_require__(1);\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst { AzureClient } = __webpack_require__(324);\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst DataverseTokenProvider = __webpack_require__(551);\r\n\r\nconst { SharedMap, ConnectionState } = fluid;\r\n\r\nconst objectTypes = [\r\n    SharedMap\r\n]\r\n\r\nconst containerSchema = {\r\n    dynamicObjectTypes: objectTypes,\r\n    initialObjects: {\r\n        sharedState: SharedMap,\r\n    },\r\n};\r\n\r\nclass AzureFluidClient {\r\n    static _clientInstance;\r\n    static _container;\r\n    static _audience;\r\n    static _userSharedMap;\r\n\r\n    static getInstance(config) {\r\n        if (!this._clientInstance) {\r\n            const afrClientProps = {\r\n                connection: {\r\n                    type: \"remote\",\r\n                    tenantId: config.swptenantId,\r\n                    tokenProvider: new DataverseTokenProvider(\r\n                        config.swpAccessToken,\r\n                        () => this.fetchAccessToken()\r\n                    ),\r\n                    endpoint: config.discoveryendpoint,\r\n                },\r\n            };\r\n\r\n            AzureFluidClient._clientInstance = new AzureClient(afrClientProps);\r\n        }\r\n        return this._clientInstance;\r\n    }\r\n\r\n    static async fetchContainerAndService(config, id) {\r\n        if (\r\n            this._container?.connectionState !== ConnectionState.Connected\r\n        ) {\r\n            const azureClient = this.getInstance(config);\r\n            const { container, services } = await azureClient.getContainer(\r\n                id,\r\n                containerSchema\r\n            );\r\n            if (container.connectionState !== ConnectionState.Connected) {\r\n                await new Promise((resolve) => {\r\n                    container.once(\"connected\", () => {\r\n                        resolve();\r\n                    });\r\n                });\r\n            }\r\n            this._container = container;\r\n            this._audience = services.audience;\r\n            this._userSharedMap = container.initialObjects.sharedState;\r\n        }\r\n        return {\r\n            container: this._container,\r\n            audience: this._audience,\r\n            map: this._userSharedMap,\r\n        };\r\n    }\r\n}\r\n\r\nlet initialLoad = true;\r\n\r\nasync function loadContainer(config, swpId, entityInfo) {\r\n    try {\r\n        self.postMessage({\r\n            type: \"telemetry-info\",\r\n            eventName: \"webExtensionWebWorkerLoadContainerStart\",\r\n        });\r\n\r\n        const { container, audience, map } =\r\n            await AzureFluidClient.fetchContainerAndService(config, swpId);\r\n        const existingMembers = audience.getMembers();\r\n        const myself = audience.getMyself();\r\n        const selectionSharedMap = await (await map.get('selection')).get();\r\n\r\n        const getUserIdByConnectionId = (targetConnectionId) => {\r\n            const members = audience.getMembers();\r\n            for (const [userId, member] of members.entries()) {\r\n                const connections = member.connections;\r\n                if (connections.some((connection) => connection.id === targetConnectionId)) {\r\n                    return { userId: userId, userName: member.userName, aadObjectId: member.additionalDetails.AadObjectId };\r\n                }\r\n            }\r\n\r\n            throw new Error(\"Web Extension WebWorker GetUserIdByConnectionId Failed\");\r\n        };\r\n\r\n        if (audience && myself) {\r\n            const myConnectionId = audience['container'].clientId;\r\n            const entityIdObj = new Array(entityInfo.rootWebPageId);\r\n            selectionSharedMap.set(myConnectionId, entityIdObj);\r\n\r\n            if (initialLoad) {\r\n                initialLoad = false;\r\n\r\n                const user = getUserIdByConnectionId(myConnectionId);\r\n\r\n                const userConnections = audience\r\n                    .getMembers()\r\n                    .get(user.userId).connections;\r\n\r\n                const userEntityIdArray = [];\r\n\r\n                const connectionIdInContainer = await map\r\n                    .get(\"selection\")\r\n                    .get();\r\n\r\n                userConnections.forEach((connection) => {\r\n                    userEntityIdArray.push(\r\n                        connectionIdInContainer.get(connection.id)\r\n                    );\r\n                });\r\n\r\n                // aadObjectId is the unique identifier for a user\r\n                self.postMessage({\r\n                    type: \"client-data\",\r\n                    userId: user.aadObjectId,\r\n                    userName: user.userName,\r\n                    containerId: swpId,\r\n                    entityId: userEntityIdArray,\r\n                });\r\n\r\n                self.postMessage({\r\n                    type: \"telemetry-info\",\r\n                    eventName: \"webExtensionContainerInitialPopulateSuccess\",\r\n                });\r\n            }\r\n        }\r\n\r\n        audience.on(\"memberRemoved\", (clientId, member) => {\r\n            if (!existingMembers.get(member.additionalDetails.AadObjectId)) {\r\n                self.postMessage({\r\n                    type: \"member-removed\",\r\n                    userId: member.additionalDetails.AadObjectId,\r\n                });\r\n                self.postMessage({\r\n                    type: \"telemetry-info\",\r\n                    eventName: \"webExtensionWebWorkerMemberRemovedSuccess\",\r\n                    userId: member.additionalDetails.AadObjectId,\r\n                });\r\n            } else {\r\n                self.postMessage({\r\n                    type: \"telemetry-error\",\r\n                    methodName: \"webWorker memberRemoved\",\r\n                    errorMessage: \"Web Extension WebWorker Member Removed Failed\",\r\n                });\r\n            }\r\n        });\r\n\r\n        selectionSharedMap.on(\"valueChanged\", async (changed, local) => {\r\n            try {\r\n                const user = getUserIdByConnectionId(changed.key);\r\n\r\n                const userConnections = audience\r\n                    .getMembers()\r\n                    .get(user.userId).connections;\r\n\r\n                const userEntityIdArray = [];\r\n\r\n                const connectionIdInContainer = await map\r\n                    .get(\"selection\")\r\n                    .get();\r\n\r\n                userConnections.forEach((connection) => {\r\n                    userEntityIdArray.push(\r\n                        connectionIdInContainer.get(connection.id)\r\n                    );\r\n                });\r\n\r\n                // aadObjectId is the unique identifier for a user\r\n                self.postMessage({\r\n                    type: \"client-data\",\r\n                    userId: user.aadObjectId,\r\n                    userName: user.userName,\r\n                    containerId: swpId,\r\n                    entityId: userEntityIdArray,\r\n                });\r\n\r\n                self.postMessage({\r\n                    type: \"telemetry-info\",\r\n                    eventName:\r\n                        \"webExtensionWebWorkerGetUserIdByConnectionIdSuccess\",\r\n                    userId: user.aadObjectId,\r\n                });\r\n            } catch (error) {\r\n                self.postMessage({\r\n                    type: \"telemetry-error\",\r\n                    methodName: \"webWorker valueChanged\",\r\n                    errorMessage: error?.message,\r\n                    error: error,\r\n                });\r\n            }\r\n        });\r\n    } catch (error) {\r\n        self.postMessage({\r\n            type: \"telemetry-error\",\r\n            eventName: \"webExtensionWebWorkerLoadContainerFailed\",\r\n            methodName: loadContainer.name,\r\n            errorMessage: error?.message,\r\n            error: error,\r\n        });\r\n    }\r\n}\r\n\r\nfunction runFluidApp() {\r\n    // Listen for messages from the extension\r\n    // eslint-disable-next-line no-undef\r\n    self.addEventListener(\"message\", async (event) => {\r\n        const message = event.data;\r\n\r\n        await loadContainer(\r\n            message.afrConfig,\r\n            message.afrConfig.swpId,\r\n            message.entityInfo\r\n        );\r\n    });\r\n}\r\n\r\nrunFluidApp();\r\n\n})();\n\n/******/ })()\n;\n//# sourceMappingURL=webworker.worker.js.map", "Worker", undefined, __webpack_require__.p + "webworker.worker.js");
}

})();

var __webpack_export_target__ = self;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=main.js.map