/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachState": () => (/* reexport safe */ _containerDefinitions__WEBPACK_IMPORTED_MODULE_0__.AttachState),
/* harmony export */   "ConnectionState": () => (/* reexport safe */ _containerLoader__WEBPACK_IMPORTED_MODULE_1__.ConnectionState),
/* harmony export */   "ContainerErrorType": () => (/* reexport safe */ _containerDefinitions__WEBPACK_IMPORTED_MODULE_0__.ContainerErrorType),
/* harmony export */   "DOProviderContainerRuntimeFactory": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.DOProviderContainerRuntimeFactory),
/* harmony export */   "DirectoryFactory": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.DirectoryFactory),
/* harmony export */   "DriverErrorType": () => (/* reexport safe */ _driverDefinitions__WEBPACK_IMPORTED_MODULE_2__.DriverErrorType),
/* harmony export */   "FluidContainer": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.FluidContainer),
/* harmony export */   "Interval": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.Interval),
/* harmony export */   "IntervalCollection": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.IntervalCollection),
/* harmony export */   "IntervalCollectionIterator": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.IntervalCollectionIterator),
/* harmony export */   "IntervalType": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.IntervalType),
/* harmony export */   "LocalValueMaker": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.LocalValueMaker),
/* harmony export */   "MapFactory": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.MapFactory),
/* harmony export */   "PaddingSegment": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.PaddingSegment),
/* harmony export */   "RootDataObject": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.RootDataObject),
/* harmony export */   "RunSegment": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.RunSegment),
/* harmony export */   "SequenceDeltaEvent": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceDeltaEvent),
/* harmony export */   "SequenceEvent": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceEvent),
/* harmony export */   "SequenceInterval": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceInterval),
/* harmony export */   "SequenceMaintenanceEvent": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SequenceMaintenanceEvent),
/* harmony export */   "ServiceAudience": () => (/* reexport safe */ _fluidStatic__WEBPACK_IMPORTED_MODULE_3__.ServiceAudience),
/* harmony export */   "SharedDirectory": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.SharedDirectory),
/* harmony export */   "SharedIntervalCollection": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedIntervalCollection),
/* harmony export */   "SharedIntervalCollectionFactory": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedIntervalCollectionFactory),
/* harmony export */   "SharedMap": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_4__.SharedMap),
/* harmony export */   "SharedNumberSequence": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedNumberSequence),
/* harmony export */   "SharedNumberSequenceFactory": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedNumberSequenceFactory),
/* harmony export */   "SharedObjectSequence": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence),
/* harmony export */   "SharedObjectSequenceFactory": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequenceFactory),
/* harmony export */   "SharedSegmentSequence": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedSegmentSequence),
/* harmony export */   "SharedSequence": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedSequence),
/* harmony export */   "SharedString": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedString),
/* harmony export */   "SharedStringFactory": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SharedStringFactory),
/* harmony export */   "SparseMatrix": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SparseMatrix),
/* harmony export */   "SparseMatrixFactory": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SparseMatrixFactory),
/* harmony export */   "SubSequence": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.SubSequence),
/* harmony export */   "maxCellPosition": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxCellPosition),
/* harmony export */   "maxCol": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxCol),
/* harmony export */   "maxCols": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxCols),
/* harmony export */   "maxRow": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxRow),
/* harmony export */   "maxRows": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.maxRows),
/* harmony export */   "positionToRowCol": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.positionToRowCol),
/* harmony export */   "rowColToPosition": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_5__.rowColToPosition)
/* harmony export */ });
/* harmony import */ var _containerDefinitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _containerLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _driverDefinitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _fluidStatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(275);
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(277);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * The **fluid-framework** package bundles a collection of Fluid Framework client packages for easy use when paired with
 * a corresponding service client package (for example, `\@fluidframework/azure-client` or
 * `\@fluidframework/tinylicious-client`).
 *
 * @packageDocumentation
 */






//# sourceMappingURL=index.js.map

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachState": () => (/* reexport safe */ _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.AttachState),
/* harmony export */   "ContainerErrorType": () => (/* reexport safe */ _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

//# sourceMappingURL=containerDefinitions.js.map

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachState": () => (/* binding */ AttachState),
/* harmony export */   "BindState": () => (/* binding */ BindState),
/* harmony export */   "IRuntimeFactory": () => (/* binding */ IRuntimeFactory)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * The attachment state of some Fluid data (e.g. a container or data store), denoting whether it is uploaded to the
 * service.  The transition from detached to attached state is a one-way transition.
 */
var AttachState;
(function (AttachState) {
    /**
     * In detached state, the data is only present on the local client's machine.  It has not yet been uploaded
     * to the service.
     */
    AttachState["Detached"] = "Detached";
    /**
     * In attaching state, the data has started the upload to the service, but has not yet completed.
     */
    AttachState["Attaching"] = "Attaching";
    /**
     * In attached state, the data has completed upload to the service.  It can be accessed by other clients after
     * reaching attached state.
     */
    AttachState["Attached"] = "Attached";
})(AttachState || (AttachState = {}));
// Represents the bind state of the entity.
var BindState;
(function (BindState) {
    BindState["NotBound"] = "NotBound";
    BindState["Binding"] = "Binding";
    BindState["Bound"] = "Bound";
})(BindState || (BindState = {}));
const IRuntimeFactory = "IRuntimeFactory";
//# sourceMappingURL=runtime.js.map

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerErrorType": () => (/* binding */ ContainerErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Different error types the Container may report out to the Host
 */
var ContainerErrorType;
(function (ContainerErrorType) {
    /**
     * Some error, most likely an exception caught by runtime and propagated to container as critical error
     */
    ContainerErrorType["genericError"] = "genericError";
    /**
     * Throttling error from server. Server is busy and is asking not to reconnect for some time
     */
    ContainerErrorType["throttlingError"] = "throttlingError";
    /**
     * Data loss error detected by Container / DeltaManager. Likely points to storage issue.
     */
    ContainerErrorType["dataCorruptionError"] = "dataCorruptionError";
    /**
     * Error encountered when processing an operation. May correlate with data corruption.
     */
    ContainerErrorType["dataProcessingError"] = "dataProcessingError";
    /**
     * Error indicating an API is being used improperly resulting in an invalid operation.
     */
    ContainerErrorType["usageError"] = "usageError";
    /**
     * Error indicating an client session has expired. Currently this only happens when GC is allowed on a document and
     * aids in safely deleting unused objects.
     */
    ContainerErrorType["clientSessionExpiredError"] = "clientSessionExpiredError";
})(ContainerErrorType || (ContainerErrorType = {}));
//# sourceMappingURL=error.js.map

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionState": () => (/* reexport safe */ _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_0__.ConnectionState)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

//# sourceMappingURL=containerLoader.js.map

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionState": () => (/* binding */ ConnectionState)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var ConnectionState;
(function (ConnectionState) {
    /**
     * The container is not connected to the ordering service
     * Note - When in this state the container may be about to reconnect,
     * or may remain disconnected until explicitly told to connect.
     */
    ConnectionState[ConnectionState["Disconnected"] = 0] = "Disconnected";
    /**
     * The container is disconnected but actively trying to establish a new connection
     * PLEASE NOTE that this numerical value falls out of the order you may expect for this state
     */
    ConnectionState[ConnectionState["EstablishingConnection"] = 3] = "EstablishingConnection";
    /**
     * See {@link ConnectionState.CatchingUp}, which is the new name for this state.
     * @deprecated - This state itself is not gone, just being renamed. Please use {@link ConnectionState.CatchingUp}.
     */
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    /**
     * The container has an inbound connection only, and is catching up to the latest known state from the service.
     */
    ConnectionState[ConnectionState["CatchingUp"] = 1] = "CatchingUp";
    /**
     * The container is fully connected and syncing
     */
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
})(ConnectionState || (ConnectionState = {}));
//# sourceMappingURL=connectionState.js.map

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DriverErrorType": () => (/* reexport safe */ _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__.DriverErrorType)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

//# sourceMappingURL=driverDefinitions.js.map

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DriverErrorType": () => (/* binding */ DriverErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Driver Error types
 * Lists types that are likely to be used by all drivers
 */
var DriverErrorType;
(function (DriverErrorType) {
    /**
     * A fatal error with no specific interpretation covered by other DriverErrorType values
     */
    DriverErrorType["genericError"] = "genericError";
    /**
     * Some non-categorized (below) networking error
     * Include errors like  fatal server error (usually 500).
     */
    DriverErrorType["genericNetworkError"] = "genericNetworkError";
    /**
     * Access denied - user does not have enough privileges to open a file, or continue to operate on a file
     */
    DriverErrorType["authorizationError"] = "authorizationError";
    /**
     * File not found, or file deleted during session
     */
    DriverErrorType["fileNotFoundOrAccessDeniedError"] = "fileNotFoundOrAccessDeniedError";
    /**
     * Throttling error from server. Server is busy and is asking not to reconnect for some time
     */
    DriverErrorType["throttlingError"] = "throttlingError";
    /**
     * We can not reach server due to computer being offline.
     */
    DriverErrorType["offlineError"] = "offlineError";
    /*
     * Unsupported client protocol
     */
    DriverErrorType["unsupportedClientProtocolVersion"] = "unsupportedClientProtocolVersion";
    /**
     * User does not have write permissions to a file, but is changing content of a file.
     * That might be indication of some data store error - data stores should not generate ops in readonly mode.
     */
    DriverErrorType["writeError"] = "writeError";
    /**
     * A generic fetch failure that indicates we were not able to get a response from the server.
     * This may be due to the client being offline (though, if we are able to detect offline state it will be
     * logged as an offlineError instead).  Other possibilities could be DNS errors, malformed fetch request,
     * CSP violation, etc.
     */
    DriverErrorType["fetchFailure"] = "fetchFailure";
    /**
     * Unexpected response from server. Either JSON is malformed, or some required properties are missing
     */
    DriverErrorType["incorrectServerResponse"] = "incorrectServerResponse";
    /**
     * This error occurs when the file is modified externally (not through Fluid protocol) in storage.
     * It will occur in cases where client has some state or cache that is based on old content (identity) of a file,
     * and storage / driver / loader detects such mismatch.
     * When it's hit, client needs to forget all the knowlege about this file and start over.
     */
    DriverErrorType["fileOverwrittenInStorage"] = "fileOverwrittenInStorage";
    /**
     * The document is read-only and delta stream connection is forbidden.
     */
    DriverErrorType["deltaStreamConnectionForbidden"] = "deltaStreamConnectionForbidden";
    /**
     * The location of file/container can change on server. So if the file location moves and we try to access the old
     * location, then this error is thrown to let the client know about the new location info.
     */
    DriverErrorType["locationRedirection"] = "locationRedirection";
})(DriverErrorType || (DriverErrorType = {}));
//# sourceMappingURL=driverError.js.map

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DOProviderContainerRuntimeFactory": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.DOProviderContainerRuntimeFactory),
/* harmony export */   "FluidContainer": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.FluidContainer),
/* harmony export */   "RootDataObject": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.RootDataObject),
/* harmony export */   "ServiceAudience": () => (/* reexport safe */ _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.ServiceAudience)
/* harmony export */ });
/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

//# sourceMappingURL=fluidStatic.js.map

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DOProviderContainerRuntimeFactory": () => (/* reexport safe */ _rootDataObject__WEBPACK_IMPORTED_MODULE_1__.DOProviderContainerRuntimeFactory),
/* harmony export */   "FluidContainer": () => (/* reexport safe */ _fluidContainer__WEBPACK_IMPORTED_MODULE_0__.FluidContainer),
/* harmony export */   "RootDataObject": () => (/* reexport safe */ _rootDataObject__WEBPACK_IMPORTED_MODULE_1__.RootDataObject),
/* harmony export */   "ServiceAudience": () => (/* reexport safe */ _serviceAudience__WEBPACK_IMPORTED_MODULE_2__.ServiceAudience)
/* harmony export */ });
/* harmony import */ var _fluidContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _rootDataObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _serviceAudience__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(274);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Provides a simple and powerful way to consume collaborative Fluid data.
 *
 * @packageDocumentation
 */




//# sourceMappingURL=index.js.map

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidContainer": () => (/* binding */ FluidContainer)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Base {@link IFluidContainer} implementation.
 *
 * @remarks Note: this implementation is not complete. Consumers who rely on {@link IFluidContainer.attach}
 * will need to utilize or provide a service-specific implementation of this type that implements that method.
 */
class FluidContainer extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(container, rootDataObject) {
        super();
        this.container = container;
        this.rootDataObject = rootDataObject;
        this.connectedHandler = () => this.emit("connected");
        this.disconnectedHandler = () => this.emit("disconnected");
        this.disposedHandler = (error) => this.emit("disposed", error);
        this.savedHandler = () => this.emit("saved");
        this.dirtyHandler = () => this.emit("dirty");
        container.on("connected", this.connectedHandler);
        container.on("closed", this.disposedHandler);
        container.on("disconnected", this.disconnectedHandler);
        container.on("saved", this.savedHandler);
        container.on("dirty", this.dirtyHandler);
    }
    /**
     * {@inheritDoc IFluidContainer.isDirty}
     */
    get isDirty() {
        return this.container.isDirty;
    }
    /**
     * {@inheritDoc IFluidContainer.attachState}
     */
    get attachState() {
        return this.container.attachState;
    }
    /**
     * {@inheritDoc IFluidContainer.disposed}
     */
    get disposed() {
        return this.container.closed;
    }
    /**
     * {@inheritDoc IFluidContainer.connectionState}
     */
    get connectionState() {
        return this.container.connectionState;
    }
    /**
     * {@inheritDoc IFluidContainer.initialObjects}
     */
    get initialObjects() {
        return this.rootDataObject.initialObjects;
    }
    /**
     * Incomplete base implementation of {@link IFluidContainer.attach}.
     * @remarks Note: this implementation will unconditionally throw.
     * Consumers who rely on this will need to utilize or provide a service specific implementation of this base type
     * that provides an implementation of this method.
     *
     * The reason is because externally we are presenting a separation between the service and the `FluidContainer`,
     * but internally this separation is not there.
     */
    async attach() {
        throw new Error("Cannot attach container. Container is not in detached state");
    }
    /**
     * {@inheritDoc IFluidContainer.connect}
     */
    async connect() {
        var _a, _b;
        (_b = (_a = this.container).connect) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * {@inheritDoc IFluidContainer.connect}
     */
    async disconnect() {
        var _a, _b;
        (_b = (_a = this.container).disconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * {@inheritDoc IFluidContainer.create}
     */
    async create(objectClass) {
        return this.rootDataObject.create(objectClass);
    }
    /**
     * {@inheritDoc IFluidContainer.dispose}
     */
    dispose() {
        this.container.close();
        this.container.off("connected", this.connectedHandler);
        this.container.off("closed", this.disposedHandler);
        this.container.off("disconnected", this.disconnectedHandler);
        this.container.off("saved", this.savedHandler);
        this.container.off("dirty", this.dirtyHandler);
    }
}
//# sourceMappingURL=fluidContainer.js.map

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 13 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DOProviderContainerRuntimeFactory": () => (/* binding */ DOProviderContainerRuntimeFactory),
/* harmony export */   "RootDataObject": () => (/* binding */ RootDataObject)
/* harmony export */ });
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(145);
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(151);
/* harmony import */ var _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(144);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * The entry-point/root collaborative object of the Fluid Container.
 * This class abstracts the dynamic code required to build a Fluid Container into a static representation
 * for end customers.
 */
class RootDataObject extends _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_0__.DataObject {
    constructor() {
        super(...arguments);
        this.initialObjectsDirKey = "initial-objects-key";
        this._initialObjects = {};
    }
    get initialObjectsDir() {
        const dir = this.root.getSubDirectory(this.initialObjectsDirKey);
        if (dir === undefined) {
            throw new Error("InitialObjects sub-directory was not initialized");
        }
        return dir;
    }
    /**
     * The first time this object is initialized, creates each object identified in
     * {@link RootDataObjectProps.initialObjects} and stores them as unique values in the root directory.
     *
     * See {@link @fluidframework/aqueduct#PureDataObject.initializingFirstTime}
     */
    async initializingFirstTime(props) {
        this.root.createSubDirectory(this.initialObjectsDirKey);
        // Create initial objects provided by the developer
        const initialObjectsP = [];
        Object.entries(props.initialObjects).forEach(([id, objectClass]) => {
            const createObject = async () => {
                const obj = await this.create(objectClass);
                this.initialObjectsDir.set(id, obj.handle);
            };
            initialObjectsP.push(createObject());
        });
        await Promise.all(initialObjectsP);
    }
    /**
     * Every time an instance is initialized, loads all of the initial objects in the root directory so they can be
     * accessed immediately.
     *
     * See {@link @fluidframework/aqueduct#PureDataObject.hasInitialized}
     */
    async hasInitialized() {
        // We will always load the initial objects so they are available to the developer
        const loadInitialObjectsP = [];
        for (const [key, value] of Array.from(this.initialObjectsDir.entries())) {
            const loadDir = async () => {
                const obj = await value.get();
                Object.assign(this._initialObjects, { [key]: obj });
            };
            loadInitialObjectsP.push(loadDir());
        }
        await Promise.all(loadInitialObjectsP);
    }
    /**
     * Provides a record of the initial objects defined on creation.
     * See {@link RootDataObject.initializingFirstTime}
     */
    get initialObjects() {
        if (Object.keys(this._initialObjects).length === 0) {
            throw new Error("Initial Objects were not correctly initialized");
        }
        return this._initialObjects;
    }
    /**
     * Dynamically creates a new detached collaborative object (DDS/DataObject).
     * @param objectClass - Type of the collaborative object to be created.
     */
    async create(objectClass) {
        if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isDataObjectClass)(objectClass)) {
            return this.createDataObject(objectClass);
        }
        else if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isSharedObjectClass)(objectClass)) {
            return this.createSharedObject(objectClass);
        }
        throw new Error("Could not create new Fluid object because an unknown object was passed");
    }
    async createDataObject(dataObjectClass) {
        const factory = dataObjectClass.factory;
        const packagePath = [...this.context.packagePath, factory.type];
        const router = await this.context.containerRuntime.createDataStore(packagePath);
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.requestFluidObject)(router, "/");
    }
    createSharedObject(sharedObjectClass) {
        const factory = sharedObjectClass.getFactory();
        const obj = this.runtime.createChannel(undefined, factory.type);
        return obj;
    }
}
const rootDataStoreId = "rootDOId";
/**
 * Container code that provides a single {@link RootDataObject}.  This data object is
 * dynamically customized (registry and initial objects) based on the schema provided to the container runtime factory.
 */
class DOProviderContainerRuntimeFactory extends _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_3__.BaseContainerRuntimeFactory {
    constructor(schema) {
        const [registryEntries, sharedObjects] = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.parseDataObjectsFromSharedObjects)(schema);
        const rootDataObjectFactory = new _fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_4__.DataObjectFactory("rootDO", RootDataObject, sharedObjects, {}, registryEntries);
        super([rootDataObjectFactory.registryEntry], undefined, [(0,_fluidframework_aqueduct__WEBPACK_IMPORTED_MODULE_5__.defaultRouteRequestHandler)(rootDataStoreId)], 
        // temporary workaround to disable message batching until the message batch size issue is resolved
        // resolution progress is tracked by the Feature 465 work item in AzDO
        { flushMode: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_6__.FlushMode.Immediate });
        this.rootDataObjectFactory = rootDataObjectFactory;
        this.initialObjects = schema.initialObjects;
    }
    /**
     * {@inheritDoc @fluidframework/aqueduct#BaseContainerRuntimeFactory.containerInitializingFirstTime}
     */
    async containerInitializingFirstTime(runtime) {
        // The first time we create the container we create the RootDataObject
        await this.rootDataObjectFactory.createRootInstance(rootDataStoreId, runtime, { initialObjects: this.initialObjects });
    }
}
//# sourceMappingURL=rootDataObject.js.map

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObject": () => (/* binding */ DataObject)
/* harmony export */ });
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(142);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _pureDataObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * DataObject is a base data store that is primed with a root directory. It
 * ensures that it is created and ready before you can access it.
 *
 * Having a single root directory allows for easier development. Instead of creating
 * and registering channels with the runtime any new DDS that is set on the root
 * will automatically be registered.
 *
 * @typeParam I - The optional input types used to strongly type the data object
 */
class DataObject extends _pureDataObject__WEBPACK_IMPORTED_MODULE_0__.PureDataObject {
    constructor() {
        super(...arguments);
        this.rootDirectoryId = "root";
    }
    /**
     * {@inheritDoc PureDataObject.request}
     */
    async request(request) {
        const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.RequestParser.create(request);
        const itemId = requestParser.pathParts[0];
        if (itemId === "bigBlobs") {
            const value = this.root.get(requestParser.pathParts.join("/"));
            if (value === undefined) {
                return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(requestParser);
            }
            return { mimeType: "fluid/object", status: 200, value };
        }
        else {
            return super.request(requestParser);
        }
    }
    /**
     * The root directory will either be ready or will return an error. If an error is thrown
     * the root has not been correctly created/set.
     */
    get root() {
        if (!this.internalRoot) {
            throw new Error(this.getUninitializedErrorString(`root`));
        }
        return this.internalRoot;
    }
    /**
     * Initializes internal objects and calls initialization overrides.
     * Caller is responsible for ensuring this is only invoked once.
     */
    async initializeInternal(existing) {
        if (!existing) {
            // Create a root directory and register it before calling initializingFirstTime
            this.internalRoot = _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedDirectory.create(this.runtime, this.rootDirectoryId);
            this.internalRoot.bindToContext();
        }
        else {
            // data store has a root directory so we just need to set it before calling initializingFromExisting
            this.internalRoot = await this.runtime.getChannel(this.rootDirectoryId);
            // This will actually be an ISharedMap if the channel was previously created by the older version of
            // DataObject which used a SharedMap.  Since SharedMap and SharedDirectory are compatible unless
            // SharedDirectory-only commands are used on SharedMap, this will mostly just work for compatibility.
            if (this.internalRoot.attributes.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_4__.MapFactory.Type) {
                this.runtime.logger.send({
                    category: "generic",
                    eventName: "MapDataObject",
                    message: "Legacy document, SharedMap is masquerading as SharedDirectory in DataObject",
                });
            }
        }
        await super.initializeInternal(existing);
    }
    /**
     * Generates an error string indicating an item is uninitialized.
     * @param item - The name of the item that was uninitialized.
     */
    getUninitializedErrorString(item) {
        return `${item} must be initialized before being accessed.`;
    }
}
//# sourceMappingURL=dataObject.js.map

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PureDataObject": () => (/* binding */ PureDataObject)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);
/* harmony import */ var _container_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);
/* harmony import */ var _request_handlers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





/**
 * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.
 * You probably don't want to inherit from this data store directly unless
 * you are creating another base data store class
 *
 * @typeParam I - The optional input types used to strongly type the data object
 */
class PureDataObject extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(props) {
        super();
        this._disposed = false;
        this.runtime = props.runtime;
        this.context = props.context;
        this.providers = props.providers;
        this.initProps = props.initProps;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime._dataObject === undefined, 0x0bd /* "Object runtime already has DataObject!" */);
        this.runtime._dataObject = this;
        // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the
        // same as reaching its routeContext (FluidDataStoreRuntime) so the relative path to it from the
        // routeContext is empty.
        this.innerHandle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_2__.FluidObjectHandle(this, "", this.runtime.objectsRoutingContext);
        // Container event handlers
        this.runtime.once("dispose", () => {
            this._disposed = true;
            this.dispose();
        });
    }
    get disposed() { return this._disposed; }
    get id() { return this.runtime.id; }
    get IFluidRouter() { return this; }
    get IFluidLoadable() { return this; }
    get IFluidHandle() { return this.innerHandle; }
    /**
     * Handle to a data store
     */
    get handle() { return this.innerHandle; }
    static async getDataObject(runtime) {
        const obj = runtime._dataObject;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(obj !== undefined, 0x0bc /* "Runtime has no DataObject!" */);
        await obj.finishInitialization(true);
        return obj;
    }
    // #region IFluidRouter
    /**
     * Return this object if someone requests it directly
     * We will return this object in two scenarios:
     *  1. the request url is a "/"
     *  2. the request url is empty
     */
    async request(req) {
        return (0,_request_handlers__WEBPACK_IMPORTED_MODULE_3__.defaultFluidObjectRequestHandler)(this, req);
    }
    // #endregion IFluidRouter
    // #region IFluidLoadable
    // #endregion IFluidLoadable
    /**
     * Call this API to ensure PureDataObject is fully initialized.
     * Initialization happens on demand, only on as-needed bases.
     * In most cases you should allow factory/object to decide when to finish initialization.
     * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods
     * and need a fully initialized object, then you can call this API to ensure object is fully initialized.
     */
    async finishInitialization(existing) {
        if (this.initializeP !== undefined) {
            return this.initializeP;
        }
        this.initializeP = this.initializeInternal(existing);
        return this.initializeP;
    }
    /**
     * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should
     * generally not be done.
     *
     * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is
     * responsible for ensuring this is only invoked once.
     */
    async initializeInternal(existing) {
        var _a;
        await this.preInitialize();
        if (existing) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.initProps === undefined, 0x0be /* "Trying to initialize from existing while initProps is set!" */);
            await this.initializingFromExisting();
        }
        else {
            await this.initializingFirstTime((_a = this.context.createProps) !== null && _a !== void 0 ? _a : this.initProps);
        }
        await this.hasInitialized();
    }
    /**
     * Retrieve Fluid object using the handle get
     *
     * @param key - key that object (handle/id) is stored with in the directory
     * @param directory - directory containing the object
     * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to
     * define custom types/getters for object retrieval
     */
    async getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {
        const handleMaybe = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);
        const handle = handleMaybe === null || handleMaybe === void 0 ? void 0 : handleMaybe.IFluidHandle;
        if (handle) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return handle.get();
        }
    }
    /**
     * Gets the service at a given id.
     * @param id - service id
     */
    async getService(id) {
        return (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.handleFromLegacyUri)(`/${_container_services__WEBPACK_IMPORTED_MODULE_5__.serviceRoutePathRoot}/${id}`, this.context.containerRuntime).get();
    }
    /**
     * Called every time the data store is initialized, before initializingFirstTime or
     * initializingFromExisting is called.
     */
    async preInitialize() { }
    /**
     * Called the first time the data store is initialized (new creations with a new
     * data store runtime)
     *
     * @param props - Optional props to be passed in on create
     */
    async initializingFirstTime(props) { }
    /**
     * Called every time but the first time the data store is initialized (creations
     * with an existing data store runtime)
     */
    async initializingFromExisting() { }
    /**
     * Called every time the data store is initialized after create or existing.
     */
    async hasInitialized() { }
    /**
     * Called when the host container closes and disposes itself
     */
    dispose() {
        super.dispose();
    }
}
//# sourceMappingURL=pureDataObject.js.map

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventForwarder": () => (/* binding */ EventForwarder)
/* harmony export */ });
/* harmony import */ var _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Base class used for forwarding events from a source EventEmitter.
 * This can be useful when all arbitrary listeners need to be removed,
 * but the primary source needs to stay intact.
 */
class EventForwarder extends _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(source) {
        super();
        this.isDisposed = false;
        this.forwardingEvents = new Map();
        if (source !== undefined) {
            // NewListener event is raised whenever someone starts listening to this events, so
            // we keep track of events being listened to, and start forwarding from the source
            // event emitter per event listened to on this
            const removeListenerHandler = (event) => this.unforwardEvent(source, event);
            const newListenerHandler = (event) => this.forwardEvent(source, event);
            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);
            this.on(EventForwarder.newListenerEvent, newListenerHandler);
        }
    }
    static isEmitterEvent(event) {
        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;
    }
    get disposed() { return this.isDisposed; }
    dispose() {
        this.isDisposed = true;
        for (const listenerRemovers of this.forwardingEvents.values()) {
            for (const listenerRemover of listenerRemovers.values()) {
                try {
                    listenerRemover();
                }
                catch (_a) {
                    // Should be fine because of removeAllListeners below
                }
            }
        }
        this.removeAllListeners();
        this.forwardingEvents.clear();
    }
    forwardEvent(source, ...events) {
        for (const event of events) {
            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                let sources = this.forwardingEvents.get(event);
                if (sources === undefined) {
                    sources = new Map();
                    this.forwardingEvents.set(event, sources);
                }
                if (!sources.has(source)) {
                    const listener = (...args) => this.emit(event, ...args);
                    sources.set(source, () => source.off(event, listener));
                    source.on(event, listener);
                }
            }
        }
    }
    unforwardEvent(source, ...events) {
        for (const event of events) {
            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                const sources = this.forwardingEvents.get(event);
                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {
                    if (this.listenerCount(event) === 0) {
                        const listenerRemover = sources.get(source);
                        if (listenerRemover !== undefined) {
                            listenerRemover();
                        }
                        sources.delete(source);
                        if (sources.size === 0) {
                            this.forwardingEvents.delete(event);
                        }
                    }
                }
            }
        }
    }
}
EventForwarder.newListenerEvent = "newListener";
EventForwarder.removeListenerEvent = "removeListener";
//# sourceMappingURL=eventForwarder.js.map

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidObjectHandle": () => (/* binding */ FluidObjectHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class FluidObjectHandle {
    /**
     * Creates a new FluidObjectHandle.
     * @param value - The FluidObject object this handle is for.
     * @param path - The path to this handle relative to the routeContext.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(value, path, routeContext) {
        this.value = value;
        this.path = path;
        this.routeContext = routeContext;
        this.pendingHandlesToMakeVisible = new Set();
        // Tracks whether this handle is locally visible in the container.
        this.locallyVisible = false;
        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandle() { return this; }
    get isAttached() {
        return this.routeContext.isAttached;
    }
    /**
     * Tells whether the object of this handle is visible in the container locally or globally.
     */
    get visible() {
        /**
         * If the object of this handle is attached, it is visible in the container. Ideally, checking local visibility
         * should be enough for a handle. However, there are scenarios where the object becomes locally visible but the
         * handle does not know this - This will happen is attachGraph is never called on the handle. Couple of examples
         * where this can happen:
         * 1. Handles to DDS other than the default handle won't know if the DDS becomes visible after the handle was
         *    created.
         * 2. Handles to root data stores will never know that it was visible because the handle will not be stores in
         *    another DDS and so, attachGraph will never be called on it.
         */
        return this.isAttached || this.locallyVisible;
    }
    async get() {
        return this.value;
    }
    attachGraph() {
        if (this.visible) {
            return;
        }
        this.locallyVisible = true;
        this.pendingHandlesToMakeVisible.forEach((handle) => {
            handle.attachGraph();
        });
        this.pendingHandlesToMakeVisible.clear();
        this.routeContext.attachGraph();
    }
    bind(handle) {
        // If this handle is visible, attach the graph of the incoming handle as well.
        if (this.visible) {
            handle.attachGraph();
            return;
        }
        this.pendingHandlesToMakeVisible.add(handle);
    }
}
//# sourceMappingURL=fluidHandle.js.map

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateHandleContextPath": () => (/* binding */ generateHandleContextPath)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Generates the absolute path for a Fluid object given its path and its parent routeContext.
 * @param path - The path to the Fluid object relative to the route context.
 * @param routeContext - The route context that contains the Fluid object.
 * @returns The absolute path to the Fluid object from the root of the Container.
 */
function generateHandleContextPath(path, routeContext) {
    if (path === "") {
        // The `path` is empty.
        // If the routeContext does not exist, this is the root.
        // If the routeContext exists, the absolute path is the same as that of the routeContext.
        return routeContext === undefined ? "" : routeContext.absolutePath;
    }
    else {
        // Remove beginning and trailing slashes, if any, from the path.
        let normalizedPath = path.startsWith("/") ? path.slice(1) : path;
        normalizedPath = normalizedPath.endsWith("/") ? normalizedPath.slice(0, -1) : normalizedPath;
        // If the routeContext does not exist, path is the absolute path.
        // If the routeContext exists, absolute path is routeContext's absolute path plus the path.
        return routeContext === undefined
            ? `/${normalizedPath}`
            : `${routeContext.absolutePath === "/" ? "" : routeContext.absolutePath}/${normalizedPath}`;
    }
}
//# sourceMappingURL=dataStoreHandleContextUtils.js.map

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultFluidObjectRequestHandler": () => (/* binding */ defaultFluidObjectRequestHandler),
/* harmony export */   "defaultRouteRequestHandler": () => (/* binding */ defaultRouteRequestHandler),
/* harmony export */   "mountableViewRequestHandler": () => (/* binding */ mountableViewRequestHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * A mountable view is only required if the view needs to be mounted across a bundle boundary.  Mounting across
 * bundle boundaries breaks some frameworks, so the mountable view is used to ensure the mounting is done within
 * the same bundle as the view.  For example, React hooks don't work if mounted across bundles since there will
 * be two React instances, breaking the Rules of Hooks.  When cross-bundle mounting isn't required, the mountable
 * view isn't necessary.
 *
 * When a request is received with a mountableView: true header, this request handler will reissue the request
 * without the header, and respond with a mountable view of the given class using the response.
 * @param MountableViewClass - The type of mountable view to use when responding
 */
const mountableViewRequestHandler = (MountableViewClass, handlers) => {
    const nestedHandler = (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_0__.buildRuntimeRequestHandler)(...handlers);
    return async (request, runtime) => {
        var _a;
        const mountableView = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.mountableView) === true;
        let newRequest = request;
        if (mountableView) {
            // Reissue the request without the mountableView header.
            // We'll repack whatever the response is if we can.
            const headers = Object.assign({}, request.headers);
            delete headers.mountableView;
            newRequest = {
                url: request.url,
                headers,
            };
        }
        const response = await nestedHandler(newRequest, runtime);
        if (mountableView && response.status === 200 && MountableViewClass.canMount(response.value)) {
            return {
                status: 200,
                mimeType: "fluid/object",
                value: new MountableViewClass(response.value),
            };
        }
        return response;
    };
};
/**
 * Pipe through container request into internal request.
 * If request is empty and default url is provided, redirect request to such default url.
 * @param defaultRootId - optional default root data store ID to pass request in case request is empty.
 */
const defaultRouteRequestHandler = (defaultRootId) => {
    return async (request, runtime) => {
        const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.RequestParser.create(request);
        if (parser.pathParts.length === 0) {
            return runtime.IFluidHandleContext.resolveHandle({
                url: `/${defaultRootId}${parser.query}`,
                headers: request.headers
            });
        }
        return undefined; // continue search
    };
};
/**
 * Default request handler for a Fluid object that returns the object itself if:
 *  1. the request url is empty
 *  2. the request url is "/"
 *  3. the request url starts with "/" and is followed by a query param, such as /?key=value
 * Returns a 404 error for any other url.
 */
function defaultFluidObjectRequestHandler(fluidObject, request) {
    if (request.url === "" || request.url === "/" || request.url.startsWith("/?")) {
        return { mimeType: "fluid/object", status: 200, value: fluidObject };
    }
    else {
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(request);
    }
}
//# sourceMappingURL=requestHandlers.js.map

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuntimeRequestHandlerBuilder": () => (/* binding */ RuntimeRequestHandlerBuilder),
/* harmony export */   "buildRuntimeRequestHandler": () => (/* binding */ buildRuntimeRequestHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
  * The RuntimeRequestHandlerBuilder creates a runtime request handler based on request handlers.
  * The provided handlers sequentially applied until one is able to satisfy the request.
  */
class RuntimeRequestHandlerBuilder {
    constructor() {
        this.handlers = [];
    }
    pushHandler(...handlers) {
        if (handlers !== undefined) {
            this.handlers.push(...handlers);
        }
    }
    async handleRequest(request, runtime) {
        const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RequestParser.create(request);
        for (const handler of this.handlers) {
            const response = await handler(parser, runtime);
            if (response !== undefined) {
                return response;
            }
        }
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.create404Response)(request);
    }
}
function buildRuntimeRequestHandler(...handlers) {
    const builder = new RuntimeRequestHandlerBuilder();
    builder.pushHandler(...handlers);
    return async (request, runtime) => builder.handleRequest(request, runtime);
}
//# sourceMappingURL=runtimeRequestHandlerBuilder.js.map

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestParser": () => (/* binding */ RequestParser)
/* harmony export */ });
/**
 * The Request Parser takes an IRequest provides parsing and sub request creation
 */
class RequestParser {
    constructor(request) {
        this.request = request;
        const queryStartIndex = this.request.url.indexOf("?");
        if (queryStartIndex >= 0) {
            this.query = this.request.url.substring(queryStartIndex);
        }
        else {
            this.query = "";
        }
    }
    /**
     * Splits the path of the url and decodes each path part
     * @param url - the url to get path parts of
     */
    static getPathParts(url) {
        const queryStartIndex = url.indexOf("?");
        return url
            .substring(0, queryStartIndex < 0 ? url.length : queryStartIndex)
            .split("/")
            .reduce((pv, cv) => {
            if (cv !== undefined && cv.length > 0) {
                pv.push(decodeURIComponent(cv));
            }
            return pv;
        }, []);
    }
    static create(request) {
        // Perf optimizations.
        if (request instanceof RequestParser) {
            return request;
        }
        return new RequestParser(request);
    }
    get url() {
        return this.request.url;
    }
    get headers() {
        return this.request.headers;
    }
    /**
     * Returns the decoded path parts of the request's url
     */
    get pathParts() {
        if (this.requestPathParts === undefined) {
            this.requestPathParts = RequestParser.getPathParts(this.url);
        }
        return this.requestPathParts;
    }
    /**
     * Returns true if it's a terminating path, i.e. no more elements after `elements` entries and empty query.
     * @param elements - number of elements in path
     */
    isLeaf(elements) {
        return this.query === "" && this.pathParts.length === elements;
    }
    /**
     * Creates a sub request starting at a specific path part of this request's url
     * The sub request url always has a leading slash, and always include query params if original url has any
     * e.g. original url is /a/b/?queryParams, createSubRequest(0) is /a/b/?queryParams
     * createSubRequest(1) is /b/?queryParams
     * createSubRequest(2) is /?queryParams
     * createSubRequest(n) where n is bigger than parts length, e.g. 2, or n is less than 0 will throw an exception
     *
     * note: query params are not counted towards path parts.
     *
     * @param startingPathIndex - The index of the first path part of the sub request
     */
    createSubRequest(startingPathIndex) {
        const pathLen = this.pathParts.length;
        if (startingPathIndex < 0 || startingPathIndex > pathLen) {
            throw new Error("incorrect sub-request");
        }
        if (startingPathIndex === pathLen && this.url.includes("?")) {
            return {
                url: `/${this.query}`,
                headers: this.headers,
            };
        }
        const path = `/${this.pathParts.slice(startingPathIndex).join("/")}`;
        return {
            url: this.query === "" ? path : `${path}/${this.query}`,
            headers: this.headers,
        };
    }
}
//# sourceMappingURL=requestParser.js.map

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create404Response": () => (/* binding */ create404Response),
/* harmony export */   "createDataStoreFactory": () => (/* binding */ createDataStoreFactory),
/* harmony export */   "createResponseError": () => (/* binding */ createResponseError),
/* harmony export */   "exceptionToResponse": () => (/* binding */ exceptionToResponse),
/* harmony export */   "requestFluidObject": () => (/* binding */ requestFluidObject),
/* harmony export */   "responseToException": () => (/* binding */ responseToException)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


function exceptionToResponse(err) {
    const status = 500;
    if (err !== null && typeof err === "object" && err.errorFromRequestFluidObject === true) {
        const responseErr = err;
        return {
            mimeType: "text/plain",
            status: responseErr.code,
            value: responseErr.message,
            get stack() { return responseErr.stack; },
        };
    }
    // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it
    const errWithStack = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.generateErrorWithStack)();
    return {
        mimeType: "text/plain",
        status,
        value: `${err}`,
        get stack() { var _a; return (_a = (err === null || err === void 0 ? void 0 : err.stack)) !== null && _a !== void 0 ? _a : errWithStack.stack; },
    };
}
function responseToException(response, request) {
    const message = response.value;
    const errWithStack = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.generateErrorWithStack)();
    const responseErr = {
        errorFromRequestFluidObject: true,
        message,
        name: "Error",
        code: response.status,
        get stack() { var _a; return (_a = response.stack) !== null && _a !== void 0 ? _a : errWithStack.stack; },
    };
    return responseErr;
}
async function requestFluidObject(router, url) {
    const request = typeof url === "string" ? { url } : url;
    const response = await router.request(request);
    if (response.status !== 200 || response.mimeType !== "fluid/object") {
        throw responseToException(response, request);
    }
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(response.value, 0x19a /* "Invalid response value for Fluid object request" */);
    return response.value;
}
const create404Response = (request) => createResponseError(404, "not found", request);
function createResponseError(status, value, request) {
    var _a;
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(status !== 200, 0x19b /* "Cannot not create response error on 200 status" */);
    // Omit query string which could contain personal data (aka "PII")
    const urlNoQuery = (_a = request.url) === null || _a === void 0 ? void 0 : _a.split("?")[0];
    // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it
    const errWithStack = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.generateErrorWithStack)();
    return {
        mimeType: "text/plain",
        status,
        value: urlNoQuery === undefined ? value : `${value}: ${urlNoQuery}`,
        get stack() { return errWithStack.stack; },
    };
}
function createDataStoreFactory(type, factory) {
    return {
        type,
        get IFluidDataStoreFactory() { return this; },
        get IFluidDataStoreRegistry() { return this; },
        instantiateDataStore: async (context, existing) => (await factory).instantiateDataStore(context, existing),
        get: async (name) => { var _a; return (_a = (await factory).IFluidDataStoreRegistry) === null || _a === void 0 ? void 0 : _a.get(name); },
    };
}
//# sourceMappingURL=dataStoreHelpers.js.map

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingError": () => (/* binding */ LoggingError),
/* harmony export */   "extractLogSafeErrorProperties": () => (/* binding */ extractLogSafeErrorProperties),
/* harmony export */   "generateErrorWithStack": () => (/* binding */ generateErrorWithStack),
/* harmony export */   "generateStack": () => (/* binding */ generateStack),
/* harmony export */   "getCircularReplacer": () => (/* binding */ getCircularReplacer),
/* harmony export */   "isExternalError": () => (/* binding */ isExternalError),
/* harmony export */   "isILoggingError": () => (/* binding */ isILoggingError),
/* harmony export */   "isTaggedTelemetryPropertyValue": () => (/* binding */ isTaggedTelemetryPropertyValue),
/* harmony export */   "normalizeError": () => (/* binding */ normalizeError),
/* harmony export */   "wrapError": () => (/* binding */ wrapError),
/* harmony export */   "wrapErrorAndLog": () => (/* binding */ wrapErrorAndLog)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/** @returns true if value is an object but neither null nor an array */
const isRegularObject = (value) => {
    return value !== null && !Array.isArray(value) && typeof value === "object";
};
/** Inspect the given error for common "safe" props and return them */
function extractLogSafeErrorProperties(error, sanitizeStack) {
    const removeMessageFromStack = (stack, errorName) => {
        if (!sanitizeStack) {
            return stack;
        }
        const stackFrames = stack.split("\n");
        stackFrames.shift(); // Remove "[ErrorName]: [ErrorMessage]"
        if (errorName !== undefined) {
            stackFrames.unshift(errorName); // Add "[ErrorName]"
        }
        return stackFrames.join("\n");
    };
    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === "string")
        ? error.message
        : String(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack, name } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            const errorName = (typeof name === "string") ? name : undefined;
            safeProps.stack = removeMessageFromStack(stack, errorName);
        }
    }
    return safeProps;
}
/** type guard for ILoggingError interface */
const isILoggingError = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === "function";
/** Copy props from source onto target, but do not overwrite an existing prop that matches */
function copyProps(target, source) {
    for (const key of Object.keys(source)) {
        if (target[key] === undefined) {
            target[key] = source[key];
        }
    }
}
/** For backwards compatibility with pre-errorInstanceId valid errors */
function patchLegacyError(legacyError) {
    const patchMe = legacyError;
    if (patchMe.errorInstanceId === undefined) {
        patchMe.errorInstanceId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
    }
}
/**
 * Normalize the given error yielding a valid Fluid Error
 * @returns A valid Fluid Error with any provided annotations applied
 * @param error - The error to normalize
 * @param annotations - Annotations to apply to the normalized error
 */
function normalizeError(error, annotations = {}) {
    var _a;
    // Back-compat, while IFluidErrorBase is rolled out
    if ((0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.isValidLegacyError)(error)) {
        patchLegacyError(error);
    }
    if ((0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.isFluidError)(error)) {
        // We can simply add the telemetry props to the error and return it
        error.addTelemetryProperties((_a = annotations.props) !== null && _a !== void 0 ? _a : {});
        return error;
    }
    // We have to construct a new Fluid Error, copying safe properties over
    const { message, stack } = extractLogSafeErrorProperties(error, false /* sanitizeStack */);
    const fluidError = new NormalizedExternalError({
        message,
        stack,
    });
    // We need to preserve these properties which are used in a non-typesafe way throughout driver code (see #8743)
    // Anywhere they are set should be on a valid Fluid Error that would have been returned above,
    // but we can't prove it with the types, so adding this defensive measure.
    if (typeof error === "object" && error !== null) {
        const { canRetry, retryAfterSeconds } = error;
        Object.assign(normalizeError, { canRetry, retryAfterSeconds });
    }
    if (typeof (error) !== "object") {
        // This is only interesting for non-objects
        fluidError.addTelemetryProperties({ typeofError: typeof (error) });
    }
    const originalErrorTelemetryProps = isILoggingError(error) ? error.getTelemetryProperties() : {};
    fluidError.addTelemetryProperties(Object.assign(Object.assign(Object.assign({}, originalErrorTelemetryProps), annotations.props), { untrustedOrigin: 1 }));
    return fluidError;
}
let stackPopulatedOnCreation;
/**
 * The purpose of this function is to provide ability to capture stack context quickly.
 * Accessing new Error().stack is slow, and the slowest part is accessing stack property itself.
 * There are scenarios where we generate error with stack, but error is handled in most cases and
 * stack property is not accessed.
 * For such cases it's better to not read stack property right away, but rather delay it until / if it's needed
 * Some browsers will populate stack right away, others require throwing Error, so we do auto-detection on the fly.
 * @returns Error object that has stack populated.
 */
function generateErrorWithStack() {
    const err = new Error("<<generated stack>>");
    if (stackPopulatedOnCreation === undefined) {
        stackPopulatedOnCreation = (err.stack !== undefined);
    }
    if (stackPopulatedOnCreation) {
        return err;
    }
    try {
        throw err;
    }
    catch (e) {
        return e;
    }
}
function generateStack() {
    return generateErrorWithStack().stack;
}
/**
 * Create a new error using newErrorFn, wrapping and caused by the given unknown error.
 * Copies the inner error's stack, errorInstanceId and telemetry props over to the new error if present
 * @param innerError - An error from untrusted/unknown origins
 * @param newErrorFn - callback that will create a new error given the original error's message
 * @returns A new error object "wrapping" the given error
 */
function wrapError(innerError, newErrorFn) {
    const { message, stack, } = extractLogSafeErrorProperties(innerError, false /* sanitizeStack */);
    const newError = newErrorFn(message);
    if (stack !== undefined) {
        overwriteStack(newError, stack);
    }
    // Mark external errors with untrustedOrigin flag
    if (isExternalError(innerError)) {
        newError.addTelemetryProperties({ untrustedOrigin: 1 });
    }
    // Reuse errorInstanceId
    if ((0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.hasErrorInstanceId)(innerError)) {
        newError.overwriteErrorInstanceId(innerError.errorInstanceId);
        // For "back-compat" in the logs
        newError.addTelemetryProperties({ innerErrorInstanceId: innerError.errorInstanceId });
    }
    // Lastly, copy over all other telemetry properties. Note these will not overwrite existing properties
    // This will include the untrustedOrigin property if the inner error itself was created from an external error
    if (isILoggingError(innerError)) {
        newError.addTelemetryProperties(innerError.getTelemetryProperties());
    }
    return newError;
}
/** The same as wrapError, but also logs the innerError, including the wrapping error's instance id */
function wrapErrorAndLog(innerError, newErrorFn, logger) {
    const newError = wrapError(innerError, newErrorFn);
    // This will match innerError.errorInstanceId if present (see wrapError)
    const errorInstanceId = newError.errorInstanceId;
    // For "back-compat" in the logs
    const wrappedByErrorInstanceId = errorInstanceId;
    logger.sendTelemetryEvent({
        eventName: "WrapError",
        errorInstanceId,
        wrappedByErrorInstanceId,
    }, innerError);
    return newError;
}
function overwriteStack(error, stack) {
    // supposedly setting stack on an Error can throw.
    try {
        Object.assign(error, { stack });
    }
    catch (errorSettingStack) {
        error.addTelemetryProperties({ stack2: stack });
    }
}
/**
 * True for any error object that is an (optionally normalized) external error
 * False for any error we created and raised within the FF codebase, or wrapped in a well-known error type
 */
function isExternalError(e) {
    return !(0,_fluidErrorBase__WEBPACK_IMPORTED_MODULE_1__.isValidLegacyError)(e) ||
        (e.getTelemetryProperties().untrustedOrigin === 1 &&
            e.errorType === NormalizedExternalError.normalizedErrorType);
}
/**
 * Type guard to identify if a particular value (loosely) appears to be a tagged telemetry property
 */
function isTaggedTelemetryPropertyValue(x) {
    return (typeof (x === null || x === void 0 ? void 0 : x.value) !== "object" && typeof (x === null || x === void 0 ? void 0 : x.tag) === "string");
}
/**
 * Walk an object's enumerable properties to find those fit for telemetry.
 */
function getValidTelemetryProps(obj, keysToOmit) {
    const props = {};
    for (const key of Object.keys(obj)) {
        if (keysToOmit.has(key)) {
            continue;
        }
        const val = obj[key];
        switch (typeof val) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
                props[key] = val;
                break;
            default: {
                if (isTaggedTelemetryPropertyValue(val)) {
                    props[key] = val;
                }
                else {
                    // We don't support logging arbitrary objects
                    props[key] = "REDACTED (arbitrary object)";
                }
                break;
            }
        }
    }
    return props;
}
/**
 * Borrowed from
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value#examples}
 * Avoids runtime errors with circular references.
 * Not ideal, as will cut values that are not necessarily circular references.
 * Could be improved by implementing Node's util.inspect() for browser (minus all the coloring code)
*/
const getCircularReplacer = () => {
    const seen = new WeakSet();
    return (key, value) => {
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "<removed/circular>";
            }
            seen.add(value);
        }
        return value;
    };
};
/**
 * Base class for "trusted" errors we create, whose properties can generally be logged to telemetry safely.
 * All properties set on the object, or passed in (via the constructor or addTelemetryProperties),
 * will be logged in accordance with their tag, if present.
 *
 * PLEASE take care to avoid setting sensitive data on this object without proper tagging!
 */
class LoggingError extends Error {
    /**
     * Create a new LoggingError
     * @param message - Error message to use for Error base class
     * @param props - telemetry props to include on the error for when it's logged
     * @param omitPropsFromLogging - properties by name to omit from telemetry props
     */
    constructor(message, props, omitPropsFromLogging = new Set()) {
        super(message);
        this.omitPropsFromLogging = omitPropsFromLogging;
        this._errorInstanceId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
        /** Back-compat to appease isFluidError typeguard in old code that may handle this error */
        // @ts-expect-error - This field shouldn't be referenced in the current version, but needs to exist at runtime.
        this.fluidErrorCode = "-";
        // Don't log this list itself, or the private _errorInstanceId
        omitPropsFromLogging.add("omitPropsFromLogging");
        omitPropsFromLogging.add("_errorInstanceId");
        if (props) {
            this.addTelemetryProperties(props);
        }
    }
    get errorInstanceId() { return this._errorInstanceId; }
    overwriteErrorInstanceId(id) { this._errorInstanceId = id; }
    /**
     * Add additional properties to be logged
     */
    addTelemetryProperties(props) {
        copyProps(this, props);
    }
    /**
     * Get all properties fit to be logged to telemetry for this error
     */
    getTelemetryProperties() {
        const taggableProps = getValidTelemetryProps(this, this.omitPropsFromLogging);
        // Include non-enumerable props that are not returned by getValidTelemetryProps
        return Object.assign(Object.assign({}, taggableProps), { stack: this.stack, message: this.message, errorInstanceId: this._errorInstanceId });
    }
}
/** The Error class used when normalizing an external error */
class NormalizedExternalError extends LoggingError {
    constructor(errorProps) {
        super(errorProps.message);
        this.errorType = NormalizedExternalError.normalizedErrorType;
        if (errorProps.stack !== undefined) {
            overwriteStack(this, errorProps.stack);
        }
    }
}
// errorType "genericError" is used as a default value throughout the code.
// Note that this matches ContainerErrorType/DriverErrorType's genericError
NormalizedExternalError.normalizedErrorType = "genericError";
//# sourceMappingURL=errorLogging.js.map

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasErrorInstanceId": () => (/* binding */ hasErrorInstanceId),
/* harmony export */   "isFluidError": () => (/* binding */ isFluidError),
/* harmony export */   "isValidLegacyError": () => (/* binding */ isValidLegacyError)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const hasTelemetryPropFunctions = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === "function" &&
    typeof (x === null || x === void 0 ? void 0 : x.addTelemetryProperties) === "function";
const hasErrorInstanceId = (x) => typeof (x === null || x === void 0 ? void 0 : x.errorInstanceId) === "string";
/** type guard for IFluidErrorBase interface */
function isFluidError(e) {
    return typeof (e === null || e === void 0 ? void 0 : e.errorType) === "string" &&
        typeof (e === null || e === void 0 ? void 0 : e.message) === "string" &&
        hasErrorInstanceId(e) &&
        hasTelemetryPropFunctions(e);
}
/** type guard for old standard of valid/known errors */
function isValidLegacyError(e) {
    return typeof (e === null || e === void 0 ? void 0 : e.errorType) === "string" &&
        typeof (e === null || e === void 0 ? void 0 : e.message) === "string" &&
        hasTelemetryPropFunctions(e);
}
//# sourceMappingURL=fluidErrorBase.js.map

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFluidObjectResponse": () => (/* binding */ createFluidObjectResponse),
/* harmony export */   "handleFromLegacyUri": () => (/* binding */ handleFromLegacyUri),
/* harmony export */   "rootDataStoreRequestHandler": () => (/* binding */ rootDataStoreRequestHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * A request handler to expose access to all root data stores in the container by id.
 * @param request - the request for the root data store.  The first path part must be the data store's ID.
 * @param runtime - the container runtime
 * @returns the result of the request
 */
const rootDataStoreRequestHandler = async (request, runtime) => {
    var _a;
    const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RequestParser.create(request);
    const id = requestParser.pathParts[0];
    const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.wait) === "boolean" ? request.headers.wait : undefined;
    let rootDataStore;
    try {
        // getRootDataStore currently throws if the data store is not found
        rootDataStore = await runtime.getRootDataStore(id, wait);
    }
    catch (error) {
        return undefined; // continue search
    }
    try {
        return rootDataStore.IFluidRouter.request(requestParser.createSubRequest(1));
    }
    catch (error) {
        return { status: 500, mimeType: "fluid/object", value: error };
    }
};
const createFluidObjectResponse = (fluidObject) => {
    return { status: 200, mimeType: "fluid/object", value: fluidObject };
};
class LegacyUriHandle {
    constructor(absolutePath, runtime) {
        this.absolutePath = absolutePath;
        this.runtime = runtime;
        this.isAttached = true;
    }
    get IFluidHandle() { return this; }
    attachGraph() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(false, 0x0ca /* "Trying to use legacy graph attach!" */);
    }
    async get() {
        const response = await this.runtime.IFluidHandleContext.resolveHandle({ url: this.absolutePath });
        if (response.status === 200 && response.mimeType === "fluid/object") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return response.value;
        }
        throw new Error(`Failed to resolve container path ${this.absolutePath}`);
    }
    bind(handle) {
        throw new Error("Cannot bind to LegacyUriHandle");
    }
}
function handleFromLegacyUri(uri, runtime) {
    return new LegacyUriHandle(uri, runtime);
}
//# sourceMappingURL=requestHandlers.js.map

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContainerService": () => (/* binding */ BaseContainerService),
/* harmony export */   "generateContainerServicesRequestHandler": () => (/* binding */ generateContainerServicesRequestHandler),
/* harmony export */   "serviceRoutePathRoot": () => (/* binding */ serviceRoutePathRoot)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

// TODO: should this just be "s"?
const serviceRoutePathRoot = "_services";
/**
 * This class is a simple starter class for building a Container Service. It simply provides routing
 */
class BaseContainerService {
    constructor(runtime) {
        this.runtime = runtime;
    }
    get IFluidRouter() { return this; }
    async request(request) {
        return {
            status: 200,
            mimeType: "fluid/object",
            value: this,
        };
    }
}
/**
 * ContainerService Factory that will only create one instance of the service for the Container.
 */
class SingletonContainerServiceFactory {
    constructor(serviceFn) {
        this.serviceFn = serviceFn;
    }
    async getService(runtime) {
        if (!this.service) {
            this.service = this.serviceFn(runtime);
        }
        return this.service;
    }
}
/**
 * Given a collection of IContainerServices will produce a RequestHandler for them all
 * @param serviceRegistry - Collection of Container Services
 */
const generateContainerServicesRequestHandler = (serviceRegistry) => {
    const factories = new Map();
    new Map(serviceRegistry).forEach((fn, id) => {
        factories.set(id, new SingletonContainerServiceFactory(fn));
    });
    return async (request, runtime) => {
        if (request.pathParts[0] !== serviceRoutePathRoot) {
            // If the request is not for a service we return undefined so the next handler can use it
            return undefined;
        }
        if (request.pathParts.length < 2) {
            // If there is not service to route to then return a failure
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.createResponseError)(400, "request did not specify a service to route to", request);
        }
        const factory = factories.get(request.pathParts[1]);
        if (!factory) {
            // If we can't find a registry entry then return
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.create404Response)(request);
        }
        const service = await factory.getService(runtime);
        const router = service.IFluidRouter;
        const subRequest = request.createSubRequest(2);
        if (router) {
            return router.request(subRequest);
        }
        if (!request.isLeaf(2)) {
            // If there is not terminating route but a sub-route was requested then we will fail.
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.createResponseError)(400, "request sub-url for service that doesn't support routing", request);
        }
        // Otherwise we will just return the service
        return {
            status: 200,
            mimeType: "fluid/object",
            value: service,
        };
    };
};
//# sourceMappingURL=containerServices.js.map

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectoryFactory": () => (/* binding */ DirectoryFactory),
/* harmony export */   "SharedDirectory": () => (/* binding */ SharedDirectory)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(139);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(141);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(140);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(137);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(91);
/* harmony import */ var path_browserify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var path_browserify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_browserify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(136);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a, _b;









// We use path-browserify since this code can run safely on the server or the browser.
// We standardize on using posix slashes everywhere.
const posix = path_browserify__WEBPACK_IMPORTED_MODULE_0__.posix;
const snapshotFileName = "header";
/**
 * The factory that defines the directory.
 * @sealed
 */
class DirectoryFactory {
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
     */
    get type() {
        return DirectoryFactory.Type;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
     */
    get attributes() {
        return DirectoryFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const directory = new SharedDirectory(id, runtime, attributes);
        await directory.load(services);
        return directory;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}
     */
    create(runtime, id) {
        const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);
        directory.initializeLocal();
        return directory;
    }
}
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
 */
DirectoryFactory.Type = "https://graph.microsoft.com/types/directory";
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
 */
DirectoryFactory.Attributes = {
    type: DirectoryFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion,
};
/**
 * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.
 * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.
 * SubDirectories can be retrieved for use as working directories.
 *
 * @example
 * ```typescript
 * mySharedDirectory.createSubDirectory("a").createSubDirectory("b").createSubDirectory("c").set("foo", val1);
 * const mySubDir = mySharedDirectory.getWorkingDirectory("/a/b/c");
 * mySubDir.get("foo"); // returns val1
 * ```
 *
 * @sealed
 */
class SharedDirectory extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.SharedObject {
    /**
     * Constructs a new shared directory. If the object is non-local an id and service interfaces will
     * be provided.
     * @param id - String identifier for the SharedDirectory
     * @param runtime - Data store runtime
     * @param type - Type identifier
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes, "fluid_directory_");
        /**
         * String representation for the class.
         */
        this[_a] = "SharedDirectory";
        /**
         * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.
         */
        this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        this.localValueMaker = new _localValues__WEBPACK_IMPORTED_MODULE_3__.LocalValueMaker(this.serializer);
        this.setMessageHandlers();
        // Mirror the containedValueChanged op on the SharedDirectory
        this.root.on("containedValueChanged", (changed, local) => {
            this.emit("containedValueChanged", changed, local, this);
        });
        this.root.on("subDirectoryCreated", (relativePath, local) => {
            this.emit("subDirectoryCreated", relativePath, local, this);
        });
        this.root.on("subDirectoryDeleted", (relativePath, local) => {
            this.emit("subDirectoryDeleted", relativePath, local, this);
        });
    }
    /**
     * Create a new shared directory
     *
     * @param runtime - Data store runtime the new shared directory belongs to
     * @param id - Optional name of the shared directory
     * @returns Newly create shared directory (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, DirectoryFactory.Type);
    }
    /**
     * Get a factory for SharedDirectory to register with the data store.
     *
     * @returns A factory that creates and load SharedDirectory
     */
    static getFactory() {
        return new DirectoryFactory();
    }
    /**
     * {@inheritDoc IDirectory.absolutePath}
     */
    get absolutePath() {
        return this.root.absolutePath;
    }
    /**
     * {@inheritDoc IDirectory.get}
     */
    get(key) {
        return this.root.get(key);
    }
    /**
     * {@inheritDoc IDirectory.set}
     */
    set(key, value) {
        this.root.set(key, value);
        return this;
    }
    dispose(error) {
        this.root.dispose(error);
    }
    get disposed() {
        return this.root.disposed;
    }
    /**
     * Deletes the given key from within this IDirectory.
     * @param key - The key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        return this.root.delete(key);
    }
    /**
     * Deletes all keys from within this IDirectory.
     */
    clear() {
        this.root.clear();
    }
    /**
     * Checks whether the given key exists in this IDirectory.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.root.has(key);
    }
    /**
     * The number of entries under this IDirectory.
     */
    get size() {
        return this.root.size;
    }
    /**
     * Issue a callback on each entry under this IDirectory.
     * @param callback - Callback to issue
     */
    forEach(callback) {
        this.root.forEach(callback);
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.root[Symbol.iterator]();
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    entries() {
        return this.root.entries();
    }
    /**
     * {@inheritDoc IDirectory.countSubDirectory}
     */
    countSubDirectory() {
        return this.root.countSubDirectory();
    }
    /**
     * Get an iterator over the keys under this IDirectory.
     * @returns The iterator
     */
    keys() {
        return this.root.keys();
    }
    /**
     * Get an iterator over the values under this IDirectory.
     * @returns The iterator
     */
    values() {
        return this.root.values();
    }
    /**
     * {@inheritDoc IDirectory.createSubDirectory}
     */
    createSubDirectory(subdirName) {
        return this.root.createSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.getSubDirectory}
     */
    getSubDirectory(subdirName) {
        return this.root.getSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.hasSubDirectory}
     */
    hasSubDirectory(subdirName) {
        return this.root.hasSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.deleteSubDirectory}
     */
    deleteSubDirectory(subdirName) {
        return this.root.deleteSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.subdirectories}
     */
    subdirectories() {
        return this.root.subdirectories();
    }
    /**
     * {@inheritDoc IDirectory.getWorkingDirectory}
     */
    getWorkingDirectory(relativePath) {
        const absolutePath = this.makeAbsolute(relativePath);
        if (absolutePath === posix.sep) {
            return this.root;
        }
        let currentSubDir = this.root;
        const subdirs = absolutePath.substr(1).split(posix.sep);
        for (const subdir of subdirs) {
            currentSubDir = currentSubDir.getSubDirectory(subdir);
            if (!currentSubDir) {
                return undefined;
            }
        }
        return currentSubDir;
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}
     * @internal
     */
    summarizeCore(serializer, telemetryContext) {
        return this.serializeDirectory(this.root, serializer);
    }
    /**
     * Submits an operation
     * @param op - Op to submit
     * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track
     * this op while it has not been ack'd. This will be sent when we receive this op back from the server.
     * @internal
     */
    submitDirectoryMessage(op, localOpMetadata) {
        this.submitLocalMessage(op, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}
     * @internal
     */
    onDisconnect() { }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}
     * @internal
     */
    reSubmitCore(content, localOpMetadata) {
        const message = content;
        const handler = this.messageHandlers.get(message.type);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(handler !== undefined, 0x00d /* Missing message handler for message type */);
        handler.submit(message, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     * @internal
     */
    async loadCore(storage) {
        const data = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.readAndParse)(storage, snapshotFileName);
        const newFormat = data;
        if (Array.isArray(newFormat.blobs)) {
            // New storage format
            this.populate(newFormat.content);
            await Promise.all(newFormat.blobs.map(async (value) => {
                const dataExtra = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.readAndParse)(storage, value);
                this.populate(dataExtra);
            }));
        }
        else {
            // Old storage format
            this.populate(data);
        }
    }
    /**
     * Populate the directory with the given directory data.
     * @param data - A JSON string containing serialized directory data
     * @internal
     */
    populate(data) {
        const stack = [];
        stack.push([this.root, data]);
        while (stack.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [currentSubDir, currentSubDirObject] = stack.pop();
            if (currentSubDirObject.subdirectories) {
                for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {
                    let newSubDir = currentSubDir.getSubDirectory(subdirName);
                    if (!newSubDir) {
                        newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));
                        currentSubDir.populateSubDirectory(subdirName, newSubDir);
                    }
                    stack.push([newSubDir, subdirObject]);
                }
            }
            if (currentSubDirObject.storage) {
                for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {
                    const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);
                    currentSubDir.populateStorage(key, localValue);
                }
            }
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}
     * @internal
     */
    processCore(message, local, localOpMetadata) {
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.Operation) {
            const op = message.contents;
            const handler = this.messageHandlers.get(op.type);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(handler !== undefined, 0x00e /* Missing message handler for message type */);
            handler.process(op, local, localOpMetadata);
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}
     * @internal
    */
    rollback(content, localOpMetadata) {
        const op = content;
        const subdir = this.getWorkingDirectory(op.path);
        if (subdir) {
            subdir.rollback(op, localOpMetadata);
        }
    }
    /**
     * Converts the given relative path to absolute against the root.
     * @param relativePath - The path to convert
     */
    makeAbsolute(relativePath) {
        return posix.resolve(posix.sep, relativePath);
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)
     * will have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job
     * is to convert that information into a real object for local usage.
     * @param key - Key of element being converted
     * @param absolutePath - Path of element being converted
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, absolutePath, serializable) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType.Plain] || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_7__.ValueType.Shared], 0x1e4 /* "Unexpected serializable type" */);
        return this.localValueMaker.fromSerializable(serializable);
    }
    /**
     * Set the message handlers for the directory.
     */
    setMessageHandlers() {
        this.messageHandlers.set("clear", {
            process: (op, local, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.processClearMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.resubmitClearMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("delete", {
            process: (op, local, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.processDeleteMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.resubmitKeyMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("set", {
            process: (op, local, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);
                    subdir.processSetMessage(op, context, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.resubmitKeyMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("createSubDirectory", {
            process: (op, local, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    parentSubdir.processCreateSubDirectoryMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("deleteSubDirectory", {
            process: (op, local, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    parentSubdir.processDeleteSubDirectoryMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);
                }
            },
        });
    }
    /**
     * @internal
     */
    applyStashedOp() {
        throw new Error("not implemented");
    }
    serializeDirectory(root, serializer, telemetryContext) {
        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_8__.SummaryTreeBuilder();
        let counter = 0;
        const blobs = [];
        const stack = [];
        const content = {};
        stack.push([root, content]);
        while (stack.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [currentSubDir, currentSubDirObject] = stack.pop();
            for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {
                if (!currentSubDirObject.storage) {
                    currentSubDirObject.storage = {};
                }
                const result = {
                    type: value.type,
                    // eslint-disable-next-line @typescript-eslint/ban-types
                    value: value.value && JSON.parse(value.value),
                };
                if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {
                    const extraContent = {};
                    let largeContent = extraContent;
                    if (currentSubDir.absolutePath !== posix.sep) {
                        for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {
                            const subDataObject = {};
                            largeContent.subdirectories = { [dir]: subDataObject };
                            largeContent = subDataObject;
                        }
                    }
                    largeContent.storage = { [key]: result };
                    const blobName = `blob${counter}`;
                    counter++;
                    blobs.push(blobName);
                    builder.addBlob(blobName, JSON.stringify(extraContent));
                }
                else {
                    currentSubDirObject.storage[key] = result;
                }
            }
            for (const [subdirName, subdir] of currentSubDir.subdirectories()) {
                if (!currentSubDirObject.subdirectories) {
                    currentSubDirObject.subdirectories = {};
                }
                const subDataObject = {};
                currentSubDirObject.subdirectories[subdirName] = subDataObject;
                stack.push([subdir, subDataObject]);
            }
        }
        const newFormat = {
            blobs,
            content,
        };
        builder.addBlob(snapshotFileName, JSON.stringify(newFormat));
        return builder.getSummaryTree();
    }
}
function isKeyEditLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" && metadata.type === "edit";
}
function isClearLocalOpMetadata(metadata) {
    return metadata !== undefined && metadata.type === "clear" && typeof metadata.pendingMessageId === "number" &&
        typeof metadata.previousStorage === "object";
}
function isSubDirLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        ((metadata.type === "createSubDir" && typeof metadata.previouslyExisted === "boolean") ||
            metadata.type === "deleteSubDir");
}
function isDirectoryLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        (metadata.type === "edit" || metadata.type === "deleteSubDir" ||
            (metadata.type === "clear" && typeof metadata.previousStorage === "object") ||
            (metadata.type === "createSubDir" && typeof metadata.previouslyExisted === "boolean"));
}
/**
 * Node of the directory tree.
 * @sealed
 */
class SubDirectory extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.TypedEventEmitter {
    /**
     * Constructor.
     * @param directory - Reference back to the SharedDirectory to perform operations
     * @param runtime - The data store runtime this directory is associated with
     * @param serializer - The serializer to serialize / parse handles
     * @param absolutePath - The absolute path of this IDirectory
     */
    constructor(directory, runtime, serializer, absolutePath) {
        super();
        this.directory = directory;
        this.runtime = runtime;
        this.serializer = serializer;
        this.absolutePath = absolutePath;
        /**
         * Tells if the sub directory is deleted or not.
         */
        this._deleted = false;
        /**
         * String representation for the class.
         */
        this[_b] = "SubDirectory";
        /**
         * The in-memory data the directory is storing.
         */
        this._storage = new Map();
        /**
         * The subdirectories the directory is holding.
         */
        this._subdirectories = new Map();
        /**
         * Keys that have been modified locally but not yet ack'd from the server.
         */
        this.pendingKeys = new Map();
        /**
         * Subdirectories that have been modified locally but not yet ack'd from the server.
         */
        this.pendingSubDirectories = new Map();
        /**
         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.
         */
        this.pendingMessageId = -1;
        /**
         * The pending ids of any clears that have been performed locally but not yet ack'd from the server
         */
        this.pendingClearMessageIds = [];
    }
    dispose(error) {
        this._deleted = true;
        this.emit("disposed", this);
    }
    /**
     * Unmark the deleted property when rolling back delete.
     */
    undispose() {
        this._deleted = false;
    }
    get disposed() {
        return this._deleted;
    }
    throwIfDisposed() {
        if (this._deleted) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.UsageError("Cannot access Disposed subDirectory");
        }
    }
    /**
     * Checks whether the given key exists in this IDirectory.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        this.throwIfDisposed();
        return this._storage.has(key);
    }
    /**
     * {@inheritDoc IDirectory.get}
     */
    get(key) {
        var _c;
        this.throwIfDisposed();
        return (_c = this._storage.get(key)) === null || _c === void 0 ? void 0 : _c.value;
    }
    /**
     * {@inheritDoc IDirectory.set}
     */
    set(key, value) {
        this.throwIfDisposed();
        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.
        if (key === undefined || key === null) {
            throw new Error("Undefined and null keys are not supported");
        }
        // Create a local value and serialize it.
        const localValue = this.directory.localValueMaker.fromInMemory(value);
        const serializableValue = (0,_localValues__WEBPACK_IMPORTED_MODULE_3__.makeSerializable)(localValue, this.serializer, this.directory.handle);
        // Set the value locally.
        const previousValue = this.setCore(key, localValue, true);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return this;
        }
        const op = {
            key,
            path: this.absolutePath,
            type: "set",
            value: serializableValue,
        };
        this.submitKeyMessage(op, previousValue);
        return this;
    }
    /**
     * {@inheritDoc IDirectory.countSubDirectory}
     */
    countSubDirectory() {
        return this._subdirectories.size;
    }
    /**
     * {@inheritDoc IDirectory.createSubDirectory}
     */
    createSubDirectory(subdirName) {
        this.throwIfDisposed();
        // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.
        if (subdirName === undefined || subdirName === null) {
            throw new Error("SubDirectory name may not be undefined or null");
        }
        if (subdirName.includes(posix.sep)) {
            throw new Error(`SubDirectory name may not contain ${posix.sep}`);
        }
        // Create the sub directory locally first.
        const isNew = this.createSubDirectoryCore(subdirName, true);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const subDir = this._subdirectories.get(subdirName);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return subDir;
        }
        const op = {
            path: this.absolutePath,
            subdirName,
            type: "createSubDirectory",
        };
        this.submitCreateSubDirectoryMessage(op, !isNew);
        return subDir;
    }
    /**
     * {@inheritDoc IDirectory.getSubDirectory}
     */
    getSubDirectory(subdirName) {
        this.throwIfDisposed();
        return this._subdirectories.get(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.hasSubDirectory}
     */
    hasSubDirectory(subdirName) {
        this.throwIfDisposed();
        return this._subdirectories.has(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.deleteSubDirectory}
     */
    deleteSubDirectory(subdirName) {
        this.throwIfDisposed();
        // Delete the sub directory locally first.
        const subDir = this.deleteSubDirectoryCore(subdirName, true);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return subDir !== undefined;
        }
        const op = {
            path: this.absolutePath,
            subdirName,
            type: "deleteSubDirectory",
        };
        this.submitDeleteSubDirectoryMessage(op, subDir);
        return subDir !== undefined;
    }
    /**
     * {@inheritDoc IDirectory.subdirectories}
     */
    subdirectories() {
        this.throwIfDisposed();
        return this._subdirectories.entries();
    }
    /**
     * {@inheritDoc IDirectory.getWorkingDirectory}
     */
    getWorkingDirectory(relativePath) {
        this.throwIfDisposed();
        return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));
    }
    /**
     * Deletes the given key from within this IDirectory.
     * @param key - The key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        this.throwIfDisposed();
        // Delete the key locally first.
        const previousValue = this.deleteCore(key, true);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return previousValue !== undefined;
        }
        const op = {
            key,
            path: this.absolutePath,
            type: "delete",
        };
        this.submitKeyMessage(op, previousValue);
        return previousValue !== undefined;
    }
    /**
     * Deletes all keys from within this IDirectory.
     */
    clear() {
        this.throwIfDisposed();
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            this.clearCore(true);
            return;
        }
        const copy = new Map(this._storage);
        this.clearCore(true);
        const op = {
            path: this.absolutePath,
            type: "clear",
        };
        this.submitClearMessage(op, copy);
    }
    /**
     * Issue a callback on each entry under this IDirectory.
     * @param callback - Callback to issue
     */
    forEach(callback) {
        this.throwIfDisposed();
        this._storage.forEach((localValue, key, map) => {
            callback(localValue.value, key, map);
        });
    }
    /**
     * The number of entries under this IDirectory.
     */
    get size() {
        this.throwIfDisposed();
        return this._storage.size;
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    entries() {
        this.throwIfDisposed();
        const localEntriesIterator = this._storage.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the keys under this IDirectory.
     * @returns The iterator
     */
    keys() {
        this.throwIfDisposed();
        return this._storage.keys();
    }
    /**
     * Get an iterator over the values under this IDirectory.
     * @returns The iterator
     */
    values() {
        this.throwIfDisposed();
        const localValuesIterator = this._storage.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: nextVal.value.value, done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        this.throwIfDisposed();
        return this.entries();
    }
    /**
     * Process a clear operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processClearMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (local) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x00f /* pendingMessageId is missing from the local client's operation */);
            const pendingClearMessageId = this.pendingClearMessageIds.shift();
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32a /* pendingMessageId does not match */);
            return;
        }
        this.clearExceptPendingKeys();
    }
    /**
     * Process a delete operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processDeleteMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {
            return;
        }
        this.deleteCore(op.key, local);
    }
    /**
     * Process a set operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processSetMessage(op, context, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {
            return;
        }
        // needProcessStorageOperation should have returned false if local is true
        // so we can assume context is not undefined
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.setCore(op.key, context, local);
    }
    /**
     * Process a create subdirectory operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processCreateSubDirectoryMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {
            return;
        }
        this.createSubDirectoryCore(op.subdirName, local);
    }
    /**
     * Process a delete subdirectory operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processDeleteSubDirectoryMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {
            return;
        }
        this.deleteSubDirectoryCore(op.subdirName, local);
    }
    /**
     * Submit a clear operation.
     * @param op - The operation
     */
    submitClearMessage(op, previousValue) {
        this.throwIfDisposed();
        const pendingMsgId = ++this.pendingMessageId;
        this.pendingClearMessageIds.push(pendingMsgId);
        const metadata = {
            type: "clear",
            pendingMessageId: pendingMsgId,
            previousStorage: previousValue,
        };
        this.directory.submitDirectoryMessage(op, metadata);
    }
    /**
     * Resubmit a clear operation.
     * @param op - The operation
     * @internal
     */
    resubmitClearMessage(op, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x32b /* Invalid localOpMetadata for clear */);
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const pendingClearMessageId = this.pendingClearMessageIds.shift();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32c /* pendingMessageId does not match */);
        this.submitClearMessage(op, localOpMetadata.previousStorage);
    }
    /**
     * Get a new pending message id for the op and cache it to track the pending op
     */
    getKeyMessageId(op) {
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const pendingMessageId = ++this.pendingMessageId;
        const pendingMessageIds = this.pendingKeys.get(op.key);
        if (pendingMessageIds !== undefined) {
            pendingMessageIds.push(pendingMessageId);
        }
        else {
            this.pendingKeys.set(op.key, [pendingMessageId]);
        }
        return pendingMessageId;
    }
    /**
     * Submit a key operation.
     * @param op - The operation
     * @param previousValue - The value of the key before this op
     */
    submitKeyMessage(op, previousValue) {
        this.throwIfDisposed();
        const pendingMessageId = this.getKeyMessageId(op);
        const localMetadata = { type: "edit", pendingMessageId, previousValue };
        this.directory.submitDirectoryMessage(op, localMetadata);
    }
    /**
     * Submit a key message to remote clients based on a previous submit.
     * @param op - The map key message
     * @param localOpMetadata - Metadata from the previous submit
     * @internal
     */
    resubmitKeyMessage(op, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isKeyEditLocalOpMetadata(localOpMetadata), 0x32d /* Invalid localOpMetadata in submit */);
        // clear the old pending message id
        const pendingMessageIds = this.pendingKeys.get(op.key);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x32e /* Unexpected pending message received */);
        pendingMessageIds.shift();
        if (pendingMessageIds.length === 0) {
            this.pendingKeys.delete(op.key);
        }
        this.submitKeyMessage(op, localOpMetadata.previousValue);
    }
    /**
     * Get a new pending message id for the op and cache it to track the pending op
     */
    getSubDirMessageId(op) {
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const newMessageId = ++this.pendingMessageId;
        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);
        if (pendingMessageIds !== undefined) {
            pendingMessageIds.push(newMessageId);
        }
        else {
            this.pendingSubDirectories.set(op.subdirName, [newMessageId]);
        }
        return newMessageId;
    }
    /**
     * Submit a create subdirectory operation.
     * @param op - The operation
     * @param prevExisted - Whether the subdirectory existed before the op
     */
    submitCreateSubDirectoryMessage(op, prevExisted) {
        this.throwIfDisposed();
        const newMessageId = this.getSubDirMessageId(op);
        const localOpMetadata = {
            type: "createSubDir",
            pendingMessageId: newMessageId,
            previouslyExisted: prevExisted,
        };
        this.directory.submitDirectoryMessage(op, localOpMetadata);
    }
    /**
     * Submit a delete subdirectory operation.
     * @param op - The operation
     * @param subDir - Any subdirectory deleted by the op
     */
    submitDeleteSubDirectoryMessage(op, subDir) {
        this.throwIfDisposed();
        const newMessageId = this.getSubDirMessageId(op);
        const localOpMetadata = {
            type: "deleteSubDir",
            pendingMessageId: newMessageId,
            subDirectory: subDir,
        };
        this.directory.submitDirectoryMessage(op, localOpMetadata);
    }
    /**
     * Submit a subdirectory operation again
     * @param op - The operation
     * @param localOpMetadata - metadata submitted with the op originally
     * @internal
     */
    resubmitSubDirectoryMessage(op, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isSubDirLocalOpMetadata(localOpMetadata), 0x32f /* Invalid localOpMetadata for sub directory op */);
        // clear the old pending message id
        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x330 /* Unexpected pending message received */);
        pendingMessageIds.shift();
        if (pendingMessageIds.length === 0) {
            this.pendingSubDirectories.delete(op.subdirName);
        }
        if (localOpMetadata.type === "createSubDir") {
            this.submitCreateSubDirectoryMessage(op, localOpMetadata.previouslyExisted);
        }
        else {
            this.submitDeleteSubDirectoryMessage(op, localOpMetadata.subDirectory);
        }
    }
    /**
     * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns The JSONable string representing the storage of this subdirectory
     * @internal
     */
    *getSerializedStorage(serializer) {
        this.throwIfDisposed();
        for (const [key, localValue] of this._storage) {
            const value = localValue.makeSerialized(serializer, this.directory.handle);
            const res = [key, value];
            yield res;
        }
    }
    /**
     * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.
     * @param key - The key to populate
     * @param localValue - The local value to populate into it
     * @internal
     */
    populateStorage(key, localValue) {
        this.throwIfDisposed();
        this._storage.set(key, localValue);
    }
    /**
     * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.
     * @param subdirName - The name of the subdirectory to add
     * @param newSubDir - The new subdirectory to add
     * @internal
     */
    populateSubDirectory(subdirName, newSubDir) {
        this.throwIfDisposed();
        this._subdirectories.set(subdirName, newSubDir);
    }
    /**
     * Retrieve the local value at the given key.  This is used to get value type information stashed on the local
     * value so op handlers can be retrieved
     * @param key - The key to retrieve from
     * @returns The local value
     * @internal
     */
    getLocalValue(key) {
        this.throwIfDisposed();
        return this._storage.get(key);
    }
    /**
     * Remove the pendingMessageId from the map tracking it on rollback
     * @param map - map tracking the pending messages
     * @param key - key of the edit in the op
     */
    rollbackPendingMessageId(map, key, pendingMessageId) {
        const pendingMessageIds = map.get(key);
        const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();
        if (!pendingMessageIds || lastPendingMessageId !== pendingMessageId) {
            throw new Error("Rollback op does not match last pending");
        }
        if (pendingMessageIds.length === 0) {
            map.delete(key);
        }
    }
    /**
     * Rollback a local op
     * @param op - The operation to rollback
     * @param localOpMetadata - The local metadata associated with the op.
     */
    rollback(op, localOpMetadata) {
        if (!isDirectoryLocalOpMetadata(localOpMetadata)) {
            throw new Error("Invalid localOpMetadata");
        }
        if (op.type === "clear" && localOpMetadata.type === "clear") {
            localOpMetadata.previousStorage.forEach((localValue, key) => {
                this.setCore(key, localValue, true);
            });
            const lastPendingClearId = this.pendingClearMessageIds.pop();
            if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {
                throw new Error("Rollback op does match last clear");
            }
        }
        else if ((op.type === "delete" || op.type === "set") && localOpMetadata.type === "edit") {
            if (localOpMetadata.previousValue === undefined) {
                this.deleteCore(op.key, true);
            }
            else {
                this.setCore(op.key, localOpMetadata.previousValue, true);
            }
            this.rollbackPendingMessageId(this.pendingKeys, op.key, localOpMetadata.pendingMessageId);
        }
        else if (op.type === "createSubDirectory" && localOpMetadata.type === "createSubDir") {
            if (!localOpMetadata.previouslyExisted) {
                this.deleteSubDirectoryCore(op.subdirName, true);
            }
            this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);
        }
        else if (op.type === "deleteSubDirectory" && localOpMetadata.type === "deleteSubDir") {
            if (localOpMetadata.subDirectory !== undefined) {
                this.undeleteSubDirectoryTree(localOpMetadata.subDirectory);
                // don't need to register events because deleting never unregistered
                this._subdirectories.set(op.subdirName, localOpMetadata.subDirectory);
                this.emit("subDirectoryCreated", op.subdirName, true, this);
            }
            this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);
        }
        else {
            throw new Error("Unsupported op for rollback");
        }
    }
    /**
     * Converts the given relative path into an absolute path.
     * @param path - Relative path to convert
     * @returns The equivalent absolute path
     */
    makeAbsolute(relativePath) {
        return posix.resolve(this.absolutePath, relativePath);
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the operation originated from the local client
     * @param localOpMetadata - For local client ops, this is the metadata that was submitted with the op.
     * For ops from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessStorageOperation(op, local, localOpMetadata) {
        if (this.pendingClearMessageIds.length > 0) {
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata) &&
                    localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x010 /* "Received out of order storage op when there is an unackd clear message" */);
            }
            // If I have a NACK clear, we can ignore all ops.
            return false;
        }
        const pendingKeyMessageId = this.pendingKeys.get(op.key);
        if (pendingKeyMessageId !== undefined) {
            // Found an NACK op, clear it from the directory if the latest sequence number in the directory
            // match the message's and don't process the op.
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata), 0x011 /* pendingMessageId is missing from the local client's operation */);
                const pendingMessageIds = this.pendingKeys.get(op.key);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x331 /* Unexpected pending message received */);
                pendingMessageIds.shift();
                if (pendingMessageIds.length === 0) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessSubDirectoryOperation(op, local, localOpMetadata) {
        const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);
        if (pendingSubDirectoryMessageId !== undefined) {
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(isSubDirLocalOpMetadata(localOpMetadata), 0x012 /* pendingMessageId is missing from the local client's operation */);
                const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x332 /* Unexpected pending message received */);
                pendingMessageIds.shift();
                if (pendingMessageIds.length === 0) {
                    this.pendingSubDirectories.delete(op.subdirName);
                }
            }
            return false;
        }
        return !local;
    }
    /**
     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.
     */
    clearExceptPendingKeys() {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        this.pendingKeys.forEach((value, key, map) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            temp.set(key, this._storage.get(key));
        });
        this.clearCore(false);
        temp.forEach((value, key, map) => {
            this.setCore(key, value, true);
        });
    }
    /**
     * Clear implementation used for both locally sourced clears as well as incoming remote clears.
     * @param local - Whether the message originated from the local client
     */
    clearCore(local) {
        this._storage.clear();
        this.directory.emit("clear", local, this.directory);
    }
    /**
     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.
     * @param key - The key being deleted
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key if it existed, undefined if it did not exist
     */
    deleteCore(key, local) {
        const previousLocalValue = this._storage.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        const successfullyRemoved = this._storage.delete(key);
        if (successfullyRemoved) {
            const event = { key, path: this.absolutePath, previousValue };
            this.directory.emit("valueChanged", event, local, this.directory);
            const containedEvent = { key, previousValue };
            this.emit("containedValueChanged", containedEvent, local, this);
        }
        return previousLocalValue;
    }
    /**
     * Set implementation used for both locally sourced sets as well as incoming remote sets.
     * @param key - The key being set
     * @param value - The value being set
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key, if any
     */
    setCore(key, value, local) {
        const previousLocalValue = this._storage.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        this._storage.set(key, value);
        const event = { key, path: this.absolutePath, previousValue };
        this.directory.emit("valueChanged", event, local, this.directory);
        const containedEvent = { key, previousValue };
        this.emit("containedValueChanged", containedEvent, local, this);
        return previousLocalValue;
    }
    /**
     * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.
     * @param subdirName - The name of the subdirectory being created
     * @param local - Whether the message originated from the local client
     * @returns - True if is newly created, false if it already existed.
     */
    createSubDirectoryCore(subdirName, local) {
        if (!this._subdirectories.has(subdirName)) {
            const absolutePath = posix.join(this.absolutePath, subdirName);
            const subDir = new SubDirectory(this.directory, this.runtime, this.serializer, absolutePath);
            this.registerEventsOnSubDirectory(subDir, subdirName);
            this._subdirectories.set(subdirName, subDir);
            this.emit("subDirectoryCreated", subdirName, local, this);
            return true;
        }
        return false;
    }
    registerEventsOnSubDirectory(subDirectory, subDirName) {
        subDirectory.on("subDirectoryCreated", (relativePath, local) => {
            this.emit("subDirectoryCreated", posix.join(subDirName, relativePath), local, this);
        });
        subDirectory.on("subDirectoryDeleted", (relativePath, local) => {
            this.emit("subDirectoryDeleted", posix.join(subDirName, relativePath), local, this);
        });
    }
    /**
     * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.
     * @param subdirName - The name of the subdirectory being deleted
     * @param local - Whether the message originated from the local client
     */
    deleteSubDirectoryCore(subdirName, local) {
        const previousValue = this._subdirectories.get(subdirName);
        // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots
        // Might want to consider cleaning out the structure more exhaustively though? But not when rollback.
        if (previousValue !== undefined) {
            this._subdirectories.delete(subdirName);
            this.disposeSubDirectoryTree(previousValue);
            this.emit("subDirectoryDeleted", subdirName, local, this);
        }
        return previousValue;
    }
    disposeSubDirectoryTree(directory) {
        if (!directory) {
            return;
        }
        // Dispose the subdirectory tree. This will dispose the subdirectories from bottom to top.
        const subDirectories = directory.subdirectories();
        for (const [_, subDirectory] of subDirectories) {
            this.disposeSubDirectoryTree(subDirectory);
        }
        if (typeof directory.dispose === "function") {
            directory.dispose();
        }
    }
    undeleteSubDirectoryTree(directory) {
        // Restore deleted subdirectory tree. This will unmark "deleted" from the subdirectories from bottom to top.
        for (const [_, subDirectory] of this._subdirectories.entries()) {
            this.undeleteSubDirectoryTree(subDirectory);
        }
        directory.undispose();
    }
}
//# sourceMappingURL=directory.js.map

/***/ }),
/* 38 */
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/map";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedObject": () => (/* binding */ SharedObject),
/* harmony export */   "SharedObjectCore": () => (/* binding */ SharedObjectCore)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51);
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(52);
/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
/* harmony import */ var _summarySerializer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(135);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */









/**
 *  Base class from which all shared objects derive
 */
class SharedObjectCore extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitterWithErrorHandling {
    /**
     * @param id - The id of the shared object
     * @param runtime - The IFluidDataStoreRuntime which contains the shared object
     * @param attributes - Attributes of the shared object
     */
    constructor(id, runtime, attributes) {
        super((event, e) => this.eventListenerErrorHandler(event, e));
        this.id = id;
        this.runtime = runtime;
        this.attributes = attributes;
        /**
         * Connection state
         */
        this._connected = false;
        /**
         * True if the dds is bound to its parent.
         */
        this._isBoundToContext = false;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!id.includes("/"), 0x304 /* Id cannot contain slashes */);
        this.handle = new _handle__WEBPACK_IMPORTED_MODULE_2__.SharedObjectHandle(this, id, runtime.IFluidHandleContext);
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(runtime.logger, undefined, {
            all: {
                sharedObjectId: (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])(),
                ddsType: {
                    value: this.attributes.type,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.TelemetryDataTag.CodeArtifact,
                },
            },
        });
        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.loggerToMonitoringContext)(this.logger);
        [this.opProcessingHelper, this.callbacksHelper] = this.setUpSampledTelemetryHelpers();
        this.attachListeners();
    }
    get IFluidLoadable() { return this; }
    /**
     * Gets the connection state
     * @returns The state of the connection
     */
    get connected() {
        return this._connected;
    }
    /**
     * This function is only supposed to be called from SharedObjectCore's constructor and
     * depends on a few things being set already. assert() calls make sure of it.
     * @returns The telemetry sampling helpers, so the constructor can be the one to assign them
     * to variables to avoid complaints from TypeScript.
     */
    setUpSampledTelemetryHelpers() {
        var _a, _b;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.mc !== undefined && this.logger !== undefined, "this.mc and/or this.logger has not been set");
        const opProcessingHelper = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.SampledTelemetryHelper({
            eventName: "ddsOpProcessing",
            category: "performance",
        }, this.logger, (_a = this.mc.config.getNumber("Fluid.SharedObject.OpProcessingTelemetrySampling")) !== null && _a !== void 0 ? _a : 100, true, new Map([
            ["local", { localOp: true }],
            ["remote", { localOp: false }],
        ]));
        const callbacksHelper = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.SampledTelemetryHelper({
            eventName: "ddsEventCallbacks",
            category: "performance",
        }, this.logger, (_b = this.mc.config.getNumber("Fluid.SharedObject.DdsCallbacksTelemetrySampling")) !== null && _b !== void 0 ? _b : 100, true);
        this.runtime.once("dispose", () => {
            this.callbacksHelper.dispose();
            this.opProcessingHelper.dispose();
        });
        return [opProcessingHelper, callbacksHelper];
    }
    /**
     * Marks this objects as closed. Any attempt to change it (local changes or processing remote ops)
     * would result in same error thrown. If called multiple times, only first error is remembered.
     * @param error - error object that is thrown whenever an attempt is made to modify this object
     */
    closeWithError(error) {
        if (this.closeError === undefined) {
            this.closeError = error;
        }
    }
    /**
     * Verifies that this object is not closed via closeWithError(). If it is, throws an error used to close it.
     */
    verifyNotClosed() {
        if (this.closeError !== undefined) {
            throw this.closeError;
        }
    }
    /**
     * Event listener handler helper that can be used to react to exceptions thrown from event listeners
     * It wraps error with DataProcessingError, closes this object and throws resulting error.
     * See closeWithError() for more details
     * Ideally such situation never happens, as consumers of DDS should never throw exceptions
     * in event listeners (i.e. catch any of the issues and make determination on how to handle it).
     * When such exceptions propagate through, most likely data model is no longer consistent, i.e.
     * DDS state does not match what user sees. Because of it DDS moves to "corrupted state" and does not
     * allow processing of ops or local changes, which very quickly results in container closure.
     */
    eventListenerErrorHandler(event, e) {
        const error = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_7__.DataProcessingError.wrapIfUnrecognized(e, "SharedObjectEventListenerException");
        error.addTelemetryProperties({ emittedEventName: String(event) });
        this.closeWithError(error);
        throw error;
    }
    attachListeners() {
        // Only listen to these events if not attached.
        if (!this.isAttached()) {
            this.runtime.once("attaching", () => {
                // Calling this will let the dds to do any custom processing based on attached
                // like starting generating ops.
                this.didAttach();
            });
        }
    }
    /**
     * A shared object, after construction, can either be loaded in the case that it is already part of
     * a shared document. Or later attached if it is being newly added.
     * @param services - Services used by the shared object
     */
    async load(services) {
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached) {
            this.services = services;
        }
        await this.loadCore(services.objectStorage);
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached) {
            this.attachDeltaHandler();
        }
    }
    /**
     * Initializes the object as a local, non-shared object. This object can become shared after
     * it is attached to the document.
     */
    initializeLocal() {
        this.initializeLocalCore();
    }
    /**
     * {@inheritDoc (ISharedObject:interface).bindToContext}
     */
    bindToContext() {
        if (this._isBoundToContext) {
            return;
        }
        this._isBoundToContext = true;
        this.runtime.bindChannel(this);
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).connect}
     */
    connect(services) {
        this.services = services;
        this.attachDeltaHandler();
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).isAttached}
     */
    isAttached() {
        return this.services !== undefined && this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached;
    }
    /**
     * Called when a handle is decoded by this object. A handle in the object's data represents an outbound reference
     * to another object in the container.
     * @param decodedHandle - The handle of the Fluid object that is decoded.
     */
    handleDecoded(decodedHandle) {
        var _a, _b, _c;
        if (this.isAttached()) {
            // This represents an outbound reference from this object to the node represented by decodedHandle.
            (_c = (_a = this.services) === null || _a === void 0 ? void 0 : (_b = _a.deltaConnection).addedGCOutboundReference) === null || _c === void 0 ? void 0 : _c.call(_b, this.handle, decodedHandle);
        }
    }
    /**
     * Allows the distributed data type to perform custom local loading.
     */
    initializeLocalCore() {
        return;
    }
    /**
     * Allows the distributive data type the ability to perform custom processing once an attach has happened.
     * Also called after non-local data type get loaded.
     */
    didAttach() {
        return;
    }
    /**
     * Submits a message by the local client to the runtime.
     * @param content - Content of the message
     * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     */
    submitLocalMessage(content, localOpMetadata = undefined) {
        this.verifyNotClosed();
        if (this.isAttached()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.services.deltaConnection.submit(content, localOpMetadata);
        }
    }
    /**
     * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock
     * that want to be part of summary but does not generate ops.
     */
    dirty() {
        if (!this.isAttached()) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.services.deltaConnection.dirty();
    }
    /**
     * Called when the object has fully connected to the delta stream
     * Default implementation for DDS, override if different behavior is required.
     */
    onConnect() { }
    /**
     * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.
     * The default implementation here is to resubmit the same message. The client can override if different behavior
     * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit
     * anything at all.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmitCore(content, localOpMetadata) {
        this.submitLocalMessage(content, localOpMetadata);
    }
    /**
     * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.
     * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),
     * the Promise will reject.
     * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.
     */
    async newAckBasedPromise(executor) {
        let rejectBecauseDispose;
        return new Promise((resolve, reject) => {
            rejectBecauseDispose =
                () => reject(new Error("FluidDataStoreRuntime disposed while this ack-based Promise was pending"));
            if (this.runtime.disposed) {
                rejectBecauseDispose();
                return;
            }
            this.runtime.on("dispose", rejectBecauseDispose);
            executor(resolve, reject);
        }).finally(() => {
            // Note: rejectBecauseDispose will never be undefined here
            this.runtime.off("dispose", rejectBecauseDispose);
        });
    }
    attachDeltaHandler() {
        // Services should already be there in case we are attaching delta handler.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.services !== undefined, 0x07a /* "Services should be there to attach delta handler" */);
        this._isBoundToContext = true;
        // Allows objects to do any custom processing if it is attached.
        this.didAttach();
        // attachDeltaHandler is only called after services is assigned
        this.services.deltaConnection.attach({
            process: (message, local, localOpMetadata) => {
                this.process(message, local, localOpMetadata);
            },
            setConnectionState: (connected) => {
                this.setConnectionState(connected);
            },
            reSubmit: (content, localOpMetadata) => {
                this.reSubmit(content, localOpMetadata);
            },
            applyStashedOp: (content) => {
                return this.applyStashedOp(content);
            },
            rollback: (content, localOpMetadata) => {
                this.rollback(content, localOpMetadata);
            },
        });
        // Trigger initial state
        // attachDeltaHandler is only called after services is assigned
        this.setConnectionState(this.services.deltaConnection.connected);
    }
    /**
     * Set the state of connection to services.
     * @param connected - true if connected, false otherwise.
     */
    setConnectionState(connected) {
        if (this._connected === connected) {
            // Not changing state, nothing the same.
            return;
        }
        // Should I change the state at the end? So that we *can't* send new stuff before we send old?
        this._connected = connected;
        if (!connected) {
            // Things that are true now...
            // - if we had a connection we can no longer send messages over it
            // - if we had outbound messages some may or may not be ACK'd. Won't know until next message
            //
            // - nack could get a new msn - but might as well do it in the join?
            this.onDisconnect();
        }
        else {
            // Call this for now so that DDSes like ConsensusOrderedCollection that maintain their own pending
            // messages will work.
            this.onConnect();
        }
    }
    /**
     * Handles a message being received from the remote delta server.
     * @param message - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     */
    process(message, local, localOpMetadata) {
        this.verifyNotClosed(); // This will result in container closure.
        this.emitInternal("pre-op", message, local, this);
        this.opProcessingHelper.measure(() => { this.processCore(message, local, localOpMetadata); }, local ? "local" : "remote");
        this.emitInternal("op", message, local, this);
    }
    /**
     * Called when a message has to be resubmitted. This typically happens for unacked messages after a
     * reconnection.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(content, localOpMetadata) {
        this.reSubmitCore(content, localOpMetadata);
    }
    /**
     * Revert an op
     */
    rollback(content, localOpMetadata) {
        throw new Error("rollback not supported");
    }
    /**
     * Emit an event. This function is only intended for use by DDS classes that extend SharedObject/SharedObjectCore,
     * specifically to emit events that are part of the public interface of the DDS (i.e. those that can have listeners
     * attached to them by the consumers of the DDS). It should not be called from outside the class or to emit events
     * which are only internal to the DDS. Support for calling it from outside the DDS instance might be removed in the
     * future.
     *
     * @internal
     *
     * @param event - The event to emit.
     * @param args - Arguments to pass to the event listeners.
     * @returns `true` if the event had listeners, `false` otherwise.
     */
    emit(event, ...args) {
        return this.callbacksHelper.measure(() => super.emit(event, ...args));
    }
    /**
     * Use to emit events inside {@link SharedObjectCore}, with no telemetry measurement
     * done on the duration of the callbacks. Simply calls `super.emit()`.
     * @param event - Event to emit
     * @param args - Arguments for the event
     * @returns Whatever `super.emit()` returns.
     */
    emitInternal(event, ...args) {
        return super.emit(event, ...args);
    }
}
/**
 * SharedObject with simplified, synchronous summarization and GC.
 * DDS implementations with async and incremental summarization should extend SharedObjectCore directly instead.
 */
class SharedObject extends SharedObjectCore {
    /**
     * @param id - The id of the shared object
     * @param runtime - The IFluidDataStoreRuntime which contains the shared object
     * @param attributes - Attributes of the shared object
     */
    constructor(id, runtime, attributes, telemetryContextPrefix) {
        super(id, runtime, attributes);
        this.telemetryContextPrefix = telemetryContextPrefix;
        /**
         * True while we are garbage collecting this object's data.
         */
        this._isGCing = false;
        this._serializer = new _serializer__WEBPACK_IMPORTED_MODULE_9__.FluidSerializer(this.runtime.channelsRoutingContext, (handle) => this.handleDecoded(handle));
    }
    get serializer() {
        /**
         * During garbage collection, the SummarySerializer keeps track of IFluidHandles that are serialized. These
         * handles represent references to other Fluid objects.
         *
         * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content
         * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.
         */
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this._isGCing, 0x075 /* "SummarySerializer should be used for serializing data during summary." */);
        return this._serializer;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).getAttachSummary}
     */
    getAttachSummary(fullTree = false, trackState = false, telemetryContext) {
        const result = this.summarizeCore(this.serializer, telemetryContext);
        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);
        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);
        return result;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).summarize}
     */
    async summarize(fullTree = false, trackState = false, telemetryContext) {
        const result = this.summarizeCore(this.serializer, telemetryContext);
        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);
        this.incrementTelemetryMetric(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);
        return result;
    }
    /**
     * {@inheritDoc (ISharedObject:interface).getGCData}
     */
    getGCData(fullGC = false) {
        // Set _isGCing to true. This flag is used to ensure that we only use SummarySerializer to serialize handles
        // in this object's data.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this._isGCing, 0x078 /* "Possible re-entrancy! Summary should not already be in progress." */);
        this._isGCing = true;
        let gcData;
        try {
            const serializer = new _summarySerializer__WEBPACK_IMPORTED_MODULE_11__.SummarySerializer(this.runtime.channelsRoutingContext, (handle) => this.handleDecoded(handle));
            this.processGCDataCore(serializer);
            // The GC data for this shared object contains a single GC node. The outbound routes of this node are the
            // routes of handles serialized during summarization.
            gcData = { gcNodes: { "/": serializer.getSerializedRoutes() } };
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this._isGCing, 0x079 /* "Possible re-entrancy! Summary should have been in progress." */);
        }
        finally {
            this._isGCing = false;
        }
        return gcData;
    }
    /**
     * Calls the serializer over all data in this object that reference other GC nodes.
     * Derived classes must override this to provide custom list of references to other GC nodes.
     */
    processGCDataCore(serializer) {
        // We run the full summarize logic to get the list of outbound routes from this object. This is a little
        // expensive but its okay for now. It will be updated to not use full summarize and make it more efficient.
        // See: https://github.com/microsoft/FluidFramework/issues/4547
        this.summarizeCore(serializer);
    }
    incrementTelemetryMetric(propertyName, incrementBy, telemetryContext) {
        var _a;
        const prevTotal = ((_a = telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.get(this.telemetryContextPrefix, propertyName)) !== null && _a !== void 0 ? _a : 0);
        telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.set(this.telemetryContextPrefix, propertyName, prevTotal + incrementBy);
    }
}
//# sourceMappingURL=sharedObject.js.map

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventEmitterWithErrorHandling": () => (/* binding */ EventEmitterWithErrorHandling)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);

/**
 * Event Emitter helper class
 * Any exceptions thrown by listeners will be caught and raised through "error" event.
 * Any exception thrown by "error" listeners will propagate to the caller.
 */
class EventEmitterWithErrorHandling extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(errorHandler) {
        super();
        this.errorHandler = errorHandler;
    }
    emit(event, ...args) {
        try {
            return super.emit(event, ...args);
        }
        catch (error) {
            this.errorHandler(event, error);
            return true;
        }
    }
}
//# sourceMappingURL=eventEmitterWithErrorHandling.js.map

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedObjectHandle": () => (/* binding */ SharedObjectHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Handle for shared object
 * This object is used for already loaded (in-memory) shared object
 * and is used only for serialization purposes.
 * De-serialization process goes through FluidObjectHandle and request flow:
 * FluidDataStoreRuntime.request() recognizes requests in the form of '/\<shared object id\>'
 * and loads shared object.
 */
class SharedObjectHandle extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidObjectHandle {
    /**
     * Whether services have been attached for the associated shared object.
     */
    get isAttached() {
        return this.value.isAttached();
    }
    /**
     * Creates a new SharedObjectHandle.
     * @param value - The shared object this handle is for.
     * @param path - The id of the shared object. It is also the path to this object relative to the routeContext.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(value, path, routeContext) {
        super(value, path, routeContext);
    }
    /**
     * Attaches all bound handles first (which may in turn attach further handles), then attaches this handle.
     * When attaching the handle, it registers the associated shared object.
     */
    attachGraph() {
        this.value.bindToContext();
        super.attachGraph();
    }
}
//# sourceMappingURL=handle.js.map

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChildLogger": () => (/* binding */ ChildLogger),
/* harmony export */   "MultiSinkLogger": () => (/* binding */ MultiSinkLogger),
/* harmony export */   "PerformanceEvent": () => (/* binding */ PerformanceEvent),
/* harmony export */   "TaggedLoggerAdapter": () => (/* binding */ TaggedLoggerAdapter),
/* harmony export */   "TelemetryDataTag": () => (/* binding */ TelemetryDataTag),
/* harmony export */   "TelemetryLogger": () => (/* binding */ TelemetryLogger),
/* harmony export */   "TelemetryUTLogger": () => (/* binding */ TelemetryUTLogger)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _errorLogging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Broad classifications to be applied to individual properties as they're prepared to be logged to telemetry.
 * Please do not modify existing entries for backwards compatibility.
 */
var TelemetryDataTag;
(function (TelemetryDataTag) {
    /**
     * Data containing terms from code packages that may have been dynamically loaded
     * @deprecated 1.0, will be removed in next release (see issue #6603). Use `TelemetryDataTag.CodeArtifact` instead.
     */
    TelemetryDataTag["PackageData"] = "PackageData";
    /** Data containing terms or IDs from code packages that may have been dynamically loaded */
    TelemetryDataTag["CodeArtifact"] = "CodeArtifact";
    /** Personal data of a variety of classifications that pertains to the user */
    TelemetryDataTag["UserData"] = "UserData";
})(TelemetryDataTag || (TelemetryDataTag = {}));
/**
 * TelemetryLogger class contains various helper telemetry methods,
 * encoding in one place schemas for various types of Fluid telemetry events.
 * Creates sub-logger that appends properties to all events
 */
class TelemetryLogger {
    constructor(namespace, properties) {
        this.namespace = namespace;
        this.properties = properties;
    }
    static formatTick(tick) {
        return Math.floor(tick);
    }
    /**
     * Attempts to parse number from string.
     * If fails,returns original string.
     * Used to make telemetry data typed (and support math operations, like comparison),
     * in places where we do expect numbers (like contentsize/duration property in http header)
     */
    static numberFromString(str) {
        if (str === undefined || str === null) {
            return undefined;
        }
        const num = Number(str);
        return Number.isNaN(num) ? str : num;
    }
    static sanitizePkgName(name) {
        return name.replace("@", "").replace("/", "-");
    }
    /**
     * Take an unknown error object and add the appropriate info from it to the event. Message and stack will be copied
     * over from the error object, along with other telemetry properties if it's an ILoggingError.
     * @param event - Event being logged
     * @param error - Error to extract info from
     * @param fetchStack - Whether to fetch the current callstack if error.stack is undefined
     */
    static prepareErrorObject(event, error, fetchStack) {
        const { message, errorType, stack } = (0,_errorLogging__WEBPACK_IMPORTED_MODULE_0__.extractLogSafeErrorProperties)(error, true /* sanitizeStack */);
        // First, copy over error message, stack, and errorType directly (overwrite if present on event)
        event.stack = stack;
        event.error = message; // Note that the error message goes on the 'error' field
        event.errorType = errorType;
        if ((0,_errorLogging__WEBPACK_IMPORTED_MODULE_0__.isILoggingError)(error)) {
            // Add any other telemetry properties from the LoggingError
            const telemetryProp = error.getTelemetryProperties();
            for (const key of Object.keys(telemetryProp)) {
                if (event[key] !== undefined) {
                    // Don't overwrite existing properties on the event
                    continue;
                }
                event[key] = telemetryProp[key];
            }
        }
        // Collect stack if we were not able to extract it from error
        if (event.stack === undefined && fetchStack) {
            event.stack = (0,_errorLogging__WEBPACK_IMPORTED_MODULE_0__.generateStack)();
        }
    }
    /**
     * Send a telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendTelemetryEvent(event, error) {
        var _a;
        this.sendTelemetryEventCore(Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : "generic" }), error);
    }
    /**
     * Send a telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendTelemetryEventCore(event, error) {
        const newEvent = Object.assign({}, event);
        if (error !== undefined) {
            TelemetryLogger.prepareErrorObject(newEvent, error, false);
        }
        // Will include Nan & Infinity, but probably we do not care
        if (typeof newEvent.duration === "number") {
            newEvent.duration = TelemetryLogger.formatTick(newEvent.duration);
        }
        this.send(newEvent);
    }
    /**
     * Send an error telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendErrorEvent(event, error) {
        this.sendTelemetryEventCore(Object.assign(Object.assign({ 
            // ensure the error field has some value,
            // this can and will be overridden by event, or error
            error: event.eventName }, event), { category: "error" }), error);
    }
    /**
     * Send a performance telemetry event with the logger
     *
     * @param event - Event to send
     * @param error - optional error object to log
     */
    sendPerformanceEvent(event, error) {
        var _a;
        const perfEvent = Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : "performance" });
        this.sendTelemetryEventCore(perfEvent, error);
    }
    prepareEvent(event) {
        const includeErrorProps = event.category === "error" || event.error !== undefined;
        const newEvent = Object.assign({}, event);
        if (this.namespace !== undefined) {
            newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;
        }
        if (this.properties) {
            const properties = [];
            properties.push(this.properties.all);
            if (includeErrorProps) {
                properties.push(this.properties.error);
            }
            for (const props of properties) {
                if (props !== undefined) {
                    for (const key of Object.keys(props)) {
                        if (event[key] !== undefined) {
                            continue;
                        }
                        const getterOrValue = props[key];
                        // If this throws, hopefully it is handled elsewhere
                        const value = typeof getterOrValue === "function" ? getterOrValue() : getterOrValue;
                        if (value !== undefined) {
                            newEvent[key] = value;
                        }
                    }
                }
            }
        }
        return newEvent;
    }
}
TelemetryLogger.eventNamespaceSeparator = ":";
/**
 * @deprecated 0.56, remove TaggedLoggerAdapter once its usage is removed from
 * container-runtime. Issue: #8191
 * TaggedLoggerAdapter class can add tag handling to your logger.
 */
class TaggedLoggerAdapter {
    constructor(logger) {
        this.logger = logger;
    }
    send(eventWithTagsMaybe) {
        const newEvent = {
            category: eventWithTagsMaybe.category,
            eventName: eventWithTagsMaybe.eventName,
        };
        for (const key of Object.keys(eventWithTagsMaybe)) {
            const taggableProp = eventWithTagsMaybe[key];
            const { value, tag } = (typeof taggableProp === "object")
                ? taggableProp
                : { value: taggableProp, tag: undefined };
            switch (tag) {
                case undefined:
                    // No tag means we can log plainly
                    newEvent[key] = value;
                    break;
                case TelemetryDataTag.PackageData:
                    // For Microsoft applications, PackageData is safe for now
                    // (we don't load 3P code in 1P apps)
                    newEvent[key] = value;
                    break;
                case TelemetryDataTag.UserData:
                    // Strip out anything tagged explicitly as PII.
                    // Alternate strategy would be to hash these props
                    newEvent[key] = "REDACTED (UserData)";
                    break;
                default:
                    // If we encounter a tag we don't recognize
                    // then we must assume we should scrub.
                    newEvent[key] = "REDACTED (unknown tag)";
                    break;
            }
        }
        this.logger.send(newEvent);
    }
}
/**
 * ChildLogger class contains various helper telemetry methods,
 * encoding in one place schemas for various types of Fluid telemetry events.
 * Creates sub-logger that appends properties to all events
 */
class ChildLogger extends TelemetryLogger {
    constructor(baseLogger, namespace, properties) {
        super(namespace, properties);
        this.baseLogger = baseLogger;
        // propagate the monitoring context
        if ((0,_config__WEBPACK_IMPORTED_MODULE_1__.loggerIsMonitoringContext)(baseLogger)) {
            (0,_config__WEBPACK_IMPORTED_MODULE_1__.mixinMonitoringContext)(this, new _config__WEBPACK_IMPORTED_MODULE_1__.CachedConfigProvider(baseLogger.config));
        }
    }
    /**
     * Create child logger
     * @param baseLogger - Base logger to use to output events. If undefined, proper child logger
     * is created, but it does not sends telemetry events anywhere.
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    static create(baseLogger, namespace, properties) {
        // if we are creating a child of a child, rather than nest, which will increase
        // the callstack overhead, just generate a new logger that includes everything from the previous
        if (baseLogger instanceof ChildLogger) {
            const combinedProperties = {};
            for (const extendedProps of [baseLogger.properties, properties]) {
                if (extendedProps !== undefined) {
                    if (extendedProps.all !== undefined) {
                        combinedProperties.all = Object.assign(Object.assign({}, combinedProperties.all), extendedProps.all);
                    }
                    if (extendedProps.error !== undefined) {
                        combinedProperties.error = Object.assign(Object.assign({}, combinedProperties.error), extendedProps.error);
                    }
                }
            }
            const combinedNamespace = baseLogger.namespace === undefined
                ? namespace
                : namespace === undefined
                    ? baseLogger.namespace
                    : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;
            return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties);
        }
        return new ChildLogger(baseLogger ? baseLogger : new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTelemetryNullLogger(), namespace, properties);
    }
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        this.baseLogger.send(this.prepareEvent(event));
    }
}
/**
 * Multi-sink logger
 * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink
 * Implements ITelemetryBaseLogger (through static create() method)
 */
class MultiSinkLogger extends TelemetryLogger {
    /**
     * Create multiple sink logger (i.e. logger that sends events to multiple sinks)
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    constructor(namespace, properties) {
        super(namespace, properties);
        this.loggers = [];
    }
    /**
     * Add logger to send all events to
     * @param logger - Logger to add
     */
    addLogger(logger) {
        if (logger !== undefined && logger !== null) {
            this.loggers.push(logger);
        }
    }
    /**
     * Send an event to the loggers
     *
     * @param event - the event to send to all the registered logger
     */
    send(event) {
        const newEvent = this.prepareEvent(event);
        this.loggers.forEach((logger) => {
            logger.send(newEvent);
        });
    }
}
/**
 * Helper class to log performance events
 */
class PerformanceEvent {
    constructor(logger, event, markers = { end: true, cancel: "generic" }) {
        this.logger = logger;
        this.markers = markers;
        this.startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now();
        this.event = Object.assign({}, event);
        if (this.markers.start) {
            this.reportEvent("start");
        }
        if (typeof window === "object" && window != null && window.performance) {
            this.startMark = `${event.eventName}-start`;
            window.performance.mark(this.startMark);
        }
    }
    static start(logger, event, markers) {
        return new PerformanceEvent(logger, event, markers);
    }
    static timedExec(logger, event, callback, markers) {
        const perfEvent = PerformanceEvent.start(logger, event, markers);
        try {
            const ret = callback(perfEvent);
            perfEvent.autoEnd();
            return ret;
        }
        catch (error) {
            perfEvent.cancel(undefined, error);
            throw error;
        }
    }
    static async timedExecAsync(logger, event, callback, markers) {
        const perfEvent = PerformanceEvent.start(logger, event, markers);
        try {
            const ret = await callback(perfEvent);
            perfEvent.autoEnd();
            return ret;
        }
        catch (error) {
            perfEvent.cancel(undefined, error);
            throw error;
        }
    }
    get duration() { return _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now() - this.startTime; }
    reportProgress(props, eventNameSuffix = "update") {
        this.reportEvent(eventNameSuffix, props);
    }
    autoEnd() {
        // Event might have been cancelled or ended in the callback
        if (this.event && this.markers.end) {
            this.reportEvent("end");
        }
        this.performanceEndMark();
        this.event = undefined;
    }
    end(props) {
        this.reportEvent("end", props);
        this.performanceEndMark();
        this.event = undefined;
    }
    performanceEndMark() {
        if (this.startMark && this.event) {
            const endMark = `${this.event.eventName}-end`;
            window.performance.mark(endMark);
            window.performance.measure(`${this.event.eventName}`, this.startMark, endMark);
            this.startMark = undefined;
        }
    }
    cancel(props, error) {
        if (this.markers.cancel !== undefined) {
            this.reportEvent("cancel", Object.assign({ category: this.markers.cancel }, props), error);
        }
        this.event = undefined;
    }
    /**
     * Report the event, if it hasn't already been reported.
     */
    reportEvent(eventNameSuffix, props, error) {
        // There are strange sequences involving multiple Promise chains
        // where the event can be cancelled and then later a callback is invoked
        // and the caller attempts to end directly, e.g. issue #3936. Just return.
        if (!this.event) {
            return;
        }
        const event = Object.assign(Object.assign({}, this.event), props);
        event.eventName = `${event.eventName}_${eventNameSuffix}`;
        if (eventNameSuffix !== "start") {
            event.duration = this.duration;
        }
        this.logger.sendPerformanceEvent(event, error);
    }
}
/**
 * Logger that is useful for UT
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryUTLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
        this.reportError("errorEvent in UT logger!", event, error);
    }
    sendPerformanceEvent(event, error) {
    }
    logGenericError(eventName, error) {
        this.reportError(`genericError in UT logger!`, { eventName }, error);
    }
    logException(event, exception) {
        this.reportError("exception in UT logger!", event, exception);
    }
    debugAssert(condition, event) {
        this.reportError("debugAssert in UT logger!");
    }
    shipAssert(condition, event) {
        this.reportError("shipAssert in UT logger!");
    }
    reportError(message, event, err) {
        const error = new Error(message);
        error.error = error;
        error.event = event;
        // report to console as exception can be eaten
        console.error(message);
        console.error(error);
        throw error;
    }
}
//# sourceMappingURL=logger.js.map

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CachedConfigProvider": () => (/* binding */ CachedConfigProvider),
/* harmony export */   "inMemoryConfigProvider": () => (/* binding */ inMemoryConfigProvider),
/* harmony export */   "loggerIsMonitoringContext": () => (/* binding */ loggerIsMonitoringContext),
/* harmony export */   "loggerToMonitoringContext": () => (/* binding */ loggerToMonitoringContext),
/* harmony export */   "mixinMonitoringContext": () => (/* binding */ mixinMonitoringContext),
/* harmony export */   "sessionStorageConfigProvider": () => (/* binding */ sessionStorageConfigProvider)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);

/**
 * Creates a base configuration provider based on `sessionStorage`
 *
 * @returns A lazy initialized base configuration provider with `sessionStorage` as the underlying config store
 */
const sessionStorageConfigProvider = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => inMemoryConfigProvider(safeSessionStorage()));
const NullConfigProvider = {
    getRawConfig: () => undefined,
};
/**
 * Creates a base configuration provider based on the supplied `Storage` instance
 *
 * @param storage - instance of `Storage` to be used as storage media for the config
 * @returns A base configuration provider with
 * the supplied `Storage` instance as the underlying config store
 */
const inMemoryConfigProvider = (storage) => {
    if (storage !== undefined && storage !== null) {
        return new CachedConfigProvider({
            getRawConfig: (name) => {
                var _a, _b;
                try {
                    return (_b = stronglyTypedParse((_a = storage.getItem(name)) !== null && _a !== void 0 ? _a : undefined)) === null || _b === void 0 ? void 0 : _b.raw;
                }
                catch (_c) { }
                return undefined;
            },
        });
    }
    return NullConfigProvider;
};
function isPrimitiveType(type) {
    switch (type) {
        case "boolean":
        case "number":
        case "string":
            return true;
        default:
            return false;
    }
}
/**
 * Takes any supported config type, and returns the value with a strong type. If the type of
 * the config is not a supported type undefined will be returned.
 * The user of this function should cache the result to avoid duplicated work.
 *
 * Strings will be attempted to be parsed and coerced into a strong config type.
 * if it is not possible to parsed and coerce a string to a strong config type the original string
 * will be return with a string type for the consumer to handle further if necessary.
 */
function stronglyTypedParse(input) {
    let output = input;
    let defaultReturn;
    // we do special handling for strings to try and coerce
    // them into a config type if we can. This makes it easy
    // for config sources like sessionStorage which only
    // holds strings
    if (typeof input === "string") {
        try {
            output = JSON.parse(input);
            // we succeeded in parsing, but we don't support parsing
            // for any object as we can't do it type safely
            // so in this case, the default return will be string
            // rather than undefined, and the consumer
            // can parse, as we don't want to provide
            // a false sense of security by just
            // casting.
            defaultReturn = { raw: input, string: input };
        }
        catch (_a) { }
    }
    if (output === undefined) {
        return defaultReturn;
    }
    const outputType = typeof output;
    if (isPrimitiveType(outputType)) {
        return Object.assign(Object.assign({}, defaultReturn), { raw: input, [outputType]: output });
    }
    if (Array.isArray(output)) {
        const firstType = typeof output[0];
        // ensure the first elements is a primitive type
        if (!isPrimitiveType(firstType)) {
            return defaultReturn;
        }
        // ensue all the elements types are homogeneous
        // aka they all have the same type as the first
        for (const v of output) {
            if (typeof v !== firstType) {
                return defaultReturn;
            }
        }
        return Object.assign(Object.assign({}, defaultReturn), { raw: input, [`${firstType}[]`]: output });
    }
    return defaultReturn;
}
/** Referencing the `sessionStorage` variable can throw in some environments such as Node */
const safeSessionStorage = () => {
    try {
        return sessionStorage !== null ? sessionStorage : undefined;
    }
    catch (_a) {
        return undefined;
    }
};
/**
 * Implementation of {@link IConfigProvider} which contains nested {@link IConfigProviderBase} instances
 */
class CachedConfigProvider {
    constructor(...orderedBaseProviders) {
        this.configCache = new Map();
        this.orderedBaseProviders = [];
        const knownProviders = new Set();
        const candidateProviders = [...orderedBaseProviders];
        while (candidateProviders.length > 0) {
            const baseProvider = candidateProviders.shift();
            if (baseProvider !== undefined
                && isConfigProviderBase(baseProvider)
                && !knownProviders.has(baseProvider)) {
                knownProviders.add(baseProvider);
                if (baseProvider instanceof CachedConfigProvider) {
                    candidateProviders.push(...baseProvider.orderedBaseProviders);
                }
                else {
                    this.orderedBaseProviders.push(baseProvider);
                }
            }
        }
    }
    getBoolean(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.boolean;
    }
    getNumber(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.number;
    }
    getString(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.string;
    }
    getBooleanArray(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a["boolean[]"];
    }
    getNumberArray(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a["number[]"];
    }
    getStringArray(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a["string[]"];
    }
    getRawConfig(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.raw;
    }
    getCacheEntry(name) {
        if (!this.configCache.has(name)) {
            for (const provider of this.orderedBaseProviders) {
                const parsed = stronglyTypedParse(provider === null || provider === void 0 ? void 0 : provider.getRawConfig(name));
                if (parsed !== undefined) {
                    this.configCache.set(name, parsed);
                    return parsed;
                }
            }
            // configs are immutable, if the first lookup returned no results, all lookups should
            this.configCache.set(name, { raw: undefined });
        }
        return this.configCache.get(name);
    }
}
function loggerIsMonitoringContext(obj) {
    const maybeConfig = obj;
    return isConfigProviderBase(maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.config) && (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.logger) !== undefined;
}
function loggerToMonitoringContext(logger) {
    if (loggerIsMonitoringContext(logger)) {
        return logger;
    }
    return mixinMonitoringContext(logger, sessionStorageConfigProvider.value);
}
function mixinMonitoringContext(logger, ...configs) {
    if (loggerIsMonitoringContext(logger)) {
        throw new Error("Logger is already a monitoring context");
    }
    /**
     * this is the tricky bit we use for now to smuggle monitoring context around.
     * To the logger we mixin both config and  itself, so mc.logger === logger as it is self-referential.
     * We then expose it as a Monitoring context, so via types we hide the outer logger methods.
     * To layers that expect just a logger we can pass mc.logger, but this is still a MonitoringContext
     * so if a deeper layer then converts that logger to a monitoring context it can find the smuggled properties
     * of the MonitoringContext and get the config provider.
     */
    const mc = logger;
    mc.config = new CachedConfigProvider(...configs);
    mc.logger = logger;
    return mc;
}
function isConfigProviderBase(obj) {
    const maybeConfig = obj;
    return typeof (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.getRawConfig) === "function";
}
//# sourceMappingURL=config.js.map

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lazy": () => (/* binding */ Lazy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable
  */
class Lazy {
    /**
     * Instantiates an instance of Lazy<T>
     * @param valueGenerator - the function that will generate the value when value is accessed the first time
     */
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this._evaluated = false;
    }
    /**
     * Return true if the value as been generated, otherwise false
     */
    get evaluated() {
        return this._evaluated;
    }
    /**
     * Get the value. If this is the first call the value will be generated
     */
    get value() {
        if (!this._evaluated) {
            this._evaluated = true;
            this._value = this.valueGenerator();
        }
        return this._value;
    }
}
//# sourceMappingURL=lazy.js.map

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTelemetryNullLogger": () => (/* binding */ BaseTelemetryNullLogger),
/* harmony export */   "TelemetryNullLogger": () => (/* binding */ TelemetryNullLogger),
/* harmony export */   "extractLogSafeErrorProperties": () => (/* binding */ extractLogSafeErrorProperties)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class BaseTelemetryNullLogger {
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        return;
    }
}
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryNullLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
    }
    sendPerformanceEvent(event, error) {
    }
}
function extractLogSafeErrorProperties(error) {
    const isRegularObject = (value) => {
        return value !== null && !Array.isArray(value) && typeof value === "object";
    };
    const removeMessageFromStack = (stack, errorName) => {
        const stackFrames = stack.split("\n");
        stackFrames.shift(); // Remove "[ErrorName]: [ErrorMessage]"
        if (errorName !== undefined) {
            stackFrames.unshift(errorName); // Add "[ErrorName]"
        }
        return stackFrames.join("\n");
    };
    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === "string")
        ? error.message
        : String(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack, name } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            const errorName = (typeof name === "string") ? name : undefined;
            safeProps.stack = removeMessageFromStack(stack, errorName);
        }
    }
    return safeProps;
}
//# sourceMappingURL=logger.js.map

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "performance": () => (/* binding */ performance)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const performance = window.performance;
//# sourceMappingURL=performanceBrowser.js.map

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SampledTelemetryHelper": () => (/* binding */ SampledTelemetryHelper)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper class that executes a specified code block and writes an
 * {@link @fluidframework/common-definitions#ITelemetryPerformanceEvent} to a specified logger every time a specified
 * number of executions is reached (or when the class is disposed). The `duration` field in the telemetry event is
 * the duration of the latest execution (sample) of the specified function. See the documentation of the
 * `includeAggregateMetrics` parameter for additional details that can be included.
 */
class SampledTelemetryHelper {
    /**
     * @param eventBase -
     * Custom properties to include in the telemetry performance event when it is written.
     * @param logger -
     * The logger to use to write the telemetry performance event.
     * @param sampleThreshold -
     * Telemetry performance events will be generated every time we hit this many executions of the code block.
     * @param includeAggregateMetrics -
     * If set to `true`, the telemetry performance event will include aggregated metrics (total duration, min duration,
     * max duration) for all the executions in between generated events.
     * @param perBucketProperties -
     * Map of strings that represent different buckets (which can be specified when calling the 'measure' method), to
     * properties which should be added to the telemetry event for that bucket. If a bucket being measured does not
     * have an entry in this map, no additional properties will be added to its telemetry events. The following keys are
     * reserved for use by this class: "duration", "count", "totalDuration", "minDuration", "maxDuration". If any of
     * them is specified as a key in one of the ITelemetryProperties objects in this map, that key-value pair will be
     * ignored.
     */
    constructor(eventBase, logger, sampleThreshold, includeAggregateMetrics = false, perBucketProperties = new Map()) {
        this.eventBase = eventBase;
        this.logger = logger;
        this.sampleThreshold = sampleThreshold;
        this.includeAggregateMetrics = includeAggregateMetrics;
        this.perBucketProperties = perBucketProperties;
        this.disposed = false;
        this.measurementsMap = new Map();
    }
    /**
     * @param codeToMeasure -
     * The code to be executed and measured.
     * @param bucket -
     * A key to track executions of the code block separately. Each different value of this parameter has a separate
     * set of executions and metrics tracked by the class. If no such distinction needs to be made, do not provide a
     * value.
     * @returns Whatever the passed-in code block returns.
     */
    measure(codeToMeasure, bucket = "") {
        var _a, _b, _c;
        const start = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        const returnValue = codeToMeasure();
        const duration = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - start;
        let m = this.measurementsMap.get(bucket);
        if (m === undefined) {
            m = { count: 0, duration: -1 };
            this.measurementsMap.set(bucket, m);
        }
        m.count++;
        m.duration = duration;
        if (this.includeAggregateMetrics) {
            m.totalDuration = ((_a = m.totalDuration) !== null && _a !== void 0 ? _a : 0) + duration;
            m.minDuration = Math.min((_b = m.minDuration) !== null && _b !== void 0 ? _b : duration, duration);
            m.maxDuration = Math.max((_c = m.maxDuration) !== null && _c !== void 0 ? _c : 0, duration);
        }
        if (m.count >= this.sampleThreshold) {
            this.flushBucket(bucket);
        }
        return returnValue;
    }
    flushBucket(bucket) {
        const measurements = this.measurementsMap.get(bucket);
        if (measurements === undefined) {
            return;
        }
        if (measurements.count !== 0) {
            const bucketProperties = this.perBucketProperties.get(bucket);
            const telemetryEvent = Object.assign(Object.assign(Object.assign({}, this.eventBase), bucketProperties), measurements);
            this.logger.sendPerformanceEvent(telemetryEvent);
            this.measurementsMap.delete(bucket);
        }
    }
    dispose(error) {
        this.measurementsMap.forEach((_, k) => this.flushBucket(k));
    }
}
//# sourceMappingURL=sampledTelemetryHelper.js.map

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClientSessionExpiredError": () => (/* binding */ ClientSessionExpiredError),
/* harmony export */   "DataCorruptionError": () => (/* binding */ DataCorruptionError),
/* harmony export */   "DataProcessingError": () => (/* binding */ DataProcessingError),
/* harmony export */   "GenericError": () => (/* binding */ GenericError),
/* harmony export */   "ThrottlingWarning": () => (/* binding */ ThrottlingWarning),
/* harmony export */   "UsageError": () => (/* binding */ UsageError),
/* harmony export */   "extractSafePropertiesFromMessage": () => (/* binding */ extractSafePropertiesFromMessage)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Generic wrapper for an unrecognized/uncategorized error object
 */
class GenericError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    /**
     * Create a new GenericError
     * @param message - Error message
     * @param error - inner error object
     * @param props - Telemetry props to include when the error is logged
     */
    constructor(message, error, props) {
        // Don't try to log the inner error
        super(message, props, new Set(["error"]));
        this.error = error;
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.genericError;
    }
}
/**
 * Warning emitted when requests to storage are being throttled.
 */
class ThrottlingWarning extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, retryAfterSeconds, props) {
        super(message, props);
        this.retryAfterSeconds = retryAfterSeconds;
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.throttlingError;
    }
    /**
     * Wrap the given error as a ThrottlingWarning
     * Only preserves the error message, and applies the given retry after to the new warning object
     */
    static wrap(error, retryAfterSeconds, logger) {
        const newErrorFn = (errMsg) => new ThrottlingWarning(errMsg, retryAfterSeconds);
        return (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.wrapErrorAndLog)(error, newErrorFn, logger);
    }
}
/** Error indicating an API is being used improperly resulting in an invalid operation. */
class UsageError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message) {
        super(message, { usageError: true });
        // TODO: implement IUsageError once available
        this.errorType = "usageError";
    }
}
/** Error indicating that a client's session has reached its time limit and is closed. */
class ClientSessionExpiredError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, expiryMs) {
        super(message, { timeoutMs: expiryMs });
        this.expiryMs = expiryMs;
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.clientSessionExpiredError;
    }
}
/**
 * DataCorruptionError indicates that we encountered definitive evidence that the data at rest
 * backing this container is corrupted, and this container would never be expected to load properly again
 */
class DataCorruptionError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, props) {
        super(message, Object.assign(Object.assign({}, props), { dataProcessingError: 1 }));
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataCorruptionError;
        this.canRetry = false;
    }
}
/**
 * DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service.
 * The error will often originate in the dataStore or DDS implementation that is responding to incoming changes.
 * This differs from DataCorruptionError in that this may be a transient error that will not repro in another
 * client or session.
 */
class DataProcessingError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(errorMessage) {
        super(errorMessage);
        this.errorType = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.ContainerErrorType.dataProcessingError;
        this.canRetry = false;
    }
    /** Create a new DataProcessingError detected and raised with the FF code */
    static create(errorMessage, dataProcessingCodepath, sequencedMessage, props = {}) {
        const dataProcessingError = DataProcessingError.wrapIfUnrecognized(errorMessage, dataProcessingCodepath, sequencedMessage);
        dataProcessingError.addTelemetryProperties(props);
        return dataProcessingError;
    }
    /**
     * Wrap the given error in a DataProcessingError, unless the error is already of a known type.
     * In either case, the error will have some relevant properties added for telemetry
     * We wrap conditionally since known error types represent well-understood failure modes, and ideally
     * one day we will move away from throwing these errors but rather we'll return them.
     * But an unrecognized error needs to be classified as DataProcessingError.
     * @param originalError - error to be converted
     * @param dataProcessingCodepath - which codepath failed while processing data
     * @param sequencedMessage - Sequenced message to include info about via telemetry props
     * @returns Either a new DataProcessingError, or (if wrapping is deemed unnecessary) the given error
     */
    static wrapIfUnrecognized(originalError, dataProcessingCodepath, sequencedMessage) {
        const props = Object.assign({ dataProcessingError: 1, dataProcessingCodepath }, (sequencedMessage === undefined ? undefined : extractSafePropertiesFromMessage(sequencedMessage)));
        const normalizedError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.normalizeError)(originalError, { props });
        if (!(0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.isExternalError)(normalizedError)) {
            return normalizedError;
        }
        // Create a new DataProcessingError to wrap this external error
        const dataProcessingError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.wrapError)(normalizedError, (message) => new DataProcessingError(message));
        // Copy over the props above and any others added to this error since first being normalized
        dataProcessingError.addTelemetryProperties(normalizedError.getTelemetryProperties());
        return dataProcessingError;
    }
}
const extractSafePropertiesFromMessage = (message) => ({
    messageClientId: message.clientId,
    messageSequenceNumber: message.sequenceNumber,
    messageClientSequenceNumber: message.clientSequenceNumber,
    messageReferenceSequenceNumber: message.referenceSequenceNumber,
    messageMinimumSequenceNumber: message.minimumSequenceNumber,
    messageTimestamp: message.timestamp,
});
//# sourceMappingURL=error.js.map

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidSerializer": () => (/* binding */ FluidSerializer),
/* harmony export */   "isSerializedHandle": () => (/* binding */ isSerializedHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _remoteObjectHandle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
// RATIONALE: Many methods consume and return 'any' by necessity.
/* eslint-disable @typescript-eslint/no-unsafe-return */


const isSerializedHandle = (value) => (value === null || value === void 0 ? void 0 : value.type) === "__fluid_handle__";
/**
 * Data Store serializer implementation
 */
class FluidSerializer {
    constructor(context, 
    // To be called whenever a handle is parsed by this serializer.
    handleParsedCb) {
        this.context = context;
        this.handleParsedCb = handleParsedCb;
        // If the given 'value' is an IFluidHandle, returns the encoded IFluidHandle.
        // Otherwise returns the original 'value'.  Used by 'encode()' and 'stringify()'.
        this.encodeValue = (value, bind) => {
            // Detect if 'value' is an IFluidHandle.
            const handle = value === null || value === void 0 ? void 0 : value.IFluidHandle;
            // If 'value' is an IFluidHandle return its encoded form.
            return handle !== undefined
                ? this.serializeHandle(handle, bind)
                : value;
        };
        // If the given 'value' is an encoded IFluidHandle, returns the decoded IFluidHandle.
        // Otherwise returns the original 'value'.  Used by 'decode()' and 'parse()'.
        this.decodeValue = (value) => {
            // If 'value' is a serialized IFluidHandle return the deserialized result.
            if (isSerializedHandle(value)) {
                // Old documents may have handles with relative path in their summaries. Convert these to absolute
                // paths. This will ensure that future summaries will have absolute paths for these handles.
                const absolutePath = value.url.startsWith("/")
                    ? value.url
                    : (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(value.url, this.context);
                const parsedHandle = new _remoteObjectHandle__WEBPACK_IMPORTED_MODULE_1__.RemoteFluidObjectHandle(absolutePath, this.root);
                this.handleParsedCb(parsedHandle);
                return parsedHandle;
            }
            else {
                return value;
            }
        };
        this.root = this.context;
        while (this.root.routeContext !== undefined) {
            this.root = this.root.routeContext;
        }
    }
    get IFluidSerializer() { return this; }
    /**
     * Given a mostly-jsonable object tree that may have handle objects embedded within, will return a
     * fully-jsonable object tree where any embedded IFluidHandles have been replaced with a serializable form.
     *
     * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from
     * the root to any replaced handles.  (If no handles are found, returns the original object.)
     *
     * Any unbound handles encountered are bound to the provided IFluidHandle.
     */
    encode(input, bind) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyReplace()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyReplace(input, this.encodeValue, bind)
            : input;
    }
    /**
     * Given a fully-jsonable object tree that may have encoded handle objects embedded within, will return an
     * equivalent object tree where any encoded IFluidHandles have been replaced with their decoded form.
     *
     * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from
     * the root to any replaced handles.  (If no handles are found, returns the original object.)
     *
     * The decoded handles are implicitly bound to the handle context of this serializer.
     */
    decode(input) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyReplace()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyReplace(input, this.decodeValue)
            : input;
    }
    stringify(input, bind) {
        return JSON.stringify(input, (key, value) => this.encodeValue(value, bind));
    }
    // Parses the serialized data - context must match the context with which the JSON was stringified
    parse(input) {
        return JSON.parse(input, (key, value) => this.decodeValue(value));
    }
    // Invoked for non-null objects to recursively replace references to IFluidHandles.
    // Clones as-needed to avoid mutating the `input` object.  If no IFluidHandes are present,
    // returns the original `input`.
    recursivelyReplace(input, replacer, context) {
        // Note: Caller is responsible for ensuring that `input` is defined / non-null.
        //       (Required for Object.keys() below.)
        // Execute the `replace` on the current input.  Note that Caller is responsible for ensuring that `input`
        // is a non-null object.
        const maybeReplaced = replacer(input, context);
        // If the replacer made a substitution there is no need to decscend further. IFluidHandles are always
        // leaves in the object graph.
        if (maybeReplaced !== input) {
            return maybeReplaced;
        }
        // Otherwise descend into the object graph looking for IFluidHandle instances.
        let clone;
        for (const key of Object.keys(input)) {
            const value = input[key];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!!value && typeof value === "object") {
                // Note: Except for IFluidHandle, `input` must not contain circular references (as object must
                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only
                //       lead to a later error when attempting to stringify().
                const replaced = this.recursivelyReplace(value, replacer, context);
                // If the `replaced` object is different than the original `value` then the subgraph contained one
                // or more handles.  If this happens, we need to return a clone of the `input` object where the
                // current property is replaced by the `replaced` value.
                if (replaced !== value) {
                    // Lazily create a shallow clone of the `input` object if we haven't done so already.
                    clone = clone !== null && clone !== void 0 ? clone : (Array.isArray(input)
                        ? [...input]
                        : Object.assign({}, input));
                    // Overwrite the current property `key` in the clone with the `replaced` value.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    clone[key] = replaced;
                }
            }
        }
        return clone !== null && clone !== void 0 ? clone : input;
    }
    serializeHandle(handle, bind) {
        bind.bind(handle);
        return {
            type: "__fluid_handle__",
            url: handle.absolutePath,
        };
    }
}
//# sourceMappingURL=serializer.js.map

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoteFluidObjectHandle": () => (/* binding */ RemoteFluidObjectHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * This handle is used to dynamically load a Fluid object on a remote client and is created on parsing a serialized
 * FluidObjectHandle.
 * This class is used to generate an IFluidHandle when de-serializing any all handles (including handles to DDSes,
 * custom objects) that are stored in SharedObjects. The Data Store or SharedObject corresponding to the
 * IFluidHandle can be retrieved by calling `get` on it.
 */
class RemoteFluidObjectHandle {
    /**
     * Creates a new RemoteFluidObjectHandle when parsing an IFluidHandle.
     * @param absolutePath - The absolute path to the handle from the container runtime.
     * @param routeContext - The root IFluidHandleContext that has a route to this handle.
     */
    constructor(absolutePath, routeContext) {
        this.absolutePath = absolutePath;
        this.routeContext = routeContext;
        this.isAttached = true;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(absolutePath.startsWith("/"), 0x19d /* "Handles should always have absolute paths" */);
    }
    get IFluidRouter() { return this; }
    get IFluidHandleContext() { return this; }
    get IFluidHandle() { return this; }
    async get() {
        if (this.objectP === undefined) {
            // Add `viaHandle` header to distinguish from requests from non-handle paths.
            const request = { url: this.absolutePath, headers: { [_fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__.RuntimeHeaders.viaHandle]: true } };
            this.objectP = this.routeContext.resolveHandle(request)
                .then((response) => {
                if (response.mimeType === "fluid/object") {
                    const fluidObject = response.value;
                    return fluidObject;
                }
                throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.responseToException)(response, request);
            });
        }
        return this.objectP;
    }
    attachGraph() {
        return;
    }
    bind(handle) {
        handle.attachGraph();
    }
    async request(request) {
        try {
            const object = await this.get();
            const router = object.IFluidRouter;
            return router !== undefined
                ? router.request(request)
                : (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.exceptionToResponse)(error);
        }
    }
}
//# sourceMappingURL=remoteObjectHandle.js.map

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerMessageType": () => (/* binding */ ContainerMessageType),
/* harmony export */   "ContainerRuntime": () => (/* binding */ ContainerRuntime),
/* harmony export */   "DefaultSummaryConfiguration": () => (/* binding */ DefaultSummaryConfiguration),
/* harmony export */   "RuntimeHeaders": () => (/* binding */ RuntimeHeaders),
/* harmony export */   "RuntimeMessage": () => (/* binding */ RuntimeMessage),
/* harmony export */   "ScheduleManager": () => (/* binding */ ScheduleManager),
/* harmony export */   "agentSchedulerId": () => (/* binding */ agentSchedulerId),
/* harmony export */   "getDeviceSpec": () => (/* binding */ getDeviceSpec),
/* harmony export */   "isRuntimeMessage": () => (/* binding */ isRuntimeMessage),
/* harmony export */   "unpackRuntimeMessage": () => (/* binding */ unpackRuntimeMessage)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(119);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(70);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(102);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(133);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(46);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(132);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(120);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(64);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(77);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(106);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(24);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(25);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(134);
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(103);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(27);
/* harmony import */ var _containerHandleContext__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(72);
/* harmony import */ var _dataStoreRegistry__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(131);
/* harmony import */ var _summarizer__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(115);
/* harmony import */ var _summaryManager__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(125);
/* harmony import */ var _deltaScheduler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69);
/* harmony import */ var _connectionTelemetry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67);
/* harmony import */ var _pendingStateManager__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(111);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);
/* harmony import */ var _blobManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(110);
/* harmony import */ var _dataStores__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(82);
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(76);
/* harmony import */ var _summaryCollection__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(113);
/* harmony import */ var _orderedClientElection__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(114);
/* harmony import */ var _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(71);
/* harmony import */ var _throttler__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(126);
/* harmony import */ var _runWhileConnectedCoordinator__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(124);
/* harmony import */ var _garbageCollection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(73);
/* harmony import */ var _dataStore__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(101);
/* harmony import */ var _batchTracker__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(127);
/* harmony import */ var _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(129);
/* harmony import */ var _opTelemetry__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(128);
































var ContainerMessageType;
(function (ContainerMessageType) {
    // An op to be delivered to store
    ContainerMessageType["FluidDataStoreOp"] = "component";
    // Creates a new store
    ContainerMessageType["Attach"] = "attach";
    // Chunked operation.
    ContainerMessageType["ChunkedOp"] = "chunkedOp";
    // Signifies that a blob has been attached and should not be garbage collected by storage
    ContainerMessageType["BlobAttach"] = "blobAttach";
    // Ties our new clientId to our old one on reconnect
    ContainerMessageType["Rejoin"] = "rejoin";
    // Sets the alias of a root data store
    ContainerMessageType["Alias"] = "alias";
})(ContainerMessageType || (ContainerMessageType = {}));
const DefaultSummaryConfiguration = {
    state: "enabled",
    idleTime: 5000 * 3,
    maxTime: 5000 * 12,
    maxOps: 100,
    minOpsForLastSummaryAttempt: 10,
    maxAckWaitTime: 6 * 10 * 1000,
    maxOpsSinceLastSummary: 7000,
    initialSummarizerDelayMs: 5000,
    summarizerClientElection: false,
};
/**
 * Accepted header keys for requests coming to the runtime.
 */
var RuntimeHeaders;
(function (RuntimeHeaders) {
    /** True to wait for a data store to be created and loaded before returning it. */
    RuntimeHeaders["wait"] = "wait";
    /**
     * True if the request is from an external app. Used for GC to handle scenarios where a data store
     * is deleted and requested via an external app.
     */
    RuntimeHeaders["externalRequest"] = "externalRequest";
    /** True if the request is coming from an IFluidHandle. */
    RuntimeHeaders["viaHandle"] = "viaHandle";
})(RuntimeHeaders || (RuntimeHeaders = {}));
const useDataStoreAliasingKey = "Fluid.ContainerRuntime.UseDataStoreAliasing";
const maxConsecutiveReconnectsKey = "Fluid.ContainerRuntime.MaxConsecutiveReconnects";
// Feature gate for the max op size. If the value is negative, chunking is enabled
// and all ops over 16k would be chunked. If the value is positive, all ops with
// a size strictly larger will be rejected and the container closed with an error.
const maxOpSizeInBytesKey = "Fluid.ContainerRuntime.MaxOpSizeInBytes";
// By default, we should reject any op larger than 768KB,
// in order to account for some extra overhead from serialization
// to not reach the 1MB limits in socket.io and Kafka.
const defaultMaxOpSizeInBytes = 768000;
// By default, the size of the contents for the incoming ops is tracked.
// However, in certain situations, this may incur a performance hit.
// The feature-gate below can be used to disable this feature.
const disableOpTrackingKey = "Fluid.ContainerRuntime.DisableOpTracking";
const defaultFlushMode = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased;
var RuntimeMessage;
(function (RuntimeMessage) {
    RuntimeMessage["FluidDataStoreOp"] = "component";
    RuntimeMessage["Attach"] = "attach";
    RuntimeMessage["ChunkedOp"] = "chunkedOp";
    RuntimeMessage["BlobAttach"] = "blobAttach";
    RuntimeMessage["Rejoin"] = "rejoin";
    RuntimeMessage["Alias"] = "alias";
    RuntimeMessage["Operation"] = "op";
})(RuntimeMessage || (RuntimeMessage = {}));
function isRuntimeMessage(message) {
    if (Object.values(RuntimeMessage).includes(message.type)) {
        return true;
    }
    return false;
}
function unpackRuntimeMessage(message) {
    if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.Operation) {
        // legacy op format?
        if (message.contents.address !== undefined && message.contents.type === undefined) {
            message.type = ContainerMessageType.FluidDataStoreOp;
        }
        else {
            // new format
            const innerContents = message.contents;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(innerContents.type !== undefined, 0x121 /* "Undefined inner contents type!" */);
            message.type = innerContents.type;
            message.contents = innerContents.contents;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.isUnpackedRuntimeMessage)(message), 0x122 /* "Message to unpack is not proper runtime message" */);
    }
    else {
        // Legacy format, but it's already "unpacked",
        // i.e. message.type is actually ContainerMessageType.
        // Nothing to do in such case.
    }
    return message;
}
/**
 * This class controls pausing and resuming of inbound queue to ensure that we never
 * start processing ops in a batch IF we do not have all ops in the batch.
 */
class ScheduleManagerCore {
    constructor(deltaManager, logger) {
        this.deltaManager = deltaManager;
        this.logger = logger;
        this.localPaused = false;
        this.timePaused = 0;
        this.batchCount = 0;
        // Listen for delta manager sends and add batch metadata to messages
        this.deltaManager.on("prepareSend", (messages) => {
            if (messages.length === 0) {
                return;
            }
            // First message will have the batch flag set to true if doing a batched send
            const firstMessageMetadata = messages[0].metadata;
            if (!(firstMessageMetadata === null || firstMessageMetadata === void 0 ? void 0 : firstMessageMetadata.batch)) {
                return;
            }
            // If the batch contains only a single op, clear the batch flag.
            if (messages.length === 1) {
                delete firstMessageMetadata.batch;
                return;
            }
            // Set the batch flag to false on the last message to indicate the end of the send batch
            const lastMessage = messages[messages.length - 1];
            lastMessage.metadata = Object.assign(Object.assign({}, lastMessage.metadata), { batch: false });
        });
        // Listen for updates and peek at the inbound
        this.deltaManager.inbound.on("push", (message) => {
            this.trackPending(message);
        });
        // Start with baseline - empty inbound queue.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x293 /* "initial state" */);
        const allPending = this.deltaManager.inbound.toArray();
        for (const pending of allPending) {
            this.trackPending(pending);
        }
        // We are intentionally directly listening to the "op" to inspect system ops as well.
        // If we do not observe system ops, we are likely to hit 0x296 assert when system ops
        // precedes start of incomplete batch.
        this.deltaManager.on("op", (message) => this.afterOpProcessing(message.sequenceNumber));
    }
    /**
     * The only public function in this class - called when we processed an op,
     * to make decision if op processing should be paused or not afer that.
     */
    afterOpProcessing(sequenceNumber) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x294 /* "can't have op processing paused if we are processing an op" */);
        // If the inbound queue is ever empty, nothing to do!
        if (this.deltaManager.inbound.length === 0) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseSequenceNumber === undefined, 0x295 /* "there should be no pending batch if we have no ops" */);
            return;
        }
        // The queue is
        // 1. paused only when the next message to be processed is the beginning of a batch. Done in two places:
        //    - here (processing ops until reaching start of incomplete batch)
        //    - in trackPending(), when queue was empty and start of batch showed up.
        // 2. resumed when batch end comes in (in trackPending())
        // do we have incomplete batch to worry about?
        if (this.pauseSequenceNumber !== undefined) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(sequenceNumber < this.pauseSequenceNumber, 0x296 /* "we should never start processing incomplete batch!" */);
            // If the next op is the start of incomplete batch, then we can't process it until it's fully in - pause!
            if (sequenceNumber + 1 === this.pauseSequenceNumber) {
                this.pauseQueue();
            }
        }
    }
    pauseQueue() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x297 /* "always called from resumed state" */);
        this.localPaused = true;
        this.timePaused = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.performance.now();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.deltaManager.inbound.pause();
    }
    resumeQueue(startBatch, messageEndBatch) {
        const endBatch = messageEndBatch.sequenceNumber;
        const duration = this.localPaused ? (_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.performance.now() - this.timePaused) : undefined;
        this.batchCount++;
        if (this.batchCount % 1000 === 1) {
            this.logger.sendTelemetryEvent({
                eventName: "BatchStats",
                sequenceNumber: endBatch,
                length: endBatch - startBatch + 1,
                msnDistance: endBatch - messageEndBatch.minimumSequenceNumber,
                duration,
                batchCount: this.batchCount,
                interrupted: this.localPaused,
            });
        }
        // Return early if no change in value
        if (!this.localPaused) {
            return;
        }
        this.localPaused = false;
        // Random round number - we want to know when batch waiting paused op processing.
        if (duration !== undefined && duration > _connectionTelemetry__WEBPACK_IMPORTED_MODULE_5__.latencyThreshold) {
            this.logger.sendErrorEvent({
                eventName: "MaxBatchWaitTimeExceeded",
                duration,
                sequenceNumber: endBatch,
                length: endBatch - startBatch,
            });
        }
        this.deltaManager.inbound.resume();
    }
    /**
     * Called for each incoming op (i.e. inbound "push" notification)
     */
    trackPending(message) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.deltaManager.inbound.length !== 0, 0x298 /* "we have something in the queue that generates this event" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)((this.currentBatchClientId === undefined) === (this.pauseSequenceNumber === undefined), 0x299 /* "non-synchronized state" */);
        const metadata = message.metadata;
        const batchMetadata = metadata === null || metadata === void 0 ? void 0 : metadata.batch;
        // Protocol messages are never part of a runtime batch of messages
        if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.isUnpackedRuntimeMessage)(message)) {
            // Protocol messages should never show up in the middle of the batch!
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.currentBatchClientId === undefined, 0x29a /* "System message in the middle of batch!" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchMetadata === undefined, 0x29b /* "system op in a batch?" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x29c /* "we should be processing ops when there is no active batch" */);
            return;
        }
        if (this.currentBatchClientId === undefined && batchMetadata === undefined) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x29d /* "we should be processing ops when there is no active batch" */);
            return;
        }
        // If the client ID changes then we can move the pause point. If it stayed the same then we need to check.
        // If batchMetadata is not undefined then if it's true we've begun a new batch - if false we've ended
        // the previous one
        if (this.currentBatchClientId !== undefined || batchMetadata === false) {
            if (this.currentBatchClientId !== message.clientId) {
                // "Batch not closed, yet message from another client!"
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError("OpBatchIncomplete", Object.assign({ runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion, batchClientId: this.currentBatchClientId }, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.extractSafePropertiesFromMessage)(message)));
            }
        }
        // The queue is
        // 1. paused only when the next message to be processed is the beginning of a batch. Done in two places:
        //    - in afterOpProcessing() - processing ops until reaching start of incomplete batch
        //    - here (batchMetadata == false below), when queue was empty and start of batch showed up.
        // 2. resumed when batch end comes in (batchMetadata === true case below)
        if (batchMetadata) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.currentBatchClientId === undefined, 0x29e /* "there can't be active batch" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.localPaused, 0x29f /* "we should be processing ops when there is no active batch" */);
            this.pauseSequenceNumber = message.sequenceNumber;
            this.currentBatchClientId = message.clientId;
            // Start of the batch
            // Only pause processing if queue has no other ops!
            // If there are any other ops in the queue, processing will be stopped when they are processed!
            if (this.deltaManager.inbound.length === 1) {
                this.pauseQueue();
            }
        }
        else if (batchMetadata === false) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseSequenceNumber !== undefined, 0x2a0 /* "batch presence was validated above" */);
            // Batch is complete, we can process it!
            this.resumeQueue(this.pauseSequenceNumber, message);
            this.pauseSequenceNumber = undefined;
            this.currentBatchClientId = undefined;
        }
        else {
            // Continuation of current batch. Do nothing
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.currentBatchClientId !== undefined, 0x2a1 /* "logic error" */);
        }
    }
}
/**
 * This class has the following responsibilities:
 * 1. It tracks batches as we process ops and raises "batchBegin" and "batchEnd" events.
 *    As part of it, it validates batch correctness (i.e. no system ops in the middle of batch)
 * 2. It creates instance of ScheduleManagerCore that ensures we never start processing ops from batch
 *    unless all ops of the batch are in.
 */
class ScheduleManager {
    constructor(deltaManager, emitter, logger) {
        this.deltaManager = deltaManager;
        this.emitter = emitter;
        this.logger = logger;
        this.hitError = false;
        this.deltaScheduler = new _deltaScheduler__WEBPACK_IMPORTED_MODULE_8__.DeltaScheduler(this.deltaManager, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, "DeltaScheduler"));
        void new ScheduleManagerCore(deltaManager, logger);
    }
    beforeOpProcessing(message) {
        var _a;
        if (this.batchClientId !== message.clientId) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.batchClientId === undefined, 0x2a2 /* "Batch is interrupted by other client op. Should be caught by trackPending()" */);
            // This could be the beginning of a new batch or an individual message.
            this.emitter.emit("batchBegin", message);
            this.deltaScheduler.batchBegin(message);
            const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;
            if (batch) {
                this.batchClientId = message.clientId;
            }
            else {
                this.batchClientId = undefined;
            }
        }
    }
    afterOpProcessing(error, message) {
        var _a;
        // If this is no longer true, we need to revisit what we do where we set this.hitError.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.hitError, 0x2a3 /* "container should be closed on any error" */);
        if (error) {
            // We assume here that loader will close container and stop processing all future ops.
            // This is implicit dependency. If this flow changes, this code might no longer be correct.
            this.hitError = true;
            this.batchClientId = undefined;
            this.emitter.emit("batchEnd", error, message);
            this.deltaScheduler.batchEnd(message);
            return;
        }
        const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;
        // If no batchClientId has been set then we're in an individual batch. Else, if we get
        // batch end metadata, this is end of the current batch.
        if (this.batchClientId === undefined || batch === false) {
            this.batchClientId = undefined;
            this.emitter.emit("batchEnd", undefined, message);
            this.deltaScheduler.batchEnd(message);
            return;
        }
    }
}
/**
 * Legacy ID for the built-in AgentScheduler.  To minimize disruption while removing it, retaining this as a
 * special-case for document dirty state.  Ultimately we should have no special-cases from the
 * ContainerRuntime's perspective.
 */
const agentSchedulerId = "_scheduler";
// safely check navigator and get the hardware spec value
function getDeviceSpec() {
    try {
        if (typeof navigator === "object" && navigator !== null) {
            return {
                deviceMemory: navigator.deviceMemory,
                hardwareConcurrency: navigator.hardwareConcurrency,
            };
        }
    }
    catch (_a) {
    }
    return {};
}
/**
 * Represents the runtime of the container. Contains helper functions/state of the container.
 * It will define the store level mappings.
 */
class ContainerRuntime extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_10__.TypedEventEmitter {
    constructor(context, registry, metadata, electedSummarizerData, chunks, dataStoreAliasMap, runtimeOptions, containerScope, logger, existing, blobManagerSnapshot, _storage, requestHandler, summaryConfiguration) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (summaryConfiguration === void 0) { summaryConfiguration = Object.assign(Object.assign({}, DefaultSummaryConfiguration), (_a = runtimeOptions.summaryOptions) === null || _a === void 0 ? void 0 : _a.summaryConfigOverrides); }
        super();
        this.context = context;
        this.registry = registry;
        this.runtimeOptions = runtimeOptions;
        this.containerScope = containerScope;
        this.logger = logger;
        this._storage = _storage;
        this.requestHandler = requestHandler;
        this.summaryConfiguration = summaryConfiguration;
        this.defaultMaxConsecutiveReconnects = 15;
        this._orderSequentiallyCalls = 0;
        this.needsFlush = false;
        this.flushTrigger = false;
        this.savedOps = [];
        this.consecutiveReconnects = 0;
        this._disposed = false;
        this.emitDirtyDocumentEvent = true;
        this.defaultTelemetrySignalSampleCount = 100;
        this._perfSignalData = {
            signalsLost: 0,
            signalSequenceNumber: 0,
            signalTimestamp: 0,
            trackingSignalSequenceNumber: undefined,
        };
        this.summarizeOnDemand = (...args) => {
            if (this.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType) {
                return this.summarizer.summarizeOnDemand(...args);
            }
            else if (this.summaryManager !== undefined) {
                return this.summaryManager.summarizeOnDemand(...args);
            }
            else {
                // If we're not the summarizer, and we don't have a summaryManager, we expect that
                // disableSummaries is turned on. We are throwing instead of returning a failure here,
                // because it is a misuse of the API rather than an expected failure.
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Can't summarize, disableSummaries: ${this.summariesDisabled}`);
            }
        };
        this.enqueueSummarize = (...args) => {
            if (this.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType) {
                return this.summarizer.enqueueSummarize(...args);
            }
            else if (this.summaryManager !== undefined) {
                return this.summaryManager.enqueueSummarize(...args);
            }
            else {
                // If we're not the summarizer, and we don't have a summaryManager, we expect that
                // generateSummaries is turned off. We are throwing instead of returning a failure here,
                // because it is a misuse of the API rather than an expected failure.
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Can't summarize, disableSummaries: ${this.summariesDisabled}`);
            }
        };
        this.messageAtLastSummary = metadata === null || metadata === void 0 ? void 0 : metadata.message;
        // Default to false (enabled).
        this.disableIsolatedChannels = (_b = this.runtimeOptions.summaryOptions.disableIsolatedChannels) !== null && _b !== void 0 ? _b : false;
        this._connected = this.context.connected;
        this.chunkMap = new Map(chunks);
        this.handleContext = new _containerHandleContext__WEBPACK_IMPORTED_MODULE_12__.ContainerFluidHandleContext("", this);
        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, "ContainerRuntime"));
        this.summariesDisabled = this.isSummariesDisabled();
        this.heuristicsDisabled = this.isHeuristicsDisabled();
        this.summarizerClientElectionEnabled = this.isSummarizerClientElectionEnabled();
        this.maxOpsSinceLastSummary = this.getMaxOpsSinceLastSummary();
        this.initialSummarizerDelayMs = this.getInitialSummarizerDelayMs();
        this._aliasingEnabled =
            ((_c = this.mc.config.getBoolean(useDataStoreAliasingKey)) !== null && _c !== void 0 ? _c : false) ||
                ((_d = runtimeOptions.useDataStoreAliasing) !== null && _d !== void 0 ? _d : false);
        this._maxOpSizeInBytes = ((_e = this.mc.config.getNumber(maxOpSizeInBytesKey)) !== null && _e !== void 0 ? _e : defaultMaxOpSizeInBytes);
        this.maxConsecutiveReconnects =
            (_f = this.mc.config.getNumber(maxConsecutiveReconnectsKey)) !== null && _f !== void 0 ? _f : this.defaultMaxConsecutiveReconnects;
        this._flushMode = runtimeOptions.flushMode;
        const pendingRuntimeState = context.pendingLocalState;
        const baseSnapshot = (_g = pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.baseSnapshot) !== null && _g !== void 0 ? _g : context.baseSnapshot;
        this.garbageCollector = _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GarbageCollector.create({
            runtime: this,
            gcOptions: this.runtimeOptions.gcOptions,
            baseSnapshot,
            baseLogger: this.mc.logger,
            existing,
            metadata,
            isSummarizerClient: this.context.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType,
            getNodePackagePath: async (nodePath) => this.getGCNodePackagePath(nodePath),
            getLastSummaryTimestampMs: () => { var _a; return (_a = this.messageAtLastSummary) === null || _a === void 0 ? void 0 : _a.timestamp; },
            readAndParseBlob: async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(this.storage, id),
        });
        const loadedFromSequenceNumber = this.deltaManager.initialSequenceNumber;
        this.summarizerNode = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.createRootSummarizerNodeWithGC)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, "SummarizerNode"), 
        // Summarize function to call when summarize is called. Summarizer node always tracks summary state.
        async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext), 
        // Latest change sequence number, no changes since summary applied yet
        loadedFromSequenceNumber, 
        // Summary reference sequence number, undefined if no summary yet
        baseSnapshot ? loadedFromSequenceNumber : undefined, {
            // Must set to false to prevent sending summary handle which would be pointing to
            // a summary with an older protocol state.
            canReuseHandle: false,
            // Must set to true to throw on any data stores failure that was too severe to be handled.
            // We also are not decoding the base summaries at the root.
            throwOnFailure: true,
            // If GC should not run, let the summarizer node know so that it does not track GC state.
            gcDisabled: !this.garbageCollector.shouldRunGC,
        });
        if (baseSnapshot) {
            this.summarizerNode.loadBaseSummaryWithoutDifferential(baseSnapshot);
        }
        this.dataStores = new _dataStores__WEBPACK_IMPORTED_MODULE_17__.DataStores((0,_dataStores__WEBPACK_IMPORTED_MODULE_17__.getSummaryForDatastores)(baseSnapshot, metadata), this, (attachMsg) => this.submit(ContainerMessageType.Attach, attachMsg), (id, createParam) => (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, undefined, getGCDataFn, getBaseGCDetailsFn), (id) => this.summarizerNode.deleteChild(id), this.mc.logger, async () => this.garbageCollector.getBaseGCDetails(), (path, timestampMs, packagePath) => this.garbageCollector.nodeUpdated(path, "Changed", timestampMs, packagePath), new Map(dataStoreAliasMap), this.garbageCollector.writeDataAtRoot);
        this.blobManager = new _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager(this.handleContext, blobManagerSnapshot, () => this.storage, (blobId) => this.submit(ContainerMessageType.BlobAttach, undefined, undefined, { blobId }), (blobPath) => this.garbageCollector.nodeUpdated(blobPath, "Loaded"), this, this.logger);
        this.scheduleManager = new ScheduleManager(context.deltaManager, this, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, "ScheduleManager"));
        this.deltaSender = this.deltaManager;
        this.pendingStateManager = new _pendingStateManager__WEBPACK_IMPORTED_MODULE_19__.PendingStateManager({
            applyStashedOp: this.applyStashedOp.bind(this),
            clientId: () => this.clientId,
            close: this.closeFn,
            connected: () => this.connected,
            flush: this.flush.bind(this),
            flushMode: () => this.flushMode,
            reSubmit: this.reSubmit.bind(this),
            rollback: this.rollback.bind(this),
            setFlushMode: (mode) => this.setFlushMode(mode),
        }, this._flushMode, pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.pending);
        this.context.quorum.on("removeMember", (clientId) => {
            this.clearPartialChunks(clientId);
        });
        this.summaryCollection = new _summaryCollection__WEBPACK_IMPORTED_MODULE_20__.SummaryCollection(this.deltaManager, this.logger);
        this.dirtyContainer = this.context.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached
            || this.pendingStateManager.hasPendingMessages();
        this.context.updateDirtyContainerState(this.dirtyContainer);
        if (this.summariesDisabled) {
            this.mc.logger.sendTelemetryEvent({ eventName: "SummariesDisabled" });
        }
        else {
            const orderedClientLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.logger, "OrderedClientElection");
            const orderedClientCollection = new _orderedClientElection__WEBPACK_IMPORTED_MODULE_22__.OrderedClientCollection(orderedClientLogger, this.context.deltaManager, this.context.quorum);
            const orderedClientElectionForSummarizer = new _orderedClientElection__WEBPACK_IMPORTED_MODULE_22__.OrderedClientElection(orderedClientLogger, orderedClientCollection, electedSummarizerData !== null && electedSummarizerData !== void 0 ? electedSummarizerData : this.context.deltaManager.lastSequenceNumber, _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.SummarizerClientElection.isClientEligible);
            this.summarizerClientElection = new _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.SummarizerClientElection(orderedClientLogger, this.summaryCollection, orderedClientElectionForSummarizer, this.maxOpsSinceLastSummary, this.summarizerClientElectionEnabled);
            if (this.context.clientDetails.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType) {
                this._summarizer = new _summarizer__WEBPACK_IMPORTED_MODULE_23__.Summarizer("/_summarizer", this /* ISummarizerRuntime */, () => this.summaryConfiguration, this /* ISummarizerInternalsProvider */, this.handleContext, this.summaryCollection, async (runtime) => _runWhileConnectedCoordinator__WEBPACK_IMPORTED_MODULE_24__.RunWhileConnectedCoordinator.create(runtime));
            }
            else if (_summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.SummarizerClientElection.clientDetailsPermitElection(this.context.clientDetails)) {
                // Only create a SummaryManager and SummarizerClientElection
                // if summaries are enabled and we are not the summarizer client.
                const defaultAction = () => {
                    if (this.summaryCollection.opsSinceLastAck > this.maxOpsSinceLastSummary) {
                        this.logger.sendErrorEvent({ eventName: "SummaryStatus:Behind" });
                        // unregister default to no log on every op after falling behind
                        // and register summary ack handler to re-register this handler
                        // after successful summary
                        this.summaryCollection.once(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.SummaryAck, () => {
                            this.logger.sendTelemetryEvent({ eventName: "SummaryStatus:CaughtUp" });
                            // we've caught up, so re-register the default action to monitor for
                            // falling behind, and unregister ourself
                            this.summaryCollection.on("default", defaultAction);
                        });
                        this.summaryCollection.off("default", defaultAction);
                    }
                };
                this.summaryCollection.on("default", defaultAction);
                // Create the SummaryManager and mark the initial state
                this.summaryManager = new _summaryManager__WEBPACK_IMPORTED_MODULE_25__.SummaryManager(this.summarizerClientElection, this, // IConnectedState
                this.summaryCollection, this.logger, this.formRequestSummarizerFn(this.context.loader), new _throttler__WEBPACK_IMPORTED_MODULE_26__.Throttler(60 * 1000, // 60 sec delay window
                30 * 1000, // 30 sec max delay
                // throttling function increases exponentially (0ms, 40ms, 80ms, 160ms, etc)
                (0,_throttler__WEBPACK_IMPORTED_MODULE_26__.formExponentialFn)({ coefficient: 20, initialDelay: 0 })), {
                    initialDelayMs: this.initialSummarizerDelayMs,
                }, this.heuristicsDisabled);
                this.summaryManager.start();
            }
        }
        this.deltaManager.on("readonly", (readonly) => {
            // we accumulate ops while being in read-only state.
            // once user gets write permissions and we have active connection, flush all pending ops.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(readonly === this.deltaManager.readOnlyInfo.readonly, 0x124 /* "inconsistent readonly property/event state" */);
            // We need to be very careful with when we (re)send pending ops, to ensure that we only send ops
            // when we either never send an op, or attempted to send it but we know for sure it was not
            // sequenced by server and will never be sequenced (i.e. was lost)
            // For loss of connection, we wait for our own "join" op and use it a a barrier to know all the
            // ops that made it from previous connection, before switching clientId and raising "connected" event
            // But with read-only permissions, if we transition between read-only and r/w states while on same
            // connection, then we have no good signal to tell us when it's safe to send ops we accumulated while
            // being in read-only state.
            // For that reason, we support getting to read-only state only when disconnected. This ensures that we
            // can rely on same safety mechanism and resend ops only when we establish new connection.
            // This is applicable for read-only permissions (event is raised before connection is properly registered),
            // but it's an extra requirement for Container.forceReadonly() API
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!readonly || !this.connected, 0x125 /* "Unsafe to transition to read-only state!" */);
            this.replayPendingStates();
        });
        // logging hardware telemetry
        logger.sendTelemetryEvent(Object.assign({ eventName: "DeviceSpec" }, getDeviceSpec()));
        let loadSummaryNumber;
        // Get the container creation metadata. For new container, we initialize these. For existing containers,
        // get the values from the metadata blob.
        if (existing) {
            this.createContainerMetadata = {
                createContainerRuntimeVersion: metadata === null || metadata === void 0 ? void 0 : metadata.createContainerRuntimeVersion,
                createContainerTimestamp: metadata === null || metadata === void 0 ? void 0 : metadata.createContainerTimestamp,
            };
            // back-compat 0.59.3000 - Older document may either write summaryCount or not write it at all. If it does
            // not write it, initialize summaryNumber to 0.
            loadSummaryNumber = (_j = (_h = metadata === null || metadata === void 0 ? void 0 : metadata.summaryNumber) !== null && _h !== void 0 ? _h : metadata === null || metadata === void 0 ? void 0 : metadata.summaryCount) !== null && _j !== void 0 ? _j : 0;
        }
        else {
            this.createContainerMetadata = {
                createContainerRuntimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion,
                createContainerTimestamp: Date.now(),
            };
            loadSummaryNumber = 0;
        }
        this.nextSummaryNumber = loadSummaryNumber + 1;
        this.logger.sendTelemetryEvent(Object.assign(Object.assign(Object.assign({ eventName: "ContainerLoadStats" }, this.createContainerMetadata), this.dataStores.containerLoadStats), { summaryNumber: loadSummaryNumber, summaryFormatVersion: metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion, disableIsolatedChannels: metadata === null || metadata === void 0 ? void 0 : metadata.disableIsolatedChannels, gcVersion: metadata === null || metadata === void 0 ? void 0 : metadata.gcFeature }));
        (0,_connectionTelemetry__WEBPACK_IMPORTED_MODULE_5__.ReportOpPerfTelemetry)(this.context.clientId, this.deltaManager, this.logger);
        (0,_batchTracker__WEBPACK_IMPORTED_MODULE_27__.BindBatchTracker)(this, this.logger);
        this.opTracker = new _opTelemetry__WEBPACK_IMPORTED_MODULE_28__.OpTracker(this.deltaManager, this.mc.config.getBoolean(disableOpTrackingKey) === true);
    }
    get IContainerRuntime() { return this; }
    get IFluidRouter() { return this; }
    /**
     * Load the stores from a snapshot and returns the runtime.
     * @param context - Context of the container.
     * @param registryEntries - Mapping to the stores.
     * @param requestHandler - Request handlers for the container runtime
     * @param runtimeOptions - Additional options to be passed to the runtime
     * @param existing - (optional) When loading from an existing snapshot. Precedes context.existing if provided
     */
    static async load(context, registryEntries, requestHandler, runtimeOptions = {}, containerScope = context.scope, existing) {
        var _a, _b, _c;
        // If taggedLogger exists, use it. Otherwise, wrap the vanilla logger:
        // back-compat: Remove the TaggedLoggerAdapter fallback once all the host are using loader > 0.45
        const backCompatContext = context;
        const passLogger = (_a = backCompatContext.taggedLogger) !== null && _a !== void 0 ? _a : new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TaggedLoggerAdapter(backCompatContext.logger);
        const logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(passLogger, undefined, {
            all: {
                runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion,
            },
        });
        const { summaryOptions = {}, gcOptions = {}, loadSequenceNumberVerification = "close", useDataStoreAliasing = false, flushMode = defaultFlushMode, enableOfflineLoad = false, } = runtimeOptions;
        const pendingRuntimeState = context.pendingLocalState;
        const baseSnapshot = (_b = pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.baseSnapshot) !== null && _b !== void 0 ? _b : context.baseSnapshot;
        const storage = !pendingRuntimeState ?
            context.storage :
            new _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__.SerializedSnapshotStorage(() => { return context.storage; }, pendingRuntimeState.snapshotBlobs);
        const registry = new _dataStoreRegistry__WEBPACK_IMPORTED_MODULE_30__.FluidDataStoreRegistry(registryEntries);
        const tryFetchBlob = async (blobName) => {
            const blobId = baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.blobs[blobName];
            if (baseSnapshot && blobId) {
                // IContainerContext storage api return type still has undefined in 0.39 package version.
                // So once we release 0.40 container-defn package we can remove this check.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(storage !== undefined, 0x1f5 /* "Attached state should have storage" */);
                return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(storage, blobId);
            }
        };
        const [chunks, metadata, electedSummarizerData, aliases] = await Promise.all([
            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.chunksBlobName),
            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.metadataBlobName),
            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.electedSummarizerBlobName),
            tryFetchBlob(_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.aliasBlobName),
        ]);
        const loadExisting = existing === true || context.existing === true;
        // read snapshot blobs needed for BlobManager to load
        const blobManagerSnapshot = await _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.load(baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.blobsTreeName], async (id) => {
            // IContainerContext storage api return type still has undefined in 0.39 package version.
            // So once we release 0.40 container-defn package we can remove this check.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(storage !== undefined, 0x256 /* "storage undefined in attached container" */);
            return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(storage, id);
        });
        // Verify summary runtime sequence number matches protocol sequence number.
        const runtimeSequenceNumber = (_c = metadata === null || metadata === void 0 ? void 0 : metadata.message) === null || _c === void 0 ? void 0 : _c.sequenceNumber;
        // When we load with pending state, we reuse an old snapshot so we don't expect these numbers to match
        if (!pendingRuntimeState && runtimeSequenceNumber !== undefined) {
            const protocolSequenceNumber = context.deltaManager.initialSequenceNumber;
            // Unless bypass is explicitly set, then take action when sequence numbers mismatch.
            if (loadSequenceNumberVerification !== "bypass" && runtimeSequenceNumber !== protocolSequenceNumber) {
                // "Load from summary, runtime metadata sequenceNumber !== initialSequenceNumber"
                const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError(
                // pre-0.58 error message: SummaryMetadataMismatch
                "Summary metadata mismatch", { runtimeVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_7__.pkgVersion, runtimeSequenceNumber, protocolSequenceNumber });
                if (loadSequenceNumberVerification === "log") {
                    logger.sendErrorEvent({ eventName: "SequenceNumberMismatch" }, error);
                }
                else {
                    context.closeFn(error);
                }
            }
        }
        const runtime = new ContainerRuntime(context, registry, metadata, electedSummarizerData, chunks !== null && chunks !== void 0 ? chunks : [], aliases !== null && aliases !== void 0 ? aliases : [], {
            summaryOptions,
            gcOptions,
            loadSequenceNumberVerification,
            useDataStoreAliasing,
            flushMode,
            enableOfflineLoad,
        }, containerScope, logger, loadExisting, blobManagerSnapshot, storage, requestHandler);
        if (pendingRuntimeState) {
            await runtime.processSavedOps(pendingRuntimeState);
            // delete these once runtime has seen them to save space
            pendingRuntimeState.savedOps = [];
        }
        await runtime.getSnapshotBlobs();
        return runtime;
    }
    get options() {
        return this.context.options;
    }
    get clientId() {
        return this.context.clientId;
    }
    get clientDetails() {
        return this.context.clientDetails;
    }
    get deltaManager() {
        return this.context.deltaManager;
    }
    get storage() {
        return this._storage;
    }
    get reSubmitFn() {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return this.reSubmit;
    }
    get closeFn() {
        return this.context.closeFn;
    }
    get flushMode() {
        return this._flushMode;
    }
    get scope() {
        return this.containerScope;
    }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    get attachState() {
        return this.context.attachState;
    }
    get IFluidHandleContext() {
        return this.handleContext;
    }
    get connected() {
        return this._connected;
    }
    /** clientId of parent (non-summarizing) container that owns summarizer container */
    get summarizerClientId() {
        var _a;
        return (_a = this.summarizerClientElection) === null || _a === void 0 ? void 0 : _a.electedClientId;
    }
    get disposed() { return this._disposed; }
    get summarizer() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this._summarizer !== undefined, 0x257 /* "This is not summarizing container" */);
        return this._summarizer;
    }
    isSummariesDisabled() {
        // back-compat: disableSummaries was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.disableSummaries === true) {
            return true;
        }
        return this.summaryConfiguration.state === "disabled";
    }
    isHeuristicsDisabled() {
        var _a;
        // back-compat: disableHeuristics was moved from ISummarizerOptions
        //   to ISummaryConfiguration in 0.60.
        if (((_a = this.runtimeOptions.summaryOptions.summarizerOptions) === null || _a === void 0 ? void 0 : _a.disableHeuristics) === true) {
            return true;
        }
        return this.summaryConfiguration.state === "disableHeuristics";
    }
    isSummarizerClientElectionEnabled() {
        var _a;
        if (this.mc.config.getBoolean("Fluid.ContainerRuntime.summarizerClientElection")) {
            return (_a = this.mc.config.getBoolean("Fluid.ContainerRuntime.summarizerClientElection")) !== null && _a !== void 0 ? _a : true;
        }
        // back-compat: summarizerClientElection was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.summarizerClientElection === true) {
            return true;
        }
        if (this.summaryConfiguration.state !== "disabled") {
            return this.summaryConfiguration.summarizerClientElection === true;
        }
        else {
            return false;
        }
    }
    getMaxOpsSinceLastSummary() {
        // back-compat: maxOpsSinceLastSummary was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.maxOpsSinceLastSummary !== undefined) {
            return this.runtimeOptions.summaryOptions.maxOpsSinceLastSummary;
        }
        if (this.summaryConfiguration.state !== "disabled") {
            return this.summaryConfiguration.maxOpsSinceLastSummary;
        }
        else {
            return 0;
        }
    }
    getInitialSummarizerDelayMs() {
        // back-compat: initialSummarizerDelayMs was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.initialSummarizerDelayMs !== undefined) {
            return this.runtimeOptions.summaryOptions.initialSummarizerDelayMs;
        }
        if (this.summaryConfiguration.state !== "disabled") {
            return this.summaryConfiguration.initialSummarizerDelayMs;
        }
        else {
            return 0;
        }
    }
    dispose(error) {
        var _a;
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.logger.sendTelemetryEvent({
            eventName: "ContainerRuntimeDisposed",
            isDirty: this.isDirty,
            lastSequenceNumber: this.deltaManager.lastSequenceNumber,
            attachState: this.attachState,
        }, error);
        if (this.summaryManager !== undefined) {
            this.summaryManager.dispose();
        }
        this.garbageCollector.dispose();
        (_a = this._summarizer) === null || _a === void 0 ? void 0 : _a.dispose();
        this.dataStores.dispose();
        this.pendingStateManager.dispose();
        this.emit("dispose");
        this.removeAllListeners();
    }
    get IFluidTokenProvider() {
        var _a;
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.intelligence) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                intelligence: this.options.intelligence,
            };
        }
        return undefined;
    }
    /**
     * Notifies this object about the request made to the container.
     * @param request - Request made to the handler.
     */
    async request(request) {
        try {
            const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_32__.RequestParser.create(request);
            const id = parser.pathParts[0];
            if (id === "_summarizer" && parser.pathParts.length === 1) {
                if (this._summarizer !== undefined) {
                    return {
                        status: 200,
                        mimeType: "fluid/object",
                        value: this.summarizer,
                    };
                }
                return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);
            }
            if (this.requestHandler !== undefined) {
                return this.requestHandler(parser, this);
            }
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.exceptionToResponse)(error);
        }
    }
    /**
     * Resolves URI representing handle
     * @param request - Request made to the handler.
     */
    async resolveHandle(request) {
        try {
            const requestParser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_32__.RequestParser.create(request);
            const id = requestParser.pathParts[0];
            if (id === "_channels") {
                return this.resolveHandle(requestParser.createSubRequest(1));
            }
            if (id === _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.basePath && requestParser.isLeaf(2)) {
                const handle = await this.blobManager.getBlob(requestParser.pathParts[1]);
                if (handle) {
                    return {
                        status: 200,
                        mimeType: "fluid/object",
                        value: handle.get(),
                    };
                }
                else {
                    return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);
                }
            }
            else if (requestParser.pathParts.length > 0) {
                const dataStore = await this.getDataStoreFromRequest(id, request);
                const subRequest = requestParser.createSubRequest(1);
                // We always expect createSubRequest to include a leading slash, but asserting here to protect against
                // unintentionally modifying the url if that changes.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(subRequest.url.startsWith("/"), 0x126 /* "Expected createSubRequest url to include a leading slash" */);
                return dataStore.IFluidRouter.request(subRequest);
            }
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.exceptionToResponse)(error);
        }
    }
    internalId(maybeAlias) {
        var _a;
        return (_a = this.dataStores.aliases().get(maybeAlias)) !== null && _a !== void 0 ? _a : maybeAlias;
    }
    async getDataStoreFromRequest(id, request) {
        var _a, _b, _c;
        const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[RuntimeHeaders.wait]) === "boolean"
            ? (_b = request.headers) === null || _b === void 0 ? void 0 : _b[RuntimeHeaders.wait]
            : true;
        const internalId = this.internalId(id);
        const dataStoreContext = await this.dataStores.getDataStore(internalId, wait);
        /**
         * If GC should run and this an external app request with "externalRequest" header, we need to return
         * an error if the data store being requested is marked as unreferenced as per the data store's base
         * GC data.
         *
         * This is a workaround to handle scenarios where a data store shared with an external app is deleted
         * and marked as unreferenced by GC. Returning an error will fail to load the data store for the app.
         */
        if (((_c = request.headers) === null || _c === void 0 ? void 0 : _c[RuntimeHeaders.externalRequest]) && this.garbageCollector.shouldRunGC) {
            // The data store is referenced if used routes in the base summary has a route to self.
            // Older documents may not have used routes in the summary. They are considered referenced.
            const usedRoutes = (await dataStoreContext.getBaseGCDetails()).usedRoutes;
            if (!(usedRoutes === undefined || usedRoutes.includes("") || usedRoutes.includes("/"))) {
                throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.responseToException)((0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.create404Response)(request), request);
            }
        }
        const dataStoreChannel = await dataStoreContext.realize();
        // Remove query params, leading and trailing slashes from the url. This is done to make sure the format is
        // the same as GC nodes id.
        const urlWithoutQuery = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_34__.trimLeadingAndTrailingSlashes)(request.url.split("?")[0]);
        this.garbageCollector.nodeUpdated(`/${urlWithoutQuery}`, "Loaded", undefined /* timestampMs */, dataStoreContext.packagePath, request === null || request === void 0 ? void 0 : request.headers);
        return dataStoreChannel;
    }
    /** Adds the container's metadata to the given summary tree. */
    addMetadataToSummary(summaryTree) {
        var _a;
        const metadata = Object.assign(Object.assign(Object.assign(Object.assign({}, this.createContainerMetadata), { 
            // back-compat 0.59.3000: This is renamed to summaryNumber. Can be removed when 0.59.3000 saturates.
            summaryCount: this.nextSummaryNumber, 
            // Increment the summary number for the next summary that will be generated.
            summaryNumber: this.nextSummaryNumber++, summaryFormatVersion: 1, disableIsolatedChannels: this.disableIsolatedChannels || undefined }), this.garbageCollector.getMetadata()), { 
            // The last message processed at the time of summary. If there are no new messages, use the message from the
            // last summary.
            message: (_a = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.extractSummaryMetadataMessage)(this.deltaManager.lastMessage)) !== null && _a !== void 0 ? _a : this.messageAtLastSummary });
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.metadataBlobName, JSON.stringify(metadata));
    }
    addContainerStateToSummary(summaryTree, fullTree, trackState, telemetryContext) {
        var _a;
        this.addMetadataToSummary(summaryTree);
        if (this.chunkMap.size > 0) {
            const content = JSON.stringify([...this.chunkMap]);
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.chunksBlobName, content);
        }
        const dataStoreAliases = this.dataStores.aliases();
        if (dataStoreAliases.size > 0) {
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.aliasBlobName, JSON.stringify([...dataStoreAliases]));
        }
        if (this.summarizerClientElection) {
            const electedSummarizerContent = JSON.stringify((_a = this.summarizerClientElection) === null || _a === void 0 ? void 0 : _a.serialize());
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addBlobToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.electedSummarizerBlobName, electedSummarizerContent);
        }
        const blobManagerSummary = this.blobManager.summarize();
        // Some storage (like git) doesn't allow empty tree, so we can omit it.
        // and the blob manager can handle the tree not existing when loading
        if (Object.keys(blobManagerSummary.summary.tree).length > 0) {
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addTreeToSummary)(summaryTree, _summaryFormat__WEBPACK_IMPORTED_MODULE_31__.blobsTreeName, blobManagerSummary);
        }
        if (this.garbageCollector.writeDataAtRoot) {
            const gcSummary = this.garbageCollector.summarize(fullTree, trackState, telemetryContext);
            if (gcSummary !== undefined) {
                (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.addSummarizeResultToSummary)(summaryTree, _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.gcTreeKey, gcSummary);
            }
        }
    }
    // Track how many times the container tries to reconnect with pending messages.
    // This happens when the connection state is changed and we reset the counter
    // when we are able to process a local op or when there are no pending messages.
    // If this counter reaches a max, it's a good indicator that the container
    // is not making progress and it is stuck in a retry loop.
    shouldContinueReconnecting() {
        if (this.maxConsecutiveReconnects <= 0) {
            // Feature disabled, we never stop reconnecting
            return true;
        }
        if (!this.pendingStateManager.hasPendingMessages()) {
            // If there are no pending messages, we can always reconnect
            this.resetReconnectCount();
            return true;
        }
        if (this.consecutiveReconnects === Math.floor(this.maxConsecutiveReconnects / 2)) {
            // If we're halfway through the max reconnects, send an event in order
            // to better identify false positives, if any. If the rate of this event
            // matches Container Close count below, we can safely cut down
            // maxConsecutiveReconnects to half.
            this.mc.logger.sendTelemetryEvent({
                eventName: "ReconnectsWithNoProgress",
                attempts: this.consecutiveReconnects,
                pendingMessages: this.pendingStateManager.pendingMessagesCount,
            });
        }
        return this.consecutiveReconnects < this.maxConsecutiveReconnects;
    }
    resetReconnectCount() {
        this.consecutiveReconnects = 0;
    }
    replayPendingStates() {
        // We need to be able to send ops to replay states
        if (!this.canSendOps()) {
            return;
        }
        // We need to temporary clear the dirty flags and disable
        // dirty state change events to detect whether replaying ops
        // has any effect.
        // Save the old state, reset to false, disable event emit
        const oldState = this.dirtyContainer;
        this.dirtyContainer = false;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.emitDirtyDocumentEvent, 0x127 /* "dirty document event not set on replay" */);
        this.emitDirtyDocumentEvent = false;
        let newState;
        try {
            // replay the ops
            this.pendingStateManager.replayPendingStates();
        }
        finally {
            // Save the new start and restore the old state, re-enable event emit
            newState = this.dirtyContainer;
            this.dirtyContainer = oldState;
            this.emitDirtyDocumentEvent = true;
        }
        // Officially transition from the old state to the new state.
        this.updateDocumentDirtyState(newState);
    }
    async applyStashedOp(type, op) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                return this.dataStores.applyStashedOp(op);
            case ContainerMessageType.Attach:
                return this.dataStores.applyStashedAttachOp(op);
            case ContainerMessageType.Alias:
            case ContainerMessageType.BlobAttach:
                return;
            case ContainerMessageType.ChunkedOp:
                throw new Error("chunkedOp not expected here");
            case ContainerMessageType.Rejoin:
                throw new Error("rejoin not expected here");
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_36__.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);
        }
    }
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        // There might be no change of state due to Container calling this API after loading runtime.
        const changeOfState = this._connected !== connected;
        const reconnection = changeOfState && connected;
        this._connected = connected;
        if (!connected) {
            this._perfSignalData.signalsLost = 0;
            this._perfSignalData.signalTimestamp = 0;
            this._perfSignalData.trackingSignalSequenceNumber = undefined;
        }
        if (reconnection) {
            this.consecutiveReconnects++;
            if (!this.shouldContinueReconnecting()) {
                this.closeFn(
                // pre-0.58 error message: MaxReconnectsWithNoProgress
                _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataProcessingError.create("Runtime detected too many reconnects with no progress syncing local ops", "setConnectionState", undefined, {
                    dataLoss: 1,
                    attempts: this.consecutiveReconnects,
                    pendingMessages: this.pendingStateManager.pendingMessagesCount,
                }));
                return;
            }
        }
        if (changeOfState) {
            this.replayPendingStates();
        }
        this.dataStores.setConnectionState(connected, clientId);
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_37__.raiseConnectedEvent)(this.mc.logger, this, connected, clientId);
    }
    process(messageArg, local) {
        var _a, _b;
        this.verifyNotClosed();
        // If it's not message for runtime, bail out right away.
        if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.isUnpackedRuntimeMessage)(messageArg)) {
            return;
        }
        if ((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) {
            this.savedOps.push(messageArg);
        }
        // Do shallow copy of message, as methods below will modify it.
        // There might be multiple container instances receiving same message
        // We do not need to make deep copy, as each layer will just replace message.content itself,
        // but would not modify contents details
        let message = Object.assign({}, messageArg);
        // Surround the actual processing of the operation with messages to the schedule manager indicating
        // the beginning and end. This allows it to emit appropriate events and/or pause the processing of new
        // messages once a batch has been fully processed.
        this.scheduleManager.beforeOpProcessing(message);
        try {
            message = unpackRuntimeMessage(message);
            // Chunk processing must come first given that we will transform the message to the unchunked version
            // once all pieces are available
            message = this.processRemoteChunkedMessage(message);
            let localOpMetadata;
            if (local) {
                // Call the PendingStateManager to process local messages.
                // Do not process local chunked ops until all pieces are available.
                if (message.type !== ContainerMessageType.ChunkedOp) {
                    localOpMetadata = this.pendingStateManager.processPendingLocalMessage(message);
                }
            }
            // If there are no more pending messages after processing a local message,
            // the document is no longer dirty.
            if (!this.pendingStateManager.hasPendingMessages()) {
                this.updateDocumentDirtyState(false);
            }
            switch (message.type) {
                case ContainerMessageType.Attach:
                    this.dataStores.processAttachMessage(message, local);
                    break;
                case ContainerMessageType.Alias:
                    this.processAliasMessage(message, localOpMetadata, local);
                    break;
                case ContainerMessageType.FluidDataStoreOp:
                    this.dataStores.processFluidDataStoreOp(message, local, localOpMetadata);
                    break;
                case ContainerMessageType.BlobAttach:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)((_b = message === null || message === void 0 ? void 0 : message.metadata) === null || _b === void 0 ? void 0 : _b.blobId, 0x12a /* "Missing blob id on metadata" */);
                    this.blobManager.processBlobAttachOp(message.metadata.blobId, local);
                    break;
                default:
            }
            this.emit("op", message);
            this.scheduleManager.afterOpProcessing(undefined, message);
            if (local) {
                // If we have processed a local op, this means that the container is
                // making progress and we can reset the counter for how many times
                // we have consecutively replayed the pending states
                this.resetReconnectCount();
            }
        }
        catch (e) {
            this.scheduleManager.afterOpProcessing(e, message);
            throw e;
        }
    }
    processAliasMessage(message, localOpMetadata, local) {
        this.dataStores.processAliasMessage(message, localOpMetadata, local);
    }
    /**
     * Emits the Signal event and update the perf signal data.
     * @param clientSignalSequenceNumber - is the client signal sequence number to be uploaded.
     */
    sendSignalTelemetryEvent(clientSignalSequenceNumber) {
        const duration = Date.now() - this._perfSignalData.signalTimestamp;
        this.logger.sendPerformanceEvent({
            eventName: "SignalLatency",
            duration,
            signalsLost: this._perfSignalData.signalsLost,
        });
        this._perfSignalData.signalsLost = 0;
        this._perfSignalData.signalTimestamp = 0;
    }
    processSignal(message, local) {
        const envelope = message.content;
        const transformed = {
            clientId: message.clientId,
            content: envelope.contents.content,
            type: envelope.contents.type,
        };
        // Only collect signal telemetry for messages sent by the current client.
        if (message.clientId === this.clientId && this.connected) {
            // Check to see if the signal was lost.
            if (this._perfSignalData.trackingSignalSequenceNumber !== undefined &&
                envelope.clientSignalSequenceNumber > this._perfSignalData.trackingSignalSequenceNumber) {
                this._perfSignalData.signalsLost++;
                this._perfSignalData.trackingSignalSequenceNumber = undefined;
                this.logger.sendErrorEvent({
                    eventName: "SignalLost",
                    type: envelope.contents.type,
                    signalsLost: this._perfSignalData.signalsLost,
                    trackingSequenceNumber: this._perfSignalData.trackingSignalSequenceNumber,
                    clientSignalSequenceNumber: envelope.clientSignalSequenceNumber,
                });
            }
            else if (envelope.clientSignalSequenceNumber === this._perfSignalData.trackingSignalSequenceNumber) {
                this.sendSignalTelemetryEvent(envelope.clientSignalSequenceNumber);
                this._perfSignalData.trackingSignalSequenceNumber = undefined;
            }
        }
        if (envelope.address === undefined) {
            // No address indicates a container signal message.
            this.emit("signal", transformed, local);
            return;
        }
        this.dataStores.processSignal(envelope.address, transformed, local);
    }
    async getRootDataStore(id, wait = true) {
        const internalId = this.internalId(id);
        const context = await this.dataStores.getDataStore(internalId, wait);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(await context.isRoot(), 0x12b /* "did not get root data store" */);
        return context.realize();
    }
    setFlushMode(mode) {
        if (mode === this._flushMode) {
            return;
        }
        this.mc.logger.sendTelemetryEvent({
            eventName: "FlushMode Updated",
            old: this._flushMode,
            new: mode,
        });
        // Flush any pending batches if switching to immediate
        if (mode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.Immediate) {
            this.flush();
        }
        this._flushMode = mode;
        // Let the PendingStateManager know that FlushMode has been updated.
        this.pendingStateManager.onFlushModeUpdated(mode);
    }
    flush() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this._orderSequentiallyCalls === 0, 0x24c /* "Cannot call `flush()` from `orderSequentially`'s callback" */);
        if (!this.deltaSender) {
            return;
        }
        // Let the PendingStateManager know that there was an attempt to flush messages.
        // Note that this should happen before the `this.needsFlush` check below because in the scenario where we are
        // not connected, `this.needsFlush` will be false but the PendingStateManager might have pending messages and
        // hence needs to track this.
        this.pendingStateManager.onFlush();
        // If flush has already been called then exit early
        if (!this.needsFlush) {
            return;
        }
        this.needsFlush = false;
        // Did we disconnect in the middle of turn-based batch?
        // If so, do nothing, as pending state manager will resubmit it correctly on reconnect.
        if (!this.canSendOps()) {
            return;
        }
        return this.deltaSender.flush();
    }
    orderSequentially(callback) {
        // If flush mode is already TurnBased we are either
        // nested in another orderSequentially, or
        // the app is flushing manually, in which
        // case this invocation doesn't own
        // flushing.
        if (this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased) {
            this.trackOrderSequentiallyCalls(callback);
            return;
        }
        const savedFlushMode = this.flushMode;
        this.setFlushMode(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased);
        try {
            this.trackOrderSequentiallyCalls(callback);
            this.flush();
        }
        finally {
            this.setFlushMode(savedFlushMode);
        }
    }
    trackOrderSequentiallyCalls(callback) {
        let checkpoint;
        if (this.mc.config.getBoolean("Fluid.ContainerRuntime.EnableRollback")) {
            checkpoint = this.pendingStateManager.checkpoint();
        }
        try {
            this._orderSequentiallyCalls++;
            callback();
        }
        catch (error) {
            if (checkpoint) {
                // This will throw and close the container if rollback fails
                checkpoint.rollback();
            }
            else {
                // pre-0.58 error message: orderSequentiallyCallbackException
                this.closeFn(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.GenericError("orderSequentially callback exception", error));
            }
            throw error; // throw the original error for the consumer of the runtime
        }
        finally {
            this._orderSequentiallyCalls--;
        }
    }
    async createDataStore(pkg) {
        const internalId = (0,uuid__WEBPACK_IMPORTED_MODULE_38__["default"])();
        return (0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.channelToDataStore)(await this._createDataStore(pkg, false /* isRoot */, internalId), internalId, this, this.dataStores, this.mc.logger);
    }
    /**
     * Creates a root datastore directly with a user generated id and attaches it to storage.
     * It is vulnerable to name collisions and should not be used.
     *
     * This method will be removed. See #6465.
     */
    async createRootDataStoreLegacy(pkg, rootDataStoreId) {
        const fluidDataStore = await this._createDataStore(pkg, true /* isRoot */, rootDataStoreId);
        // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For
        // older versions, we still have to call bindToContext.
        if (fluidDataStore.makeVisibleAndAttachGraph !== undefined) {
            fluidDataStore.makeVisibleAndAttachGraph();
        }
        else {
            fluidDataStore.bindToContext();
        }
        return fluidDataStore;
    }
    /**
     * @deprecated - will be removed in an upcoming release. See #9660.
     */
    async createRootDataStore(pkg, rootDataStoreId) {
        if (rootDataStoreId.includes("/")) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Id cannot contain slashes: '${rootDataStoreId}'`);
        }
        return this._aliasingEnabled === true ?
            this.createAndAliasDataStore(pkg, rootDataStoreId) :
            this.createRootDataStoreLegacy(pkg, rootDataStoreId);
    }
    /**
     * Creates a data store then attempts to alias it.
     * If aliasing fails, it will raise an exception.
     *
     * This method will be removed. See #6465.
     *
     * @param pkg - Package name of the data store
     * @param alias - Alias to be assigned to the data store
     * @param props - Properties for the data store
     * @returns - An aliased data store which can can be found / loaded by alias.
     */
    async createAndAliasDataStore(pkg, alias, props) {
        const internalId = (0,uuid__WEBPACK_IMPORTED_MODULE_38__["default"])();
        const dataStore = await this._createDataStore(pkg, false /* isRoot */, internalId, props);
        const aliasedDataStore = (0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.channelToDataStore)(dataStore, internalId, this, this.dataStores, this.mc.logger);
        const result = await aliasedDataStore.trySetAlias(alias);
        if (result !== "Success") {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.GenericError("dataStoreAliasFailure", undefined /* error */, {
                alias: {
                    value: alias,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.UserData,
                },
                internalId: {
                    value: internalId,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.PackageData,
                },
                aliasResult: result,
            });
        }
        return aliasedDataStore;
    }
    createDetachedRootDataStore(pkg, rootDataStoreId) {
        if (rootDataStoreId.includes("/")) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError(`Id cannot contain slashes: '${rootDataStoreId}'`);
        }
        return this.dataStores.createDetachedDataStoreCore(pkg, true, rootDataStoreId);
    }
    createDetachedDataStore(pkg) {
        return this.dataStores.createDetachedDataStoreCore(pkg, false);
    }
    /**
     * Creates a possibly root datastore directly with a possibly user generated id and attaches it to storage.
     * It is vulnerable to name collisions if both aforementioned conditions are true, and should not be used.
     *
     * This method will be removed. See #6465.
     */
    async _createDataStoreWithPropsLegacy(pkg, props, id = (0,uuid__WEBPACK_IMPORTED_MODULE_38__["default"])(), isRoot = false) {
        const fluidDataStore = await this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props).realize();
        if (isRoot) {
            // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.
            // For older versions, we still have to call bindToContext.
            if (fluidDataStore.makeVisibleAndAttachGraph !== undefined) {
                fluidDataStore.makeVisibleAndAttachGraph();
            }
            else {
                fluidDataStore.bindToContext();
            }
            this.logger.sendTelemetryEvent({
                eventName: "Root datastore with props",
                hasProps: props !== undefined,
            });
        }
        return (0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.channelToDataStore)(fluidDataStore, id, this, this.dataStores, this.mc.logger);
    }
    async _createDataStoreWithProps(pkg, props, id = (0,uuid__WEBPACK_IMPORTED_MODULE_38__["default"])(), isRoot = false) {
        return this._aliasingEnabled === true && isRoot ?
            this.createAndAliasDataStore(pkg, id, props) :
            this._createDataStoreWithPropsLegacy(pkg, props, id, isRoot);
    }
    async _createDataStore(pkg, isRoot, id = (0,uuid__WEBPACK_IMPORTED_MODULE_38__["default"])(), props) {
        return this.dataStores
            ._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props)
            .realize();
    }
    canSendOps() {
        return this.connected && !this.deltaManager.readOnlyInfo.readonly;
    }
    getQuorum() {
        return this.context.quorum;
    }
    getAudience() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.context.audience;
    }
    /**
     * Returns true of container is dirty, i.e. there are some pending local changes that
     * either were not sent out to delta stream or were not yet acknowledged.
     */
    get isDirty() {
        return this.dirtyContainer;
    }
    isContainerMessageDirtyable(type, contents) {
        // For legacy purposes, exclude the old built-in AgentScheduler from dirty consideration as a special-case.
        // Ultimately we should have no special-cases from the ContainerRuntime's perspective.
        if (type === ContainerMessageType.Attach) {
            const attachMessage = contents;
            if (attachMessage.id === agentSchedulerId) {
                return false;
            }
        }
        else if (type === ContainerMessageType.FluidDataStoreOp) {
            const envelope = contents;
            if (envelope.address === agentSchedulerId) {
                return false;
            }
        }
        return true;
    }
    createNewSignalEnvelope(address, type, content) {
        const newSequenceNumber = ++this._perfSignalData.signalSequenceNumber;
        const newEnvelope = {
            address,
            clientSignalSequenceNumber: newSequenceNumber,
            contents: { type, content },
        };
        // We should not track any signals in case we already have a tracking number.
        if (newSequenceNumber % this.defaultTelemetrySignalSampleCount === 1 &&
            this._perfSignalData.trackingSignalSequenceNumber === undefined) {
            this._perfSignalData.signalTimestamp = Date.now();
            this._perfSignalData.trackingSignalSequenceNumber = newSequenceNumber;
        }
        return newEnvelope;
    }
    /**
     * Submits the signal to be sent to other clients.
     * @param type - Type of the signal.
     * @param content - Content of the signal.
     */
    submitSignal(type, content) {
        this.verifyNotClosed();
        const envelope = this.createNewSignalEnvelope(undefined /* address */, type, content);
        return this.context.submitSignalFn(envelope);
    }
    submitDataStoreSignal(address, type, content) {
        const envelope = this.createNewSignalEnvelope(address, type, content);
        return this.context.submitSignalFn(envelope);
    }
    setAttachState(attachState) {
        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attaching) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attaching, 0x12d /* "Container Context should already be in attaching state" */);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached, 0x12e /* "Container Context should already be in attached state" */);
            this.emit("attached");
        }
        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached && !this.pendingStateManager.hasPendingMessages()) {
            this.updateDocumentDirtyState(false);
        }
        this.dataStores.setAttachState(attachState);
    }
    /**
     * Create a summary. Used when attaching or serializing a detached container.
     *
     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported
     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the
     * new storage IDs so requests can be redirected.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    createSummary(blobRedirectTable, telemetryContext) {
        if (blobRedirectTable) {
            this.blobManager.setRedirectTable(blobRedirectTable);
        }
        const summarizeResult = this.dataStores.createSummary(telemetryContext);
        if (!this.disableIsolatedChannels) {
            // Wrap data store summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.wrapSummaryInChannelsTree)(summarizeResult);
        }
        this.addContainerStateToSummary(summarizeResult, true /* fullTree */, false /* trackState */, telemetryContext);
        return summarizeResult.summary;
    }
    async getAbsoluteUrl(relativeUrl) {
        if (this.context.getAbsoluteUrl === undefined) {
            throw new Error("Driver does not implement getAbsoluteUrl");
        }
        if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached) {
            return undefined;
        }
        return this.context.getAbsoluteUrl(relativeUrl);
    }
    async summarizeInternal(fullTree, trackState, telemetryContext) {
        const summarizeResult = await this.dataStores.summarize(fullTree, trackState, telemetryContext);
        let pathPartsForChildren;
        if (!this.disableIsolatedChannels) {
            // Wrap data store summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_31__.wrapSummaryInChannelsTree)(summarizeResult);
            pathPartsForChildren = [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.channelsTreeName];
        }
        this.addContainerStateToSummary(summarizeResult, fullTree, trackState, telemetryContext);
        return Object.assign(Object.assign({}, summarizeResult), { id: "", pathPartsForChildren });
    }
    /**
     * Returns a summary of the runtime at the current sequence number.
     */
    async summarize(options) {
        this.verifyNotClosed();
        const { fullTree = false, trackState = true, summaryLogger = this.mc.logger, runGC = this.garbageCollector.shouldRunGC, runSweep, fullGC, } = options;
        let gcStats;
        if (runGC) {
            gcStats = await this.collectGarbage({ logger: summaryLogger, runSweep, fullGC });
        }
        const telemetryContext = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.TelemetryContext();
        const { stats, summary } = await this.summarizerNode.summarize(fullTree, trackState, telemetryContext);
        this.logger.sendTelemetryEvent({ eventName: "SummarizeTelemetry", details: telemetryContext.serialize() });
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(summary.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__.SummaryType.Tree, 0x12f /* "Container Runtime's summarize should always return a tree" */);
        return { stats, summary, gcStats };
    }
    /**
     * Implementation of IGarbageCollectionRuntime::updateStateBeforeGC.
     * Before GC runs, called by the garbage collector to update any pending GC state. This is mainly used to notify
     * the garbage collector of references detected since the last GC run. Most references are notified immediately
     * but there can be some for which async operation is required (such as detecting new root data stores).
     */
    async updateStateBeforeGC() {
        return this.dataStores.updateStateBeforeGC();
    }
    /**
     * Implementation of IGarbageCollectionRuntime::getGCData.
     * Generates and returns the GC data for this container.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC) {
        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_34__.GCDataBuilder();
        const dsGCData = await this.dataStores.getGCData(fullGC);
        builder.addNodes(dsGCData.gcNodes);
        const blobsGCData = this.blobManager.getGCData(fullGC);
        builder.addNodes(blobsGCData.gcNodes);
        return builder.getGCData();
    }
    /**
     * Implementation of IGarbageCollectionRuntime::updateUsedRoutes.
     * After GC has run, called to notify this container's nodes of routes that are used in it.
     * @param usedRoutes - The routes that are used in all nodes in this Container.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes
     * unreferenced as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        // Update our summarizer node's used routes. Updating used routes in summarizer node before
        // summarizing is required and asserted by the the summarizer node. We are the root and are
        // always referenced, so the used routes is only self-route (empty string).
        this.summarizerNode.updateUsedRoutes([""]);
        const dataStoreUsedRoutes = [];
        for (const route of usedRoutes) {
            if (route.split("/")[1] !== _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.basePath) {
                dataStoreUsedRoutes.push(route);
            }
        }
        return this.dataStores.updateUsedRoutes(dataStoreUsedRoutes, gcTimestamp);
    }
    /**
     * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing
     * scenarios with accessing deleted content.
     * @param unusedRoutes - The routes that are unused in all data stores in this Container.
     */
    deleteUnusedRoutes(unusedRoutes) {
        const blobManagerUnusedRoutes = [];
        const dataStoreUnusedRoutes = [];
        for (const route of unusedRoutes) {
            if (this.isBlobPath(route)) {
                blobManagerUnusedRoutes.push(route);
            }
            else {
                dataStoreUnusedRoutes.push(route);
            }
        }
        this.blobManager.deleteUnusedRoutes(blobManagerUnusedRoutes);
        this.dataStores.deleteUnusedRoutes(dataStoreUnusedRoutes);
    }
    /**
     * Returns a server generated referenced timestamp to be used to track unreferenced nodes by GC.
     */
    getCurrentReferenceTimestampMs() {
        var _a, _b, _c;
        // Use the timestamp of the last message seen by this client as that is server generated. If no messages have
        // been processed, use the timestamp of the message from the last summary.
        return (_b = (_a = this.deltaManager.lastMessage) === null || _a === void 0 ? void 0 : _a.timestamp) !== null && _b !== void 0 ? _b : (_c = this.messageAtLastSummary) === null || _c === void 0 ? void 0 : _c.timestamp;
    }
    /**
     * Returns the type of the GC node. Currently, there are nodes that belong to the root ("/"), data stores or
     * blob manager.
     */
    getNodeType(nodePath) {
        var _a;
        if (this.isBlobPath(nodePath)) {
            return _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.Blob;
        }
        return (_a = this.dataStores.getGCNodeType(nodePath)) !== null && _a !== void 0 ? _a : _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.Other;
    }
    /**
     * Called by GC to retrieve the package path of the node with the given path. The node should belong to a
     * data store or an attachment blob.
     */
    async getGCNodePackagePath(nodePath) {
        switch (this.getNodeType(nodePath)) {
            case _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.Blob:
                return ["_blobs"];
            case _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.DataStore:
            case _garbageCollection__WEBPACK_IMPORTED_MODULE_14__.GCNodeType.SubDataStore:
                return this.dataStores.getDataStorePackagePath(nodePath);
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 0x2de /* "Package path requested for unsupported node type." */);
        }
    }
    /**
     * Returns whether a given path is for attachment blobs that are in the format - "/BlobManager.basePath/...".
     */
    isBlobPath(path) {
        const pathParts = path.split("/");
        if (pathParts.length < 2 || pathParts[1] !== _blobManager__WEBPACK_IMPORTED_MODULE_18__.BlobManager.basePath) {
            return false;
        }
        return true;
    }
    /**
     * Runs garbage collection and updates the reference / used state of the nodes in the container.
     * @returns the statistics of the garbage collection run.
     */
    async collectGarbage(options) {
        return this.garbageCollector.collectGarbage(options);
    }
    /**
     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify
     * all references added in the system.
     * @param srcHandle - The handle of the node that added the reference.
     * @param outboundHandle - The handle of the outbound node that is referenced.
     */
    addedGCOutboundReference(srcHandle, outboundHandle) {
        this.garbageCollector.addedOutboundReference(srcHandle.absolutePath, outboundHandle.absolutePath);
    }
    /**
     * Generates the summary tree, uploads it to storage, and then submits the summarize op.
     * This is intended to be called by the summarizer, since it is the implementation of
     * ISummarizerInternalsProvider.submitSummary.
     * It takes care of state management at the container level, including pausing inbound
     * op processing, updating SummarizerNode state tracking, and garbage collection.
     * @param options - options controlling how the summary is generated or submitted
     */
    async submitSummary(options) {
        var _a, _b, _c;
        const { fullTree, refreshLatestAck, summaryLogger } = options;
        // The summary number for this summary. This will be updated during the summary process, so get it now and
        // use it for all events logged during this summary.
        const summaryNumber = this.nextSummaryNumber;
        const summaryNumberLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(summaryLogger, undefined, {
            all: { summaryNumber },
        });
        let latestSnapshotVersionId;
        if (refreshLatestAck) {
            const latestSnapshotInfo = await this.refreshLatestSummaryAckFromServer(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(summaryNumberLogger, undefined, { all: { safeSummary: true } }));
            const latestSnapshotRefSeq = latestSnapshotInfo.latestSnapshotRefSeq;
            latestSnapshotVersionId = latestSnapshotInfo.latestSnapshotVersionId;
            if (latestSnapshotRefSeq > this.deltaManager.lastSequenceNumber) {
                // We need to catch up to the latest summary's reference sequence number before pausing.
                await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(summaryNumberLogger, {
                    eventName: "WaitingForSeq",
                    lastSequenceNumber: this.deltaManager.lastSequenceNumber,
                    targetSequenceNumber: latestSnapshotRefSeq,
                    lastKnownSeqNumber: this.deltaManager.lastKnownSeqNumber,
                }, async () => waitForSeq(this.deltaManager, latestSnapshotRefSeq), { start: true, end: true, cancel: "error" });
            }
        }
        try {
            await this.deltaManager.inbound.pause();
            const summaryRefSeqNum = this.deltaManager.lastSequenceNumber;
            const minimumSequenceNumber = this.deltaManager.minimumSequenceNumber;
            const message = `Summary @${summaryRefSeqNum}:${this.deltaManager.minimumSequenceNumber}`;
            // We should be here is we haven't processed be here. If we are of if the last message's sequence number
            // doesn't match the last processed sequence number, log an error.
            if (summaryRefSeqNum !== ((_a = this.deltaManager.lastMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber)) {
                summaryNumberLogger.sendErrorEvent({
                    eventName: "LastSequenceMismatch",
                    error: message,
                });
            }
            this.summarizerNode.startSummary(summaryRefSeqNum, summaryNumberLogger);
            // Helper function to check whether we should still continue between each async step.
            const checkContinue = () => {
                // Do not check for loss of connectivity directly! Instead leave it up to
                // RunWhileConnectedCoordinator to control policy in a single place.
                // This will allow easier change of design if we chose to. For example, we may chose to allow
                // summarizer to reconnect in the future.
                // Also checking for cancellation is a must as summary process may be abandoned for other reasons,
                // like loss of connectivity for main (interactive) client.
                if (options.cancellationToken.cancelled) {
                    return { continue: false, error: "disconnected" };
                }
                // That said, we rely on submitSystemMessage() that today only works in connected state.
                // So if we fail here, it either means that RunWhileConnectedCoordinator does not work correctly,
                // OR that design changed and we need to remove this check and fix submitSystemMessage.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected, 0x258 /* "connected" */);
                // Ensure that lastSequenceNumber has not changed after pausing.
                // We need the summary op's reference sequence number to match our summary sequence number,
                // otherwise we'll get the wrong sequence number stamped on the summary's .protocol attributes.
                if (this.deltaManager.lastSequenceNumber !== summaryRefSeqNum) {
                    return {
                        continue: false,
                        // eslint-disable-next-line max-len
                        error: `lastSequenceNumber changed before uploading to storage. ${this.deltaManager.lastSequenceNumber} !== ${summaryRefSeqNum}`,
                    };
                }
                return { continue: true };
            };
            let continueResult = checkContinue();
            if (!continueResult.continue) {
                return {
                    stage: "base",
                    referenceSequenceNumber: summaryRefSeqNum,
                    minimumSequenceNumber,
                    error: continueResult.error,
                };
            }
            const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_41__.Trace.start();
            let summarizeResult;
            // If the GC state needs to be reset, we need to force a full tree summary and update the unreferenced
            // state of all the nodes.
            const forcedFullTree = this.garbageCollector.summaryStateNeedsReset;
            try {
                summarizeResult = await this.summarize({
                    fullTree: fullTree || forcedFullTree,
                    trackState: true,
                    summaryLogger: summaryNumberLogger,
                    runGC: this.garbageCollector.shouldRunGC,
                });
            }
            catch (error) {
                return {
                    stage: "base",
                    referenceSequenceNumber: summaryRefSeqNum,
                    minimumSequenceNumber,
                    error,
                };
            }
            const { summary: summaryTree, stats: partialStats } = summarizeResult;
            // Now that we have generated the summary, update the message at last summary to the last message processed.
            this.messageAtLastSummary = this.deltaManager.lastMessage;
            // Counting dataStores and handles
            // Because handles are unchanged dataStores in the current logic,
            // summarized dataStore count is total dataStore count minus handle count
            const dataStoreTree = this.disableIsolatedChannels ? summaryTree : summaryTree.tree[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.channelsTreeName];
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(dataStoreTree.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__.SummaryType.Tree, 0x1fc /* "summary is not a tree" */);
            const handleCount = Object.values(dataStoreTree.tree).filter((value) => value.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_40__.SummaryType.Handle).length;
            const gcSummaryTreeStats = summaryTree.tree[_garbageCollection__WEBPACK_IMPORTED_MODULE_14__.gcTreeKey]
                ? (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_35__.calculateStats)(summaryTree.tree[_garbageCollection__WEBPACK_IMPORTED_MODULE_14__.gcTreeKey])
                : undefined;
            const summaryStats = Object.assign({ dataStoreCount: this.dataStores.size, summarizedDataStoreCount: this.dataStores.size - handleCount, gcStateUpdatedDataStoreCount: (_b = summarizeResult.gcStats) === null || _b === void 0 ? void 0 : _b.updatedDataStoreCount, gcBlobNodeCount: gcSummaryTreeStats === null || gcSummaryTreeStats === void 0 ? void 0 : gcSummaryTreeStats.blobNodeCount, gcTotalBlobsSize: gcSummaryTreeStats === null || gcSummaryTreeStats === void 0 ? void 0 : gcSummaryTreeStats.totalBlobSize, opsSizesSinceLastSummary: this.opTracker.opsSizeAccumulator, nonSystemOpsSinceLastSummary: this.opTracker.nonSystemOpCount, summaryNumber }, partialStats);
            const generateSummaryData = {
                referenceSequenceNumber: summaryRefSeqNum,
                minimumSequenceNumber,
                summaryTree,
                summaryStats,
                generateDuration: trace.trace().duration,
                forcedFullTree,
            };
            continueResult = checkContinue();
            if (!continueResult.continue) {
                return Object.assign(Object.assign({ stage: "generate" }, generateSummaryData), { error: continueResult.error });
            }
            // It may happen that the lastAck it not correct due to missing summaryAck in case of single commit
            // summary. So if the previous summarizer closes just after submitting the summary and before
            // submitting the summaryOp then we can't rely on summaryAck. So in case we have
            // latestSnapshotVersionId from storage and it does not match with the lastAck ackHandle, then use
            // the one fetched from storage as parent as that is the latest.
            const lastAck = this.summaryCollection.latestAck;
            let summaryContext;
            if ((lastAck === null || lastAck === void 0 ? void 0 : lastAck.summaryAck.contents.handle) !== latestSnapshotVersionId
                && latestSnapshotVersionId !== undefined) {
                summaryContext = {
                    proposalHandle: undefined,
                    ackHandle: latestSnapshotVersionId,
                    referenceSequenceNumber: summaryRefSeqNum,
                };
            }
            else if (lastAck === undefined) {
                summaryContext = {
                    proposalHandle: undefined,
                    ackHandle: (_c = this.context.getLoadedFromVersion()) === null || _c === void 0 ? void 0 : _c.id,
                    referenceSequenceNumber: summaryRefSeqNum,
                };
            }
            else {
                summaryContext = {
                    proposalHandle: lastAck.summaryOp.contents.handle,
                    ackHandle: lastAck.summaryAck.contents.handle,
                    referenceSequenceNumber: summaryRefSeqNum,
                };
            }
            let handle;
            try {
                handle = await this.storage.uploadSummaryWithContext(summarizeResult.summary, summaryContext);
            }
            catch (error) {
                return Object.assign(Object.assign({ stage: "generate" }, generateSummaryData), { error });
            }
            const parent = summaryContext.ackHandle;
            const summaryMessage = {
                handle,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                head: parent,
                message,
                parents: parent ? [parent] : [],
            };
            const uploadData = Object.assign(Object.assign({}, generateSummaryData), { handle, uploadDuration: trace.trace().duration });
            continueResult = checkContinue();
            if (!continueResult.continue) {
                return Object.assign(Object.assign({ stage: "upload" }, uploadData), { error: continueResult.error });
            }
            let clientSequenceNumber;
            try {
                clientSequenceNumber = this.submitSystemMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.Summarize, summaryMessage);
            }
            catch (error) {
                return Object.assign(Object.assign({ stage: "upload" }, uploadData), { error });
            }
            const submitData = Object.assign(Object.assign({ stage: "submit" }, uploadData), { clientSequenceNumber, submitOpDuration: trace.trace().duration });
            this.summarizerNode.completeSummary(handle);
            this.opTracker.reset();
            return submitData;
        }
        finally {
            // Cleanup wip summary in case of failure
            this.summarizerNode.clearSummary();
            // Restart the delta manager
            this.deltaManager.inbound.resume();
        }
    }
    processRemoteChunkedMessage(message) {
        if (message.type !== ContainerMessageType.ChunkedOp) {
            return message;
        }
        const clientId = message.clientId;
        const chunkedContent = message.contents;
        this.addChunk(clientId, chunkedContent);
        if (chunkedContent.chunkId === chunkedContent.totalChunks) {
            const newMessage = Object.assign({}, message);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const serializedContent = this.chunkMap.get(clientId).join("");
            newMessage.contents = JSON.parse(serializedContent);
            newMessage.type = chunkedContent.originalType;
            this.clearPartialChunks(clientId);
            return newMessage;
        }
        return message;
    }
    addChunk(clientId, chunkedContent) {
        let map = this.chunkMap.get(clientId);
        if (map === undefined) {
            map = [];
            this.chunkMap.set(clientId, map);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(chunkedContent.chunkId === map.length + 1, 0x131 /* "Mismatch between new chunkId and expected chunkMap" */); // 1-based indexing
        map.push(chunkedContent.contents);
    }
    clearPartialChunks(clientId) {
        if (this.chunkMap.has(clientId)) {
            this.chunkMap.delete(clientId);
        }
    }
    updateDocumentDirtyState(dirty) {
        if (this.dirtyContainer === dirty) {
            return;
        }
        this.dirtyContainer = dirty;
        if (this.emitDirtyDocumentEvent) {
            this.emit(dirty ? "dirty" : "saved");
            this.context.updateDirtyContainerState(dirty);
        }
    }
    submitDataStoreOp(id, contents, localOpMetadata = undefined) {
        const envelope = {
            address: id,
            contents,
        };
        this.submit(ContainerMessageType.FluidDataStoreOp, envelope, localOpMetadata);
    }
    submitDataStoreAliasOp(contents, localOpMetadata) {
        const aliasMessage = contents;
        if (!(0,_dataStore__WEBPACK_IMPORTED_MODULE_39__.isDataStoreAliasMessage)(aliasMessage)) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError("malformedDataStoreAliasMessage");
        }
        this.submit(ContainerMessageType.Alias, contents, localOpMetadata);
    }
    async uploadBlob(blob) {
        this.verifyNotClosed();
        return this.blobManager.createBlob(blob);
    }
    submit(type, content, localOpMetadata = undefined, opMetadata = undefined) {
        this.verifyNotClosed();
        // There should be no ops in detached container state!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Detached, 0x132 /* "sending ops in detached container" */);
        let clientSequenceNumber = -1;
        let opMetadataInternal = opMetadata;
        if (this.canSendOps()) {
            const serializedContent = JSON.stringify(content);
            const maxOpSize = this.context.deltaManager.maxMessageSize;
            // If in TurnBased flush mode we will trigger a flush at the next turn break
            if (this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased && !this.needsFlush) {
                opMetadataInternal = Object.assign(Object.assign({}, opMetadata), { batch: true });
                this.needsFlush = true;
                // Use Promise.resolve().then() to queue a microtask to detect the end of the turn and force a flush.
                if (!this.flushTrigger) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Promise.resolve().then(() => {
                        this.flushTrigger = false;
                        this.flush();
                    });
                }
            }
            clientSequenceNumber = this.submitMaybeChunkedMessages(type, content, serializedContent, maxOpSize, this._flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased, opMetadataInternal);
        }
        // Let the PendingStateManager know that a message was submitted.
        this.pendingStateManager.onSubmitMessage(type, clientSequenceNumber, this.deltaManager.lastSequenceNumber, content, localOpMetadata, opMetadataInternal);
        if (this.isContainerMessageDirtyable(type, content)) {
            this.updateDocumentDirtyState(true);
        }
    }
    submitMaybeChunkedMessages(type, content, serializedContent, serverMaxOpSize, batch, opMetadataInternal = undefined) {
        if (this._maxOpSizeInBytes >= 0) {
            // Chunking disabled
            if (!serializedContent || serializedContent.length <= this._maxOpSizeInBytes) {
                return this.submitRuntimeMessage(type, content, batch, opMetadataInternal);
            }
            // When chunking is disabled, we ignore the server max message size
            // and if the content length is larger than the client configured message size
            // instead of splitting the content, we will fail by explicitly close the container
            this.closeFn(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.GenericError("OpTooLarge", 
            /* error */ undefined, {
                length: {
                    value: serializedContent.length,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.PackageData,
                },
                limit: {
                    value: this._maxOpSizeInBytes,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.TelemetryDataTag.PackageData,
                },
            }));
            return -1;
        }
        // Chunking enabled, fallback on the server's max message size
        // and split the content accordingly
        if (!serializedContent || serializedContent.length <= serverMaxOpSize) {
            return this.submitRuntimeMessage(type, content, batch, opMetadataInternal);
        }
        return this.submitChunkedMessage(type, serializedContent, serverMaxOpSize);
    }
    submitChunkedMessage(type, content, maxOpSize) {
        const contentLength = content.length;
        const chunkN = Math.floor((contentLength - 1) / maxOpSize) + 1;
        let offset = 0;
        let clientSequenceNumber = 0;
        for (let i = 1; i <= chunkN; i = i + 1) {
            const chunkedOp = {
                chunkId: i,
                contents: content.substr(offset, maxOpSize),
                originalType: type,
                totalChunks: chunkN,
            };
            offset += maxOpSize;
            clientSequenceNumber = this.submitRuntimeMessage(ContainerMessageType.ChunkedOp, chunkedOp, false);
        }
        return clientSequenceNumber;
    }
    submitSystemMessage(type, contents) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected, 0x133 /* "Container disconnected when trying to submit system message" */);
        // System message should not be sent in the middle of the batch.
        // That said, we can preserve existing behavior by not flushing existing buffer.
        // That might be not what caller hopes to get, but we can look deeper if telemetry tells us it's a problem.
        const middleOfBatch = this.flushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_0__.FlushMode.TurnBased && this.needsFlush;
        if (middleOfBatch) {
            this.mc.logger.sendErrorEvent({ eventName: "submitSystemMessageError", type });
        }
        return this.context.submitFn(type, contents, middleOfBatch);
    }
    submitRuntimeMessage(type, contents, batch, appData) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected, 0x259 /* "Container disconnected when trying to submit system message" */);
        const payload = { type, contents };
        return this.context.submitFn(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.Operation, payload, batch, appData);
    }
    /**
     * Throw an error if the runtime is closed.  Methods that are expected to potentially
     * be called after dispose due to asynchrony should not call this.
     */
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Runtime is closed");
        }
    }
    /**
     * Finds the right store and asks it to resubmit the message. This typically happens when we
     * reconnect and there are pending messages.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(type, content, localOpMetadata, opMetadata) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                // For Operations, call resubmitDataStoreOp which will find the right store
                // and trigger resubmission on it.
                this.dataStores.resubmitDataStoreOp(content, localOpMetadata);
                break;
            case ContainerMessageType.Attach:
            case ContainerMessageType.Alias:
                this.submit(type, content, localOpMetadata);
                break;
            case ContainerMessageType.ChunkedOp:
                throw new Error(`chunkedOp not expected here`);
            case ContainerMessageType.BlobAttach:
                this.submit(type, content, localOpMetadata, opMetadata);
                break;
            case ContainerMessageType.Rejoin:
                this.submit(type, content);
                break;
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_36__.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);
        }
    }
    rollback(type, content, localOpMetadata) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                // For operations, call rollbackDataStoreOp which will find the right store
                // and trigger rollback on it.
                this.dataStores.rollbackDataStoreOp(content, localOpMetadata);
                break;
            default:
                throw new Error(`Can't rollback ${type}`);
        }
    }
    /** Implementation of ISummarizerInternalsProvider.refreshLatestSummaryAck */
    async refreshLatestSummaryAck(proposalHandle, ackHandle, summaryRefSeq, summaryLogger) {
        const readAndParseBlob = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(this.storage, id);
        const { snapshotTree } = await this.fetchSnapshotFromStorage(ackHandle, summaryLogger, {
            eventName: "RefreshLatestSummaryGetSnapshot",
            ackHandle,
            summaryRefSeq,
            fetchLatest: false,
        });
        const result = await this.summarizerNode.refreshLatestSummary(proposalHandle, summaryRefSeq, async () => snapshotTree, readAndParseBlob, summaryLogger);
        // Notify the garbage collector so it can update its latest summary state.
        await this.garbageCollector.latestSummaryStateRefreshed(result, readAndParseBlob);
    }
    /**
     * Fetches the latest snapshot from storage and uses it to refresh SummarizerNode's
     * internal state as it should be considered the latest summary ack.
     * @param summaryLogger - logger to use when fetching snapshot from storage
     * @returns downloaded snapshot's reference sequence number
     */
    async refreshLatestSummaryAckFromServer(summaryLogger) {
        const { snapshotTree, versionId } = await this.fetchSnapshotFromStorage(null, summaryLogger, {
            eventName: "RefreshLatestSummaryGetSnapshot",
            fetchLatest: true,
        });
        const readAndParseBlob = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.readAndParse)(this.storage, id);
        const latestSnapshotRefSeq = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_42__.seqFromTree)(snapshotTree, readAndParseBlob);
        const result = await this.summarizerNode.refreshLatestSummary(undefined, latestSnapshotRefSeq, async () => snapshotTree, readAndParseBlob, summaryLogger);
        // Notify the garbage collector so it can update its latest summary state.
        await this.garbageCollector.latestSummaryStateRefreshed(result, readAndParseBlob);
        return { latestSnapshotRefSeq, latestSnapshotVersionId: versionId };
    }
    async fetchSnapshotFromStorage(versionId, logger, event) {
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(logger, event, async (perfEvent) => {
            const stats = {};
            const trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_41__.Trace.start();
            const versions = await this.storage.getVersions(versionId, 1);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!versions && !!versions[0], 0x137 /* "Failed to get version from storage" */);
            stats.getVersionDuration = trace.trace().duration;
            const maybeSnapshot = await this.storage.getSnapshotTree(versions[0]);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!maybeSnapshot, 0x138 /* "Failed to get snapshot from storage" */);
            stats.getSnapshotDuration = trace.trace().duration;
            perfEvent.end(stats);
            return { snapshotTree: maybeSnapshot, versionId: versions[0].id };
        });
    }
    notifyAttaching(snapshot) {
        var _a;
        if ((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) {
            this.baseSnapshotBlobs = _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__.SerializedSnapshotStorage.serializeTreeWithBlobContents(snapshot);
        }
    }
    async getSnapshotBlobs() {
        var _a;
        if (!((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) ||
            this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.AttachState.Attached || this.context.pendingLocalState) {
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.context.baseSnapshot, 0x2e5 /* "Must have a base snapshot" */);
        this.baseSnapshotBlobs = await _serializedSnapshotStorage__WEBPACK_IMPORTED_MODULE_29__.SerializedSnapshotStorage.serializeTree(this.context.baseSnapshot, this.storage);
    }
    getPendingLocalState() {
        var _a;
        if (!((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad)) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError("can't get state when offline load disabled");
        }
        const previousPendingState = this.context.pendingLocalState;
        if (previousPendingState) {
            return {
                pending: this.pendingStateManager.getLocalState(),
                snapshotBlobs: previousPendingState.snapshotBlobs,
                baseSnapshot: previousPendingState.baseSnapshot,
                savedOps: this.savedOps,
            };
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.context.baseSnapshot, 0x2e6 /* "Must have a base snapshot" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.baseSnapshotBlobs, 0x2e7 /* "Must serialize base snapshot blobs before getting runtime state" */);
        return {
            pending: this.pendingStateManager.getLocalState(),
            snapshotBlobs: this.baseSnapshotBlobs,
            baseSnapshot: this.context.baseSnapshot,
            savedOps: this.savedOps,
        };
    }
    /**
     * * Forms a function that will request a Summarizer.
     * @param loaderRouter - the loader acting as an IFluidRouter
     * */
    formRequestSummarizerFn(loaderRouter) {
        return async () => {
            const request = {
                headers: {
                    [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__.LoaderHeader.cache]: false,
                    [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__.LoaderHeader.clientDetails]: {
                        capabilities: { interactive: false },
                        type: _summarizerClientElection__WEBPACK_IMPORTED_MODULE_11__.summarizerClientType,
                    },
                    [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_44__.DriverHeader.summarizingClient]: true,
                    [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_43__.LoaderHeader.reconnect]: false,
                },
                url: "/_summarizer",
            };
            const fluidObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_33__.requestFluidObject)(loaderRouter, request);
            const summarizer = fluidObject.ISummarizer;
            if (!summarizer) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.UsageError("Fluid object does not implement ISummarizer");
            }
            return summarizer;
        };
    }
    async processSavedOps(state) {
        for (const op of state.savedOps) {
            this.process(op, false);
            await this.pendingStateManager.applyStashedOpsAt(op.sequenceNumber);
        }
        // we may not have seen every sequence number (because of system ops) so apply everything once we
        // don't have any more saved ops
        await this.pendingStateManager.applyStashedOpsAt();
    }
}
/**
 * Wait for a specific sequence number. Promise should resolve when we reach that number,
 * or reject if closed.
 */
const waitForSeq = async (deltaManager, targetSeq) => new Promise((resolve, reject) => {
    // TODO: remove cast to any when actual event is determined
    deltaManager.on("closed", reject);
    const handleOp = (message) => {
        if (message.sequenceNumber >= targetSeq) {
            resolve();
            deltaManager.off("op", handleOp);
        }
    };
    deltaManager.on("op", handleOp);
});
//# sourceMappingURL=containerRuntime.js.map

/***/ }),
/* 55 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(56), exports);
__exportStar(__webpack_require__(57), exports);
__exportStar(__webpack_require__(58), exports);
__exportStar(__webpack_require__(59), exports);
__exportStar(__webpack_require__(60), exports);
__exportStar(__webpack_require__(61), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IFluidDataStoreFactory = void 0;
exports.IFluidDataStoreFactory = "IFluidDataStoreFactory";
//# sourceMappingURL=dataStoreFactory.js.map

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IFluidDataStoreRegistry = void 0;
exports.IFluidDataStoreRegistry = "IFluidDataStoreRegistry";
//# sourceMappingURL=dataStoreRegistry.js.map

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VisibilityState = exports.FlushMode = void 0;
/**
 * Runtime flush mode handling
 */
var FlushMode;
(function (FlushMode) {
    /**
     * In Immediate flush mode the runtime will immediately send all operations to the driver layer.
     */
    FlushMode[FlushMode["Immediate"] = 0] = "Immediate";
    /**
     * When in TurnBased flush mode the runtime will buffer operations in the current turn and send them as a single
     * batch at the end of the turn. The flush call on the runtime can be used to force send the current batch.
     */
    FlushMode[FlushMode["TurnBased"] = 1] = "TurnBased";
})(FlushMode = exports.FlushMode || (exports.FlushMode = {}));
/**
 * This tells the visibility state of a Fluid object. It basically tracks whether the object is not visible, visible
 * locally within the container only or visible globally to all clients.
 */
exports.VisibilityState = {
    /** Indicates that the object is not visible. This is the state when an object is first created. */
    NotVisible: "NotVisible",
    /**
     * Indicates that the object is visible locally within the container. This is the state when an object is attached
     * to the container's graph but the container itself isn't globally visible. The object's state goes from not
     * visible to locally visible.
     */
    LocallyVisible: "LocallyVisible",
    /**
     * Indicates that the object is visible globally to all clients. This is the state of an object in 2 scenarios:
     * 1. It is attached to the container's graph when the container is globally visible. The object's state goes from
     *    not visible to globally visible.
     * 2. When a container becomes globally visible, all locally visible objects go from locally visible to globally
     *    visible.
     */
    GloballyVisible: "GloballyVisible",
};
//# sourceMappingURL=dataStoreContext.js.map

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gcBlobKey = void 0;
// The key to use for storing garbage collection blob in summary.
exports.gcBlobKey = "gc";
//# sourceMappingURL=garbageCollection.js.map

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.totalBlobSizePropertyName = exports.blobCountPropertyName = exports.channelsTreeName = exports.CreateSummarizerNodeSource = void 0;
var CreateSummarizerNodeSource;
(function (CreateSummarizerNodeSource) {
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["FromSummary"] = 0] = "FromSummary";
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["FromAttach"] = 1] = "FromAttach";
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["Local"] = 2] = "Local";
})(CreateSummarizerNodeSource = exports.CreateSummarizerNodeSource || (exports.CreateSummarizerNodeSource = {}));
exports.channelsTreeName = ".channels";
exports.blobCountPropertyName = "BlobCount";
exports.totalBlobSizePropertyName = "TotalBlobSize";
//# sourceMappingURL=summary.js.map

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isClientMessage": () => (/* binding */ isClientMessage),
/* harmony export */   "isRuntimeMessage": () => (/* binding */ isRuntimeMessage),
/* harmony export */   "isUnpackedRuntimeMessage": () => (/* binding */ isUnpackedRuntimeMessage)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 *
 * @param message-message
 * @returns whether or not the message type is one listed below
 * "op"
 * "summarize"
 * "propose"
 * "reject"
 * "noop"
 */
function isClientMessage(message) {
    if (isRuntimeMessage(message)) {
        return true;
    }
    switch (message.type) {
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp:
            return true;
        default:
            return false;
    }
}
/**
 *
 * @param message-message
 * @returns whether or not the message type is one listed below
 * "op"
 * "summarize"
 */
function isRuntimeMessage(message) {
    return message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Operation || message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Summarize;
}
var RuntimeMessage;
(function (RuntimeMessage) {
    RuntimeMessage["FluidDataStoreOp"] = "component";
    RuntimeMessage["Attach"] = "attach";
    RuntimeMessage["ChunkedOp"] = "chunkedOp";
    RuntimeMessage["BlobAttach"] = "blobAttach";
    RuntimeMessage["Rejoin"] = "rejoin";
    RuntimeMessage["Alias"] = "alias";
    RuntimeMessage["Operation"] = "op";
})(RuntimeMessage || (RuntimeMessage = {}));
/**
 *
 * @param message-message
 * @returns whether or not the message type is one listed below (legacy)
 * "component"
 * "attach"
 * "chunkedOp"
 * "blobAttach"
 * "rejoin"
 * "alias"
 * "op"
 */
function isUnpackedRuntimeMessage(message) {
    if (Object.values(RuntimeMessage).includes(message.type)) {
        return true;
    }
    return false;
}
//# sourceMappingURL=messageRecognition.js.map

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "performance": () => (/* binding */ performance)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const performance = window.performance;
//# sourceMappingURL=performanceBrowser.js.map

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReportOpPerfTelemetry": () => (/* binding */ ReportOpPerfTelemetry),
/* harmony export */   "latencyThreshold": () => (/* binding */ latencyThreshold)
/* harmony export */ });
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * We report various latency-related errors when waiting for op roundtrip takes longer than that amout of time.
 */
const latencyThreshold = 5000;
class OpPerfTelemetry {
    constructor(clientId, deltaManager, logger) {
        this.clientId = clientId;
        this.deltaManager = deltaManager;
        this.pongCount = 0;
        this.msnTrackingTimestamp = 0;
        this.opProcessingTimes = {};
        // Performance Data to be reported for ops round trips and processing.
        this.opPerfData = {};
        this.firstConnection = true;
        this.bootTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        this.connectionStartTime = 0;
        this.gap = 0;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, "OpPerf");
        this.deltaManager.on("pong", (latency) => this.recordPingTime(latency));
        this.deltaManager.on("submitOp", (message) => this.beforeOpSubmit(message));
        this.deltaManager.on("op", (message) => this.afterProcessingOp(message));
        this.deltaManager.on("connect", (details, opsBehind) => {
            this.clientId = details.clientId;
            if (opsBehind !== undefined) {
                this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;
                this.gap = opsBehind;
                this.connectionStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
                // We might be already up-today. If so, report it right away.
                if (this.gap <= 0) {
                    this.reportGettingUpToDate();
                }
            }
        });
        this.deltaManager.on("disconnect", () => {
            this.sequenceNumberForMsnTracking = undefined;
            this.clientSequenceNumberForLatencyStatistics = undefined;
            this.opProcessingTimes = {};
            this.opPerfData = {};
            this.connectionOpSeqNumber = undefined;
            this.firstConnection = false;
            this.pongCount = 0;
        });
        this.deltaManager.outbound.on("push", (messages) => {
            for (const msg of messages) {
                if (msg.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Operation &&
                    this.clientSequenceNumberForLatencyStatistics === msg.clientSequenceNumber) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2c8 /* "outboundPushEventTime should be undefined" */);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opPerfData.durationNetwork === undefined, 0x2c9 /* "durationNetwork should be undefined" */);
                    this.opProcessingTimes.outboundPushEventTime = Date.now();
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opPerfData.durationOutboundBatching === undefined, 0x2ca /* "durationOutboundBatching should be undefined" */);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.submitOpEventTime !== undefined, 0x2cb /* "submitOpEventTime should be undefined" */);
                    this.opPerfData.durationOutboundBatching = this.opProcessingTimes.outboundPushEventTime
                        - this.opProcessingTimes.submitOpEventTime;
                }
            }
        });
        this.deltaManager.inbound.on("push", (message) => {
            if (this.clientId === message.clientId &&
                message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Operation &&
                this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber &&
                this.opProcessingTimes.outboundPushEventTime !== undefined) {
                this.opProcessingTimes.inboundPushEventTime = Date.now();
                this.opPerfData.durationNetwork = this.opProcessingTimes.inboundPushEventTime
                    - this.opProcessingTimes.outboundPushEventTime;
                this.opProcessingTimes.outboundPushEventTime = undefined;
                this.opPerfData.lengthInboundQueue = this.deltaManager.inbound.length;
            }
        });
        this.deltaManager.inbound.on("idle", (count, duration) => {
            // Do not want to log zero for sure.
            // We are more interested in aggregates, so logging only if we are processing some number of ops
            // Cut-off is arbitrary - can be increased or decreased based on amount of data collected and questions we
            // want to get answered
            // back-compat: Once 0.36 loader version saturates (count & duration args were added there),
            // we can remove typeof check.
            if (typeof count === "number" && count >= 100) {
                this.logger.sendPerformanceEvent({
                    eventName: "GetDeltas_OpProcessing",
                    count,
                    duration,
                });
            }
        });
    }
    reportGettingUpToDate() {
        this.connectionOpSeqNumber = undefined;
        this.logger.sendPerformanceEvent({
            eventName: "ConnectionSpeed",
            duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - this.connectionStartTime,
            ops: this.gap,
            // track time to connect only for first connection.
            timeToConnect: this.firstConnection ?
                _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) :
                undefined,
            firstConnection: this.firstConnection,
        });
    }
    recordPingTime(latency) {
        this.pingLatency = latency;
        // logging one in every 1000 pongs, including the first time, if it is a "write" client.
        if (this.pongCount % 100 === 0 && this.deltaManager.active) {
            this.logger.sendPerformanceEvent({
                eventName: "DeltaLatency",
                duration: latency,
            });
        }
        this.pongCount++;
    }
    beforeOpSubmit(message) {
        // start with first client op and measure latency every 500 client ops
        if (this.clientSequenceNumberForLatencyStatistics === undefined &&
            message.clientSequenceNumber % 500 === 1) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2cc /* "OpTimeSittingInboundQueue should be undefined" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opPerfData.durationNetwork === undefined, 0x2cd /* "durationNetwork should be undefined" */);
            this.opProcessingTimes.submitOpEventTime = Date.now();
            this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;
        }
    }
    afterProcessingOp(message) {
        const sequenceNumber = message.sequenceNumber;
        if (sequenceNumber === this.connectionOpSeqNumber) {
            this.reportGettingUpToDate();
        }
        // Record collab window max size after every 1000th op.
        if (this.sequenceNumberForMsnTracking === undefined && sequenceNumber % 1000 === 0) {
            this.sequenceNumberForMsnTracking = sequenceNumber;
            this.msnTrackingTimestamp = message.timestamp;
        }
        if (this.sequenceNumberForMsnTracking !== undefined &&
            message.minimumSequenceNumber >= this.sequenceNumberForMsnTracking) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.msnTrackingTimestamp !== undefined, 0x2ce /* "msnTrackingTimestamp should not be undefined" */);
            this.logger.sendPerformanceEvent({
                eventName: "MsnStatistics",
                sequenceNumber,
                msnDistance: sequenceNumber - this.sequenceNumberForMsnTracking,
                duration: message.timestamp - this.msnTrackingTimestamp,
            });
            this.sequenceNumberForMsnTracking = undefined;
        }
        if (this.clientId === message.clientId &&
            this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.opProcessingTimes.submitOpEventTime !== undefined, 0x120 /* "Undefined latency statistics (op send time)" */);
            const currentTime = Date.now();
            if (this.opProcessingTimes.inboundPushEventTime !== undefined) {
                this.opPerfData.durationInboundToProcessing = currentTime
                    - this.opProcessingTimes.inboundPushEventTime;
            }
            const duration = currentTime - this.opProcessingTimes.submitOpEventTime;
            // One of the core expectations for Fluid service is to be fast.
            // When it's not the case, we want to learn about it and be able to investigate, so
            // raise awareness.
            // This also helps identify cases where it's due to client behavior (sending too many ops)
            // that results in overwhelming ordering service and thus starting to see long latencies.
            // The threshold could be adjusted, but ideally it stays  workload-agnostic, as service
            // performance impacts all workloads relying on service.
            const category = duration > latencyThreshold ? "error" : "performance";
            this.logger.sendPerformanceEvent(Object.assign({ eventName: "OpRoundtripTime", sequenceNumber, referenceSequenceNumber: message.referenceSequenceNumber, duration,
                category, pingLatency: this.pingLatency, msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber }, this.opPerfData));
            this.clientSequenceNumberForLatencyStatistics = undefined;
            this.opPerfData = {};
        }
    }
}
function ReportOpPerfTelemetry(clientId, deltaManager, logger) {
    new OpPerfTelemetry(clientId, deltaManager, logger);
}
//# sourceMappingURL=connectionTelemetry.js.map

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/container-runtime";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaScheduler": () => (/* binding */ DeltaScheduler)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there
 * is more than one op a particular run of the queue. It does not schedule if there is just one
 * op or just one batch in the run. It does the following two things:
 * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue
 *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block
 *    the JS thread for a long time processing ops synchronously (for example, when catching up
 *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).
 * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops
 *    processed, the time and number of turns it took to process the ops.
 */
class DeltaScheduler {
    constructor(deltaManager, logger) {
        this.logger = logger;
        // The increase in time for processing ops after each turn.
        this.processingTimeIncrement = 10;
        this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;
        // This keeps track of the number of times inbound queue has been scheduled. After a particular
        // count, we log telemetry for the number of ops processed, the time and number of turns it took
        // to process the ops.
        this.schedulingCount = 0;
        this.deltaManager = deltaManager;
        this.deltaManager.inbound.on("idle", () => { this.inboundQueueIdle(); });
    }
    batchBegin(message) {
        if (!this.processingStartTime) {
            this.processingStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        }
        if (this.schedulingLog === undefined && this.schedulingCount % 500 === 0) {
            // Every 500th time we are scheduling the inbound queue, we log telemetry for the
            // number of ops processed, the time and number of turns it took to process the ops.
            this.schedulingLog = {
                opsRemainingToProcess: 0,
                numberOfTurns: 1,
                totalProcessingTime: 0,
                numberOfBatchesProcessed: 0,
                firstSequenceNumber: message.sequenceNumber,
                lastSequenceNumber: message.sequenceNumber,
                startTime: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now(),
            };
        }
    }
    batchEnd(message) {
        if (this.schedulingLog) {
            this.schedulingLog.numberOfBatchesProcessed++;
            this.schedulingLog.lastSequenceNumber = message.sequenceNumber;
            this.schedulingLog.opsRemainingToProcess = this.deltaManager.inbound.length;
        }
        if (this.shouldRunScheduler()) {
            const currentTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const elapsedTime = currentTime - this.processingStartTime;
            if (elapsedTime > this.currentAllowedProcessingTimeForTurn) {
                // We have processed ops for more than the total processing time. So, pause the
                // queue, yield the thread and schedule a resume.
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.deltaManager.inbound.pause();
                // Increase the total processing time. Keep doing this after each turn until all the ops have
                // been processed. This way we keep the responsiveness at the beginning while also making sure
                // that all the ops process fairly quickly.
                this.currentAllowedProcessingTimeForTurn += this.processingTimeIncrement;
                // If we are logging the telemetry this time, update the telemetry log object.
                if (this.schedulingLog) {
                    this.schedulingLog.numberOfTurns++;
                    this.schedulingLog.totalProcessingTime += elapsedTime;
                }
                setTimeout(() => {
                    if (this.schedulingLog) {
                        this.logger.sendTelemetryEvent({
                            eventName: "InboundOpsPartialProcessingTime",
                            duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(elapsedTime),
                            opsProcessed: this.schedulingLog.lastSequenceNumber -
                                this.schedulingLog.firstSequenceNumber + 1,
                            opsRemainingToProcess: this.deltaManager.inbound.length,
                            processingTime: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),
                            numberOfTurns: this.schedulingLog.numberOfTurns,
                            batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,
                            timeToResume: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - currentTime),
                        });
                    }
                    this.deltaManager.inbound.resume();
                });
                this.processingStartTime = undefined;
            }
        }
    }
    inboundQueueIdle() {
        if (this.schedulingLog) {
            // Add the time taken for processing the final ops to the total processing time in the
            // telemetry log object.
            const currentTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.schedulingLog.totalProcessingTime += currentTime - this.processingStartTime;
            this.logger.sendTelemetryEvent({
                eventName: "InboundOpsProcessingTime",
                opsRemainingToProcess: this.schedulingLog.opsRemainingToProcess,
                numberOfTurns: this.schedulingLog.numberOfTurns,
                processingTime: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),
                opsProcessed: this.schedulingLog.lastSequenceNumber - this.schedulingLog.firstSequenceNumber + 1,
                batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,
                duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(currentTime - this.schedulingLog.startTime),
                schedulingCount: this.schedulingCount,
            });
            this.schedulingLog = undefined;
        }
        // If we scheduled this batch of the inbound queue, increment the counter that tracks the
        // number of times we have done this.
        this.schedulingCount++;
        // Reset the processing times.
        this.processingStartTime = undefined;
        this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;
    }
    /**
     * This function tells whether we should run the scheduler.
     */
    shouldRunScheduler() {
        // If there are still ops in the queue after the one we are processing now, we should
        // run the scheduler.
        return this.deltaManager.inbound.length > 0;
    }
}
// The time for processing ops in a single turn.
DeltaScheduler.processingTime = 50;
//# sourceMappingURL=deltaScheduler.js.map

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizerClientElection": () => (/* binding */ SummarizerClientElection),
/* harmony export */   "summarizerClientType": () => (/* binding */ summarizerClientType)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


const summarizerClientType = "summarizer";
/**
 * This class encapsulates logic around tracking the elected summarizer client.
 * It will handle updating the elected client when a summary ack hasn't been seen
 * for some configured number of ops.
 */
class SummarizerClientElection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(logger, summaryCollection, clientElection, maxOpsSinceLastSummary, electionEnabled) {
        super();
        this.logger = logger;
        this.summaryCollection = summaryCollection;
        this.clientElection = clientElection;
        this.maxOpsSinceLastSummary = maxOpsSinceLastSummary;
        this.electionEnabled = electionEnabled;
        /**
         * Used to prevent excess logging by recording the sequence number that we last reported at,
         * and making sure we don't report another event to telemetry. If things work as intended,
         * this is not needed, otherwise it could report an event on every op in worst case scenario.
         */
        this.lastReportedSeq = 0;
        // On every inbound op, if enough ops pass without seeing a summary ack (per elected client),
        // elect a new client and log to telemetry.
        this.summaryCollection.on("default", ({ sequenceNumber }) => {
            var _a, _b, _c;
            const electedClientId = this.electedClientId;
            if (electedClientId === undefined) {
                // Reset election if no elected client, but eligible clients are connected.
                // This should be uncommon, but is possible if the initial state of the
                // ordered client election contains an undefined client id or one not found
                // in the quorum (the latter would already log an error).
                if (this.clientElection.eligibleCount > 0) {
                    this.clientElection.resetElectedClient(sequenceNumber);
                }
                return;
            }
            let electionSequenceNumber = this.clientElection.electionSequenceNumber;
            const opsWithoutSummary = sequenceNumber - ((_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber);
            if (opsWithoutSummary > this.maxOpsSinceLastSummary) {
                // Log and elect a new summarizer client.
                const opsSinceLastReport = sequenceNumber - this.lastReportedSeq;
                if (opsSinceLastReport > this.maxOpsSinceLastSummary) {
                    this.logger.sendErrorEvent({
                        eventName: "ElectedClientNotSummarizing",
                        electedClientId,
                        lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,
                        electionSequenceNumber,
                        nextElectedClientId: (_b = this.clientElection.peekNextElectedClient()) === null || _b === void 0 ? void 0 : _b.clientId,
                        electionEnabled: this.electionEnabled,
                    });
                    this.lastReportedSeq = sequenceNumber;
                }
                if (this.electionEnabled) {
                    const previousParentId = this.electedParentId;
                    this.clientElection.incrementElectedClient(sequenceNumber);
                    // Verify that state incremented as expected. This should be reliable,
                    // since all of OrderedClientElection is synchronous.
                    electionSequenceNumber = this.clientElection.electionSequenceNumber;
                    if (sequenceNumber > ((_c = this.lastSummaryAckSeqForClient) !== null && _c !== void 0 ? _c : electionSequenceNumber)) {
                        if (opsSinceLastReport > this.maxOpsSinceLastSummary) {
                            this.logger.sendErrorEvent({
                                eventName: "UnexpectedElectionSequenceNumber",
                                // Expected to be undefined
                                lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,
                                // Expected to be same as op sequenceNumber
                                electionSequenceNumber,
                                sequenceNumber,
                                previousClientId: electedClientId,
                                previousParentId,
                                electedParentId: this.electedParentId,
                                electedClientId: this.electedClientId,
                                opsSinceLastReport,
                                maxOpsSinceLastSummary,
                            });
                        }
                    }
                }
            }
        });
        // When a summary ack comes in, reset our op seq counter.
        this.summaryCollection.on(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.MessageType.SummaryAck, (op) => {
            this.lastSummaryAckSeqForClient = op.sequenceNumber;
        });
        // Use oldest client election for unanimously and deterministically deciding
        // which client should summarize.
        this.clientElection.on("election", (client, sequenceNumber) => {
            this.lastSummaryAckSeqForClient = undefined;
            if (client === undefined && this.clientElection.eligibleCount > 0) {
                // If no client is valid for election, reset to the oldest again.
                // Also make extra sure not to get stuck in an infinite loop here:
                // If there are no eligible clients, just wait until a client joins
                // and will be auto-elected.
                this.clientElection.resetElectedClient(sequenceNumber);
            }
            // Election can trigger a change in SummaryManager state.
            this.emit("electedSummarizerChanged");
        });
    }
    get electedClientId() {
        var _a;
        return (_a = this.clientElection.electedClient) === null || _a === void 0 ? void 0 : _a.clientId;
    }
    get electedParentId() {
        var _a;
        return (_a = this.clientElection.electedParent) === null || _a === void 0 ? void 0 : _a.clientId;
    }
    serialize() {
        var _a;
        const { electedClientId, electedParentId, electionSequenceNumber } = this.clientElection.serialize();
        return {
            electedClientId,
            electedParentId,
            electionSequenceNumber: (_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber,
        };
    }
    static isClientEligible(client) {
        const details = client.client.details;
        if (details === undefined) {
            // Very old clients back-compat
            return true;
        }
        return SummarizerClientElection.clientDetailsPermitElection(details);
    }
}
SummarizerClientElection.clientDetailsPermitElection = (details) => details.capabilities.interactive || details.type === summarizerClientType;
//# sourceMappingURL=summarizerClientElection.js.map

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerFluidHandleContext": () => (/* binding */ ContainerFluidHandleContext)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


class ContainerFluidHandleContext {
    /**
     * Creates a new ContainerFluidHandleContext.
     * @param path - The path to this handle relative to the routeContext.
     * @param runtime - The IRuntime object this context represents.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(path, runtime, routeContext) {
        this.path = path;
        this.runtime = runtime;
        this.routeContext = routeContext;
        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandleContext() { return this; }
    attachGraph() {
        throw new Error("can't attach container runtime form within container!");
    }
    get isAttached() {
        return this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_1__.AttachState.Detached;
    }
    async resolveHandle(request) {
        return this.runtime.resolveHandle(request);
    }
}
//# sourceMappingURL=containerHandleContext.js.map

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GCNodeType": () => (/* binding */ GCNodeType),
/* harmony export */   "GarbageCollector": () => (/* binding */ GarbageCollector),
/* harmony export */   "defaultSessionExpiryDurationMs": () => (/* binding */ defaultSessionExpiryDurationMs),
/* harmony export */   "disableSessionExpiryKey": () => (/* binding */ disableSessionExpiryKey),
/* harmony export */   "gcBlobPrefix": () => (/* binding */ gcBlobPrefix),
/* harmony export */   "gcTreeKey": () => (/* binding */ gcTreeKey),
/* harmony export */   "oneDayMs": () => (/* binding */ oneDayMs),
/* harmony export */   "runSessionExpiryKey": () => (/* binding */ runSessionExpiryKey),
/* harmony export */   "trackGCStateKey": () => (/* binding */ trackGCStateKey)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(105);
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(103);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(77);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _containerRuntime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(54);
/* harmony import */ var _dataStores__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82);
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};










/** This is the current version of garbage collection. */
const GCVersion = 1;
// The key for the GC tree in summary.
const gcTreeKey = "gc";
// They prefix for GC blobs in the GC tree in summary.
const gcBlobPrefix = "__gc";
// Feature gate key to turn GC on / off.
const runGCKey = "Fluid.GarbageCollection.RunGC";
// Feature gate key to turn GC sweep on / off.
const runSweepKey = "Fluid.GarbageCollection.RunSweep";
// Feature gate key to turn GC test mode on / off.
const gcTestModeKey = "Fluid.GarbageCollection.GCTestMode";
// Feature gate key to write GC data at the root of the summary tree.
const writeAtRootKey = "Fluid.GarbageCollection.WriteDataAtRoot";
// Feature gate key to expire a session after a set period of time.
const runSessionExpiryKey = "Fluid.GarbageCollection.RunSessionExpiry";
// Feature gate key to disable expiring session after a set period of time, even if expiry value is present
const disableSessionExpiryKey = "Fluid.GarbageCollection.DisableSessionExpiry";
// Feature gate key to write the gc blob as a handle if the data is the same.
const trackGCStateKey = "Fluid.GarbageCollection.TrackGCState";
// Feature gate key to turn GC sweep log off.
const disableSweepLogKey = "Fluid.GarbageCollection.DisableSweepLog";
// One day in milliseconds.
const oneDayMs = 1 * 24 * 60 * 60 * 1000;
const defaultInactiveTimeoutMs = 7 * oneDayMs; // 7 days
const defaultSessionExpiryDurationMs = 30 * oneDayMs; // 30 days
/** The types of GC nodes in the GC reference graph. */
const GCNodeType = {
    // Nodes that are for data stores.
    DataStore: "DataStore",
    // Nodes that are within a data store. For example, DDS nodes.
    SubDataStore: "SubDataStore",
    // Nodes that are for attachment blobs, i.e., blobs uploaded via BlobManager.
    Blob: "Blob",
    // Nodes that are neither of the above. For example, root node.
    Other: "Other",
};
/** The state of node that is unreferenced. */
const UnreferencedState = {
    /** The node is active, i.e., it can become referenced again. */
    Active: "Active",
    /** The node is inactive, i.e., it should not become referenced. */
    Inactive: "Inactive",
    /** The node is ready to be deleted by the sweep phase. */
    SweepReady: "SweepReady",
};
/**
 * Helper class that tracks the state of an unreferenced node such as the time it was unreferenced and if it can
 * be deleted by the sweep phase.
 */
class UnreferencedStateTracker {
    constructor(unreferencedTimestampMs, 
    /** The time after which node transitions to Inactive state. */
    inactiveTimeoutMs, 
    /** The time after which node transitions to SweepReady state; undefined if session expiry is disabled. */
    sweepTimeoutMs, 
    /** The current reference timestamp; undefined if no ops have ever been processed which can happen in tests. */
    currentReferenceTimestampMs) {
        this.unreferencedTimestampMs = unreferencedTimestampMs;
        this.inactiveTimeoutMs = inactiveTimeoutMs;
        this.sweepTimeoutMs = sweepTimeoutMs;
        this._state = UnreferencedState.Active;
        // If there is no current reference timestamp, don't track the node's unreferenced state. This will happen
        // later when updateTracking is called with a reference timestamp.
        if (currentReferenceTimestampMs !== undefined) {
            this.updateTracking(currentReferenceTimestampMs);
        }
    }
    get state() {
        return this._state;
    }
    /* Updates the unreferenced state based on the provided timestamp. */
    updateTracking(currentReferenceTimestampMs) {
        const unreferencedDurationMs = currentReferenceTimestampMs - this.unreferencedTimestampMs;
        // If the node has been unreferenced for sweep timeout amount of time, update the state to SweepReady.
        if (this.sweepTimeoutMs !== undefined && unreferencedDurationMs >= this.sweepTimeoutMs) {
            this._state = UnreferencedState.SweepReady;
            this.clearTimers();
            return;
        }
        // If the node has been unreferenced for inactive timeoutMs amount of time, update the state to inactive.
        // Also, start a timer for the sweep timeout.
        if (unreferencedDurationMs >= this.inactiveTimeoutMs) {
            this._state = UnreferencedState.Inactive;
            this.clearTimers();
            if (this.sweepTimeoutMs !== undefined) {
                setLongTimeout(this.sweepTimeoutMs - unreferencedDurationMs, () => { this._state = UnreferencedState.SweepReady; }, (timer) => { this.sweepTimer = timer; });
            }
            return;
        }
        // The node is still active. Start the inactive timer for the remaining duration.
        const remainingDurationMs = this.inactiveTimeoutMs - unreferencedDurationMs;
        if (this.inactiveTimer === undefined) {
            const inactiveTimeoutHandler = () => {
                this._state = UnreferencedState.Inactive;
                // After the node becomes inactive, start the sweep timer after which the node will be ready for sweep.
                if (this.sweepTimeoutMs !== undefined) {
                    setLongTimeout(this.sweepTimeoutMs - this.inactiveTimeoutMs, () => { this._state = UnreferencedState.SweepReady; }, (timer) => { this.sweepTimer = timer; });
                }
            };
            this.inactiveTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Timer(remainingDurationMs, () => inactiveTimeoutHandler());
        }
        this.inactiveTimer.restart(remainingDurationMs);
    }
    clearTimers() {
        var _a;
        (_a = this.inactiveTimer) === null || _a === void 0 ? void 0 : _a.clear();
        if (this.sweepTimer !== undefined) {
            clearTimeout(this.sweepTimer);
        }
    }
    /** Stop tracking this node. Reset the unreferenced timers and state, if any. */
    stopTracking() {
        this.clearTimers();
        this._state = UnreferencedState.Active;
    }
}
/**
 * The garbage collector for the container runtime. It consolidates the garbage collection functionality and maintains
 * its state across summaries.
 *
 * Node - represented as nodeId, it's a node on the GC graph
 * Outbound Route - a path from one node to another node, think `nodeA` -\> `nodeB`
 * Graph - all nodes with their respective routes
 *             GC Graph
 *
 *               Node
 *        NodeId = "datastore1"
 *           /             \\
 *    OutboundRoute   OutboundRoute
 *         /                 \\
 *       Node               Node
 *  NodeId = "dds1"     NodeId = "dds2"
 */
class GarbageCollector {
    constructor(createParams) {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Tells whether the GC data should be written to the root of the summary tree.
         */
        this._writeDataAtRoot = true;
        /**
         * Tells whether the initial GC state needs to be reset. This can happen under 2 conditions:
         * 1. The base snapshot contains GC state but GC is disabled. This will happen the first time GC is disabled after
         *    it was enabled before. GC state needs to be removed from summary and all nodes should be marked referenced.
         * 2. The base snapshot does not have GC state but GC is enabled. This will happen the very first time GC runs on
         *    a document and the first time GC is enabled after is was disabled before.
         *
         * Note that the state needs reset only for the very first time summary is generated by this client. After that, the
         * state will be up-to-date and this flag will be reset.
        */
        this.initialStateNeedsReset = false;
        // The current GC version that this container is running.
        this.currentGCVersion = GCVersion;
        // Keeps a list of references (edges in the GC graph) between GC runs. Each entry has a node id and a list of
        // outbound routes from that node.
        this.newReferencesSinceLastRun = new Map();
        // Map of node ids to their unreferenced state tracker.
        this.unreferencedNodesState = new Map();
        // Keeps track of unreferenced events that are logged for a node. This is used to limit the log generation to one
        // per event per node.
        this.loggedUnreferencedEvents = new Set();
        // Queue for unreferenced events that should be logged the next time GC runs.
        this.pendingEventsQueue = [];
        // The number of times GC has successfully completed on this instance of GarbageCollector.
        this.completedRuns = 0;
        this.runtime = createParams.runtime;
        this.isSummarizerClient = createParams.isSummarizerClient;
        this.gcOptions = createParams.gcOptions;
        this.getNodePackagePath = createParams.getNodePackagePath;
        this.getLastSummaryTimestampMs = createParams.getLastSummaryTimestampMs;
        const baseSnapshot = createParams.baseSnapshot;
        const metadata = createParams.metadata;
        const readAndParseBlob = createParams.readAndParseBlob;
        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(createParams.baseLogger, "GarbageCollector", { all: { completedGCRuns: () => this.completedRuns } }));
        let prevSummaryGCVersion;
        /**
         * The following GC state is enabled during container creation and cannot be changed throughout its lifetime:
         * 1. Whether running GC mark phase is allowed or not.
         * 2. Whether running GC sweep phase is allowed or not.
         * 3. Whether GC session expiry is enabled or not.
         * For existing containers, we get this information from the metadata blob of its summary.
         */
        if (createParams.existing) {
            prevSummaryGCVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.getGCVersion)(metadata);
            // Existing documents which did not have metadata blob or had GC disabled have version as 0. For all
            // other existing documents, GC is enabled.
            this.gcEnabled = prevSummaryGCVersion > 0;
            this.sweepEnabled = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.sweepEnabled) !== null && _a !== void 0 ? _a : false;
            this.sessionExpiryTimeoutMs = metadata === null || metadata === void 0 ? void 0 : metadata.sessionExpiryTimeoutMs;
        }
        else {
            // Sweep should not be enabled without enabling GC mark phase. We could silently disable sweep in this
            // scenario but explicitly failing makes it clearer and promotes correct usage.
            if (this.gcOptions.sweepAllowed && this.gcOptions.gcAllowed === false) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError("GC sweep phase cannot be enabled without enabling GC mark phase");
            }
            // For new documents, GC is enabled by default. It can be explicitly disabled by setting the gcAllowed
            // flag in GC options to false.
            this.gcEnabled = this.gcOptions.gcAllowed !== false;
            // The sweep phase has to be explicitly enabled by setting the sweepAllowed flag in GC options to true.
            this.sweepEnabled = this.gcOptions.sweepAllowed === true;
            // Set the Session Expiry only if the flag is enabled or the test option is set.
            if (this.mc.config.getBoolean(runSessionExpiryKey) && this.gcEnabled) {
                this.sessionExpiryTimeoutMs = defaultSessionExpiryDurationMs;
            }
        }
        // If session expiry is enabled, we need to close the container when the session expiry timeout expires.
        if (this.sessionExpiryTimeoutMs !== undefined && this.mc.config.getBoolean(disableSessionExpiryKey) !== true) {
            // If Test Override config is set, override Session Expiry timeout.
            const overrideSessionExpiryTimeoutMs = this.mc.config.getNumber("Fluid.GarbageCollection.TestOverride.SessionExpiryMs");
            const timeoutMs = overrideSessionExpiryTimeoutMs !== null && overrideSessionExpiryTimeoutMs !== void 0 ? overrideSessionExpiryTimeoutMs : this.sessionExpiryTimeoutMs;
            setLongTimeout(timeoutMs, () => { this.runtime.closeFn(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.ClientSessionExpiredError(`Client session expired.`, timeoutMs)); }, (timer) => { this.sessionExpiryTimer = timer; });
            /**
             * Sweep timeout is the time after which unreferenced content can be swept.
             * Sweep timeout = session expiry timeout + snapshot cache expiry timeout + one day buffer. The buffer is
             * added to account for any clock skew. We use server timestamps throughout so the skew should be minimal
             * but make it one day to be safe.
             */
            if (createParams.snapshotCacheExpiryMs !== undefined) {
                this.sweepTimeoutMs = this.sessionExpiryTimeoutMs + createParams.snapshotCacheExpiryMs + oneDayMs;
            }
        }
        // For existing document, the latest summary is the one that we loaded from. So, use its GC version as the
        // latest tracked GC version. For new documents, we will be writing the first summary with the current version.
        this.latestSummaryGCVersion = prevSummaryGCVersion !== null && prevSummaryGCVersion !== void 0 ? prevSummaryGCVersion : this.currentGCVersion;
        /**
         * Whether GC should run or not. The following conditions have to be met to run sweep:
         * 1. GC should be enabled for this container.
         * 2. GC should not be disabled via disableGC GC option.
         * These conditions can be overridden via runGCKey feature flag.
         */
        this.shouldRunGC = (_b = this.mc.config.getBoolean(runGCKey)) !== null && _b !== void 0 ? _b : (
        // GC must be enabled for the document.
        this.gcEnabled
            // GC must not be disabled via GC options.
            && !this.gcOptions.disableGC);
        /**
         * Whether sweep should run or not. The following conditions have to be met to run sweep:
         * 1. Overall GC or mark phase must be enabled (this.shouldRunGC).
         * 2. Sweep timeout should be available. Without this, we wouldn't know when an object should be deleted.
         * 3. Sweep should be enabled for this container (this.sweepEnabled). This can be overridden via runSweep
         *    feature flag.
         */
        this.shouldRunSweep = this.shouldRunGC
            && this.sweepTimeoutMs !== undefined
            && ((_c = this.mc.config.getBoolean(runSweepKey)) !== null && _c !== void 0 ? _c : this.sweepEnabled);
        this.trackGCState = this.mc.config.getBoolean(trackGCStateKey) === true;
        // Override inactive timeout if test config or gc options to override it is set.
        this.inactiveTimeoutMs = (_e = (_d = this.mc.config.getNumber("Fluid.GarbageCollection.TestOverride.InactiveTimeoutMs")) !== null && _d !== void 0 ? _d : this.gcOptions.inactiveTimeoutMs) !== null && _e !== void 0 ? _e : defaultInactiveTimeoutMs;
        // Inactive timeout must be greater than sweep timeout since a node goes from active -> inactive -> sweep ready.
        if (this.sweepTimeoutMs !== undefined && this.inactiveTimeoutMs > this.sweepTimeoutMs) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError("inactive timeout should not be greated than the sweep timeout");
        }
        // Whether we are running in test mode. In this mode, unreferenced nodes are immediately deleted.
        this.testMode = (_f = this.mc.config.getBoolean(gcTestModeKey)) !== null && _f !== void 0 ? _f : this.gcOptions.runGCInTestMode === true;
        // GC state is written into root of the summary tree by default. Can be overridden via feature flag for now.
        this._writeDataAtRoot = (_g = this.mc.config.getBoolean(writeAtRootKey)) !== null && _g !== void 0 ? _g : true;
        if (this._writeDataAtRoot) {
            // The GC state needs to be reset if the base snapshot contains GC tree and GC is disabled or it doesn't
            // contain GC tree and GC is enabled.
            const gcTreePresent = (baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[gcTreeKey]) !== undefined;
            this.initialStateNeedsReset = gcTreePresent !== this.shouldRunGC;
        }
        // Get the GC state from the GC blob in the base snapshot. Use LazyPromise because we only want to do
        // this once since it involves fetching blobs from storage which is expensive.
        const baseSummaryStateP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.LazyPromise(async () => {
            var _a;
            if (baseSnapshot === undefined) {
                return undefined;
            }
            // For newer documents, GC data should be present in the GC tree in the root of the snapshot.
            const gcSnapshotTree = baseSnapshot.trees[gcTreeKey];
            if (gcSnapshotTree !== undefined) {
                // If the GC tree is written at root, we should also do the same.
                this._writeDataAtRoot = true;
                const baseGCState = await getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);
                if (this.trackGCState) {
                    this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(baseGCState));
                }
                return baseGCState;
            }
            // back-compat - Older documents will have the GC blobs in each data store's summary tree. Get them and
            // consolidate into IGarbageCollectionState format.
            // Add a node for the root node that is not present in older snapshot format.
            const gcState = { gcNodes: { "/": { outboundRoutes: [] } } };
            const dataStoreSnapshotTree = (0,_dataStores__WEBPACK_IMPORTED_MODULE_6__.getSummaryForDatastores)(baseSnapshot, metadata);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(dataStoreSnapshotTree !== undefined, 0x2a8 /* "Expected data store snapshot tree in base snapshot" */);
            for (const [dsId, dsSnapshotTree] of Object.entries(dataStoreSnapshotTree.trees)) {
                const blobId = dsSnapshotTree.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_8__.gcBlobKey];
                if (blobId === undefined) {
                    continue;
                }
                const gcSummaryDetails = await readAndParseBlob(blobId);
                // If there are no nodes for this data store, skip it.
                if (((_a = gcSummaryDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) === undefined) {
                    continue;
                }
                const dsRootId = `/${dsId}`;
                // Since we used to write GC data at data store level, we won't have an entry for the root ("/").
                // Construct that entry by adding root data store ids to its outbound routes.
                const initialSnapshotDetails = await readAndParseBlob(dsSnapshotTree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.dataStoreAttributesBlobName]);
                if (initialSnapshotDetails.isRootDataStore) {
                    gcState.gcNodes["/"].outboundRoutes.push(dsRootId);
                }
                for (const [id, outboundRoutes] of Object.entries(gcSummaryDetails.gcData.gcNodes)) {
                    // Prefix the data store id to the GC node ids to make them relative to the root from being
                    // relative to the data store. Similar to how its done in DataStore::getGCData.
                    const rootId = id === "/" ? dsRootId : `${dsRootId}${id}`;
                    gcState.gcNodes[rootId] = { outboundRoutes: Array.from(outboundRoutes) };
                }
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(gcState.gcNodes[dsRootId] !== undefined, 0x2a9 /* GC nodes for data store not in GC blob */);
                gcState.gcNodes[dsRootId].unreferencedTimestampMs = gcSummaryDetails.unrefTimestamp;
            }
            // If there is only one node (root node just added above), either GC is disabled or we are loading from the
            // very first summary generated by detached container. In both cases, GC was not run - return undefined.
            return Object.keys(gcState.gcNodes).length === 1 ? undefined : gcState;
        });
        /**
         * Set up the initializer which initializes the base GC state from the base snapshot. Note that the reference
         * timestamp maybe from old ops which were not summarized and stored in the file. So, the unreferenced state
         * may be out of date. This is fine because the state is updated every time GC runs based on the time then.
         */
        this.initializeBaseStateP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.LazyPromise(async () => {
            const currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs();
            const baseState = await baseSummaryStateP;
            if (baseState === undefined) {
                return;
            }
            const gcNodes = {};
            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {
                if (nodeData.unreferencedTimestampMs !== undefined) {
                    this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(nodeData.unreferencedTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));
                }
                gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);
            }
            this.previousGCDataFromLastRun = { gcNodes };
        });
        // Get the GC details for each node from the GC state in the base summary. This is returned in getBaseGCDetails
        // which the caller uses to initialize each node's GC state.
        this.baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.LazyPromise(async () => {
            const baseState = await baseSummaryStateP;
            if (baseState === undefined) {
                return new Map();
            }
            const gcNodes = {};
            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {
                gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);
            }
            // Run GC on the nodes in the base summary to get the routes used in each node in the container.
            // This is an optimization for space (vs performance) wherein we don't need to store the used routes of
            // each node in the summary.
            const usedRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__.runGarbageCollection)(gcNodes, ["/"]).referencedNodeIds;
            const baseGCDetailsMap = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.unpackChildNodesGCDetails)({ gcData: { gcNodes }, usedRoutes });
            // Currently, the nodes may write the GC data. So, we need to update it's base GC details with the
            // unreferenced timestamp. Once we start writing the GC data here, we won't need to do this anymore.
            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {
                if (nodeData.unreferencedTimestampMs !== undefined) {
                    const dataStoreGCDetails = baseGCDetailsMap.get(nodeId.slice(1));
                    if (dataStoreGCDetails !== undefined) {
                        dataStoreGCDetails.unrefTimestamp = nodeData.unreferencedTimestampMs;
                    }
                }
            }
            return baseGCDetailsMap;
        });
        // Log all the GC options and the state determined by the garbage collector. This is interesting only for the
        // summarizer client since it is the only one that runs GC. It also helps keep the telemetry less noisy.
        const gcConfigProps = JSON.stringify(Object.assign({ gcEnabled: this.gcEnabled, sweepEnabled: this.sweepEnabled, runGC: this.shouldRunGC, runSweep: this.shouldRunSweep, writeAtRoot: this._writeDataAtRoot, testMode: this.testMode, sessionExpiry: this.sessionExpiryTimeoutMs, inactiveTimeout: this.inactiveTimeoutMs, existing: createParams.existing, trackGCState: this.trackGCState }, this.gcOptions));
        if (this.isSummarizerClient) {
            this.mc.logger.sendTelemetryEvent({
                eventName: "GarbageCollectorLoaded",
                gcConfigs: gcConfigProps,
            });
        }
        // Initialize the base state that is used to detect when inactive objects are used.
        if (this.shouldRunGC) {
            this.initializeBaseStateP.catch((error) => {
                const dpe = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.wrapIfUnrecognized(error, "FailedToInitializeGC");
                dpe.addTelemetryProperties({ gcConfigs: gcConfigProps });
                throw dpe;
            });
        }
    }
    static create(createParams) {
        return new GarbageCollector(createParams);
    }
    /**
     * Tells whether the GC state needs to be reset in the next summary. We need to do this if:
     * 1. GC was enabled and is now disabled. The GC state needs to be removed and everything becomes referenced.
     * 2. GC was disabled and is now enabled. The GC state needs to be regenerated and added to summary.
     * 3. The GC version in the latest summary is different from the current GC version. This can happen if:
     *    3.1. The summary this client loaded with has data from a different GC version.
     *    3.2. This client's latest summary was updated from a snapshot that has a different GC version.
     */
    get summaryStateNeedsReset() {
        return this.initialStateNeedsReset ||
            (this.shouldRunGC && this.latestSummaryGCVersion !== this.currentGCVersion);
    }
    get writeDataAtRoot() {
        return this._writeDataAtRoot;
    }
    /**
     * Runs garbage collection and updates the reference / used state of the nodes in the container.
     * @returns the number of data stores that have been marked as unreferenced.
     */
    async collectGarbage(options) {
        const { fullGC = this.gcOptions.runFullGC === true || this.summaryStateNeedsReset, } = options;
        const logger = options.logger
            ? _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(options.logger, undefined, { all: { completedGCRuns: () => this.completedRuns } })
            : this.mc.logger;
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(logger, { eventName: "GarbageCollection" }, async (event) => {
            await this.runPreGCSteps();
            // Get the runtime's GC data and run GC on the reference graph in it.
            const gcData = await this.runtime.getGCData(fullGC);
            const gcResult = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__.runGarbageCollection)(gcData.gcNodes, ["/"]);
            const gcStats = await this.runPostGCSteps(gcData, gcResult, logger);
            event.end(Object.assign({}, gcStats));
            this.completedRuns++;
            return gcStats;
        }, { end: true, cancel: "error" });
    }
    async runPreGCSteps() {
        // Ensure that base state has been initialized.
        await this.initializeBaseStateP;
        // Let the runtime update its pending state before GC runs.
        await this.runtime.updateStateBeforeGC();
    }
    async runPostGCSteps(gcData, gcResult, logger) {
        // Generate statistics from the current run. This is done before updating the current state because it
        // generates some of its data based on previous state of the system.
        const gcStats = this.generateStats(gcResult);
        // Update the state since the last GC run. There can be nodes that were referenced between the last and
        // the current run. We need to identify than and update their unreferenced state if needed.
        this.updateStateSinceLastRun(gcData, logger);
        // Update the current state and update the runtime of all routes or ids that used as per the GC run.
        const currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs();
        this.updateCurrentState(gcData, gcResult, currentReferenceTimestampMs);
        this.runtime.updateUsedRoutes(gcResult.referencedNodeIds, currentReferenceTimestampMs);
        // Log events for objects that are ready to be deleted by sweep. When we have sweep enabled, we will
        // delete these objects here instead.
        this.logSweepEvents(logger, currentReferenceTimestampMs);
        // If we are running in GC test mode, delete objects for unused routes. This enables testing scenarios
        // involving access to deleted data.
        if (this.testMode) {
            this.runtime.deleteUnusedRoutes(gcResult.deletedNodeIds);
        }
        // Log pending unreferenced events such as a node being used after inactive. This is done after GC runs and
        // updates its state so that we don't send false positives based on intermediate state. For example, we may get
        // reference to an unreferenced node from another unreferenced node which means the node wasn't revived.
        await this.logUnreferencedEvents(logger);
        return gcStats;
    }
    /**
     * Summarizes the GC data and returns it as a summary tree.
     * We current write the entire GC state in a single blob. This can be modified later to write multiple
     * blobs. All the blob keys should start with `gcBlobPrefix`.
     */
    summarize(fullTree, trackState, telemetryContext) {
        var _a;
        if (!this.shouldRunGC || this.previousGCDataFromLastRun === undefined) {
            return;
        }
        const gcState = { gcNodes: {} };
        for (const [nodeId, outboundRoutes] of Object.entries(this.previousGCDataFromLastRun.gcNodes)) {
            gcState.gcNodes[nodeId] = {
                outboundRoutes,
                unreferencedTimestampMs: (_a = this.unreferencedNodesState.get(nodeId)) === null || _a === void 0 ? void 0 : _a.unreferencedTimestampMs,
            };
        }
        const newSerializedSummaryState = JSON.stringify(generateSortedGCState(gcState));
        /**
         * As an optimization if the GC tree hasn't changed and we're tracking the gc state, return a tree handle
         * instead of returning the whole GC tree. If there are changes, then we want to return the whole tree.
         */
        if (this.trackGCState) {
            this.pendingSerializedSummaryState = newSerializedSummaryState;
            if (this.latestSerializedSummaryState !== undefined &&
                this.latestSerializedSummaryState === newSerializedSummaryState &&
                !fullTree &&
                trackState) {
                const stats = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.mergeStats)();
                stats.handleNodeCount++;
                return {
                    summary: {
                        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.SummaryType.Handle,
                        handle: `/${gcTreeKey}`,
                        handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.SummaryType.Tree,
                    },
                    stats,
                };
            }
        }
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.SummaryTreeBuilder();
        builder.addBlob(`${gcBlobPrefix}_root`, newSerializedSummaryState);
        return builder.getSummaryTree();
    }
    getMetadata() {
        return {
            /**
             * If GC is enabled, the GC data is written using the current GC version and that is the gcFeature that goes
             * into the metadata blob. If GC is disabled, the gcFeature is 0.
             */
            gcFeature: this.gcEnabled ? this.currentGCVersion : 0,
            sessionExpiryTimeoutMs: this.sessionExpiryTimeoutMs,
            sweepEnabled: this.sweepEnabled,
        };
    }
    /**
     * Returns a map of node ids to their base GC details generated from the base summary. This is used by the caller
     * to initialize the GC state of the nodes.
     */
    async getBaseGCDetails() {
        return this.baseGCDetailsP;
    }
    /**
     * Called when the latest summary of the system has been refreshed. This will be used to update the state of the
     * latest summary tracked.
     */
    async latestSummaryStateRefreshed(result, readAndParseBlob) {
        if (!this.shouldRunGC || !result.latestSummaryUpdated) {
            return;
        }
        // If the summary was tracked by this client, it was the one that generated the summary in the first place.
        // Basically, it was written in the current GC version.
        if (result.wasSummaryTracked) {
            this.latestSummaryGCVersion = this.currentGCVersion;
            this.initialStateNeedsReset = false;
            if (this.trackGCState) {
                this.latestSerializedSummaryState = this.pendingSerializedSummaryState;
                this.pendingSerializedSummaryState = undefined;
            }
            return;
        }
        // If the summary was not tracked by this client, update latest GC version and blob from the snapshot in the
        // result as that is now the latest summary.
        const snapshot = result.snapshot;
        const metadataBlobId = snapshot.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.metadataBlobName];
        if (metadataBlobId) {
            const metadata = await readAndParseBlob(metadataBlobId);
            this.latestSummaryGCVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_3__.getGCVersion)(metadata);
        }
        const gcSnapshotTree = snapshot.trees[gcTreeKey];
        if (gcSnapshotTree !== undefined && this.trackGCState) {
            const latestGCState = await getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);
            this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(latestGCState));
        }
        else {
            this.latestSerializedSummaryState = undefined;
        }
        this.pendingSerializedSummaryState = undefined;
    }
    /**
     * Called when a node with the given id is updated. If the node is inactive, log an error.
     * @param nodePath - The id of the node that changed.
     * @param reason - Whether the node was loaded or changed.
     * @param timestampMs - The timestamp when the node changed.
     * @param packagePath - The package path of the node. This may not be available if the node hasn't been loaded yet.
     * @param requestHeaders - If the node was loaded via request path, the headers in the request.
     */
    nodeUpdated(nodePath, reason, timestampMs, packagePath, requestHeaders) {
        if (!this.shouldRunGC) {
            return;
        }
        const nodeStateTracker = this.unreferencedNodesState.get(nodePath);
        if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {
            this.inactiveNodeUsed(reason, nodePath, nodeStateTracker, undefined /* fromNodeId */, packagePath, timestampMs, requestHeaders);
        }
    }
    /**
     * Called when an outbound reference is added to a node. This is used to identify all nodes that have been
     * referenced between summaries so that their unreferenced timestamp can be reset.
     *
     * @param fromNodePath - The node from which the reference is added.
     * @param toNodePath - The node to which the reference is added.
     */
    addedOutboundReference(fromNodePath, toNodePath) {
        var _a;
        if (!this.shouldRunGC) {
            return;
        }
        const outboundRoutes = (_a = this.newReferencesSinceLastRun.get(fromNodePath)) !== null && _a !== void 0 ? _a : [];
        outboundRoutes.push(toNodePath);
        this.newReferencesSinceLastRun.set(fromNodePath, outboundRoutes);
        const nodeStateTracker = this.unreferencedNodesState.get(toNodePath);
        if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {
            this.inactiveNodeUsed("Revived", toNodePath, nodeStateTracker, fromNodePath);
        }
    }
    dispose() {
        if (this.sessionExpiryTimer !== undefined) {
            clearTimeout(this.sessionExpiryTimer);
            this.sessionExpiryTimer = undefined;
        }
    }
    /**
     * Updates the state of the system as per the current GC run. It does the following:
     * 1. Sets up the current GC state as per the gcData.
     * 2. Starts tracking for nodes that have become unreferenced in this run.
     * 3. Clears tracking for nodes that were unreferenced but became referenced in this run.
     * @param gcData - The data representing the reference graph on which GC is run.
     * @param gcResult - The result of the GC run on the gcData.
     * @param currentReferenceTimestampMs - The timestamp to be used for unreferenced nodes' timestamp.
     */
    updateCurrentState(gcData, gcResult, currentReferenceTimestampMs) {
        this.previousGCDataFromLastRun = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.cloneGCData)(gcData);
        this.newReferencesSinceLastRun.clear();
        // Iterate through the referenced nodes and stop tracking if they were unreferenced before.
        for (const nodeId of gcResult.referencedNodeIds) {
            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);
            if (nodeStateTracker !== undefined) {
                // Stop tracking so as to clear out any running timers.
                nodeStateTracker.stopTracking();
                // Delete the node as we don't need to track it any more.
                this.unreferencedNodesState.delete(nodeId);
            }
        }
        /**
         * If there is no current reference time, skip tracking when a node becomes unreferenced. This would happen
         * if no ops have been processed ever and we still try to run GC. If so, there is nothing interesting to track
         * anyway.
         */
        if (currentReferenceTimestampMs === undefined) {
            return;
        }
        /**
         * If a node became unreferenced in this run, start tracking it.
         * If a node was already unreferenced, update its tracking information. Since the current reference time is
         * from the ops seen, this will ensure that we keep updating the unreferenced state as time moves forward.
         */
        for (const nodeId of gcResult.deletedNodeIds) {
            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);
            if (nodeStateTracker === undefined) {
                this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(currentReferenceTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));
            }
            else {
                nodeStateTracker.updateTracking(currentReferenceTimestampMs);
            }
        }
    }
    /**
     * Since GC runs periodically, the GC data that is generated only tells us the state of the world at that point in
     * time. It's possible that nodes transition from `unreferenced -> referenced -> unreferenced` between two runs. The
     * unreferenced timestamp of such nodes needs to be reset as they may have been accessed when they were referenced.
     *
     * This function identifies nodes that were referenced since last run and removes their unreferenced state, if any.
     * If these nodes are currently unreferenced, they will be assigned new unreferenced state by the current run.
     */
    updateStateSinceLastRun(currentGCData, logger) {
        // If we haven't run GC before there is nothing to do.
        if (this.previousGCDataFromLastRun === undefined) {
            return;
        }
        // Find any references that haven't been identified correctly.
        const missingExplicitReferences = this.findMissingExplicitReferences(currentGCData, this.previousGCDataFromLastRun, this.newReferencesSinceLastRun);
        if (this.writeDataAtRoot && missingExplicitReferences.length > 0) {
            missingExplicitReferences.forEach((missingExplicitReference) => {
                const event = {
                    eventName: "gcUnknownOutboundReferences",
                    gcNodeId: missingExplicitReference[0],
                    gcRoutes: JSON.stringify(missingExplicitReference[1]),
                };
                logger.sendPerformanceEvent(event);
            });
        }
        // No references were added since the last run so we don't have to update reference states of any unreferenced
        // nodes
        if (this.newReferencesSinceLastRun.size === 0) {
            return;
        }
        /**
         * Generate a super set of the GC data that contains the nodes and edges from last run, plus any new node and
         * edges that have been added since then. To do this, combine the GC data from the last run and the current
         * run, and then add the references since last run.
         *
         * Note on why we need to combine the data from previous run, current run and all references in between -
         * 1. We need data from last run because some of its references may have been deleted since then. If those
         *    references added new outbound references before getting deleted, we need to detect them.
         * 2. We need new outbound references since last run because some of them may have been deleted later. If those
         *    references added new outbound references before getting deleted, we need to detect them.
         * 3. We need data from the current run because currently we may not detect when DDSes are referenced:
         *    - We don't require DDSes handles to be stored in a referenced DDS. For this, we need GC at DDS level
         *      which is tracked by https://github.com/microsoft/FluidFramework/issues/8470.
         *    - A new data store may have "root" DDSes already created and we don't detect them today.
         */
        const gcDataSuperSet = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.concatGarbageCollectionData)(this.previousGCDataFromLastRun, currentGCData);
        this.newReferencesSinceLastRun.forEach((outboundRoutes, sourceNodeId) => {
            if (gcDataSuperSet.gcNodes[sourceNodeId] === undefined) {
                gcDataSuperSet.gcNodes[sourceNodeId] = outboundRoutes;
            }
            else {
                gcDataSuperSet.gcNodes[sourceNodeId].push(...outboundRoutes);
            }
        });
        /**
         * Run GC on the above reference graph to find all nodes that are referenced. For each one, if they are
         * unreferenced, stop tracking them and remove from unreferenced list.
         * Some of these nodes may be unreferenced now and if so, the current run will add unreferenced state for them.
         */
        const gcResult = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_9__.runGarbageCollection)(gcDataSuperSet.gcNodes, ["/"]);
        for (const nodeId of gcResult.referencedNodeIds) {
            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);
            if (nodeStateTracker !== undefined) {
                // Stop tracking so as to clear out any running timers.
                nodeStateTracker.stopTracking();
                // Delete the node as we don't need to track it any more.
                this.unreferencedNodesState.delete(nodeId);
            }
        }
    }
    /**
     * Finds all new references or outbound routes in the current graph that haven't been explicitly notified to GC.
     * The principle is that every new reference or outbound route must be notified to GC via the
     * addedOutboundReference method. It it hasn't, its a bug and we want to identify these scenarios.
     *
     * In more simple terms:
     * Missing Explicit References = Current References - Previous References - Explicitly Added References;
     *
     * @param currentGCData - The GC data (reference graph) from the current GC run.
     * @param previousGCData - The GC data (reference graph) from the previous GC run.
     * @param explicitReferences - New references added explicity between the previous and the current run.
     * @returns - a list of missing explicit references
     */
    findMissingExplicitReferences(currentGCData, previousGCData, explicitReferences) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(previousGCData !== undefined, 0x2b7);
        const currentGraph = Object.entries(currentGCData.gcNodes);
        const missingExplicitReferences = [];
        currentGraph.forEach(([nodeId, currentOutboundRoutes]) => {
            var _a, _b;
            const previousRoutes = (_a = previousGCData.gcNodes[nodeId]) !== null && _a !== void 0 ? _a : [];
            const explicitRoutes = (_b = explicitReferences.get(nodeId)) !== null && _b !== void 0 ? _b : [];
            const missingExplicitRoutes = [];
            currentOutboundRoutes.forEach((route) => {
                const isBlobOrDataStoreRoute = this.runtime.getNodeType(route) === GCNodeType.Blob ||
                    this.runtime.getNodeType(route) === GCNodeType.DataStore;
                // Ignore implicitly added DDS routes to their parent datastores
                const notRouteFromDDSToParentDataStore = !nodeId.startsWith(route);
                if (isBlobOrDataStoreRoute &&
                    notRouteFromDDSToParentDataStore &&
                    (!previousRoutes.includes(route) && !explicitRoutes.includes(route))) {
                    missingExplicitRoutes.push(route);
                }
            });
            if (missingExplicitRoutes.length > 0) {
                missingExplicitReferences.push([nodeId, missingExplicitRoutes]);
            }
        });
        // Ideally missingExplicitReferences should always have a size 0
        return missingExplicitReferences;
    }
    /**
     * Generates the stats of a garbage collection run from the given results of the run.
     * @param gcResult - The result of a GC run.
     * @returns the GC stats of the GC run.
     */
    generateStats(gcResult) {
        const gcStats = {
            nodeCount: 0,
            dataStoreCount: 0,
            attachmentBlobCount: 0,
            unrefNodeCount: 0,
            unrefDataStoreCount: 0,
            unrefAttachmentBlobCount: 0,
            updatedNodeCount: 0,
            updatedDataStoreCount: 0,
            updatedAttachmentBlobCount: 0,
        };
        const updateNodeStats = (nodeId, referenced) => {
            gcStats.nodeCount++;
            // If there is no previous GC data, every node's state is generated and is considered as updated.
            // Otherwise, find out if any node went from referenced to unreferenced or vice-versa.
            const stateUpdated = this.previousGCDataFromLastRun === undefined ||
                this.unreferencedNodesState.has(nodeId) === referenced;
            if (stateUpdated) {
                gcStats.updatedNodeCount++;
            }
            if (!referenced) {
                gcStats.unrefNodeCount++;
            }
            if (this.runtime.getNodeType(nodeId) === GCNodeType.DataStore) {
                gcStats.dataStoreCount++;
                if (stateUpdated) {
                    gcStats.updatedDataStoreCount++;
                }
                if (!referenced) {
                    gcStats.unrefDataStoreCount++;
                }
            }
            if (this.runtime.getNodeType(nodeId) === GCNodeType.Blob) {
                gcStats.attachmentBlobCount++;
                if (stateUpdated) {
                    gcStats.updatedAttachmentBlobCount++;
                }
                if (!referenced) {
                    gcStats.unrefAttachmentBlobCount++;
                }
            }
        };
        for (const nodeId of gcResult.referencedNodeIds) {
            updateNodeStats(nodeId, true /* referenced */);
        }
        for (const nodeId of gcResult.deletedNodeIds) {
            updateNodeStats(nodeId, false /* referenced */);
        }
        return gcStats;
    }
    /**
     * For nodes that are ready to sweep, log an event for now. Until we start running sweep which deletes objects,
     * this will give us a view into how much deleted content a container has.
     */
    logSweepEvents(logger, currentReferenceTimestampMs) {
        if (this.mc.config.getBoolean(disableSweepLogKey) === true
            || currentReferenceTimestampMs === undefined
            || this.sweepTimeoutMs === undefined) {
            return;
        }
        this.unreferencedNodesState.forEach((nodeStateTracker, nodeId) => {
            if (nodeStateTracker.state !== UnreferencedState.SweepReady) {
                return;
            }
            const nodeType = this.runtime.getNodeType(nodeId);
            if (nodeType !== GCNodeType.DataStore && nodeType !== GCNodeType.Blob) {
                return;
            }
            // Log deleted event for each node only once to reduce noise in telemetry.
            const uniqueEventId = `Deleted-${nodeId}`;
            if (this.loggedUnreferencedEvents.has(uniqueEventId)) {
                return;
            }
            this.loggedUnreferencedEvents.add(uniqueEventId);
            logger.sendTelemetryEvent({
                eventName: "GCObjectDeleted",
                id: nodeId,
                type: nodeType,
                age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,
                timeout: this.sweepTimeoutMs,
                completedGCRuns: this.completedRuns,
                lastSummaryTime: this.getLastSummaryTimestampMs(),
            });
        });
    }
    /**
     * Called when an inactive node is used after. Queue up an event that will be logged next time GC runs.
     */
    inactiveNodeUsed(usageType, nodeId, nodeStateTracker, fromNodeId, packagePath, currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs(), requestHeaders) {
        // If there is no reference timestamp to work with, no ops have been processed after creation. If so, skip
        // logging as nothing interesting would have happened worth logging.
        // If the node is active, skip logging.
        if (currentReferenceTimestampMs === undefined || nodeStateTracker.state === UnreferencedState.Active) {
            return;
        }
        // For non-summarizer clients, only log "Loaded" type events since these objects may not be loaded in the
        // summarizer clients if they are based off of user actions (such as scrolling to content for these objects).
        if (!this.isSummarizerClient && usageType !== "Loaded") {
            return;
        }
        // We only care about data stores and attachment blobs for this telemetry since GC only marks these objects
        // as unreferenced. Also, if an inactive DDS is used, the corresponding data store store will also be used.
        const nodeType = this.runtime.getNodeType(nodeId);
        if (nodeType !== GCNodeType.DataStore && nodeType !== GCNodeType.Blob) {
            return;
        }
        const state = nodeStateTracker.state;
        const uniqueEventId = `${state}-${nodeId}-${usageType}`;
        if (this.loggedUnreferencedEvents.has(uniqueEventId)) {
            return;
        }
        this.loggedUnreferencedEvents.add(uniqueEventId);
        const propsToLog = {
            id: nodeId,
            type: nodeType,
            unrefTime: nodeStateTracker.unreferencedTimestampMs,
            age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,
            timeout: nodeStateTracker.state === UnreferencedState.Inactive
                ? this.inactiveTimeoutMs
                : this.sweepTimeoutMs,
            completedGCRuns: this.completedRuns,
            lastSummaryTime: this.getLastSummaryTimestampMs(),
            externalRequest: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[_containerRuntime__WEBPACK_IMPORTED_MODULE_13__.RuntimeHeaders.externalRequest],
            viaHandle: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[_containerRuntime__WEBPACK_IMPORTED_MODULE_13__.RuntimeHeaders.viaHandle],
            fromId: fromNodeId,
        };
        // For summarizer client, queue the event so it is logged the next time GC runs if the event is still valid.
        // For non-summarizer client, log the event now since GC won't run on it. This may result in false positives
        // but it's a good signal nonetheless and we can consume it with a grain of salt.
        if (this.isSummarizerClient) {
            this.pendingEventsQueue.push(Object.assign(Object.assign({}, propsToLog), { usageType, state }));
        }
        else {
            this.mc.logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), { eventName: `${state}Object_${usageType}`, pkg: packagePath ? { value: packagePath.join("/"), tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.CodeArtifact } : undefined }));
        }
    }
    async logUnreferencedEvents(logger) {
        for (const eventProps of this.pendingEventsQueue) {
            const { usageType, state } = eventProps, propsToLog = __rest(eventProps, ["usageType", "state"]);
            /**
             * Revived event is logged only if the node is active. If the node is not active, the reference to it was
             * from another unreferenced node and this scenario is not interesting to log.
             * Loaded and Changed events are logged only if the node is not active. If the node is active, it was
             * revived and a Revived event will be logged for it.
             */
            const nodeStateTracker = this.unreferencedNodesState.get(eventProps.id);
            const active = nodeStateTracker === undefined || nodeStateTracker.state === UnreferencedState.Active;
            if ((usageType === "Revived") === active) {
                const pkg = await this.getNodePackagePath(eventProps.id);
                const fromPkg = eventProps.fromId ? await this.getNodePackagePath(eventProps.fromId) : undefined;
                logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), { eventName: `${state}Object_${usageType}`, pkg: pkg ? { value: pkg.join("/"), tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.CodeArtifact } : undefined, fromPkg: fromPkg ? { value: fromPkg.join("/"), tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.CodeArtifact } : undefined }));
            }
        }
        this.pendingEventsQueue = [];
    }
}
/**
 * Gets the garbage collection state from the given snapshot tree. The GC state may be written into multiple blobs.
 * Merge the GC state from all such blobs and return the merged GC state.
 */
async function getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob) {
    let rootGCState = { gcNodes: {} };
    for (const key of Object.keys(gcSnapshotTree.blobs)) {
        // Skip blobs that do not start with the GC prefix.
        if (!key.startsWith(gcBlobPrefix)) {
            continue;
        }
        const blobId = gcSnapshotTree.blobs[key];
        if (blobId === undefined) {
            continue;
        }
        const gcState = await readAndParseBlob(blobId);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(gcState !== undefined, 0x2ad /* "GC blob missing from snapshot" */);
        // Merge the GC state of this blob into the root GC state.
        rootGCState = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_10__.concatGarbageCollectionStates)(rootGCState, gcState);
    }
    return rootGCState;
}
function generateSortedGCState(gcState) {
    const sortableArray = Object.entries(gcState.gcNodes);
    sortableArray.sort(([a], [b]) => a.localeCompare(b));
    const sortedGCState = { gcNodes: {} };
    for (const [nodeId, nodeData] of sortableArray) {
        nodeData.outboundRoutes.sort();
        sortedGCState.gcNodes[nodeId] = nodeData;
    }
    return sortedGCState;
}
/**
 * setLongTimeout is used for timeouts longer than setTimeout's ~24.8 day max
 * @param timeoutMs - the total time the timeout needs to last in ms
 * @param timeoutFn - the function to execute when the timer ends
 * @param setTimerFn - the function used to update your timer variable
 */
function setLongTimeout(timeoutMs, timeoutFn, setTimerFn) {
    // The setTimeout max is 24.8 days before looping occurs.
    const maxTimeout = 2147483647;
    let timer;
    if (timeoutMs > maxTimeout) {
        const newTimeoutMs = timeoutMs - maxTimeout;
        timer = setTimeout(() => setLongTimeout(newTimeoutMs, timeoutFn, setTimerFn), maxTimeout);
    }
    else {
        timer = setTimeout(() => timeoutFn(), timeoutMs);
    }
    setTimerFn(timer);
}
//# sourceMappingURL=garbageCollection.js.map

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromiseTimer": () => (/* binding */ PromiseTimer),
/* harmony export */   "Timer": () => (/* binding */ Timer)
/* harmony export */ });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * This class is a thin wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the same
 * or similar handlers and timeouts.
 */
class Timer {
    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {
        this.defaultTimeout = defaultTimeout;
        this.defaultHandler = defaultHandler;
        this.getCurrentTick = getCurrentTick;
    }
    /**
     * Returns true if the timer is running.
     */
    get hasTimer() {
        return !!this.runningState;
    }
    /**
     * Calls setTimeout and tracks the resulting timeout.
     * @param ms - overrides default timeout in ms
     * @param handler - overrides default handler
     */
    start(ms = this.defaultTimeout, handler = this.defaultHandler) {
        this.startCore(ms, handler, ms);
    }
    /**
     * Calls clearTimeout on the underlying timeout if running.
     */
    clear() {
        if (!this.runningState) {
            return;
        }
        clearTimeout(this.runningState.timeout);
        this.runningState = undefined;
    }
    /**
     * Restarts the timer with the new handler and duration.
     * If a new handler is passed, the original handler may
     * never execute.
     * This is a potentially more efficient way to clear and start
     * a new timer.
     * @param ms - overrides previous or default timeout in ms
     * @param handler - overrides previous or default handler
     */
    restart(ms, handler) {
        var _a, _b;
        if (!this.runningState) {
            // If restart is called first, it behaves as a call to start
            this.start(ms, handler);
        }
        else {
            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;
            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;
            const remainingTime = this.calculateRemainingTime(this.runningState);
            if (duration < remainingTime) {
                // If remaining time exceeds restart duration, do a hard restart.
                // The existing timeout time is too long.
                this.start(duration, handlerToUse);
            }
            else if (duration === remainingTime) {
                // The existing timeout time is perfect, just update handler and data.
                this.runningState.handler = handlerToUse;
                this.runningState.restart = undefined;
                this.runningState.intendedDuration = duration;
            }
            else {
                // If restart duration exceeds remaining time, set restart info.
                // Existing timeout will start a new timeout for remaining time.
                this.runningState.restart = {
                    startTick: this.getCurrentTick(),
                    duration,
                    handler: handlerToUse,
                };
            }
        }
    }
    startCore(duration, handler, intendedDuration) {
        this.clear();
        this.runningState = {
            startTick: this.getCurrentTick(),
            duration,
            intendedDuration,
            handler,
            timeout: setTimeout(() => this.handler(), duration),
        };
    }
    handler() {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.runningState, 0x00a /* "Running timer missing handler" */);
        const restart = this.runningState.restart;
        if (restart !== undefined) {
            // Restart with remaining time
            const remainingTime = this.calculateRemainingTime(restart);
            this.startCore(remainingTime, () => restart.handler(), restart.duration);
        }
        else {
            // Run clear first, in case the handler decides to start again
            const handler = this.runningState.handler;
            this.clear();
            handler();
        }
    }
    calculateRemainingTime(runningTimeout) {
        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;
        return runningTimeout.duration - elapsedTime;
    }
}
/**
 * This class is a wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the
 * same handlers and timeouts, while also providing a promise that
 * resolves when it times out.
 */
class PromiseTimer {
    constructor(defaultTimeout, defaultHandler) {
        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));
    }
    get hasTimer() {
        return this.timer.hasTimer;
    }
    async start(ms, handler) {
        this.clear();
        this.deferred = new _promises__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);
        return this.deferred.promise;
    }
    clear() {
        this.timer.clear();
        if (this.deferred) {
            this.deferred.resolve({ timerResult: "cancel" });
            this.deferred = undefined;
        }
    }
    wrapHandler(handler) {
        handler();
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.deferred, 0x00b /* "Handler executed without deferred" */);
        this.deferred.resolve({ timerResult: "timeout" });
        this.deferred = undefined;
    }
}
//# sourceMappingURL=timer.js.map

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aliasBlobName": () => (/* binding */ aliasBlobName),
/* harmony export */   "blobsTreeName": () => (/* binding */ blobsTreeName),
/* harmony export */   "chunksBlobName": () => (/* binding */ chunksBlobName),
/* harmony export */   "dataStoreAttributesBlobName": () => (/* binding */ dataStoreAttributesBlobName),
/* harmony export */   "electedSummarizerBlobName": () => (/* binding */ electedSummarizerBlobName),
/* harmony export */   "extractSummaryMetadataMessage": () => (/* binding */ extractSummaryMetadataMessage),
/* harmony export */   "getAttributesFormatVersion": () => (/* binding */ getAttributesFormatVersion),
/* harmony export */   "getFluidDataStoreAttributes": () => (/* binding */ getFluidDataStoreAttributes),
/* harmony export */   "getGCVersion": () => (/* binding */ getGCVersion),
/* harmony export */   "getMetadataFormatVersion": () => (/* binding */ getMetadataFormatVersion),
/* harmony export */   "hasIsolatedChannels": () => (/* binding */ hasIsolatedChannels),
/* harmony export */   "metadataBlobName": () => (/* binding */ metadataBlobName),
/* harmony export */   "nonDataStorePaths": () => (/* binding */ nonDataStorePaths),
/* harmony export */   "protocolTreeName": () => (/* binding */ protocolTreeName),
/* harmony export */   "rootHasIsolatedChannels": () => (/* binding */ rootHasIsolatedChannels),
/* harmony export */   "wrapSummaryInChannelsTree": () => (/* binding */ wrapSummaryInChannelsTree)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _garbageCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





function getAttributesFormatVersion(attributes) {
    if (attributes.summaryFormatVersion) {
        /**
         * Version 2+: Introduces .channels trees for isolation of
         * channel trees from data store objects.
         */
        return attributes.summaryFormatVersion;
    }
    else if (attributes.snapshotFormatVersion === "0.1") {
        /**
         * Version 1: from this version the pkg within the data store
         * attributes blob is a JSON array rather than a string.
         */
        return 1;
    }
    /**
     * Version 0: format version is missing from summary.
     * This indicates it is an older version.
     */
    return 0;
}
function hasIsolatedChannels(attributes) {
    return !!attributes.summaryFormatVersion && !attributes.disableIsolatedChannels;
}
/**
 * Extracts the properties from an ISequencedDocumentMessage as defined by ISummaryMetadataMessage. This message is
 * added to the metadata blob in summary.
 */
const extractSummaryMetadataMessage = (message) => message === undefined ? undefined : {
    clientId: message.clientId,
    clientSequenceNumber: message.clientSequenceNumber,
    minimumSequenceNumber: message.minimumSequenceNumber,
    referenceSequenceNumber: message.referenceSequenceNumber,
    sequenceNumber: message.sequenceNumber,
    timestamp: message.timestamp,
    type: message.type,
};
function getMetadataFormatVersion(metadata) {
    var _a;
    /**
     * Version 2+: Introduces runtime sequence number for data verification.
     *
     * Version 1+: Introduces .metadata blob and .channels trees for isolation of
     * data store trees from container-level objects.
     * Also introduces enableGC option stored in the summary.
     *
     * Version 0: metadata blob missing; format version is missing from summary.
     * This indicates it is an older version.
     */
    return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion) !== null && _a !== void 0 ? _a : 0;
}
const aliasBlobName = ".aliases";
const metadataBlobName = ".metadata";
const chunksBlobName = ".chunks";
const electedSummarizerBlobName = ".electedSummarizer";
const blobsTreeName = ".blobs";
function rootHasIsolatedChannels(metadata) {
    return !!metadata && !metadata.disableIsolatedChannels;
}
function getGCVersion(metadata) {
    var _a;
    if (!metadata) {
        // Force to 0/disallowed in prior versions
        return 0;
    }
    return (_a = metadata.gcFeature) !== null && _a !== void 0 ? _a : 0;
}
const protocolTreeName = ".protocol";
/**
 * List of tree IDs at the container level which are reserved.
 * This is for older versions of summaries that do not yet have an
 * isolated data stores namespace. Without the namespace, this must
 * be used to prevent name collisions with data store IDs.
 */
const nonDataStorePaths = [protocolTreeName, ".logTail", ".serviceProtocol", blobsTreeName, _garbageCollection__WEBPACK_IMPORTED_MODULE_0__.gcTreeKey];
const dataStoreAttributesBlobName = ".component";
/**
 * Modifies summary tree and stats to put tree under .channels tree.
 *
 * @param summarizeResult - Summary tree and stats to modify
 *
 * @example
 * Converts from:
 * ```typescript
 * {
 *     type: SummaryType.Tree,
 *     tree: { a: {...}, b: {...}, c: {...} },
 * }
 * ```
 *
 * to:
 *
 * ```typescript
 * {
 *     type: SummaryType.Tree,
 *     tree: {
 *         ".channels": {
 *             type: SummaryType.Tree,
 *             tree: { a: {...}, b: {...}, c: {...} }
 *         },
 *     },
 * }
 * ```
 * And adds +1 to treeNodeCount in stats.
 */
function wrapSummaryInChannelsTree(summarizeResult) {
    summarizeResult.summary = {
        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Tree,
        tree: { [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_2__.channelsTreeName]: summarizeResult.summary },
    };
    summarizeResult.stats.treeNodeCount++;
}
async function getFluidDataStoreAttributes(storage, snapshot) {
    const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_3__.readAndParse)(storage, snapshot.blobs[dataStoreAttributesBlobName]);
    // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.
    // For snapshotFormatVersion = "0.1" (1) or above, pkg is jsonified, otherwise it is just a string.
    // However the feature of loading a detached container from snapshot, is added when the
    // snapshotFormatVersion is at least "0.1" (1), so we don't expect it to be anything else.
    const formatVersion = getAttributesFormatVersion(attributes);
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(formatVersion > 0, 0x1d5 /* Invalid snapshot format version */);
    return attributes;
}
//# sourceMappingURL=summaryFormat.js.map

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readAndParse": () => (/* binding */ readAndParse)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Read a blob from IDocumentStorageService and JSON.parse it into object of type T
 *
 * @param storage - the IDocumentStorageService to read from
 * @param id - the id of the blob to read and parse
 * @returns the object that we decoded and JSON.parse
 */
async function readAndParse(storage, id) {
    const blob = await storage.readBlob(id);
    const decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, "utf8");
    return JSON.parse(decoded);
}
//# sourceMappingURL=readAndParse.js.map

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataStores": () => (/* binding */ DataStores),
/* harmony export */   "getSummaryForDatastores": () => (/* binding */ getSummaryForDatastores)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(25);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(97);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(99);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(63);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(27);
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(103);
/* harmony import */ var _dataStoreContexts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);
/* harmony import */ var _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85);
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(76);
/* harmony import */ var _dataStore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(101);
/* harmony import */ var _garbageCollection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(73);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */















/**
 * This class encapsulates data store handling. Currently it is only used by the container runtime,
 * but eventually could be hosted on any channel once we formalize the channel api boundary.
 */
class DataStores {
    constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, deleteChildSummarizerNodeFn, baseLogger, getBaseGCDetails, gcNodeUpdated, aliasMap, writeGCDataAtRoot, contexts = new _dataStoreContexts__WEBPACK_IMPORTED_MODULE_0__.DataStoreContexts(baseLogger)) {
        this.baseSnapshot = baseSnapshot;
        this.runtime = runtime;
        this.submitAttachFn = submitAttachFn;
        this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;
        this.deleteChildSummarizerNodeFn = deleteChildSummarizerNodeFn;
        this.gcNodeUpdated = gcNodeUpdated;
        this.aliasMap = aliasMap;
        this.writeGCDataAtRoot = writeGCDataAtRoot;
        this.contexts = contexts;
        // Stores tracked by the Domain
        this.pendingAttach = new Map();
        // 0.24 back-compat attachingBeforeSummary
        this.attachOpFiredForDataStore = new Set();
        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => this.contexts.dispose());
        // Stores the ids of new data stores between two GC runs. This is used to notify the garbage collector of new
        // root data stores that are added.
        this.dataStoresSinceLastGC = [];
        this.dispose = () => this.disposeOnce.value;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(baseLogger);
        this.containerRuntimeHandle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__.FluidObjectHandle(this.runtime, "/", this.runtime.IFluidHandleContext);
        const baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.LazyPromise(async () => {
            return getBaseGCDetails();
        });
        // Returns the base GC details for the data store with the given id.
        const dataStoreBaseGCDetails = async (dataStoreId) => {
            const baseGCDetails = await baseGCDetailsP;
            return baseGCDetails.get(dataStoreId);
        };
        // Extract stores stored inside the snapshot
        const fluidDataStores = new Map();
        if (baseSnapshot) {
            for (const [key, value] of Object.entries(baseSnapshot.trees)) {
                fluidDataStores.set(key, value);
            }
        }
        let unreferencedDataStoreCount = 0;
        // Create a context for each of them
        for (const [key, value] of fluidDataStores) {
            let dataStoreContext;
            // counting number of unreferenced data stores
            if (value.unreferenced) {
                unreferencedDataStoreCount++;
            }
            // If we have a detached container, then create local data store contexts.
            if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached) {
                dataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.RemoteFluidDataStoreContext({
                    id: key,
                    snapshotTree: value,
                    getBaseGCDetails: async () => dataStoreBaseGCDetails(key),
                    runtime: this.runtime,
                    storage: this.runtime.storage,
                    scope: this.runtime.scope,
                    createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.FromSummary }),
                    writeGCDataAtRoot: this.writeGCDataAtRoot,
                    disableIsolatedChannels: this.runtime.disableIsolatedChannels,
                });
            }
            else {
                if (typeof value !== "object") {
                    throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__.LoggingError("Snapshot should be there to load from!!");
                }
                const snapshotTree = value;
                dataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.LocalFluidDataStoreContext({
                    id: key,
                    pkg: undefined,
                    runtime: this.runtime,
                    storage: this.runtime.storage,
                    scope: this.runtime.scope,
                    createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.FromSummary }),
                    makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(key),
                    snapshotTree,
                    isRootDataStore: undefined,
                    writeGCDataAtRoot: this.writeGCDataAtRoot,
                    disableIsolatedChannels: this.runtime.disableIsolatedChannels,
                });
            }
            this.contexts.addBoundOrRemoted(dataStoreContext);
        }
        this.containerLoadStats = {
            containerLoadDataStoreCount: fluidDataStores.size,
            referencedDataStoreCount: fluidDataStores.size - unreferencedDataStoreCount,
        };
    }
    aliases() {
        return this.aliasMap;
    }
    processAttachMessage(message, local) {
        var _a, _b;
        const attachMessage = message.contents;
        this.dataStoresSinceLastGC.push(attachMessage.id);
        // The local object has already been attached
        if (local) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(this.pendingAttach.has(attachMessage.id), 0x15e /* "Local object does not have matching attach message id" */);
            (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit("attached");
            this.pendingAttach.delete(attachMessage.id);
            return;
        }
        // If a non-local operation then go and create the object, otherwise mark it as officially attached.
        if (this.alreadyProcessed(attachMessage.id)) {
            // TODO: dataStoreId may require a different tag from PackageData #7488
            const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.DataCorruptionError(
            // pre-0.58 error message: duplicateDataStoreCreatedWithExistingId
            "Duplicate DataStore created with existing id", Object.assign(Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.extractSafePropertiesFromMessage)(message)), { dataStoreId: {
                    value: attachMessage.id,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.PackageData,
                } }));
            throw error;
        }
        const flatBlobs = new Map();
        let snapshotTree;
        if (attachMessage.snapshot) {
            snapshotTree = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);
        }
        // Include the type of attach message which is the pkg of the store to be
        // used by RemoteFluidDataStoreContext in case it is not in the snapshot.
        const pkg = [attachMessage.type];
        const remoteFluidDataStoreContext = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.RemoteFluidDataStoreContext({
            id: attachMessage.id,
            snapshotTree,
            // New data stores begin with empty GC details since GC hasn't run on them yet.
            getBaseGCDetails: async () => { return {}; },
            runtime: this.runtime,
            storage: new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__.BlobCacheStorageService(this.runtime.storage, flatBlobs),
            scope: this.runtime.scope,
            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(attachMessage.id, {
                type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.FromAttach,
                sequenceNumber: message.sequenceNumber,
                snapshot: (_b = attachMessage.snapshot) !== null && _b !== void 0 ? _b : {
                    entries: [(0,_dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.createAttributesBlob)(pkg, true /* isRootDataStore */, this.runtime.disableIsolatedChannels)],
                },
            }),
            writeGCDataAtRoot: this.writeGCDataAtRoot,
            disableIsolatedChannels: this.runtime.disableIsolatedChannels,
            pkg,
        });
        this.contexts.addBoundOrRemoted(remoteFluidDataStoreContext);
    }
    processAliasMessage(message, localOpMetadata, local) {
        const aliasMessage = message.contents;
        if (!(0,_dataStore__WEBPACK_IMPORTED_MODULE_13__.isDataStoreAliasMessage)(aliasMessage)) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.DataCorruptionError("malformedDataStoreAliasMessage", Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_10__.extractSafePropertiesFromMessage)(message)));
        }
        const resolve = localOpMetadata;
        const aliasResult = this.processAliasMessageCore(aliasMessage);
        if (local) {
            resolve(aliasResult);
        }
    }
    processAliasMessageCore(aliasMessage) {
        if (this.alreadyProcessed(aliasMessage.alias)) {
            return false;
        }
        const context = this.contexts.get(aliasMessage.internalId);
        if (context === undefined) {
            this.logger.sendErrorEvent({
                eventName: "AliasFluidDataStoreNotFound",
                fluidDataStoreId: aliasMessage.internalId,
            });
            return false;
        }
        const handle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__.FluidObjectHandle(context, aliasMessage.internalId, this.runtime.IFluidHandleContext);
        this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);
        this.aliasMap.set(aliasMessage.alias, context.id);
        context.setInMemoryRoot();
        return true;
    }
    alreadyProcessed(id) {
        return this.aliasMap.get(id) !== undefined || this.contexts.get(id) !== undefined;
    }
    /**
     * Make the data stores locally visible in the container graph by moving the data store context from unbound to
     * bound list. This data store can now be reached from the root.
     * @param id - The id of the data store context to make visible.
     */
    makeDataStoreLocallyVisible(id) {
        const localContext = this.contexts.getUnbound(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!localContext, 0x15f /* "Could not find unbound context to bind" */);
        /**
         * If the container is not detached, it is globally visible to all clients. This data store should also be
         * globally visible. Move it to attaching state and send an "attach" op for it.
         * If the container is detached, this data store will be part of the summary that makes the container attached.
         */
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Detached) {
            localContext.emit("attaching");
            const message = localContext.generateAttachMessage();
            this.pendingAttach.set(id, message);
            this.submitAttachFn(message);
            this.attachOpFiredForDataStore.add(id);
        }
        this.contexts.bind(id);
    }
    createDetachedDataStoreCore(pkg, isRoot, id = (0,uuid__WEBPACK_IMPORTED_MODULE_14__["default"])()) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!id.includes("/"), 0x30c /* Id cannot contain slashes */);
        const context = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.LocalDetachedFluidDataStoreContext({
            id,
            pkg,
            runtime: this.runtime,
            storage: this.runtime.storage,
            scope: this.runtime.scope,
            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.Local }),
            makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),
            snapshotTree: undefined,
            isRootDataStore: isRoot,
            writeGCDataAtRoot: this.writeGCDataAtRoot,
            disableIsolatedChannels: this.runtime.disableIsolatedChannels,
        });
        this.contexts.addUnbound(context);
        return context;
    }
    _createFluidDataStoreContext(pkg, id, isRoot, props) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!id.includes("/"), 0x30d /* Id cannot contain slashes */);
        const context = new _dataStoreContext__WEBPACK_IMPORTED_MODULE_6__.LocalFluidDataStoreContext({
            id,
            pkg,
            runtime: this.runtime,
            storage: this.runtime.storage,
            scope: this.runtime.scope,
            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.CreateSummarizerNodeSource.Local }),
            makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),
            snapshotTree: undefined,
            isRootDataStore: isRoot,
            writeGCDataAtRoot: this.writeGCDataAtRoot,
            disableIsolatedChannels: this.runtime.disableIsolatedChannels,
            createProps: props,
        });
        this.contexts.addUnbound(context);
        return context;
    }
    get disposed() { return this.disposeOnce.evaluated; }
    resubmitDataStoreOp(content, localOpMetadata) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x160 /* "There should be a store context for the op" */);
        context.reSubmit(envelope.contents, localOpMetadata);
    }
    rollbackDataStoreOp(content, localOpMetadata) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x2e8 /* "There should be a store context for the op" */);
        context.rollback(envelope.contents, localOpMetadata);
    }
    async applyStashedOp(content) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x161 /* "There should be a store context for the op" */);
        return context.applyStashedOp(envelope.contents);
    }
    async applyStashedAttachOp(message) {
        this.pendingAttach.set(message.id, message);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        this.processAttachMessage({ contents: message }, false);
    }
    processFluidDataStoreOp(message, local, localMessageMetadata) {
        const envelope = message.contents;
        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });
        const context = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!context, 0x162 /* "There should be a store context for the op" */);
        context.process(transformed, local, localMessageMetadata);
        // Notify that a GC node for the data store changed. This is used to detect if a deleted data store is
        // being used.
        this.gcNodeUpdated(`/${envelope.address}`, message.timestamp, context.isLoaded ? context.packagePath : undefined);
    }
    async getDataStore(id, wait) {
        const context = await this.contexts.getBoundOrRemoted(id, wait);
        if (context === undefined) {
            // The requested data store does not exits. Throw a 404 response exception.
            const request = { url: id };
            throw (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__.responseToException)((0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_15__.create404Response)(request), request);
        }
        return context;
    }
    processSignal(address, message, local) {
        const context = this.contexts.get(address);
        if (!context) {
            // Attach message may not have been processed yet
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!local, 0x163 /* "Missing datastore for local signal" */);
            this.logger.sendTelemetryEvent({
                eventName: "SignalFluidDataStoreNotFound",
                fluidDataStoreId: {
                    value: address,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.TelemetryDataTag.PackageData,
                },
            });
            return;
        }
        context.processSignal(message, local);
    }
    setConnectionState(connected, clientId) {
        for (const [fluidDataStore, context] of this.contexts) {
            try {
                context.setConnectionState(connected, clientId);
            }
            catch (error) {
                this.logger.sendErrorEvent({
                    eventName: "SetConnectionStateError",
                    clientId,
                    fluidDataStore,
                }, error);
            }
        }
    }
    setAttachState(attachState) {
        let eventName;
        if (attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attaching) {
            eventName = "attaching";
        }
        else {
            eventName = "attached";
        }
        for (const [, context] of this.contexts) {
            // Fire only for bounded stores.
            if (!this.contexts.isNotBound(context.id)) {
                context.emit(eventName);
            }
        }
    }
    get size() {
        return this.contexts.size;
    }
    async summarize(fullTree, trackState, telemetryContext) {
        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();
        // Iterate over each store and ask it to snapshot
        await Promise.all(Array.from(this.contexts)
            .filter(([_, context]) => {
            // Summarizer works only with clients with no local changes!
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(context.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attaching, 0x165 /* "Summarizer cannot work if client has local changes" */);
            return context.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached;
        }).map(async ([contextId, context]) => {
            const contextSummary = await context.summarize(fullTree, trackState, telemetryContext);
            summaryBuilder.addWithStats(contextId, contextSummary);
        }));
        return summaryBuilder.getSummaryTree();
    }
    createSummary(telemetryContext) {
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();
        // Attaching graph of some stores can cause other stores to get bound too.
        // So keep taking summary until no new stores get bound.
        let notBoundContextsLength;
        do {
            const builderTree = builder.summary.tree;
            notBoundContextsLength = this.contexts.notBoundLength();
            // Iterate over each data store and ask it to snapshot
            Array.from(this.contexts)
                .filter(([key, _]) => 
            // Take summary of bounded data stores only, make sure we haven't summarized them already
            // and no attach op has been fired for that data store because for loader versions <= 0.24
            // we set attach state as "attaching" before taking createNew summary.
            !(this.contexts.isNotBound(key)
                || builderTree[key]
                || this.attachOpFiredForDataStore.has(key)))
                .map(([key, value]) => {
                let dataStoreSummary;
                if (value.isLoaded) {
                    const snapshot = value.generateAttachMessage().snapshot;
                    dataStoreSummary = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertToSummaryTree)(snapshot, true);
                }
                else {
                    // If this data store is not yet loaded, then there should be no changes in the snapshot from
                    // which it was created as it is detached container. So just use the previous snapshot.
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!this.baseSnapshot, 0x166 /* "BaseSnapshot should be there as detached container loaded from snapshot" */);
                    dataStoreSummary = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertSnapshotTreeToSummaryTree)(this.baseSnapshot.trees[key]);
                }
                builder.addWithStats(key, dataStoreSummary);
            });
        } while (notBoundContextsLength !== this.contexts.notBoundLength());
        return builder.getSummaryTree();
    }
    /**
     * Before GC runs, called by the garbage collector to update any pending GC state.
     * The garbage collector needs to know all outbound references that are added. Since root data stores are not
     * explicitly marked as referenced, notify GC of new root data stores that were added since the last GC run.
     */
    async updateStateBeforeGC() {
        for (const id of this.dataStoresSinceLastGC) {
            const context = this.contexts.get(id);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(context !== undefined, 0x2b6 /* Missing data store context */);
            if (await context.isRoot()) {
                // A root data store is basically a reference from the container runtime to the data store.
                const handle = new _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_3__.FluidObjectHandle(context, id, this.runtime.IFluidHandleContext);
                this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);
            }
        }
        this.dataStoresSinceLastGC = [];
    }
    /**
     * Generates data used for garbage collection. It does the following:
     * 1. Calls into each child data store context to get its GC data.
     * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be
     *    identified as belonging to the child.
     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent
     *    the GC data of this channel.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_17__.GCDataBuilder();
        // Iterate over each store and get their GC data.
        await Promise.all(Array.from(this.contexts)
            .filter(([_, context]) => {
            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference
            // graph so any references they might have won't be connected as well.
            return context.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_5__.AttachState.Attached;
        }).map(async ([contextId, context]) => {
            const contextGCData = await context.getGCData(fullGC);
            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.
            // This also gradually builds the id of each node to be a path from the root.
            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);
        }));
        // Get the outbound routes and add a GC node for this channel.
        builder.addNode("/", await this.getOutboundRoutes());
        return builder.getGCData();
    }
    /**
     * After GC has run, called to notify this Container's data stores of routes that are used in it.
     * @param usedRoutes - The routes that are used in all data stores in this Container.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes
     * unreferenced as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        var _a;
        // Get a map of data store ids to routes used in it.
        const usedDataStoreRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_17__.unpackChildNodesUsedRoutes)(usedRoutes);
        // Verify that the used routes are correct.
        for (const [id] of usedDataStoreRoutes) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(this.contexts.has(id), 0x167 /* "Used route does not belong to any known data store" */);
        }
        // Update the used routes in each data store. Used routes is empty for unused data stores.
        for (const [contextId, context] of this.contexts) {
            context.updateUsedRoutes((_a = usedDataStoreRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);
        }
    }
    /**
     * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing
     * scenarios with accessing deleted content.
     * @param unusedRoutes - The routes that are unused in all data stores in this Container.
     */
    deleteUnusedRoutes(unusedRoutes) {
        for (const route of unusedRoutes) {
            const pathParts = route.split("/");
            // Delete data store only if its route (/datastoreId) is in unusedRoutes. We don't want to delete a data
            // store based on its DDS being unused.
            if (pathParts.length > 2) {
                continue;
            }
            const dataStoreId = pathParts[1];
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(this.contexts.has(dataStoreId), 0x2d7 /* No data store with specified id */);
            // Delete the contexts of unused data stores.
            this.contexts.delete(dataStoreId);
            // Delete the summarizer node of the unused data stores.
            this.deleteChildSummarizerNodeFn(dataStoreId);
        }
    }
    /**
     * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are
     * part of outbound routes.
     */
    async getOutboundRoutes() {
        const outboundRoutes = [];
        for (const [contextId, context] of this.contexts) {
            const isRootDataStore = await context.isRoot();
            if (isRootDataStore) {
                outboundRoutes.push(`/${contextId}`);
            }
        }
        return outboundRoutes;
    }
    /**
     * Called by GC to retrieve the package path of a data store node with the given path.
     */
    async getDataStorePackagePath(nodePath) {
        var _a;
        // If the node belongs to a data store, return its package path. For DDSes, we return the package path of the
        // data store that contains it.
        const context = this.contexts.get(nodePath.split("/")[1]);
        return (_a = (await (context === null || context === void 0 ? void 0 : context.getInitialSnapshotDetails()))) === null || _a === void 0 ? void 0 : _a.pkg;
    }
    /**
     * Called by GC to determine if a node is for a data store or for an object within a data store (for e.g. DDS).
     * @returns the GC node type if the node belongs to a data store or object within data store, undefined otherwise.
     */
    getGCNodeType(nodePath) {
        const pathParts = nodePath.split("/");
        if (!this.contexts.has(pathParts[1])) {
            return undefined;
        }
        // Data stores paths are of the format "/dataStoreId".
        // Sub data store paths are of the format "/dataStoreId/subPath/...".
        if (pathParts.length === 2) {
            return _garbageCollection__WEBPACK_IMPORTED_MODULE_18__.GCNodeType.DataStore;
        }
        return _garbageCollection__WEBPACK_IMPORTED_MODULE_18__.GCNodeType.SubDataStore;
    }
}
function getSummaryForDatastores(snapshot, metadata) {
    if (!snapshot) {
        return undefined;
    }
    if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_19__.rootHasIsolatedChannels)(metadata)) {
        const datastoresSnapshot = snapshot.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_7__.channelsTreeName];
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.assert)(!!datastoresSnapshot, 0x168 /* Expected tree in snapshot not found */);
        return datastoresSnapshot;
    }
    else {
        // back-compat: strip out all non-datastore paths before giving to DataStores object.
        const datastoresTrees = {};
        for (const [key, value] of Object.entries(snapshot.trees)) {
            if (!_summaryFormat__WEBPACK_IMPORTED_MODULE_19__.nonDataStorePaths.includes(key)) {
                datastoresTrees[key] = value;
            }
        }
        return Object.assign(Object.assign({}, snapshot), { trees: datastoresTrees });
    }
}
//# sourceMappingURL=dataStores.js.map

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataStoreContexts": () => (/* binding */ DataStoreContexts)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


class DataStoreContexts {
    constructor(baseLogger) {
        this.notBoundContexts = new Set();
        /** Attached and loaded context proxies */
        this._contexts = new Map();
        /**
         * List of pending context waiting either to be bound or to arrive from another client.
         * This covers the case where a local context has been created but not yet bound,
         * or the case where a client knows a store will exist and is waiting on its creation,
         * so that a caller may await the deferred's promise until such a time as the context is fully ready.
         * This is a superset of _contexts, since contexts remain here once the Deferred resolves.
         */
        this.deferredContexts = new Map();
        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => {
            // close/stop all store contexts
            for (const [fluidDataStoreId, contextD] of this.deferredContexts) {
                contextD.promise.then((context) => {
                    context.dispose();
                }).catch((contextError) => {
                    this._logger.sendErrorEvent({
                        eventName: "FluidDataStoreContextDisposeError",
                        fluidDataStoreId,
                    }, contextError);
                });
            }
        });
        this.dispose = () => this.disposeOnce.value;
        this._logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger);
    }
    [Symbol.iterator]() {
        return this._contexts.entries();
    }
    get size() {
        return this._contexts.size;
    }
    get disposed() { return this.disposeOnce.evaluated; }
    notBoundLength() {
        return this.notBoundContexts.size;
    }
    isNotBound(id) {
        return this.notBoundContexts.has(id);
    }
    has(id) {
        return this._contexts.has(id);
    }
    get(id) {
        return this._contexts.get(id);
    }
    delete(id) {
        this.deferredContexts.delete(id);
        this.notBoundContexts.delete(id);
        return this._contexts.delete(id);
    }
    /**
     * Return the unbound local context with the given id,
     * or undefined if it's not found or not unbound.
     */
    getUnbound(id) {
        const context = this._contexts.get(id);
        if (context === undefined || !this.notBoundContexts.has(id)) {
            return undefined;
        }
        return this._contexts.get(id);
    }
    /**
     * Add the given context, marking it as to-be-bound
     */
    addUnbound(context) {
        const id = context.id;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this._contexts.has(id), 0x158 /* "Creating store with existing ID" */);
        this._contexts.set(id, context);
        this.notBoundContexts.add(id);
        this.ensureDeferred(id);
    }
    /**
     * Get the context with the given id, once it exists locally and is attached.
     * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.
     * @param id - The id of the context to get
     * @param wait - If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.
     */
    async getBoundOrRemoted(id, wait) {
        const deferredContext = this.ensureDeferred(id);
        if (!wait && !deferredContext.isCompleted) {
            return undefined;
        }
        return deferredContext.promise;
    }
    ensureDeferred(id) {
        const deferred = this.deferredContexts.get(id);
        if (deferred) {
            return deferred;
        }
        const newDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Deferred();
        this.deferredContexts.set(id, newDeferred);
        return newDeferred;
    }
    /**
     * Update this context as bound
     */
    bind(id) {
        const removed = this.notBoundContexts.delete(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(removed, 0x159 /* "The given id was not found in notBoundContexts to delete" */);
        this.resolveDeferred(id);
    }
    /**
     * Triggers the deferred to resolve, indicating the context is not local-only
     * @param id - The id of the context to resolve to
     */
    resolveDeferred(id) {
        const context = this._contexts.get(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!context, 0x15a /* "Cannot find context to resolve to" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.notBoundContexts.has(id), 0x15b /* "Expected this id to already be removed from notBoundContexts" */);
        const deferred = this.deferredContexts.get(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!deferred, 0x15c /* "Cannot find deferred to resolve" */);
        deferred.resolve(context);
    }
    /**
     * Add the given context, marking it as not local-only.
     * This could be because it's a local context that's been bound, or because it's a remote context.
     * @param context - The context to add
     */
    addBoundOrRemoted(context) {
        const id = context.id;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this._contexts.has(id), 0x15d /* "Creating store with existing ID" */);
        this._contexts.set(id, context);
        // Resolve the deferred immediately since this context is not unbound
        this.ensureDeferred(id);
        this.resolveDeferred(id);
    }
}
//# sourceMappingURL=dataStoreContexts.js.map

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lazy": () => (/* binding */ Lazy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable
  */
class Lazy {
    /**
     * Instantiates an instance of Lazy<T>
     * @param valueGenerator - the function that will generate the value when value is accessed the first time
     */
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this._evaluated = false;
    }
    /**
     * Return true if the value as been generated, otherwise false
     */
    get evaluated() {
        return this._evaluated;
    }
    /**
     * Get the value. If this is the first call the value will be generated
     */
    get value() {
        if (!this._evaluated) {
            this._evaluated = true;
            this._value = this.valueGenerator();
        }
        return this._value;
    }
}
//# sourceMappingURL=lazy.js.map

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidDataStoreContext": () => (/* binding */ FluidDataStoreContext),
/* harmony export */   "LocalDetachedFluidDataStoreContext": () => (/* binding */ LocalDetachedFluidDataStoreContext),
/* harmony export */   "LocalFluidDataStoreContext": () => (/* binding */ LocalFluidDataStoreContext),
/* harmony export */   "LocalFluidDataStoreContextBase": () => (/* binding */ LocalFluidDataStoreContextBase),
/* harmony export */   "RemoteFluidDataStoreContext": () => (/* binding */ RemoteFluidDataStoreContext),
/* harmony export */   "createAttributesBlob": () => (/* binding */ createAttributesBlob)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(90);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(51);
/* harmony import */ var _summaryFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */









function createAttributes(pkg, isRootDataStore, disableIsolatedChannels) {
    const stringifiedPkg = JSON.stringify(pkg);
    return disableIsolatedChannels ? {
        pkg: stringifiedPkg,
        snapshotFormatVersion: "0.1",
        isRootDataStore,
    } : {
        pkg: stringifiedPkg,
        summaryFormatVersion: 2,
        isRootDataStore,
    };
}
function createAttributesBlob(pkg, isRootDataStore, disableIsolatedChannels) {
    const attributes = createAttributes(pkg, isRootDataStore, disableIsolatedChannels);
    return new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.BlobTreeEntry(_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));
}
/**
 * Represents the context for the store. This context is passed to the store runtime.
 */
class FluidDataStoreContext extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(props, existing, bindState, isLocalDataStore, makeLocallyVisibleFn) {
        super();
        this.existing = existing;
        this.bindState = bindState;
        this.isLocalDataStore = isLocalDataStore;
        this.makeLocallyVisibleFn = makeLocallyVisibleFn;
        this._disposed = false;
        this.detachedRuntimeCreation = false;
        this.loaded = false;
        this.pending = [];
        this._isInMemoryRoot = false;
        this._containerRuntime = props.runtime;
        this.id = props.id;
        this.storage = props.storage;
        this.scope = props.scope;
        this.writeGCDataAtRoot = props.writeGCDataAtRoot;
        this.disableIsolatedChannels = props.disableIsolatedChannels;
        this.pkg = props.pkg;
        // URIs use slashes as delimiters. Handles use URIs.
        // Thus having slashes in types almost guarantees trouble down the road!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.id.includes("/"), 0x13a /* Data store ID contains slash */);
        this._attachState = this.containerRuntime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached && this.existing ?
            this.containerRuntime.attachState : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached;
        this.bindToContext = () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.bindState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.NotBound, 0x13b /* "datastore context is already in bound state" */);
            this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Binding;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x13c /* "undefined channel on datastore context" */);
            this.makeLocallyVisible();
            this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound;
        };
        const thisSummarizeInternal = async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext);
        this.summarizerNode = props.createSummarizerNodeFn(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => this.getBaseGCDetails());
        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(this.logger, "FluidDataStoreContext");
        this.thresholdOpsCounter = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ThresholdCounter(FluidDataStoreContext.pendingOpsCountThreshold, this.subLogger);
    }
    get packagePath() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x139 /* "Undefined package path" */);
        return this.pkg;
    }
    get options() {
        return this._containerRuntime.options;
    }
    get clientId() {
        return this._containerRuntime.clientId;
    }
    get clientDetails() {
        return this._containerRuntime.clientDetails;
    }
    get logger() {
        return this._containerRuntime.logger;
    }
    get deltaManager() {
        return this._containerRuntime.deltaManager;
    }
    get connected() {
        return this._containerRuntime.connected;
    }
    get IFluidHandleContext() {
        return this._containerRuntime.IFluidHandleContext;
    }
    get containerRuntime() {
        return this._containerRuntime;
    }
    get isLoaded() {
        return this.loaded;
    }
    get baseSnapshot() {
        return this._baseSnapshot;
    }
    get disposed() { return this._disposed; }
    get attachState() {
        return this._attachState;
    }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    /**
     * A datastore is considered as root if it
     * 1. is root in memory - see isInMemoryRoot
     * 2. is root as part of the base snapshot that the datastore loaded from
     * @returns whether a datastore is root
     */
    async isRoot() {
        return this.isInMemoryRoot() || (await this.getInitialSnapshotDetails()).isRootDataStore;
    }
    /**
     * There are 3 states where isInMemoryRoot needs to be true
     * 1. when a datastore becomes aliased. This can happen for both remote and local datastores
     * 2. when a datastore is created locally as root
     * 3. when a datastore is created locally as root and is rehydrated
     * @returns whether a datastore is root in memory
     */
    isInMemoryRoot() {
        return this._isInMemoryRoot;
    }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        // Dispose any pending runtime after it gets fulfilled
        // Errors are logged where this.channelDeferred is consumed/generated (realizeCore(), bindRuntime())
        if (this.channelDeferred) {
            this.channelDeferred.promise.then((runtime) => {
                runtime.dispose();
            }).catch((error) => { });
        }
    }
    rejectDeferredRealize(reason, packageName) {
        throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError(reason, { packageName: { value: packageName, tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.TelemetryDataTag.PackageData } });
    }
    async realize() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.detachedRuntimeCreation, 0x13d /* "Detached runtime creation on realize()" */);
        if (!this.channelDeferred) {
            this.channelDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.Deferred();
            this.realizeCore(this.existing).catch((error) => {
                var _a;
                const errorWrapped = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_9__.DataProcessingError.wrapIfUnrecognized(error, "realizeFluidDataStoreContext");
                errorWrapped.addTelemetryProperties({ fluidDataStoreId: { value: this.id, tag: "PackageData" } });
                (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(errorWrapped);
                this.logger.sendErrorEvent({ eventName: "RealizeError" }, errorWrapped);
            });
        }
        return this.channelDeferred.promise;
    }
    async factoryFromPackagePath(packages) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg === packages, 0x13e /* "Unexpected package path" */);
        if (packages === undefined) {
            this.rejectDeferredRealize("packages is undefined");
        }
        let entry;
        let registry = this._containerRuntime.IFluidDataStoreRegistry;
        let lastPkg;
        for (const pkg of packages) {
            if (!registry) {
                this.rejectDeferredRealize("No registry for package", lastPkg);
            }
            lastPkg = pkg;
            entry = await registry.get(pkg);
            if (!entry) {
                this.rejectDeferredRealize("Registry does not contain entry for the package", pkg);
            }
            registry = entry.IFluidDataStoreRegistry;
        }
        const factory = entry === null || entry === void 0 ? void 0 : entry.IFluidDataStoreFactory;
        if (factory === undefined) {
            this.rejectDeferredRealize("Can't find factory for package", lastPkg);
        }
        return { factory, registry };
    }
    async realizeCore(existing) {
        const details = await this.getInitialSnapshotDetails();
        // Base snapshot is the baseline where pending ops are applied to.
        // It is important that this be in sync with the pending ops, and also
        // that it is set here, before bindRuntime is called.
        this._baseSnapshot = details.snapshot;
        const packages = details.pkg;
        const { factory, registry } = await this.factoryFromPackagePath(packages);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.registry === undefined, 0x13f /* "datastore context registry is already set" */);
        this.registry = registry;
        const channel = await factory.instantiateDataStore(this, existing);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(channel !== undefined, 0x140 /* "undefined channel on datastore context" */);
        this.bindRuntime(channel);
    }
    /**
     * Notifies this object about changes in the connection state.
     * @param value - New connection state.
     * @param clientId - ID of the client. It's old ID when in disconnected state and
     * it's new client ID when we are connecting or connected.
     */
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        // Connection events are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connected === connected, 0x141 /* "Unexpected connected state" */);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.channel.setConnectionState(connected, clientId);
    }
    process(messageArg, local, localOpMetadata) {
        var _a;
        this.verifyNotClosed();
        const innerContents = messageArg.contents;
        const message = Object.assign(Object.assign({}, messageArg), { type: innerContents.type, contents: innerContents.content });
        this.summarizerNode.recordChange(message);
        if (this.loaded) {
            return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!local, 0x142 /* "local store channel is not loaded" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pending !== undefined, 0x23d /* "pending is undefined" */);
            this.pending.push(message);
            this.thresholdOpsCounter.sendIfMultiple("StorePendingOps", this.pending.length);
        }
    }
    processSignal(message, local) {
        var _a;
        this.verifyNotClosed();
        // Signals are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);
    }
    getQuorum() {
        return this._containerRuntime.getQuorum();
    }
    getAudience() {
        return this._containerRuntime.getAudience();
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = true, telemetryContext) {
        return this.summarizerNode.summarize(fullTree, trackState, telemetryContext);
    }
    async summarizeInternal(fullTree, trackState, telemetryContext) {
        await this.realize();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const summarizeResult = await this.channel.summarize(fullTree, trackState, telemetryContext);
        let pathPartsForChildren;
        if (!this.disableIsolatedChannels) {
            // Wrap dds summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.wrapSummaryInChannelsTree)(summarizeResult);
            pathPartsForChildren = [_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.channelsTreeName];
        }
        // Add data store's attributes to the summary.
        const { pkg } = await this.getInitialSnapshotDetails();
        const isRoot = await this.isRoot();
        const attributes = createAttributes(pkg, isRoot, this.disableIsolatedChannels);
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.addBlobToSummary)(summarizeResult, _summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));
        // Add GC data to the summary if it's not written at the root.
        if (!this.writeGCDataAtRoot) {
            (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.addBlobToSummary)(summarizeResult, _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.gcBlobKey, JSON.stringify(this.summarizerNode.getGCSummaryDetails()));
        }
        // If we are not referenced, mark the summary tree as unreferenced. Also, update unreferenced blob
        // size in the summary stats with the blobs size of this data store.
        if (!this.summarizerNode.isReferenced()) {
            summarizeResult.summary.unreferenced = true;
            summarizeResult.stats.unreferencedBlobSize = summarizeResult.stats.totalBlobSize;
        }
        return Object.assign(Object.assign({}, summarizeResult), { id: this.id, pathPartsForChildren });
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this data store
     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the
     * document.
     * If there is no new data in this data store since the last summary, previous GC data is used.
     * If there is new data, the GC data is generated again (by calling getGCDataInternal).
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        return this.summarizerNode.getGCData(fullGC);
    }
    /**
     * Generates data used for garbage collection. This is called when there is new data since last summary. It
     * realizes the data store and calls into each channel context to get its GC data.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCDataInternal(fullGC = false) {
        await this.realize();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x143 /* "Channel should not be undefined when running GC" */);
        return this.channel.getGCData(fullGC);
    }
    /**
     * After GC has run, called to notify the data store of routes used in it. These are used for the following:
     * 1. To identify if this data store is being referenced in the document or not.
     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.
     * 3. These are added to the summary generated by the data store.
     * 4. To notify child contexts of their used routes. This is done immediately if the data store is loaded. Else,
     *    it is done when realizing the data store.
     * 5. To update the timestamp when this data store or any children are marked as unreferenced.
     * @param usedRoutes - The routes that are used in this data store.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced
     * as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        // Update the used routes in this data store's summarizer node.
        this.summarizerNode.updateUsedRoutes(usedRoutes, gcTimestamp);
        /**
         * If the data store has not been realized yet, we need this used state to update the used state of the channel
         * when it realizes. It's safe to keep only the last used state because if something changes because of this GC
         * run, the data store will be immediately realized as part of the summary that follows GC. For example, if a
         * child's reference state changes, the gcTimestamp has to be used to update its unreferencedTimestamp. Since
         * it will result in a change in this data store's used routes, it will be realized to regenerate its summary.
         */
        this.lastUsedState = { usedRoutes, gcTimestamp };
        // If we are loaded, call the channel so it can update the used routes of the child contexts.
        // If we are not loaded, we will update this when we are realized.
        if (this.loaded) {
            this.updateChannelUsedRoutes();
        }
    }
    /**
     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify
     * all references added in the system.
     * @param srcHandle - The handle of the node that added the reference.
     * @param outboundHandle - The handle of the outbound node that is referenced.
     */
    addedGCOutboundReference(srcHandle, outboundHandle) {
        this._containerRuntime.addedGCOutboundReference(srcHandle, outboundHandle);
    }
    /**
     * Updates the used routes of the channel and its child contexts. The channel must be loaded before calling this.
     * It is called in these two scenarios:
     * 1. When the used routes of the data store is updated and the data store is loaded.
     * 2. When the data store is realized. This updates the channel's used routes as per last GC run.
     */
    updateChannelUsedRoutes() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.loaded, 0x144 /* "Channel should be loaded when updating used routes" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x145 /* "Channel should be present when data store is loaded" */);
        // If there is no lastUsedState, GC has not run up until this point.
        if (this.lastUsedState === undefined) {
            return;
        }
        // Remove the route to this data store, if it exists.
        const usedChannelRoutes = this.lastUsedState.usedRoutes.filter((id) => { return id !== "/" && id !== ""; });
        this.channel.updateUsedRoutes(usedChannelRoutes, this.lastUsedState.gcTimestamp);
    }
    /**
     * @deprecated 0.18.Should call request on the runtime directly
     */
    async request(request) {
        const runtime = await this.realize();
        return runtime.request(request);
    }
    submitMessage(type, content, localOpMetadata) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x146 /* "Channel must exist when submitting message" */);
        const fluidDataStoreContent = {
            content,
            type,
        };
        this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);
    }
    /**
     * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.
     * It indicates that there is data in the object that needs to be summarized.
     * We will update the latestSequenceNumber of the summary tracker of this
     * store and of the object's channel.
     *
     * @param address - The address of the channel that is dirty.
     *
     */
    setChannelDirty(address) {
        this.verifyNotClosed();
        // Get the latest sequence number.
        const latestSequenceNumber = this.deltaManager.lastSequenceNumber;
        this.summarizerNode.invalidate(latestSequenceNumber);
        const channelSummarizerNode = this.summarizerNode.getChild(address);
        if (channelSummarizerNode) {
            channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?
        }
    }
    submitSignal(type, content) {
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x147 /* "Channel must exist on submitting signal" */);
        return this._containerRuntime.submitDataStoreSignal(this.id, type, content);
    }
    /**
     * This is called by the data store channel when it becomes locally visible indicating that it is ready to become
     * globally visible now.
     */
    makeLocallyVisible() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x2cf /* "undefined channel on datastore context" */);
        this.makeLocallyVisibleFn();
    }
    bindRuntime(channel) {
        var _a;
        if (this.channel) {
            throw new Error("Runtime already bound");
        }
        try {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.detachedRuntimeCreation, 0x148 /* "Detached runtime creation on runtime bind" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channelDeferred !== undefined, 0x149 /* "Undefined channel deferral" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x14a /* "Undefined package path" */);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pending = this.pending;
            // Apply all pending ops
            for (const op of pending) {
                channel.process(op, false, undefined /* localOpMetadata */);
            }
            this.thresholdOpsCounter.send("ProcessPendingOps", pending.length);
            this.pending = undefined;
            // And now mark the runtime active
            this.loaded = true;
            this.channel = channel;
            // Freeze the package path to ensure that someone doesn't modify it when it is
            // returned in packagePath().
            Object.freeze(this.pkg);
            /**
             * Update the used routes of the channel. If GC has run before this data store was realized, we will have
             * the used routes saved. So, this will ensure that all the child contexts have up-to-date used routes as
             * per the last time GC was run.
             * Also, this data store may have been realized during summarize. In that case, the child contexts need to
             * have their used routes updated to determine if its needs to summarize again and to add it to the summary.
             */
            this.updateChannelUsedRoutes();
            // And notify the pending promise it is now available
            this.channelDeferred.resolve(this.channel);
        }
        catch (error) {
            (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);
            this.logger.sendErrorEvent({ eventName: "BindRuntimeError", fluidDataStoreId: { value: this.id, tag: "PackageData" } }, error);
        }
    }
    async getAbsoluteUrl(relativeUrl) {
        if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attached) {
            return undefined;
        }
        return this._containerRuntime.getAbsoluteUrl(relativeUrl);
    }
    /**
     * @deprecated - Sets the datastore as root, for aliasing purposes: #7948
     * This method should not be used outside of the aliasing context.
     * It will be removed, as the source of truth for this flag will be the aliasing blob.
     */
    setInMemoryRoot() {
        this._isInMemoryRoot = true;
    }
    reSubmit(contents, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x14b /* "Channel must exist when resubmitting ops" */);
        const innerContents = contents;
        this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);
    }
    rollback(contents, localOpMetadata) {
        if (!this.channel) {
            throw new Error("Channel must exist when rolling back ops");
        }
        if (!this.channel.rollback) {
            throw new Error("Channel doesn't support rollback");
        }
        const innerContents = contents;
        this.channel.rollback(innerContents.type, innerContents.content, localOpMetadata);
    }
    async applyStashedOp(contents) {
        if (!this.channel) {
            await this.realize();
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.channel, 0x14c /* "Channel must exist when rebasing ops" */);
        const innerContents = contents;
        return this.channel.applyStashedOp(innerContents.content);
    }
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Context is closed");
        }
    }
    getCreateChildSummarizerNodeFn(id, createParam) {
        return (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, 
        // DDS will not create failure summaries
        { throwOnFailure: true }, getGCDataFn, getBaseGCDetailsFn);
    }
    async uploadBlob(blob) {
        return this.containerRuntime.uploadBlob(blob);
    }
}
FluidDataStoreContext.pendingOpsCountThreshold = 1000;
class RemoteFluidDataStoreContext extends FluidDataStoreContext {
    constructor(props) {
        super(props, true /* existing */, _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound, false /* isLocalDataStore */, () => {
            throw new Error("Already attached");
        });
        this.initialSnapshotDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.LazyPromise(async () => {
            var _a, _b;
            let tree;
            let isRootDataStore = true;
            if (typeof this.initSnapshotValue === "string") {
                const commit = (await this.storage.getVersions(this.initSnapshotValue, 1))[0];
                tree = (_a = await this.storage.getSnapshotTree(commit)) !== null && _a !== void 0 ? _a : undefined;
            }
            else {
                tree = this.initSnapshotValue;
            }
            const localReadAndParse = async (id) => (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_12__.readAndParse)(this.storage, id);
            if (tree) {
                const loadedSummary = await this.summarizerNode.loadBaseSummary(tree, localReadAndParse);
                tree = loadedSummary.baseSummary;
                // Prepend outstanding ops to pending queue of ops to process.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.pending = loadedSummary.outstandingOps.concat(this.pending);
            }
            if (!!tree && tree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName] !== undefined) {
                // Need to get through snapshot and use that to populate extraBlobs
                const attributes = await localReadAndParse(tree.blobs[_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName]);
                let pkgFromSnapshot;
                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.
                // For snapshotFormatVersion = "0.1" (1) or above, pkg is jsonified, otherwise it is just a string.
                const formatVersion = (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.getAttributesFormatVersion)(attributes);
                if (formatVersion < 1) {
                    if (attributes.pkg.startsWith("[\"") && attributes.pkg.endsWith("\"]")) {
                        pkgFromSnapshot = JSON.parse(attributes.pkg);
                    }
                    else {
                        pkgFromSnapshot = [attributes.pkg];
                    }
                }
                else {
                    pkgFromSnapshot = JSON.parse(attributes.pkg);
                }
                this.pkg = pkgFromSnapshot;
                /**
                 * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that
                 * data stores in older documents are not garbage collected incorrectly. This may lead to additional
                 * roots in the document but they won't break.
                 */
                isRootDataStore = (_b = attributes.isRootDataStore) !== null && _b !== void 0 ? _b : true;
                if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.hasIsolatedChannels)(attributes)) {
                    tree = tree.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.channelsTreeName];
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(tree !== undefined, 0x1fe /* "isolated channels subtree should exist in remote datastore snapshot" */);
                }
            }
            return {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                pkg: this.pkg,
                isRootDataStore,
                snapshot: tree,
            };
        });
        this.initSnapshotValue = props.snapshotTree;
        this.baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.LazyPromise(async () => {
            var _a;
            return (_a = (await props.getBaseGCDetails())) !== null && _a !== void 0 ? _a : {};
        });
    }
    async getInitialSnapshotDetails() {
        return this.initialSnapshotDetailsP;
    }
    /**
     * @deprecated - Renamed to getBaseGCDetails.
     */
    async getInitialGCSummaryDetails() {
        return this.getBaseGCDetails();
    }
    async getBaseGCDetails() {
        return this.baseGCDetailsP;
    }
    generateAttachMessage() {
        throw new Error("Cannot attach remote store");
    }
}
/**
 * Base class for detached & attached context classes
 */
class LocalFluidDataStoreContextBase extends FluidDataStoreContext {
    constructor(props) {
        super(props, props.snapshotTree !== undefined ? true : false /* existing */, props.snapshotTree ? _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.Bound : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.BindState.NotBound, true /* isLocalDataStore */, props.makeLocallyVisibleFn);
        this.snapshotTree = props.snapshotTree;
        if (props.isRootDataStore === true) {
            this.setInMemoryRoot();
        }
        this.createProps = props.createProps;
        this.attachListeners();
    }
    attachListeners() {
        this.once("attaching", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Detached, 0x14d /* "Should move from detached to attaching" */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attaching;
        });
        this.once("attached", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attaching, 0x14e /* "Should move from attaching to attached" */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_4__.AttachState.Attached;
        });
    }
    generateAttachMessage() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channel !== undefined, 0x14f /* "There should be a channel when generating attach message" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x150 /* "pkg should be available in local data store context" */);
        const summarizeResult = this.channel.getAttachSummary();
        if (!this.disableIsolatedChannels) {
            // Wrap dds summaries in .channels subtree.
            (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.wrapSummaryInChannelsTree)(summarizeResult);
        }
        // Add data store's attributes to the summary.
        const attributes = createAttributes(this.pkg, this.isInMemoryRoot(), this.disableIsolatedChannels);
        (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.addBlobToSummary)(summarizeResult, _summaryFormat__WEBPACK_IMPORTED_MODULE_1__.dataStoreAttributesBlobName, JSON.stringify(attributes));
        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.
        const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.convertSummaryTreeToITree)(summarizeResult.summary);
        const message = {
            id: this.id,
            snapshot,
            type: this.pkg[this.pkg.length - 1],
        };
        return message;
    }
    async getInitialSnapshotDetails() {
        var _a;
        let snapshot = this.snapshotTree;
        let attributes;
        let isRootDataStore = false;
        if (snapshot !== undefined) {
            // Get the dataStore attributes.
            // Note: storage can be undefined in special case while detached.
            attributes = await (0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.getFluidDataStoreAttributes)(this.storage, snapshot);
            if ((0,_summaryFormat__WEBPACK_IMPORTED_MODULE_1__.hasIsolatedChannels)(attributes)) {
                snapshot = snapshot.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_10__.channelsTreeName];
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(snapshot !== undefined, 0x1ff /* "isolated channels subtree should exist in local datastore snapshot" */);
            }
            if (this.pkg === undefined) {
                this.pkg = JSON.parse(attributes.pkg);
                // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data
                // stores in older documents are not garbage collected incorrectly. This may lead to additional
                // roots in the document but they won't break.
                if ((_a = attributes.isRootDataStore) !== null && _a !== void 0 ? _a : true) {
                    isRootDataStore = true;
                    this.setInMemoryRoot();
                }
            }
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.pkg !== undefined, 0x152 /* "pkg should be available in local data store" */);
        return {
            pkg: this.pkg,
            isRootDataStore,
            snapshot,
        };
    }
    /**
     * @deprecated - Renamed to getBaseGCDetails.
     */
    async getInitialGCSummaryDetails() {
        // Local data store does not have initial summary.
        return {};
    }
    async getBaseGCDetails() {
        // Local data store does not have initial summary.
        return {};
    }
}
/**
 * context implementation for "attached" data store runtime.
 * Various workflows (snapshot creation, requests) result in .realize() being called
 * on context, resulting in instantiation and attachment of runtime.
 * Runtime is created using data store factory that is associated with this context.
 */
class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(props) {
        super(props);
    }
}
/**
 * Detached context. Data Store runtime will be attached to it by attachRuntime() call
 * Before attachment happens, this context is not associated with particular type of runtime
 * or factory, i.e. it's package path is undefined.
 * Attachment process provides all missing parts - package path, data store runtime, and data store factory
 */
class LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(props) {
        super(props);
        this.detachedRuntimeCreation = true;
    }
    async attachRuntime(registry, dataStoreChannel) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.detachedRuntimeCreation, 0x154 /* "runtime creation is already attached" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.channelDeferred === undefined, 0x155 /* "channel deferral is already set" */);
        const factory = registry.IFluidDataStoreFactory;
        const entry = await this.factoryFromPackagePath(this.pkg);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(entry.factory === factory, 0x156 /* "Unexpected factory for package path" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.registry === undefined, 0x157 /* "datastore registry already attached" */);
        this.registry = entry.registry;
        this.detachedRuntimeCreation = false;
        this.channelDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.Deferred();
        super.bindRuntime(dataStoreChannel);
        if (await this.isRoot()) {
            // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.
            // For older versions, we still have to call bindToContext.
            if (dataStoreChannel.makeVisibleAndAttachGraph !== undefined) {
                dataStoreChannel.makeVisibleAndAttachGraph();
            }
            else {
                dataStoreChannel.bindToContext();
            }
        }
    }
    async getInitialSnapshotDetails() {
        if (this.detachedRuntimeCreation) {
            throw new Error("Detached Fluid Data Store context can't be realized! Please attach runtime first!");
        }
        return super.getInitialSnapshotDetails();
    }
}
//# sourceMappingURL=dataStoreContext.js.map

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachmentTreeEntry": () => (/* binding */ AttachmentTreeEntry),
/* harmony export */   "BlobTreeEntry": () => (/* binding */ BlobTreeEntry),
/* harmony export */   "TreeTreeEntry": () => (/* binding */ TreeTreeEntry),
/* harmony export */   "addBlobToTree": () => (/* binding */ addBlobToTree),
/* harmony export */   "buildHierarchy": () => (/* binding */ buildHierarchy),
/* harmony export */   "getGitMode": () => (/* binding */ getGitMode),
/* harmony export */   "getGitType": () => (/* binding */ getGitType)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Take a summary object and returns its git mode.
 *
 * @param value - summary object
 * @returns the git mode of summary object
 */
function getGitMode(value) {
    const type = value.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle ? value.handleType : value.type;
    switch (type) {
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment:
            return _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File;
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree:
            return _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.Directory;
        default:
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(type, `Unknown type: ${type}`);
    }
}
/**
 * Take a summary object and returns its type.
 *
 * @param value - summary object
 * @returns the type of summary object
 */
function getGitType(value) {
    const type = value.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle ? value.handleType : value.type;
    switch (type) {
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment:
            return "blob";
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree:
            return "tree";
        default:
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(type, `Unknown type: ${type}`);
    }
}
/**
 * Build a tree hierarchy base on a flat tree
 *
 * @param flatTree - a flat tree
 * @param blobsShaToPathCache - Map with blobs sha as keys and values as path of the blob.
 * @param removeAppTreePrefix - Remove `.app/` from beginning of paths when present
 * @returns the hierarchical tree
 */
function buildHierarchy(flatTree, blobsShaToPathCache = new Map(), removeAppTreePrefix = false) {
    const lookup = {};
    const root = { id: flatTree.sha, blobs: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.tree) {
        const entryPath = removeAppTreePrefix ? entry.path.replace(/^\.app\//, "") : entry.path;
        const lastIndex = entryPath.lastIndexOf("/");
        const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entryPath.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { id: entry.sha, blobs: {}, commits: {}, trees: {} };
            node.trees[decodeURIComponent(entryPathBase)] = newTree;
            lookup[entryPath] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[decodeURIComponent(entryPathBase)] = entry.sha;
            blobsShaToPathCache.set(entry.sha, `/${entryPath}`);
        }
        else {
            throw new Error("Unknown entry type!!");
        }
    }
    return root;
}
/**
 * Basic implementation of a blob ITreeEntry
 */
class BlobTreeEntry {
    /**
     * Creates a blob ITreeEntry
     * @param path - path of entry
     * @param contents - blob contents
     * @param encoding - encoding of contents; defaults to utf-8
     */
    constructor(path, contents, encoding = "utf-8") {
        this.path = path;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob;
        this.value = { contents, encoding };
    }
}
/**
 * Basic implementation of a tree ITreeEntry
 */
class TreeTreeEntry {
    /**
     * Creates a tree ITreeEntry
     * @param path - path of entry
     * @param value - subtree
     */
    constructor(path, value) {
        this.path = path;
        this.value = value;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.Directory;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Tree;
    }
}
/**
 * Basic implementation of an attachment ITreeEntry
 */
class AttachmentTreeEntry {
    /**
     * Creates an attachment ITreeEntry
     * @param path - path of entry
     * @param id - id of external blob attachment
     */
    constructor(path, id) {
        this.path = path;
        this.id = id;
        this.mode = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File;
        this.type = _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Attachment;
        this.value = { id };
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function addBlobToTree(tree, blobName, content) {
    tree.entries.push({
        mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.FileMode.File,
        path: blobName,
        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob,
        value: {
            contents: JSON.stringify(content),
            encoding: "utf-8",
        },
    });
}
//# sourceMappingURL=blobs.js.map

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileMode": () => (/* binding */ FileMode),
/* harmony export */   "TreeEntry": () => (/* binding */ TreeEntry)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Symlink"] = "120000";
})(FileMode || (FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry["Blob"] = "Blob";
    TreeEntry["Tree"] = "Tree";
    TreeEntry["Attachment"] = "Attachment";
})(TreeEntry || (TreeEntry = {}));
//# sourceMappingURL=storage.js.map

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThresholdCounter": () => (/* binding */ ThresholdCounter)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Utility counter which will send event only if the provided value
 * is above a configured threshold
 */
class ThresholdCounter {
    constructor(threshold, logger, thresholdMultiple = threshold) {
        this.threshold = threshold;
        this.logger = logger;
        this.thresholdMultiple = thresholdMultiple;
    }
    /**
     * Sends the value if it's above the treshold.
     */
    send(eventName, value) {
        if (value < this.threshold) {
            return;
        }
        this.logger.sendPerformanceEvent({
            eventName,
            value,
        });
    }
    /**
     * Sends the value if it's above the treshold
     * and a multiple of the threshold.
     *
     * To be used in scenarios where we'd like to record a
     * threshold violation while reducing telemetry noise.
     */
    sendIfMultiple(eventName, value) {
        if (value === this.thresholdMultiple) {
            this.logger.sendPerformanceEvent({
                eventName,
                value,
            });
            // reduce number of "multiple" events.
            this.thresholdMultiple = this.thresholdMultiple * 2;
        }
    }
}
//# sourceMappingURL=thresholdCounter.js.map

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryTreeBuilder": () => (/* binding */ SummaryTreeBuilder),
/* harmony export */   "TelemetryContext": () => (/* binding */ TelemetryContext),
/* harmony export */   "addBlobToSummary": () => (/* binding */ addBlobToSummary),
/* harmony export */   "addSummarizeResultToSummary": () => (/* binding */ addSummarizeResultToSummary),
/* harmony export */   "addTreeToSummary": () => (/* binding */ addTreeToSummary),
/* harmony export */   "calculateStats": () => (/* binding */ calculateStats),
/* harmony export */   "convertSnapshotTreeToSummaryTree": () => (/* binding */ convertSnapshotTreeToSummaryTree),
/* harmony export */   "convertSummaryTreeToITree": () => (/* binding */ convertSummaryTreeToITree),
/* harmony export */   "convertToSummaryTree": () => (/* binding */ convertToSummaryTree),
/* harmony export */   "convertToSummaryTreeWithStats": () => (/* binding */ convertToSummaryTreeWithStats),
/* harmony export */   "getBlobSize": () => (/* binding */ getBlobSize),
/* harmony export */   "mergeStats": () => (/* binding */ mergeStats),
/* harmony export */   "utf8ByteLength": () => (/* binding */ utf8ByteLength)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Combines summary stats by adding their totals together.
 * Returns empty stats if called without args.
 * @param stats - stats to merge
 */
function mergeStats(...stats) {
    const results = {
        treeNodeCount: 0,
        blobNodeCount: 0,
        handleNodeCount: 0,
        totalBlobSize: 0,
        unreferencedBlobSize: 0,
    };
    for (const stat of stats) {
        results.treeNodeCount += stat.treeNodeCount;
        results.blobNodeCount += stat.blobNodeCount;
        results.handleNodeCount += stat.handleNodeCount;
        results.totalBlobSize += stat.totalBlobSize;
        results.unreferencedBlobSize += stat.unreferencedBlobSize;
    }
    return results;
}
function utf8ByteLength(str) {
    // returns the byte length of an utf8 string
    let s = str.length;
    for (let i = str.length - 1; i >= 0; i--) {
        const code = str.charCodeAt(i);
        if (code > 0x7f && code <= 0x7ff) {
            s++;
        }
        else if (code > 0x7ff && code <= 0xffff) {
            s += 2;
        }
        if (code >= 0xDC00 && code <= 0xDFFF) {
            i--; // trail surrogate
        }
    }
    return s;
}
function getBlobSize(content) {
    if (typeof content === "string") {
        return utf8ByteLength(content);
    }
    else {
        return content.byteLength;
    }
}
function calculateStatsCore(summaryObject, stats) {
    switch (summaryObject.type) {
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {
            stats.treeNodeCount++;
            for (const value of Object.values(summaryObject.tree)) {
                calculateStatsCore(value, stats);
            }
            return;
        }
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {
            stats.handleNodeCount++;
            return;
        }
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {
            stats.blobNodeCount++;
            stats.totalBlobSize += getBlobSize(summaryObject.content);
            return;
        }
        default: return;
    }
}
function calculateStats(summary) {
    const stats = mergeStats();
    calculateStatsCore(summary, stats);
    return stats;
}
function addBlobToSummary(summary, key, content) {
    const blob = {
        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob,
        content,
    };
    summary.summary.tree[key] = blob;
    summary.stats.blobNodeCount++;
    summary.stats.totalBlobSize += getBlobSize(content);
}
function addTreeToSummary(summary, key, summarizeResult) {
    summary.summary.tree[key] = summarizeResult.summary;
    summary.stats = mergeStats(summary.stats, summarizeResult.stats);
}
function addSummarizeResultToSummary(summary, key, summarizeResult) {
    summary.summary.tree[key] = summarizeResult.summary;
    summary.stats = mergeStats(summary.stats, summarizeResult.stats);
}
class SummaryTreeBuilder {
    constructor() {
        this.attachmentCounter = 0;
        this.summaryTree = {};
        this.summaryStats = mergeStats();
        this.summaryStats.treeNodeCount++;
    }
    get summary() {
        return {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,
            tree: Object.assign({}, this.summaryTree),
        };
    }
    get stats() {
        return Object.assign({}, this.summaryStats);
    }
    addBlob(key, content) {
        // Prevent cloning by directly referencing underlying private properties
        addBlobToSummary({
            summary: {
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,
                tree: this.summaryTree,
            },
            stats: this.summaryStats,
        }, key, content);
    }
    addHandle(key, handleType, handle) {
        this.summaryTree[key] = {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle,
            handleType,
            handle,
        };
        this.summaryStats.handleNodeCount++;
    }
    addWithStats(key, summarizeResult) {
        this.summaryTree[key] = summarizeResult.summary;
        this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);
    }
    addAttachment(id) {
        this.summaryTree[this.attachmentCounter++] = { id, type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment };
    }
    getSummaryTree() {
        return { summary: this.summary, stats: this.stats };
    }
}
/**
 * Converts snapshot ITree to ISummaryTree format and tracks stats.
 * @param snapshot - snapshot in ITree format
 * @param fullTree - true to never use handles, even if id is specified
 */
function convertToSummaryTreeWithStats(snapshot, fullTree = false) {
    const builder = new SummaryTreeBuilder();
    for (const entry of snapshot.entries) {
        switch (entry.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Blob: {
                const blob = entry.value;
                let content;
                if (blob.encoding === "base64") {
                    content = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.IsoBuffer.from(blob.contents, "base64");
                }
                else {
                    content = blob.contents;
                }
                builder.addBlob(entry.path, content);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Tree: {
                const subtree = convertToSummaryTree(entry.value, fullTree);
                builder.addWithStats(entry.path, subtree);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.TreeEntry.Attachment: {
                const id = entry.value.id;
                builder.addAttachment(id);
                break;
            }
            default:
                throw new Error("Unexpected TreeEntry type");
        }
    }
    const summaryTree = builder.getSummaryTree();
    summaryTree.summary.unreferenced = snapshot.unreferenced;
    return summaryTree;
}
/**
 * Converts snapshot ITree to ISummaryTree format and tracks stats.
 * @param snapshot - snapshot in ITree format
 * @param fullTree - true to never use handles, even if id is specified
 */
function convertToSummaryTree(snapshot, fullTree = false) {
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (snapshot.id && !fullTree) {
        const stats = mergeStats();
        stats.handleNodeCount++;
        return {
            summary: {
                handle: snapshot.id,
                handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle,
            },
            stats,
        };
    }
    else {
        return convertToSummaryTreeWithStats(snapshot, fullTree);
    }
}
/**
 * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was
 * was taken by serialize api in detached container.
 * @param snapshot - snapshot in ISnapshotTree format
 */
function convertSnapshotTreeToSummaryTree(snapshot) {
    const builder = new SummaryTreeBuilder();
    for (const [path, id] of Object.entries(snapshot.blobs)) {
        let decoded;
        if (snapshot.blobsContents !== undefined) {
            const content = snapshot.blobsContents[id];
            if (content !== undefined) {
                decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.bufferToString)(content, "utf-8");
            }
            // 0.44 back-compat We still put contents in same blob for back-compat so need to add blob
            // only for blobPath -> blobId mapping and not for blobId -> blob value contents.
        }
        else if (snapshot.blobs[id] !== undefined) {
            decoded = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.fromBase64ToUtf8)(snapshot.blobs[id]);
        }
        if (decoded !== undefined) {
            builder.addBlob(path, decoded);
        }
    }
    for (const [key, tree] of Object.entries(snapshot.trees)) {
        const subtree = convertSnapshotTreeToSummaryTree(tree);
        builder.addWithStats(key, subtree);
    }
    const summaryTree = builder.getSummaryTree();
    summaryTree.summary.unreferenced = snapshot.unreferenced;
    return summaryTree;
}
/**
 * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.
 * @param summaryTree - summary tree in ISummaryTree format
 */
function convertSummaryTreeToITree(summaryTree) {
    const entries = [];
    for (const [key, value] of Object.entries(summaryTree.tree)) {
        switch (value.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {
                let parsedContent;
                let encoding = "utf-8";
                if (typeof value.content === "string") {
                    parsedContent = value.content;
                }
                else {
                    parsedContent = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Uint8ArrayToString)(value.content, "base64");
                    encoding = "base64";
                }
                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.BlobTreeEntry(key, parsedContent, encoding));
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {
                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.TreeTreeEntry(key, convertSummaryTreeToITree(value)));
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment: {
                entries.push(new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.AttachmentTreeEntry(key, value.id));
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {
                throw new Error("Should not have Handle type in summary tree");
            }
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.unreachableCase)(value, "Unexpected summary tree type");
        }
    }
    return {
        entries,
        unreferenced: summaryTree.unreferenced,
    };
}
class TelemetryContext {
    constructor() {
        this.telemetry = new Map();
    }
    /**
     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.set}
     */
    set(prefix, property, value) {
        this.telemetry.set(`${prefix}${property}`, value);
    }
    /**
     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.get}
     */
    get(prefix, property) {
        return this.telemetry.get(`${prefix}${property}`);
    }
    /**
     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.serialize}
     */
    serialize() {
        const jsonObject = {};
        this.telemetry.forEach((value, key) => {
            jsonObject[key] = value;
        });
        return JSON.stringify(jsonObject);
    }
}
//# sourceMappingURL=summaryUtils.js.map

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileMode": () => (/* binding */ FileMode),
/* harmony export */   "TreeEntry": () => (/* binding */ TreeEntry)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Symlink"] = "120000";
})(FileMode || (FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry["Blob"] = "Blob";
    TreeEntry["Tree"] = "Tree";
    TreeEntry["Attachment"] = "Attachment";
})(TreeEntry || (TreeEntry = {}));
//# sourceMappingURL=storage.js.map

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromBase64ToUtf8": () => (/* binding */ fromBase64ToUtf8),
/* harmony export */   "fromUtf8ToBase64": () => (/* binding */ fromUtf8ToBase64),
/* harmony export */   "toUtf8": () => (/* binding */ toUtf8)
/* harmony export */ });
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

const fromBase64ToUtf8 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "base64").toString("utf-8");
const fromUtf8ToBase64 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "utf8").toString("base64");
/**
 * Convenience function to convert unknown encoding to utf8 that avoids
 * buffer copies/encode ops when no conversion is needed
 * @param input - The source string to convert
 * @param encoding - The source string's encoding
 */
const toUtf8 = (input, encoding) => {
    switch (encoding) {
        case "utf8":
        case "utf-8":
            return input;
        default:
            return _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, encoding).toString();
    }
};
//# sourceMappingURL=base64Encoding.js.map

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildSnapshotTree": () => (/* binding */ buildSnapshotTree)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




function flattenCore(path, treeEntries, blobMap) {
    const entries = [];
    for (const treeEntry of treeEntries) {
        const subPath = `${path}${treeEntry.path}`;
        if (treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Blob) {
            const blob = treeEntry.value;
            const buffer = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.stringToBuffer)(blob.contents, blob.encoding);
            const id = (0,uuid__WEBPACK_IMPORTED_MODULE_2__["default"])();
            blobMap.set(id, buffer);
            const entry = {
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],
                path: subPath,
                sha: id,
                size: 0,
                type: "blob",
                url: "",
            };
            entries.push(entry);
        }
        else if (treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Tree) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(treeEntry.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.TreeEntry.Tree, 0x101 /* "Unexpected tree entry type on flatten!" */);
            const t = treeEntry.value;
            const entry = {
                mode: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.FileMode[treeEntry.mode],
                path: subPath,
                sha: "",
                size: -1,
                type: "tree",
                url: "",
            };
            entries.push(entry);
            const subTreeEntries = flattenCore(`${subPath}/`, t.entries, blobMap);
            entries.push(...subTreeEntries);
        }
    }
    return entries;
}
/**
 * Create a flatten view of an array of ITreeEntry
 *
 * @param tree - an array of ITreeEntry to flatten
 * @param blobMap - a map of blob's sha1 to content
 * @returns A flatten with of the ITreeEntry
 */
function flatten(tree, blobMap) {
    const entries = flattenCore("", tree, blobMap);
    return {
        sha: "",
        tree: entries,
        url: "",
    };
}
/**
 * Build a tree hierarchy base on an array of ITreeEntry
 *
 * @param entries - an array of ITreeEntry to flatten
 * @param blobMap - a map of blob's sha1 to content that gets filled with content from entries
 * NOTE: blobMap's validity is contingent on the returned promise's resolution
 * @returns the hierarchical tree
 */
function buildSnapshotTree(entries, blobMap) {
    const flattened = flatten(entries, blobMap);
    return (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.buildHierarchy)(flattened);
}
//# sourceMappingURL=buildSnapshotTree.js.map

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileMode": () => (/* binding */ FileMode),
/* harmony export */   "TreeEntry": () => (/* binding */ TreeEntry)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Symlink"] = "120000";
})(FileMode || (FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry["Blob"] = "Blob";
    TreeEntry["Tree"] = "Tree";
    TreeEntry["Attachment"] = "Attachment";
})(TreeEntry || (TreeEntry = {}));
//# sourceMappingURL=storage.js.map

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobCacheStorageService": () => (/* binding */ BlobCacheStorageService)
/* harmony export */ });
/* harmony import */ var _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * IDocumentStorageService adapter with pre-cached blobs.
 */
class BlobCacheStorageService extends _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {
    constructor(internalStorageService, blobs) {
        super(internalStorageService);
        this.blobs = blobs;
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    async readBlob(id) {
        const blob = this.blobs.get(id);
        if (blob !== undefined) {
            return blob;
        }
        return this.internalStorageService.readBlob(id);
    }
}
//# sourceMappingURL=blobCacheStorageService.js.map

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentStorageServiceProxy": () => (/* binding */ DocumentStorageServiceProxy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
class DocumentStorageServiceProxy {
    constructor(internalStorageService) {
        this.internalStorageService = internalStorageService;
    }
    set policies(policies) {
        this._policies = policies;
    }
    get policies() {
        var _a;
        return (_a = this._policies) !== null && _a !== void 0 ? _a : this.internalStorageService.policies;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    async getSnapshotTree(version, scenarioName) {
        return this.internalStorageService.getSnapshotTree(version, scenarioName);
    }
    async getVersions(versionId, count, scenarioName) {
        return this.internalStorageService.getVersions(versionId, count, scenarioName);
    }
    async uploadSummaryWithContext(summary, context) {
        return this.internalStorageService.uploadSummaryWithContext(summary, context);
    }
    async downloadSummary(handle) {
        return this.internalStorageService.downloadSummary(handle);
    }
    async createBlob(file) {
        return this.internalStorageService.createBlob(file);
    }
    async readBlob(blobId) {
        return this.internalStorageService.readBlob(blobId);
    }
}
//# sourceMappingURL=documentStorageServiceProxy.js.map

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "channelToDataStore": () => (/* binding */ channelToDataStore),
/* harmony export */   "isDataStoreAliasMessage": () => (/* binding */ isDataStoreAliasMessage)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * Type guard that returns true if the given alias message is actually an instance of
 * a class which implements {@link IDataStoreAliasMessage}
 * @param maybeDataStoreAliasMessage - message object to be validated
 * @returns True if the {@link IDataStoreAliasMessage} is fully implemented, false otherwise
 */
const isDataStoreAliasMessage = (maybeDataStoreAliasMessage) => {
    return typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.internalId) === "string"
        && typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.alias) === "string";
};
const channelToDataStore = (fluidDataStoreChannel, internalId, runtime, datastores, logger) => new DataStore(fluidDataStoreChannel, internalId, runtime, datastores, logger);
var AliasState;
(function (AliasState) {
    AliasState["Aliased"] = "Aliased";
    AliasState["Aliasing"] = "Aliasing";
    AliasState["None"] = "None";
})(AliasState || (AliasState = {}));
class DataStore {
    constructor(fluidDataStoreChannel, internalId, runtime, datastores, logger) {
        this.fluidDataStoreChannel = fluidDataStoreChannel;
        this.internalId = internalId;
        this.runtime = runtime;
        this.datastores = datastores;
        this.logger = logger;
        this.aliasState = AliasState.None;
    }
    async trySetAlias(alias) {
        if (alias.includes("/")) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__.UsageError(`The alias cannot contain slashes: '${alias}'`);
        }
        switch (this.aliasState) {
            // If we're already aliasing, check if it's for the same value and return
            // the stored promise, otherwise return 'AlreadyAliased'
            case AliasState.Aliasing:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.aliasResult !== undefined, 0x316 /* There should be a cached promise of in-progress aliasing */);
                await this.aliasResult;
                return this.alias === alias ? "Success" : "AlreadyAliased";
            // If this datastore is already aliased, return true only if this
            // is a repeated call for the same alias
            case AliasState.Aliased:
                return this.alias === alias ? "Success" : "AlreadyAliased";
            // There is no current or past alias operation for this datastore,
            // it is safe to continue execution
            case AliasState.None: break;
            default: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(this.aliasState);
        }
        this.aliasState = AliasState.Aliasing;
        this.aliasResult = this.trySetAliasInternal(alias);
        return this.aliasResult;
    }
    async trySetAliasInternal(alias) {
        const message = {
            internalId: this.internalId,
            alias,
        };
        // back-compat 0.58.2000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For
        // older versions, we still have to call bindToContext.
        if (this.fluidDataStoreChannel.makeVisibleAndAttachGraph !== undefined) {
            this.fluidDataStoreChannel.makeVisibleAndAttachGraph();
        }
        else {
            this.fluidDataStoreChannel.bindToContext();
        }
        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached) {
            const localResult = this.datastores.processAliasMessageCore(message);
            // Explicitly lock-out future attempts of aliasing,
            // regardless of result
            this.aliasState = AliasState.Aliased;
            return localResult ? "Success" : "Conflict";
        }
        const aliased = await this.ackBasedPromise((resolve) => {
            this.runtime.submitDataStoreAliasOp(message, resolve);
        }).then((succeeded) => {
            // Explicitly Lock-out future attempts of aliasing,
            // regardless of result
            this.aliasState = AliasState.Aliased;
            if (succeeded) {
                this.alias = alias;
            }
            return succeeded;
        }).catch((error) => {
            this.logger.sendErrorEvent({
                eventName: "AliasingException",
                alias: {
                    value: alias,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.TelemetryDataTag.UserData,
                },
                internalId: {
                    value: this.internalId,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.TelemetryDataTag.PackageData,
                },
            }, error);
            this.aliasState = AliasState.None;
            return false;
        });
        return aliased ? "Success" : "Conflict";
    }
    async request(request) {
        return this.fluidDataStoreChannel.request(request);
    }
    get IFluidRouter() { return this.fluidDataStoreChannel; }
    async ackBasedPromise(executor) {
        let rejectBecauseDispose;
        return new Promise((resolve, reject) => {
            rejectBecauseDispose =
                () => reject(new Error("ContainerRuntime disposed while this ack-based Promise was pending"));
            if (this.runtime.disposed) {
                rejectBecauseDispose();
                return;
            }
            this.runtime.on("dispose", rejectBecauseDispose);
            executor(resolve, reject);
        }).finally(() => {
            this.runtime.off("dispose", rejectBecauseDispose);
        });
    }
}
//# sourceMappingURL=dataStore.js.map

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GCDataBuilder": () => (/* binding */ GCDataBuilder),
/* harmony export */   "cloneGCData": () => (/* binding */ cloneGCData),
/* harmony export */   "concatGarbageCollectionData": () => (/* binding */ concatGarbageCollectionData),
/* harmony export */   "concatGarbageCollectionStates": () => (/* binding */ concatGarbageCollectionStates),
/* harmony export */   "removeRouteFromAllNodes": () => (/* binding */ removeRouteFromAllNodes),
/* harmony export */   "trimLeadingAndTrailingSlashes": () => (/* binding */ trimLeadingAndTrailingSlashes),
/* harmony export */   "trimLeadingSlashes": () => (/* binding */ trimLeadingSlashes),
/* harmony export */   "trimTrailingSlashes": () => (/* binding */ trimTrailingSlashes),
/* harmony export */   "unpackChildNodesGCDetails": () => (/* binding */ unpackChildNodesGCDetails),
/* harmony export */   "unpackChildNodesUsedRoutes": () => (/* binding */ unpackChildNodesUsedRoutes)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Trims the leading and trailing slashes from the given string.
 * @param str - A string that may contain leading and / or trailing slashes.
 * @returns A new string without leading and trailing slashes.
 */
function trimLeadingAndTrailingSlashes(str) {
    return str.replace(/^\/+|\/+$/g, "");
}
/**
 * Trims the leading slashes from the given string.
 * @param str - A string that may contain leading slashes.
 * @returns A new string without leading slashes.
 */
function trimLeadingSlashes(str) {
    return str.replace(/^\/+/g, "");
}
/**
 * Trims the trailing slashes from the given string.
 * @param str - A string that may contain trailing slashes.
 * @returns A new string without trailing slashes.
 */
function trimTrailingSlashes(str) {
    return str.replace(/\/+$/g, "");
}
/**
 * Helper function that clones the GC data.
 * @param gcData - The GC data to clone.
 * @returns a clone of the given GC data.
 */
function cloneGCData(gcData) {
    const clonedGCNodes = {};
    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {
        clonedGCNodes[id] = Array.from(outboundRoutes);
    }
    return {
        gcNodes: clonedGCNodes,
    };
}
/**
 * Helper function that unpacks the GC details of the children from a given node's GC details.
 * @param gcDetails - The GC details of a node.
 * @returns A map of GC details of each children of the the given node.
 */
function unpackChildNodesGCDetails(gcDetails) {
    const childGCDetailsMap = new Map();
    // If GC data is not available, bail out.
    if (gcDetails.gcData === undefined) {
        return childGCDetailsMap;
    }
    // Remove the node's self GC nodes, if any, and generate the children GC nodes.
    const gcNodes = gcDetails.gcData.gcNodes;
    delete gcNodes["/"];
    for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(id.startsWith("/"), 0x2ae /* "node id should always be an absolute route" */);
        const childId = id.split("/")[1];
        let childGCNodeId = id.slice(childId.length + 1);
        // GC node id always begins with "/". Handle the special case where a child's id in the parent's GC nodes is
        // of format `/root`. In this case, the childId is root and childGCNodeId is "". Make childGCNodeId = "/".
        if (childGCNodeId === "") {
            childGCNodeId = "/";
        }
        let childGCDetails = childGCDetailsMap.get(childId);
        if (childGCDetails === undefined) {
            childGCDetails = { gcData: { gcNodes: {} }, usedRoutes: [] };
        }
        // gcData should not undefined as its always at least initialized as  empty above.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childGCDetails.gcData !== undefined, 0x2af /* "Child GC data should have been initialized" */);
        childGCDetails.gcData.gcNodes[childGCNodeId] = [...new Set(outboundRoutes)];
        childGCDetailsMap.set(childId, childGCDetails);
    }
    if (gcDetails.usedRoutes === undefined) {
        return childGCDetailsMap;
    }
    // Remove the node's self used route, if any, and generate the children used routes.
    const usedRoutes = gcDetails.usedRoutes.filter((route) => route !== "" && route !== "/");
    for (const route of usedRoutes) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(route.startsWith("/"), 0x2b0 /* "Used route should always be an absolute route" */);
        const childId = route.split("/")[1];
        const childUsedRoute = route.slice(childId.length + 1);
        const childGCDetails = childGCDetailsMap.get(childId);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((childGCDetails === null || childGCDetails === void 0 ? void 0 : childGCDetails.usedRoutes) !== undefined, 0x2b1 /* "This should have be initiallized when generate GC nodes above" */);
        childGCDetails.usedRoutes.push(childUsedRoute);
        childGCDetailsMap.set(childId, childGCDetails);
    }
    return childGCDetailsMap;
}
/**
 * Helper function that unpacks the used routes of children from a given node's used routes.
 * @param usedRoutes - The used routes of a node.
 * @returns A map of used routes of each children of the the given node.
 */
function unpackChildNodesUsedRoutes(usedRoutes) {
    // Remove the node's self used route, if any, and generate the children used routes.
    const filteredUsedRoutes = usedRoutes.filter((route) => route !== "" && route !== "/");
    const childUsedRoutesMap = new Map();
    for (const route of filteredUsedRoutes) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(route.startsWith("/"), 0x198 /* "Used route should always be an absolute route" */);
        const childId = route.split("/")[1];
        const childUsedRoute = route.slice(childId.length + 1);
        const childUsedRoutes = childUsedRoutesMap.get(childId);
        if (childUsedRoutes !== undefined) {
            childUsedRoutes.push(childUsedRoute);
        }
        else {
            childUsedRoutesMap.set(childId, [childUsedRoute]);
        }
    }
    return childUsedRoutesMap;
}
/**
 * Removes the given route from the outbound routes of all the given GC nodes, and any duplicates
 * @param gcNodes - The nodes from which the route is to be removed.
 * @param outboundRoute - The route to be removed.
 */
function removeRouteFromAllNodes(gcNodes, outboundRoute) {
    const channels = Object.entries(gcNodes);
    for (const [nodeId, outboundRoutes] of channels) {
        // Remove route from channel to parent for each channel
        const outboundRoutesSet = new Set(outboundRoutes);
        outboundRoutesSet.delete(outboundRoute);
        gcNodes[nodeId] = [...outboundRoutesSet];
    }
}
/**
 * Concatenates the given GC states and returns the concatenated GC state.
 */
function concatGarbageCollectionStates(gcState1, gcState2) {
    var _a;
    const combinedGCNodes = {};
    for (const [nodeId, nodeData] of Object.entries(gcState1.gcNodes)) {
        combinedGCNodes[nodeId] = {
            outboundRoutes: Array.from(nodeData.outboundRoutes),
            unreferencedTimestampMs: nodeData.unreferencedTimestampMs,
        };
    }
    for (const [nodeId, nodeData] of Object.entries(gcState2.gcNodes)) {
        let combinedNodedata = combinedGCNodes[nodeId];
        if (combinedNodedata === undefined) {
            combinedNodedata = {
                outboundRoutes: Array.from(nodeData.outboundRoutes),
                unreferencedTimestampMs: nodeData.unreferencedTimestampMs,
            };
        }
        else {
            // Validate that same node doesn't have different unreferenced timestamp.
            if (nodeData.unreferencedTimestampMs !== undefined
                && combinedNodedata.unreferencedTimestampMs !== undefined) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(nodeData.unreferencedTimestampMs === combinedNodedata.unreferencedTimestampMs, 0x2b2 /* "Two entries for the same GC node with different unreferenced timestamp" */);
            }
            combinedNodedata = {
                outboundRoutes: [...new Set([...nodeData.outboundRoutes, ...combinedNodedata.outboundRoutes])],
                unreferencedTimestampMs: (_a = nodeData.unreferencedTimestampMs) !== null && _a !== void 0 ? _a : combinedNodedata.unreferencedTimestampMs,
            };
        }
        combinedGCNodes[nodeId] = combinedNodedata;
    }
    return { gcNodes: combinedGCNodes };
}
/**
 * Concatenates the given GC datas and returns the concatenated GC data.
 */
function concatGarbageCollectionData(gcData1, gcData2) {
    const combinedGCData = cloneGCData(gcData1);
    for (const [id, routes] of Object.entries(gcData2.gcNodes)) {
        if (combinedGCData.gcNodes[id] === undefined) {
            combinedGCData.gcNodes[id] = Array.from(routes);
        }
        else {
            const combinedRoutes = [...routes, ...combinedGCData.gcNodes[id]];
            combinedGCData.gcNodes[id] = [...new Set(combinedRoutes)];
        }
    }
    return combinedGCData;
}
class GCDataBuilder {
    constructor() {
        this.gcNodesSet = {};
    }
    get gcNodes() {
        const gcNodes = {};
        for (const [nodeId, outboundRoutes] of Object.entries(this.gcNodesSet)) {
            gcNodes[nodeId] = [...outboundRoutes];
        }
        return gcNodes;
    }
    addNode(id, outboundRoutes) {
        this.gcNodesSet[id] = new Set(outboundRoutes);
    }
    /**
     * Adds the given GC nodes. It does the following:
     * - Normalizes the ids of the given nodes.
     * - Prefixes the given `prefixId` to the given nodes' ids.
     * - Adds the outbound routes of the nodes against the normalized and prefixed id.
     */
    prefixAndAddNodes(prefixId, gcNodes) {
        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
            // Remove any leading slashes from the id.
            let normalizedId = trimLeadingSlashes(id);
            // Prefix the given id to the normalized id.
            normalizedId = `/${prefixId}/${normalizedId}`;
            // Remove any trailing slashes from the normalized id. Note that the trailing slashes are removed after
            // adding the prefix for handling the special case where id is "/".
            normalizedId = trimTrailingSlashes(normalizedId);
            // Add the outbound routes against the normalized and prefixed id without duplicates.
            this.gcNodesSet[normalizedId] = new Set(outboundRoutes);
        }
    }
    addNodes(gcNodes) {
        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
            this.gcNodesSet[id] = new Set(outboundRoutes);
        }
    }
    /**
     * Adds the given outbound route to the outbound routes of all GC nodes.
     */
    addRouteToAllNodes(outboundRoute) {
        for (const outboundRoutes of Object.values(this.gcNodesSet)) {
            outboundRoutes.add(outboundRoute);
        }
    }
    getGCData() {
        return {
            gcNodes: this.gcNodes,
        };
    }
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runGarbageCollection": () => (/* binding */ runGarbageCollection)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Runs garbage collection on the given reference graph.
 * @param referenceGraph - The reference graph to run GC on. It's a list of nodes where each node has an id and set of
 * routes to other nodes in the graph.
 * @param rootIds - The ids of root nodes that are considered referenced.
 * @returns the ids of referenced nodes and the ids of deleted nodes in the referenced graph.
 */
function runGarbageCollection(referenceGraph, rootIds) {
    // This set keeps track of nodes that we have visited. It is used to detect cycles in the graph.
    const visited = new Set();
    // This tracks the ids of referenced nodes. The nodes corresponding to rootIds are always considered
    // referenced so we start with those.
    const referencedIds = [...rootIds];
    for (const id of referencedIds) {
        // If we have already seen this node, ignore and continue. Else, add it to visited list.
        if (visited.has(id)) {
            continue;
        }
        visited.add(id);
        // Get the node for the referenced id and add its outbound routes to referencedIds since they are
        // also referenced.
        const routes = referenceGraph[id];
        if (routes !== undefined) {
            referencedIds.push(...routes);
        }
    }
    const referencedNodeIds = [];
    const deletedNodeIds = [];
    for (const id of Object.keys(referenceGraph)) {
        // The nodes from the reference graph whose ids are in the visited list are referenced.
        // The rest of the nodes are deleted.
        if (visited.has(id)) {
            referencedNodeIds.push(id);
        }
        else {
            deletedNodeIds.push(id);
        }
    }
    return { referencedNodeIds, deletedNodeIds };
}
//# sourceMappingURL=garbageCollector.js.map

/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizerNodeWithGC": () => (/* binding */ SummarizerNodeWithGC),
/* harmony export */   "createRootSummarizerNodeWithGC": () => (/* binding */ createRootSummarizerNodeWithGC)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _summarizerNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(108);
/* harmony import */ var _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(107);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





// Extend SummaryNode to add used routes tracking to it.
class SummaryNodeWithGC extends _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__.SummaryNode {
    constructor(serializedUsedRoutes, summary) {
        super(summary);
        this.serializedUsedRoutes = serializedUsedRoutes;
    }
}
/**
 * Extends the functionality of SummarizerNode to manage this node's garbage collection data:
 * - Adds a new API `getGCData` to return GC data of this node.
 * - Caches the result of `getGCData` to be used if nothing changes between summaries.
 * - Manages the used routes of this node. These are used to identify if this node is referenced in the document
 *   and to determine if the node's used state changed since last summary.
 * - Adds trackState param to summarize. If trackState is false, it bypasses the SummarizerNode and calls
 *   directly into summarizeInternal method.
 */
class SummarizerNodeWithGC extends _summarizerNode__WEBPACK_IMPORTED_MODULE_1__.SummarizerNode {
    /**
     * Do not call constructor directly.
     * Use createRootSummarizerNodeWithGC to create root node, or createChild to create child nodes.
     */
    constructor(logger, summarizeFn, config, changeSequenceNumber, 
    /** Undefined means created without summary */
    latestSummary, initialSummary, wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn) {
        super(logger, async (fullTree, _trackState, telemetryContext) => summarizeFn(fullTree, true /* trackState */, telemetryContext), config, changeSequenceNumber, latestSummary, initialSummary, wipSummaryLogger);
        this.summarizeFn = summarizeFn;
        this.getGCDataFn = getGCDataFn;
        // Keeps track of whether we have loaded the base details to ensure that we on;y do it once.
        this.baseGCDetailsLoaded = false;
        // Set used routes to have self route by default. This makes the node referenced by default. This is done to ensure
        // that this node is not marked as collected when running GC has been disabled. Once, the option to disable GC is
        // removed (from runGC flag in IContainerRuntimeOptions), this should be changed to be have no routes by default.
        this.usedRoutes = [""];
        this.gcDisabled = config.gcDisabled === true;
        this.baseGCDetailsP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.LazyPromise(async () => {
            var _a;
            return (_a = (await (getBaseGCDetailsFn === null || getBaseGCDetailsFn === void 0 ? void 0 : getBaseGCDetailsFn()))) !== null && _a !== void 0 ? _a : { usedRoutes: [] };
        });
    }
    /**
     * @deprecated - Renamed to getBaseGCDetails.
     */
    getGCSummaryDetails() {
        return this.getBaseGCDetails();
    }
    // Returns the GC details to be added to this node's summary and is used to initialize new nodes' GC state.
    getBaseGCDetails() {
        return {
            gcData: this.gcData,
            usedRoutes: this.usedRoutes,
            unrefTimestamp: this.unreferencedTimestampMs,
        };
    }
    /**
     * Loads state from this node's initial GC summary details. This contains the following data from the last summary
     * seen by the server for this client:
     * - usedRoutes: This is used to figure out if the used state of this node changed since last summary.
     * - gcData: The garbage collection data of this node that is required for running GC.
     */
    async loadBaseGCDetails() {
        var _a;
        const baseGCDetails = await this.baseGCDetailsP;
        // Possible race - If there were parallel calls to loadBaseGCDetails, we want to make sure that we only update
        // the state from the base details only once.
        if (this.baseGCDetailsLoaded) {
            return;
        }
        this.baseGCDetailsLoaded = true;
        // If the GC details has GC data, initialize our GC data from it.
        if (baseGCDetails.gcData !== undefined) {
            this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(baseGCDetails.gcData);
        }
        // Sort the used routes because we compare them with the current used routes to check if they changed between
        // summaries. Both are sorted so that the order of elements is the same.
        this.referenceUsedRoutes = (_a = baseGCDetails.usedRoutes) === null || _a === void 0 ? void 0 : _a.sort();
        this.unreferencedTimestampMs = baseGCDetails.unrefTimestamp;
    }
    async summarize(fullTree, trackState = true, telemetryContext) {
        // If GC is not disabled and we are tracking a summary, GC should have run and updated the used routes for this
        // summary by calling updateUsedRoutes which sets wipSerializedUsedRoutes.
        if (!this.gcDisabled && this.isTrackingInProgress()) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.wipSerializedUsedRoutes !== undefined, 0x1b1 /* "wip used routes should be set if tracking a summary" */);
        }
        // If trackState is true, get summary from base summarizer node which tracks summary state.
        // If trackState is false, get summary from summarizeInternal.
        return trackState
            ? super.summarize(fullTree, true /* trackState */, telemetryContext)
            : this.summarizeFn(fullTree, trackState, telemetryContext);
    }
    /**
     * Returns the GC data of this node. If nothing has changed since last summary, it tries to reuse the data from
     * the previous summary. Else, it gets new GC data from the underlying Fluid object.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.gcDisabled, 0x1b2 /* "Getting GC data should not be called when GC is disabled!" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.getGCDataFn !== undefined, 0x1b3 /* "GC data cannot be retrieved without getGCDataFn" */);
        // Load GC details from the initial summary, if not already loaded. If this is the first time this function is
        // called and the node's data has not changed since last summary, the GC data in initial details is returned.
        await this.loadBaseGCDetails();
        // If there is no new data since last summary and we have GC data from the previous run, return it. We may not
        // have data from previous GC run for clients with older summary format before GC was added. They won't have
        // GC details in their initial summary.
        if (!fullGC && !this.hasDataChanged() && this.gcData !== undefined) {
            return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(this.gcData);
        }
        const gcData = await this.getGCDataFn(fullGC);
        this.gcData = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_3__.cloneGCData)(gcData);
        return gcData;
    }
    /**
     * Called during the start of a summary. Updates the work-in-progress used routes.
     */
    startSummary(referenceSequenceNumber, summaryLogger) {
        // If GC is disabled, skip setting wip used routes since we should not track GC state.
        if (!this.gcDisabled) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(this.wipSerializedUsedRoutes === undefined, 0x1b4 /* "We should not already be tracking used routes when to track a new summary" */);
        }
        super.startSummary(referenceSequenceNumber, summaryLogger);
    }
    /**
     * Called after summary has been uploaded to the server. Add the work-in-progress state to the pending
     * summary queue. We track this until we get an ack from the server for this summary.
     */
    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {
        let wipSerializedUsedRoutes;
        // If GC is disabled, don't set wip used routes.
        if (!this.gcDisabled) {
            wipSerializedUsedRoutes = this.wipSerializedUsedRoutes;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(wipSerializedUsedRoutes !== undefined, 0x1b5 /* "We should have been tracking used routes" */);
        }
        super.completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion);
        // If GC is disabled, skip setting pending summary with GC state.
        if (!this.gcDisabled) {
            const summaryNode = this.pendingSummaries.get(proposalHandle);
            if (summaryNode !== undefined) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const summaryNodeWithGC = new SummaryNodeWithGC(wipSerializedUsedRoutes, summaryNode);
                this.pendingSummaries.set(proposalHandle, summaryNodeWithGC);
            }
        }
    }
    /**
     * Clears the work-in-progress state.
     */
    clearSummary() {
        this.wipSerializedUsedRoutes = undefined;
        super.clearSummary();
    }
    /**
     * Called when we get an ack from the server for a summary we sent. Update the reference state of this node
     * from the state in the pending summary queue.
     */
    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {
        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.
        if (!this.gcDisabled) {
            const summaryNode = this.pendingSummaries.get(proposalHandle);
            if (summaryNode !== undefined) {
                this.referenceUsedRoutes = JSON.parse(summaryNode.serializedUsedRoutes);
            }
        }
        return super.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);
    }
    /**
     * Called when we need to upload the reference state from the given summary. Read the GC blob and get the state
     * to upload from it.
     */
    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {
        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.
        if (!this.gcDisabled) {
            const gcDetailsBlob = snapshotTree.blobs[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.gcBlobKey];
            if (gcDetailsBlob !== undefined) {
                const gcDetails = await readAndParseBlob(gcDetailsBlob);
                // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.
                if (this.referenceSequenceNumber >= referenceSequenceNumber) {
                    return;
                }
                this.referenceUsedRoutes = gcDetails.usedRoutes;
            }
        }
        return super.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob);
    }
    /**
     * Override the createChild method to return an instance of SummarizerNodeWithGC.
     */
    createChild(
    /** Summarize function */
    summarizeInternalFn, 
    /** Initial id or path part of this node */
    id, 
    /**
     * Information needed to create the node.
     * If it is from a base summary, it will assert that a summary has been seen.
     * Attach information if it is created from an attach op.
     */
    createParam, config = {}, getGCDataFn, getBaseGCDetailsFn) {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.children.has(id), 0x1b6 /* "Create SummarizerNode child already exists" */);
        const createDetails = this.getCreateDetailsForChild(id, createParam);
        const child = new SummarizerNodeWithGC(this.defaultLogger, summarizeInternalFn, Object.assign(Object.assign({}, config), { 
            // Propagate our gcDisabled state to the child if its not explicity specified in child's config.
            gcDisabled: (_a = config.gcDisabled) !== null && _a !== void 0 ? _a : this.gcDisabled }), createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn);
        // There may be additional state that has to be updated in this child. For example, if a summary is being
        // tracked, the child's summary tracking state needs to be updated too.
        this.maybeUpdateChildState(child);
        this.children.set(id, child);
        return child;
    }
    /**
     * Deletes the child node with the given id.
     */
    deleteChild(id) {
        this.children.delete(id);
    }
    /**
     * Override the getChild method to return an instance of SummarizerNodeWithGC.
     */
    getChild(id) {
        return this.children.get(id);
    }
    isReferenced() {
        return this.usedRoutes.includes("") || this.usedRoutes.includes("/");
    }
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        // Sort the given routes before updating. This will ensure that the routes compared in hasUsedStateChanged()
        // are in the same order.
        this.usedRoutes = usedRoutes.sort();
        // If GC is not disabled and we are tracking a summary, update the work-in-progress used routes so that it can
        // be tracked for this summary.
        if (!this.gcDisabled && this.isTrackingInProgress()) {
            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);
        }
        if (this.isReferenced()) {
            this.unreferencedTimestampMs = undefined;
            return;
        }
        // If this node just became unreferenced, update its unreferencedTimestampMs.
        if (this.unreferencedTimestampMs === undefined) {
            this.unreferencedTimestampMs = gcTimestamp;
        }
    }
    /**
     * Override the hasChanged method. If this node data or its used state changed, the node is considered changed.
     */
    hasChanged() {
        return this.hasDataChanged() || this.hasUsedStateChanged();
    }
    /**
     * This tells whether the data in this node has changed or not.
     */
    hasDataChanged() {
        return super.hasChanged();
    }
    /**
     * This tells whether the used state of this node has changed since last successful summary. If the used routes
     * of this node changed, its used state is considered changed. Basically, if this node or any of its child nodes
     * was previously used and became unused (or vice versa), its used state has changed.
     */
    hasUsedStateChanged() {
        // If GC is disabled, we are not tracking used state, return false.
        if (this.gcDisabled) {
            return false;
        }
        return this.referenceUsedRoutes === undefined ||
            JSON.stringify(this.usedRoutes) !== JSON.stringify(this.referenceUsedRoutes);
    }
}
/**
 * Creates a root summarizer node with GC functionality built-in.
 * @param logger - Logger to use within SummarizerNode
 * @param summarizeInternalFn - Function to generate summary
 * @param changeSequenceNumber - Sequence number of latest change to new node/subtree
 * @param referenceSequenceNumber - Reference sequence number of last acked summary,
 * or undefined if not loaded from summary
 * @param config - Configure behavior of summarizer node
 * @param getGCDataFn - Function to get the GC data of this node
 * @param baseGCDetailsP - Function to get the initial GC details of this node
 */
const createRootSummarizerNodeWithGC = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}, getGCDataFn, getBaseGCDetailsFn) => new SummarizerNodeWithGC(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_0__.SummaryNode.createForRoot(referenceSequenceNumber), undefined /* initialSummary */, undefined /* wipSummaryLogger */, getGCDataFn, getBaseGCDetailsFn);
//# sourceMappingURL=summarizerNodeWithGc.js.map

/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EscapedPath": () => (/* binding */ EscapedPath),
/* harmony export */   "SummaryNode": () => (/* binding */ SummaryNode),
/* harmony export */   "decodeSummary": () => (/* binding */ decodeSummary),
/* harmony export */   "encodeSummary": () => (/* binding */ encodeSummary),
/* harmony export */   "parseSummaryForSubtrees": () => (/* binding */ parseSummaryForSubtrees),
/* harmony export */   "parseSummaryTreeForSubtrees": () => (/* binding */ parseSummaryTreeForSubtrees)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _summaryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




const baseSummaryTreeKey = "_baseSummary";
const outstandingOpsBlobKey = "_outstandingOps";
const maxDecodeDepth = 100;
/** Path for nodes in a tree with escaped special characters */
class EscapedPath {
    constructor(path) {
        this.path = path;
    }
    static create(path) {
        return new EscapedPath(encodeURIComponent(path));
    }
    static createAndConcat(pathParts) {
        var _a;
        let ret = EscapedPath.create((_a = pathParts[0]) !== null && _a !== void 0 ? _a : "");
        for (let i = 1; i < pathParts.length; i++) {
            ret = ret.concat(EscapedPath.create(pathParts[i]));
        }
        return ret;
    }
    toString() {
        return this.path;
    }
    concat(path) {
        return new EscapedPath(`${this.path}/${path.path}`);
    }
}
/** Information about a summary relevant to a specific node in the tree */
class SummaryNode {
    constructor(summary) {
        this.summary = summary;
    }
    /** Creates an instance that is valid for the root with specific basePath and localPath */
    static createForRoot(referenceSequenceNumber) {
        return new SummaryNode({
            referenceSequenceNumber,
            basePath: undefined,
            localPath: EscapedPath.create(""), // root hard-coded to ""
        });
    }
    /** Summary reference sequence number, i.e. last sequence number seen when it was created */
    get referenceSequenceNumber() {
        return this.summary.referenceSequenceNumber;
    }
    /** Full path to parent node, or undefined if this is the root */
    get basePath() {
        return this.summary.basePath;
    }
    /** Relative path to this node from its parent node */
    get localPath() {
        return this.summary.localPath;
    }
    /** Relative path from this node to its node innermost base summary */
    get additionalPath() {
        return this.summary.additionalPath;
    }
    set additionalPath(additionalPath) {
        this.summary.additionalPath = additionalPath;
    }
    /** Gets the full path to this node, to be used when sending a handle */
    get fullPath() {
        var _a, _b;
        return (_b = (_a = this.basePath) === null || _a === void 0 ? void 0 : _a.concat(this.localPath)) !== null && _b !== void 0 ? _b : this.localPath;
    }
    /**
     * Gets the full path to this node's innermost base summary.
     * The children nodes can use this as their basePath to determine their path.
     */
    get fullPathForChildren() {
        return this.additionalPath !== undefined
            ? this.fullPath.concat(this.additionalPath)
            : this.fullPath;
    }
    /**
     * Creates a new node within the same summary for a child of this node.
     * @param id - id of the child node
     */
    createForChild(id) {
        return new SummaryNode({
            referenceSequenceNumber: this.referenceSequenceNumber,
            basePath: this.fullPathForChildren,
            localPath: EscapedPath.create(id),
        });
    }
}
/**
 * Checks if the snapshot is created by referencing a previous successful
 * summary plus outstanding ops. If so, it will recursively "decode" it until
 * it gets to the last successful summary (the base summary) and returns that
 * as well as a function for fetching the outstanding ops. Also returns the
 * full path to the previous base summary for child summarizer nodes to use as
 * their base path when necessary.
 * @param snapshot - snapshot tree to decode
 */
function decodeSummary(snapshot, logger) {
    let baseSummary = snapshot;
    const pathParts = [];
    const opsBlobs = [];
    for (let i = 0;; i++) {
        if (i > maxDecodeDepth) {
            logger.sendTelemetryEvent({
                eventName: "DecodeSummaryMaxDepth",
                maxDecodeDepth,
            });
        }
        const outstandingOpsBlob = baseSummary.blobs[outstandingOpsBlobKey];
        const newBaseSummary = baseSummary.trees[baseSummaryTreeKey];
        if (outstandingOpsBlob === undefined && newBaseSummary === undefined) {
            return {
                baseSummary,
                pathParts,
                async getOutstandingOps(readAndParseBlob) {
                    let outstandingOps = [];
                    for (const opsBlob of opsBlobs) {
                        const newOutstandingOps = await readAndParseBlob(opsBlob);
                        if (outstandingOps.length > 0 && newOutstandingOps.length > 0) {
                            const latestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;
                            const newEarliestSeq = newOutstandingOps[0].sequenceNumber;
                            if (newEarliestSeq <= latestSeq) {
                                logger.sendTelemetryEvent({
                                    eventName: "DuplicateOutstandingOps",
                                    // eslint-disable-next-line max-len
                                    message: `newEarliestSeq <= latestSeq in decodeSummary: ${newEarliestSeq} <= ${latestSeq}`,
                                });
                                while (newOutstandingOps.length > 0
                                    && newOutstandingOps[0].sequenceNumber <= latestSeq) {
                                    newOutstandingOps.shift();
                                }
                            }
                        }
                        outstandingOps = outstandingOps.concat(newOutstandingOps);
                    }
                    return outstandingOps;
                },
            };
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!outstandingOpsBlob, 0x1af /* "Outstanding ops blob missing, but base summary tree exists" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(newBaseSummary !== undefined, 0x1b0 /* "Base summary tree missing, but outstanding ops blob exists" */);
        baseSummary = newBaseSummary;
        pathParts.push(baseSummaryTreeKey);
        opsBlobs.unshift(outstandingOpsBlob);
    }
}
/**
 * Creates a summary tree which is a handle of the previous successfully acked summary
 * and a blob of the outstanding ops since that summary. If there is no acked summary yet,
 * it will create with the tree found in the initial attach op and the blob of outstanding ops.
 * @param summaryParam - information about last acked summary and paths to encode if from summary,
 * otherwise the initial summary from the attach op.
 * @param outstandingOps - outstanding ops since last acked summary
 */
function encodeSummary(summaryParam, outstandingOps) {
    let additionalPath = EscapedPath.create(baseSummaryTreeKey);
    const builder = new _summaryUtils__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeBuilder();
    builder.addBlob(outstandingOpsBlobKey, JSON.stringify(outstandingOps));
    if (summaryParam.fromSummary) {
        // Create using handle of latest acked summary
        const summaryNode = summaryParam.summaryNode;
        if (summaryNode.additionalPath !== undefined) {
            additionalPath = additionalPath.concat(summaryNode.additionalPath);
        }
        builder.addHandle(baseSummaryTreeKey, _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree, summaryNode.fullPath.path);
    }
    else {
        // Create using initial summary from attach op
        builder.addWithStats(baseSummaryTreeKey, summaryParam.initialSummary);
    }
    const summary = builder.getSummaryTree();
    return Object.assign(Object.assign({}, summary), { additionalPath });
}
/**
 * Checks if the summary contains .channels subtree where the children subtrees
 * would be located if exists.
 * @param baseSummary - summary to check
 */
function parseSummaryForSubtrees(baseSummary) {
    // New versions of snapshots have child nodes isolated in .channels subtree
    const channelsSubtree = baseSummary.trees[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName];
    if (channelsSubtree !== undefined) {
        return {
            childrenTree: channelsSubtree,
            childrenPathPart: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName,
        };
    }
    return {
        childrenTree: baseSummary,
        childrenPathPart: undefined,
    };
}
/**
 * Checks if the summary contains .channels subtree where the children subtrees
 * would be located if exists.
 * @param baseSummary - summary to check
 */
function parseSummaryTreeForSubtrees(summary) {
    // New versions of snapshots have child nodes isolated in .channels subtree
    const channelsSubtree = summary.tree[_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName];
    if (channelsSubtree !== undefined) {
        return {
            childrenTree: channelsSubtree,
            childrenPathPart: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.channelsTreeName,
        };
    }
    return {
        childrenTree: summary,
        childrenPathPart: undefined,
    };
}
//# sourceMappingURL=summarizerNodeUtils.js.map

/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizerNode": () => (/* binding */ SummarizerNode),
/* harmony export */   "createRootSummarizerNode": () => (/* binding */ createRootSummarizerNode)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96);
/* harmony import */ var _summaryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);
/* harmony import */ var _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(107);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





/**
 * Encapsulates the summarizing work and state of an individual tree node in the
 * summary tree. It tracks changes and allows for optimizations when unchanged, or
 * can allow for fallback summaries to be generated when an error is encountered.
 * Usage is for the root node to call startSummary first to begin tracking a WIP
 * (work in progress) summary. Then all nodes will call summarize to summaries their
 * individual parts. Once completed and uploaded to storage, the root node will call
 * completeSummary or clearSummary to clear the WIP summary tracking state if something
 * went wrong. The SummarizerNodes will track all pending summaries that have been
 * recorded by the completeSummary call. When one of them is acked, the root node should
 * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline
 * latest successful summary.
 */
class SummarizerNode {
    /**
     * Do not call constructor directly.
     * Use createRootSummarizerNode to create root node, or createChild to create child nodes.
     */
    constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber, 
    /** Undefined means created without summary */
    _latestSummary, initialSummary, wipSummaryLogger) {
        var _a;
        this.defaultLogger = defaultLogger;
        this.summarizeInternalFn = summarizeInternalFn;
        this._changeSequenceNumber = _changeSequenceNumber;
        this._latestSummary = _latestSummary;
        this.initialSummary = initialSummary;
        this.wipSummaryLogger = wipSummaryLogger;
        this.children = new Map();
        this.pendingSummaries = new Map();
        this.outstandingOps = [];
        this.wipSkipRecursion = false;
        this.canReuseHandle = (_a = config.canReuseHandle) !== null && _a !== void 0 ? _a : true;
        // BUGBUG: Seeing issues with differential summaries.
        // this will disable them, and throw instead
        // while we continue to investigate
        this.throwOnError = true; // config.throwOnFailure ?? false;
        this.trackingSequenceNumber = this._changeSequenceNumber;
    }
    /**
     * The reference sequence number of the most recent acked summary.
     * Returns 0 if there is not yet an acked summary.
     */
    get referenceSequenceNumber() {
        var _a, _b;
        return (_b = (_a = this._latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber) !== null && _b !== void 0 ? _b : 0;
    }
    startSummary(referenceSequenceNumber, summaryLogger) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger === undefined, 0x19f /* "wipSummaryLogger should not be set yet in startSummary" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipReferenceSequenceNumber === undefined, 0x1a0 /* "Already tracking a summary" */);
        this.wipSummaryLogger = summaryLogger;
        for (const child of this.children.values()) {
            child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);
        }
        this.wipReferenceSequenceNumber = referenceSequenceNumber;
    }
    async summarize(fullTree, trackState = true, telemetryContext) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isTrackingInProgress(), 0x1a1 /* "summarize should not be called when not tracking the summary" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger !== undefined, 0x1a2 /* "wipSummaryLogger should have been set in startSummary or ctor" */);
        // Try to reuse the tree if unchanged
        if (this.canReuseHandle && !fullTree && !this.hasChanged()) {
            const latestSummary = this._latestSummary;
            if (latestSummary !== undefined) {
                this.wipLocalPaths = {
                    localPath: latestSummary.localPath,
                    additionalPath: latestSummary.additionalPath,
                };
                this.wipSkipRecursion = true;
                const stats = (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.mergeStats)();
                stats.handleNodeCount++;
                return {
                    summary: {
                        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Handle,
                        handle: latestSummary.fullPath.path,
                        handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree,
                    },
                    stats,
                };
            }
        }
        try {
            const result = await this.summarizeInternalFn(fullTree, true, telemetryContext);
            this.wipLocalPaths = { localPath: _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(result.id) };
            if (result.pathPartsForChildren !== undefined) {
                this.wipLocalPaths.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.createAndConcat(result.pathPartsForChildren);
            }
            return { summary: result.summary, stats: result.stats };
        }
        catch (error) {
            if (this.throwOnError || this.trackingSequenceNumber < this._changeSequenceNumber) {
                throw error;
            }
            const latestSummary = this._latestSummary;
            const initialSummary = this.initialSummary;
            let encodeParam;
            let localPath;
            if (latestSummary !== undefined) {
                // Create using handle of latest acked summary
                encodeParam = {
                    fromSummary: true,
                    summaryNode: latestSummary,
                };
                localPath = latestSummary.localPath;
            }
            else if ((initialSummary === null || initialSummary === void 0 ? void 0 : initialSummary.summary) !== undefined) {
                // Create using initial summary from attach op
                encodeParam = {
                    fromSummary: false,
                    initialSummary: initialSummary.summary,
                };
                localPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(initialSummary.id);
            }
            else {
                // No base summary to reference
                throw error;
            }
            this.wipSummaryLogger.sendErrorEvent({
                eventName: "SummarizingWithBasePlusOps",
            }, error);
            const summary = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.encodeSummary)(encodeParam, this.outstandingOps);
            this.wipLocalPaths = {
                localPath,
                additionalPath: summary.additionalPath,
            };
            this.wipSkipRecursion = true;
            return { summary: summary.summary, stats: summary.stats };
        }
    }
    /**
     * Complete the WIP summary for the given proposalHandle
     */
    completeSummary(proposalHandle) {
        this.completeSummaryCore(proposalHandle, undefined, false);
    }
    /**
     * Recursive implementation for completeSummary, with additional internal-only parameters
     */
    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipSummaryLogger !== undefined, 0x1a3 /* "wipSummaryLogger should have been set in startSummary or ctor" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.wipReferenceSequenceNumber !== undefined, 0x1a4 /* "Not tracking a summary" */);
        let localPathsToUse = this.wipLocalPaths;
        if (parentSkipRecursion) {
            const latestSummary = this._latestSummary;
            if (latestSummary !== undefined) {
                // This case the parent node created a failure summary or was reused.
                // This node and all children should only try to reference their path
                // by its last known good state in the actual summary tree.
                // If parent fails or is reused, the child summarize is not called so
                // it did not get a chance to change its paths.
                // In this case, essentially only propagate the new summary ref seq num.
                localPathsToUse = {
                    localPath: latestSummary.localPath,
                    additionalPath: latestSummary.additionalPath,
                };
            }
            else {
                // This case the child is added after the latest non-failure summary.
                // This node and all children should consider themselves as still not
                // having a successful summary yet.
                // We cannot "reuse" this node if unchanged since that summary, because
                // handles will be unable to point to that node. It never made it to the
                // tree itself, and only exists as an attach op in the _outstandingOps.
                this.clearSummary();
                return;
            }
        }
        // This should come from wipLocalPaths in normal cases, or from the latestSummary
        // if parentIsFailure or parentIsReused is true.
        // If there is no latestSummary, clearSummary and return before reaching this code.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!localPathsToUse, 0x1a5 /* "Tracked summary local paths not set" */);
        const summary = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode(Object.assign(Object.assign({}, localPathsToUse), { referenceSequenceNumber: this.wipReferenceSequenceNumber, basePath: parentPath }));
        const fullPathForChildren = summary.fullPathForChildren;
        for (const child of this.children.values()) {
            child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);
        }
        // Note that this overwrites existing pending summary with
        // the same proposalHandle. If proposalHandle is something like
        // a hash or unique identifier, this should be fine. If storage
        // can return the same proposalHandle for a different summary,
        // this should still be okay, because we should be proposing the
        // newer one later which would have to overwrite the previous one.
        this.pendingSummaries.set(proposalHandle, summary);
        this.clearSummary();
    }
    clearSummary() {
        this.wipReferenceSequenceNumber = undefined;
        this.wipLocalPaths = undefined;
        this.wipSkipRecursion = false;
        this.wipSummaryLogger = undefined;
        for (const child of this.children.values()) {
            child.clearSummary();
        }
    }
    /**
     * Refreshes the latest summary tracked by this node. If we have a pending summary for the given proposal handle,
     * it becomes the latest summary. If the current summary is already ahead (e.g., loaded from a service summary),
     * we skip the update. Otherwise, we get the snapshot by calling `getSnapshot` and update latest
     * summary based off of that.
     * @returns A RefreshSummaryResult type which returns information based on the following three scenarios:
     *          1. The latest summary was not udpated.
     *          2. The latest summary was updated and the summary corresponding to the params was being tracked.
     *          3. The latest summary was updated but the summary corresponding to the params was not tracked. In this
     *             case, the latest summary is updated based on the downloaded snapshot which is also returned.
     */
    async refreshLatestSummary(proposalHandle, summaryRefSeq, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {
        if (proposalHandle !== undefined) {
            const maybeSummaryNode = this.pendingSummaries.get(proposalHandle);
            if (maybeSummaryNode !== undefined) {
                this.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);
                return { latestSummaryUpdated: true, wasSummaryTracked: true };
            }
        }
        // If we have seen a summary same or later as the current one, ignore it.
        if (this.referenceSequenceNumber >= summaryRefSeq) {
            return { latestSummaryUpdated: false };
        }
        const snapshotTree = await getSnapshot();
        await this.refreshLatestSummaryFromSnapshot(summaryRefSeq, snapshotTree, undefined, _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(""), correlatedSummaryLogger, readAndParseBlob);
        return { latestSummaryUpdated: true, wasSummaryTracked: false, snapshot: snapshotTree };
    }
    /**
     * Called when we get an ack from the server for a summary we've just sent. Updates the reference state of this node
     * from the state in the pending summary queue.
     * @param proposalHandle - Handle for the current proposal.
     * @param referenceSequenceNumber -  reference sequence number of sent summary.
     */
    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {
        const summaryNode = this.pendingSummaries.get(proposalHandle);
        if (summaryNode === undefined) {
            // This should only happen if parent skipped recursion AND no prior summary existed.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this._latestSummary === undefined, 0x1a6 /* "Not found pending summary, but this node has previously completed a summary" */);
            return;
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(referenceSequenceNumber === summaryNode.referenceSequenceNumber, 0x1a7 /* Pending summary reference sequence number should be consistent */);
            // Clear earlier pending summaries
            this.pendingSummaries.delete(proposalHandle);
        }
        this.refreshLatestSummaryCore(referenceSequenceNumber);
        this._latestSummary = summaryNode;
        // Propagate update to all child nodes
        for (const child of this.children.values()) {
            child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);
        }
    }
    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {
        // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.
        if (this.referenceSequenceNumber >= referenceSequenceNumber) {
            return;
        }
        this.refreshLatestSummaryCore(referenceSequenceNumber);
        const { baseSummary, pathParts } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.decodeSummary)(snapshotTree, correlatedSummaryLogger);
        this._latestSummary = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode({
            referenceSequenceNumber,
            basePath,
            localPath,
        });
        const { childrenTree, childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryForSubtrees)(baseSummary);
        if (childrenPathPart !== undefined) {
            pathParts.push(childrenPathPart);
        }
        if (pathParts.length > 0) {
            this._latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.createAndConcat(pathParts);
        }
        // Propagate update to all child nodes
        const pathForChildren = this._latestSummary.fullPathForChildren;
        await Promise.all(Array.from(this.children)
            .filter(([id]) => {
            // Assuming subtrees missing from snapshot are newer than the snapshot,
            // but might be nice to assert this using earliest seq for node.
            return childrenTree.trees[id] !== undefined;
        }).map(async ([id, child]) => {
            return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);
        }));
    }
    refreshLatestSummaryCore(referenceSequenceNumber) {
        for (const [key, value] of this.pendingSummaries) {
            if (value.referenceSequenceNumber < referenceSequenceNumber) {
                this.pendingSummaries.delete(key);
            }
        }
        // Clear earlier outstanding ops
        while (this.outstandingOps.length > 0
            && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {
            this.outstandingOps.shift();
        }
    }
    loadBaseSummaryWithoutDifferential(snapshot) {
        // Check base summary to see if it has any additional path parts
        // separating child SummarizerNodes. Checks for .channels subtrees.
        const { childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryForSubtrees)(snapshot);
        if (childrenPathPart !== undefined && this._latestSummary !== undefined) {
            this._latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.create(childrenPathPart);
        }
    }
    async loadBaseSummary(snapshot, readAndParseBlob) {
        const decodedSummary = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.decodeSummary)(snapshot, this.defaultLogger);
        const outstandingOps = await decodedSummary.getOutstandingOps(readAndParseBlob);
        const { childrenPathPart } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryForSubtrees)(decodedSummary.baseSummary);
        if (childrenPathPart !== undefined) {
            decodedSummary.pathParts.push(childrenPathPart);
        }
        if (decodedSummary.pathParts.length > 0 && this._latestSummary !== undefined) {
            this._latestSummary.additionalPath = _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.EscapedPath.createAndConcat(decodedSummary.pathParts);
        }
        // Defensive assertion: tracking number should already exceed this number.
        // This is probably a little excessive; can remove when stable.
        if (outstandingOps.length > 0) {
            const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(newOpsLatestSeq <= this.trackingSequenceNumber, 0x1a9 /* "When loading base summary, expected outstanding ops <= tracking sequence number" */);
        }
        return {
            baseSummary: decodedSummary.baseSummary,
            outstandingOps,
        };
    }
    recordChange(op) {
        const lastOp = this.outstandingOps[this.outstandingOps.length - 1];
        if (lastOp !== undefined) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(lastOp.sequenceNumber < op.sequenceNumber, 0x1aa /* Out of order change recorded */);
        }
        this.invalidate(op.sequenceNumber);
        this.trackingSequenceNumber = op.sequenceNumber;
        this.outstandingOps.push(op);
    }
    invalidate(sequenceNumber) {
        if (sequenceNumber > this._changeSequenceNumber) {
            this._changeSequenceNumber = sequenceNumber;
        }
    }
    /**
     * True if a change has been recorded with sequence number exceeding
     * the latest successfully acked summary reference sequence number.
     * False implies that the previous summary can be reused.
     */
    hasChanged() {
        return this._changeSequenceNumber > this.referenceSequenceNumber;
    }
    get latestSummary() {
        return this._latestSummary;
    }
    createChild(
    /** Summarize function */
    summarizeInternalFn, 
    /** Initial id or path part of this node */
    id, 
    /**
     * Information needed to create the node.
     * If it is from a base summary, it will assert that a summary has been seen.
     * Attach information if it is created from an attach op.
     */
    createParam, config = {}) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.children.has(id), 0x1ab /* "Create SummarizerNode child already exists" */);
        const createDetails = this.getCreateDetailsForChild(id, createParam);
        const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger);
        // There may be additional state that has to be updated in this child. For example, if a summary is being
        // tracked, the child's summary tracking state needs to be updated too. Same goes for pendingSummaries we might
        // have outstanding on the parent in case we realize nodes in between Summary Op and Summary Ack.
        this.maybeUpdateChildState(child);
        this.children.set(id, child);
        return child;
    }
    getChild(id) {
        return this.children.get(id);
    }
    /**
     * Returns the details needed to create a child node.
     * @param id - Initial id or path part of the child node.
     * @param createParam - Information needed to create the node.
     * @returns the details needed to create the child node.
     */
    getCreateDetailsForChild(id, createParam) {
        var _a;
        let initialSummary;
        let latestSummary;
        let changeSequenceNumber;
        const parentLatestSummary = this._latestSummary;
        switch (createParam.type) {
            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.FromAttach: {
                if (parentLatestSummary !== undefined
                    && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {
                    // Prioritize latest summary if it was after this node was attached.
                    latestSummary = parentLatestSummary.createForChild(id);
                }
                else {
                    const summary = (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.convertToSummaryTree)(createParam.snapshot);
                    initialSummary = {
                        sequenceNumber: createParam.sequenceNumber,
                        id,
                        summary,
                    };
                }
                changeSequenceNumber = createParam.sequenceNumber;
                break;
            }
            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.FromSummary: {
                if (this.initialSummary === undefined) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!parentLatestSummary, 0x1ac /* "Cannot create child from summary if parent does not have latest summary" */);
                }
                // fallthrough to local
            }
            case _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.Local: {
                const parentInitialSummary = this.initialSummary;
                if (parentInitialSummary !== undefined) {
                    let childSummary;
                    if (parentInitialSummary.summary !== undefined) {
                        const { childrenTree } = (0,_summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.parseSummaryTreeForSubtrees)(parentInitialSummary.summary.summary);
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childrenTree.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree, 0x1d6 /* "Parent summary object is not a tree" */);
                        childSummary = childrenTree.tree[id];
                    }
                    if (createParam.type === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_4__.CreateSummarizerNodeSource.FromSummary) {
                        // Locally created would not have differential subtree.
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!childSummary, 0x1ad /* "Missing child summary tree" */);
                    }
                    let childSummaryWithStats;
                    if (childSummary !== undefined) {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(childSummary.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.SummaryType.Tree, 0x1ae /* "Child summary object is not a tree" */);
                        childSummaryWithStats = {
                            summary: childSummary,
                            stats: (0,_summaryUtils__WEBPACK_IMPORTED_MODULE_1__.calculateStats)(childSummary),
                        };
                    }
                    initialSummary = {
                        sequenceNumber: parentInitialSummary.sequenceNumber,
                        id,
                        summary: childSummaryWithStats,
                    };
                }
                latestSummary = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.createForChild(id);
                changeSequenceNumber = (_a = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.referenceSequenceNumber) !== null && _a !== void 0 ? _a : -1;
                break;
            }
            default: {
                const type = createParam.type;
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.unreachableCase)(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);
            }
        }
        return {
            initialSummary,
            latestSummary,
            changeSequenceNumber,
        };
    }
    /**
     * Updates the state of the child if required. For example, if a summary is currently being  tracked, the child's
     * summary tracking state needs to be updated too.
     * Also, in case a child node gets realized in between Summary Op and Summary Ack, let's initialize the child's
     * pending summary as well.
     * @param child - The child node whose state is to be updated.
     */
    maybeUpdateChildState(child) {
        // If we are tracking a summary, this child was created after the tracking started. So, we need to update the
        // child's tracking state as well.
        if (this.isTrackingInProgress()) {
            child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;
        }
        // In case we have pending summaries on the parent, let's initialize it on the child.
        if (child._latestSummary !== undefined) {
            for (const [key, value] of this.pendingSummaries.entries()) {
                const newLatestSummaryNode = new _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode({
                    referenceSequenceNumber: value.referenceSequenceNumber,
                    basePath: child._latestSummary.basePath,
                    localPath: child._latestSummary.localPath,
                });
                child.addPendingSummary(key, newLatestSummaryNode);
            }
        }
    }
    addPendingSummary(key, summary) {
        this.pendingSummaries.set(key, summary);
    }
    /**
     * Tells whether summary tracking is in progress. True if "startSummary" API is called before summarize.
     */
    isTrackingInProgress() {
        return this.wipReferenceSequenceNumber !== undefined;
    }
}
/**
 * Creates a root summarizer node.
 * @param logger - Logger to use within SummarizerNode
 * @param summarizeInternalFn - Function to generate summary
 * @param changeSequenceNumber - Sequence number of latest change to new node/subtree
 * @param referenceSequenceNumber - Reference sequence number of last acked summary,
 * or undefined if not loaded from summary
 * @param config - Configure behavior of summarizer node
 */
const createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : _summarizerNodeUtils__WEBPACK_IMPORTED_MODULE_3__.SummaryNode.createForRoot(referenceSequenceNumber));
//# sourceMappingURL=summarizerNode.js.map

/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobHandle": () => (/* binding */ BlobHandle),
/* harmony export */   "BlobManager": () => (/* binding */ BlobManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * This class represents blob (long string)
 * This object is used only when creating (writing) new blob and serialization purposes.
 * De-serialization process goes through FluidObjectHandle and request flow:
 * DataObject.request() recognizes requests in the form of `/blobs/<id>`
 * and loads blob.
 */
class BlobHandle {
    constructor(path, routeContext, get) {
        this.path = path;
        this.routeContext = routeContext;
        this.get = get;
        this.attached = false;
        this.absolutePath = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandle() { return this; }
    get isAttached() {
        return this.attached;
    }
    attachGraph() {
        this.attached = true;
    }
    bind(handle) {
        throw new Error("Cannot bind to blob handle");
    }
}
class BlobManager {
    constructor(routeContext, snapshot, getStorage, attachBlobCallback, 
    // To be called when a blob node is requested. blobPath is the path of the blob's node in GC's graph. It's
    // of the format `/<BlobManager.basePath>/<blobId>`.
    gcNodeUpdated, runtime, logger) {
        this.routeContext = routeContext;
        this.getStorage = getStorage;
        this.attachBlobCallback = attachBlobCallback;
        this.gcNodeUpdated = gcNodeUpdated;
        this.runtime = runtime;
        this.logger = logger;
        // uploaded blob IDs
        this.blobIds = new Set();
        // blobs for which upload is pending. maps to a promise that will resolve once the blob has been uploaded and a
        // BlobAttach op has round-tripped.
        this.pendingBlobIds = new Map();
        // blobs uploaded while detached; cleared upon attach
        this.detachedBlobIds = new Set();
        this.runtime.once("dispose", () => {
            for (const promise of this.pendingBlobIds.values()) {
                promise.reject(new Error("runtime disposed while blobAttach op in flight"));
            }
        });
        this.load(snapshot);
    }
    hasBlob(id) {
        return this.blobIds.has(id) || this.detachedBlobIds.has(id);
    }
    /**
     * For a blobId, returns its path in GC's graph. The node path is of the format `/<BlobManager.basePath>/<blobId>`
     * This path must match the path of the blob handle returned by the createBlob API because blobs are marked
     * referenced by storing these handles in a referenced DDS.
     */
    getBlobGCNodePath(blobId) {
        return `/${BlobManager.basePath}/${blobId}`;
    }
    async getBlob(blobId) {
        var _a, _b;
        const storageId = (_b = (_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.get(blobId)) !== null && _b !== void 0 ? _b : blobId;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.hasBlob(storageId), 0x11f /* "requesting unknown blobs" */);
        // When this blob is retrieved, let the container runtime know that the corresponding GC node got updated.
        this.gcNodeUpdated(this.getBlobGCNodePath(blobId));
        return new BlobHandle(`${BlobManager.basePath}/${storageId}`, this.routeContext, async () => _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "AttachmentReadBlob", id: storageId }, async () => {
            return this.getStorage().readBlob(storageId);
        }, { end: true, cancel: "error" }));
    }
    async createBlob(blob) {
        var _a, _b;
        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching) {
            // blob upload is not supported in "Attaching" state
            this.logger.sendTelemetryEvent({ eventName: "CreateBlobWhileAttaching" });
            await new Promise((resolve) => this.runtime.once("attached", resolve));
        }
        if (!this.runtime.connected && this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached) {
            // see https://github.com/microsoft/FluidFramework/issues/8246
            // Avoid getting storage if we are offline since it might be undefined. In the future we will return
            // handles immediately while offline
            await new Promise((resolve) => this.runtime.once("connected", resolve));
        }
        const response = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "createBlob" }, async () => this.getStorage().createBlob(blob), { end: true, cancel: "error" });
        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, this.routeContext, 
        // get() should go through BlobManager.getBlob() so handles created while detached can be redirected
        // to the correct storage id after they are uploaded
        async () => this.getBlob(response.id).then(async (h) => h.get()));
        if (this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached) {
            this.detachedBlobIds.add(response.id);
            return handle;
        }
        // Note - server will de-dup blobs, so we might get existing blobId!
        if (this.pendingBlobIds.has(response.id)) {
            await ((_a = this.pendingBlobIds.get(response.id)) === null || _a === void 0 ? void 0 : _a.promise);
        }
        else if (!this.blobIds.has(response.id)) {
            this.pendingBlobIds.set(response.id, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Deferred());
            // send blob attach op and wait until we see it to return the handle
            this.attachBlobCallback(response.id);
            await ((_b = this.pendingBlobIds.get(response.id)) === null || _b === void 0 ? void 0 : _b.promise);
        }
        return handle;
    }
    processBlobAttachOp(blobId, local) {
        if (local) {
            const pendingBlobP = this.pendingBlobIds.get(blobId);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(pendingBlobP !== undefined, 0x1f8 /* "local BlobAttach op with no pending blob" */);
            pendingBlobP.resolve();
            this.pendingBlobIds.delete(blobId);
        }
        this.blobIds.add(blobId);
    }
    /**
     * Reads blobs needed to load BlobManager from storage.
     */
    static async load(blobsTree, tryFetchBlob) {
        if (!blobsTree) {
            return {};
        }
        let redirectTable;
        const tableId = blobsTree.blobs[this.redirectTableBlobName];
        if (tableId) {
            redirectTable = await tryFetchBlob(tableId);
        }
        const ids = Object.entries(blobsTree.blobs)
            .filter(([k, _]) => k !== this.redirectTableBlobName).map(([_, v]) => v);
        return { ids, redirectTable };
    }
    /**
     * Load a set of previously attached blob IDs from a previous snapshot. Note
     * that BlobManager tracking and reporting attached blobs is a temporary
     * solution since storage expects attached blobs to be reported and any that
     * are not reported as attached may be GCed. In the future attached blob
     * IDs will be collected at summarization time, and runtime will not care
     * about the existence or specific formatting of this tree in returned
     * snapshots.
     *
     * @param blobsTree - Tree containing IDs of previously attached blobs. This
     * corresponds to snapshot() below. We look for the IDs in the blob entries
     * of the tree since the both the r11s and SPO drivers replace the
     * attachment types returned in snapshot() with blobs.
     */
    load(snapshot) {
        var _a, _b, _c;
        if (snapshot.ids) {
            const detached = this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached;
            snapshot.ids.map((entry) => detached ? this.detachedBlobIds.add(entry) : this.blobIds.add(entry));
        }
        if (snapshot.redirectTable) {
            this.redirectTable = new Map(snapshot.redirectTable);
        }
        this.logger.sendTelemetryEvent({
            eventName: "AttachmentBlobsLoaded",
            count: (_b = (_a = snapshot.ids) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,
            redirectTable: (_c = snapshot.redirectTable) === null || _c === void 0 ? void 0 : _c.length,
        });
    }
    /**
     * Generates data used for garbage collection. Each blob uploaded represents a node in the GC graph as it can be
     * individually referenced by storing its handle in a referenced DDS. Returns the list of blob ids as GC nodes.
     * @param fullGC - true to bypass optimizations and force full generation of GC data. BlobManager doesn't care
     * about this for now because the data is a simple list of blob ids.
     */
    getGCData(fullGC = false) {
        const gcData = { gcNodes: {} };
        this.blobIds.forEach((blobId) => {
            gcData.gcNodes[this.getBlobGCNodePath(blobId)] = [];
        });
        /**
         * For all blobs in the redirect table, the handle returned on creation is based off of the localId. So, these
         * nodes can be referenced by storing the localId handle. When that happens, the corresponding storageId node
         * must also be marked referenced. So, we add a route from the localId node to the storageId node.
         * Note that because of de-duping, there can be multiple localIds that all redirect to the same storageId or
         * a blob may be referenced via its storageId handle.
         */
        if (this.redirectTable !== undefined) {
            for (const [localId, storageId] of this.redirectTable) {
                // Add node for the localId and add a route to the storageId node. The storageId node will have been
                // added above when adding nodes for this.blobIds.
                gcData.gcNodes[this.getBlobGCNodePath(localId)] = [this.getBlobGCNodePath(storageId)];
            }
        }
        return gcData;
    }
    /**
     * When running GC in test mode, this is called to delete blobs that are unused.
     * @param unusedRoutes - These are the blob node ids that are unused and should be deleted.
     */
    deleteUnusedRoutes(unusedRoutes) {
        var _a;
        // The routes or blob node paths are in the same format as returned in getGCData -
        // `/<BlobManager.basePath>/<blobId>`.
        for (const route of unusedRoutes) {
            const pathParts = route.split("/");
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(pathParts.length === 3 && pathParts[1] === BlobManager.basePath, 0x2d5 /* "Invalid blob node id in unused routes." */);
            const blobId = pathParts[2];
            // The unused blobId could be a localId. If so, remove it from the redirect table and continue. The
            // corresponding storageId may still be used either directly or via other localIds.
            if ((_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.has(blobId)) {
                this.redirectTable.delete(blobId);
                continue;
            }
            this.blobIds.delete(blobId);
        }
    }
    summarize(telemetryContext) {
        // If we have a redirect table it means the container is about to transition to "Attaching" state, so we need
        // to return an actual snapshot containing all the real storage IDs we know about.
        const attachingOrAttached = !!this.redirectTable || this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached;
        const blobIds = attachingOrAttached ? this.blobIds : this.detachedBlobIds;
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_5__.SummaryTreeBuilder();
        blobIds.forEach((blobId) => {
            builder.addAttachment(blobId);
        });
        if (this.redirectTable && this.redirectTable.size > 0) {
            builder.addBlob(BlobManager.redirectTableBlobName, JSON.stringify(Array.from(this.redirectTable.entries())));
        }
        return builder.getSummaryTree();
    }
    setRedirectTable(table) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Detached, 0x252 /* "redirect table can only be set in detached container" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.redirectTable, 0x253 /* "redirect table already exists" */);
        for (const [localId, storageId] of table) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.detachedBlobIds.delete(localId), 0x254 /* "unrecognized id in redirect table" */);
            this.blobIds.add(storageId);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.detachedBlobIds.size === 0, 0x255 /* "detached blob id absent in redirect table" */);
        this.redirectTable = table;
    }
}
BlobManager.basePath = "_blobs";
BlobManager.redirectTableBlobName = ".redirectTable";
//# sourceMappingURL=blobManager.js.map

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PendingStateManager": () => (/* binding */ PendingStateManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(double_ended_queue__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





/**
 * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been
 * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed
 * batches along with the messages.
 * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing
 * of messages and triggering resubmission of unacked ops.
 *
 * It verifies that all the ops are acked, are received in the right order and batch information is correct.
 */
class PendingStateManager {
    constructor(stateHandler, initialFlushMode, initialLocalState) {
        var _a;
        this.stateHandler = stateHandler;
        this.pendingStates = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())();
        this.disposeOnce = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => {
            this.initialStates.clear();
            this.pendingStates.clear();
        });
        // Maintains the count of messages that are currently unacked.
        this._pendingMessagesCount = 0;
        // Indicates whether we are processing a batch.
        this.isProcessingBatch = false;
        this.dispose = () => this.disposeOnce.value;
        this.initialStates = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())((_a = initialLocalState === null || initialLocalState === void 0 ? void 0 : initialLocalState.pendingStates) !== null && _a !== void 0 ? _a : []);
        this.flushModeForNextMessage = initialFlushMode;
        this.onFlushModeUpdated(initialFlushMode);
    }
    get pendingMessagesCount() {
        return this._pendingMessagesCount;
    }
    /**
     * Called to check if there are any pending messages in the pending state queue.
     * @returns A boolean indicating whether there are messages or not.
     */
    hasPendingMessages() {
        return this._pendingMessagesCount !== 0 || !this.initialStates.isEmpty();
    }
    getLocalState() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.initialStates.isEmpty(), 0x2e9 /* "Must call getLocalState() after applying initial states" */);
        if (this.hasPendingMessages()) {
            return {
                pendingStates: this.pendingStates.toArray().map(
                // delete localOpMetadata since it may not be serializable
                // and will be regenerated by applyStashedOp()
                (state) => state.type === "message" ? Object.assign(Object.assign({}, state), { localOpMetadata: undefined }) : state),
            };
        }
    }
    get disposed() { return this.disposeOnce.evaluated; }
    /**
     * Called when a message is submitted locally. Adds the message and the associated details to the pending state
     * queue.
     * @param type - The container message type.
     * @param clientSequenceNumber - The clientSequenceNumber associated with the message.
     * @param content - The message content.
     * @param localOpMetadata - The local metadata associated with the message.
     */
    onSubmitMessage(type, clientSequenceNumber, referenceSequenceNumber, content, localOpMetadata, opMetadata) {
        const pendingMessage = {
            type: "message",
            messageType: type,
            clientSequenceNumber,
            referenceSequenceNumber,
            content,
            localOpMetadata,
            opMetadata,
        };
        this.pendingStates.push(pendingMessage);
        this._pendingMessagesCount++;
    }
    /**
     * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.
     * @param flushMode - The flushMode that was updated.
     */
    onFlushModeUpdated(flushMode) {
        this.pendingStates.push({ type: "flushMode", flushMode });
    }
    /**
     * Called when flush() is called on the ContainerRuntime to manually flush messages.
     */
    onFlush() {
        // If the FlushMode is Immediate, we don't need to track an explicit flush call because every message is
        // automatically flushed. So, flush is a no-op.
        if (this.stateHandler.flushMode() === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.FlushMode.Immediate) {
            return;
        }
        // If the previous state is not a message, flush is a no-op.
        const previousState = this.pendingStates.peekBack();
        if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) !== "message") {
            return;
        }
        // An explicit flush is interesting and is tracked only if there are messages sent in TurnBased mode.
        this.pendingStates.push({ type: "flush" });
    }
    /**
     * Applies stashed ops at their reference sequence number so they are ready to be ACKed or resubmitted
     * @param seqNum - Sequence number at which to apply ops. Will apply all ops if seqNum is undefined.
     */
    async applyStashedOpsAt(seqNum) {
        // apply stashed ops at sequence number
        while (!this.initialStates.isEmpty()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const nextState = this.initialStates.peekFront();
            if (nextState.type === "message") {
                if (seqNum !== undefined) {
                    if (nextState.referenceSequenceNumber > seqNum) {
                        break; // nothing left to do at this sequence number
                    }
                    else if (nextState.referenceSequenceNumber < seqNum) {
                        throw new Error("loaded from snapshot too recent to apply stashed ops");
                    }
                }
                // applyStashedOp will cause the DDS to behave as if it has sent the op but not actually send it
                const localOpMetadata = await this.stateHandler.applyStashedOp(nextState.messageType, nextState.content);
                nextState.localOpMetadata = localOpMetadata;
            }
            // then we push onto pendingStates which will cause PendingStateManager to resubmit when we connect
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.pendingStates.push(this.initialStates.shift());
        }
    }
    /**
     * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that
     * the batch information was preserved for batch messages.
     * @param message - The message that got ack'd and needs to be processed.
     */
    processPendingLocalMessage(message) {
        // Pre-processing part - This may be the start of a batch.
        this.maybeProcessBatchBegin(message);
        // Get the next state from the pending queue and verify that it is of type "message".
        const pendingState = this.peekNextPendingState();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingState.type === "message", 0x169 /* "No pending message found for this remote message" */);
        this.pendingStates.shift();
        // Processing part - Verify that there has been no data corruption.
        // The clientSequenceNumber of the incoming message must match that of the pending message.
        if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {
            // Close the container because this could indicate data corruption.
            const error = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.create("pending local message clientSequenceNumber mismatch", "unexpectedAckReceived", message, { expectedClientSequenceNumber: pendingState.clientSequenceNumber });
            this.stateHandler.close(error);
            return;
        }
        this._pendingMessagesCount--;
        // Post-processing part - If we are processing a batch then this could be the last message in the batch.
        this.maybeProcessBatchEnd(message);
        return pendingState.localOpMetadata;
    }
    /**
     * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.
     * @param message - The message that is being processed.
     */
    maybeProcessBatchBegin(message) {
        // Tracks the last FlushMode that was set before this message was sent.
        let pendingFlushMode;
        // Tracks whether a flush was called before this message was sent.
        let pendingFlush = false;
        /**
         * We are checking if the next message is the start of a batch. It can happen in the following scenarios:
         * 1. The FlushMode was set to TurnBased before this message was sent.
         * 2. The FlushMode was already TurnBased and a flush was called before this message was sent. This essentially
         *    means that the flush marked the end of a previous batch and beginning of a new batch.
         *
         * Keep reading pending states from the queue until we encounter a message. It's possible that the FlushMode was
         * updated a bunch of times without sending any messages.
         */
        let nextPendingState = this.peekNextPendingState();
        while (nextPendingState.type !== "message") {
            if (nextPendingState.type === "flushMode") {
                pendingFlushMode = nextPendingState.flushMode;
            }
            if (nextPendingState.type === "flush") {
                pendingFlush = true;
            }
            this.pendingStates.shift();
            nextPendingState = this.peekNextPendingState();
        }
        if (pendingFlushMode !== undefined) {
            this.flushModeForNextMessage = pendingFlushMode;
        }
        // If the FlushMode was set to Immediate before this message was sent, this message won't be a batch message
        // because in Immediate mode, every message is flushed individually.
        if (pendingFlushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.FlushMode.Immediate) {
            return;
        }
        /**
         * This message is the first in a batch if before it was sent either the FlushMode was set to TurnBased or there
         * was an explicit flush call. Note that a flush call is tracked only in TurnBased mode and it indicates the end
         * of one batch and beginning of another.
         */
        if (pendingFlushMode === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_3__.FlushMode.TurnBased || pendingFlush) {
            // We should not already be processing a batch and there should be no pending batch begin message.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, 0x16b /* "The pending batch state indicates we are already processing a batch" */);
            // Set the pending batch state indicating we have started processing a batch.
            this.pendingBatchBeginMessage = message;
            this.isProcessingBatch = true;
        }
    }
    /**
     * This message could be the last message in batch. If so, clear batch state since the batch is complete.
     * @param message - The message that is being processed.
     */
    maybeProcessBatchEnd(message) {
        var _a, _b;
        if (!this.isProcessingBatch) {
            return;
        }
        const nextPendingState = this.peekNextPendingState();
        if (nextPendingState.type === "message") {
            return;
        }
        /**
         * We are in the middle of processing a batch. The batch ends when we see an explicit flush. We should never see
         * a FlushMode before flush. This is true because we track batches only when FlushMode is TurnBased and in this
         * mode, a batch ends either by calling flush or by changing the mode to Immediate which also triggers a flush.
         */
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(nextPendingState.type !== "flushMode", 0x2bd /* "We should not see a pending FlushMode until we see a flush when processing a batch" */);
        // There should be a pending batch begin message.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pendingBatchBeginMessage !== undefined, 0x16d /* "There is no pending batch begin message" */);
        // Get the batch begin metadata from the first message in the batch.
        const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch;
        // There could be just a single message in the batch. If so, it should not have any batch metadata. If there
        // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.
        if (this.pendingBatchBeginMessage === message) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchBeginMetadata === undefined, 0x16e /* "Batch with single message should not have batch metadata" */);
        }
        else {
            // Get the batch metadata from the last message in the batch.
            const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchBeginMetadata === true, 0x16f /* "Did not receive batch begin metadata" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(batchEndMetadata === false, 0x170 /* "Did not receive batch end metadata" */);
        }
        // Clear the pending batch state now that we have processed the entire batch.
        this.pendingBatchBeginMessage = undefined;
        this.isProcessingBatch = false;
    }
    /**
     * Capture the pending state at this point
     */
    checkpoint() {
        const checkpointHead = this.pendingStates.peekBack();
        return {
            rollback: () => {
                try {
                    while (this.pendingStates.peekBack() !== checkpointHead) {
                        this.rollbackNextPendingState();
                    }
                }
                catch (err) {
                    const error = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.wrapError)(err, (message) => {
                        return _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.create(`RollbackError: ${message}`, "checkpointRollback", undefined);
                    });
                    this.stateHandler.close(error);
                    throw error;
                }
            },
        };
    }
    /**
     * Returns the next pending state from the pending state queue.
     */
    peekNextPendingState() {
        const nextPendingState = this.pendingStates.peekFront();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!nextPendingState, 0x171 /* "No pending state found for the remote message" */);
        return nextPendingState;
    }
    /**
     * Undo the last pending state
     */
    rollbackNextPendingState() {
        const pendingStatesCount = this.pendingStates.length;
        if (pendingStatesCount === 0) {
            return;
        }
        this._pendingMessagesCount--;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const pendingState = this.pendingStates.pop();
        switch (pendingState.type) {
            case "message":
                this.stateHandler.rollback(pendingState.messageType, pendingState.content, pendingState.localOpMetadata);
                break;
            default:
                throw new Error(`Can't rollback state ${pendingState.type}`);
        }
    }
    /**
     * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending
     * states in its queue. This includes setting the FlushMode and triggering resubmission of unacked ops.
     */
    replayPendingStates() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.stateHandler.connected(), 0x172 /* "The connection state is not consistent with the runtime" */);
        // This assert suggests we are about to send same ops twice, which will result in data loss.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.clientId !== this.stateHandler.clientId(), 0x173 /* "replayPendingStates called twice for same clientId!" */);
        this.clientId = this.stateHandler.clientId();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.initialStates.isEmpty(), 0x174 /* "initial states should be empty before replaying pending" */);
        let pendingStatesCount = this.pendingStates.length;
        if (pendingStatesCount === 0) {
            return;
        }
        // Reset the pending message count because all these messages will be removed from the queue.
        this._pendingMessagesCount = 0;
        // Save the current FlushMode so that we can revert it back after replaying the states.
        const savedFlushMode = this.stateHandler.flushMode();
        // Set the flush mode for the next message. This step is important because the flush mode may have been changed
        // after the next pending message was sent.
        this.stateHandler.setFlushMode(this.flushModeForNextMessage);
        // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were
        // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue
        // which must not be replayed.
        while (pendingStatesCount > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pendingState = this.pendingStates.shift();
            switch (pendingState.type) {
                case "message":
                    this.stateHandler.reSubmit(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);
                    break;
                case "flushMode":
                    this.stateHandler.setFlushMode(pendingState.flushMode);
                    break;
                case "flush":
                    this.stateHandler.flush();
                    break;
                default:
                    break;
            }
            pendingStatesCount--;
        }
        // Revert the FlushMode.
        this.stateHandler.setFlushMode(savedFlushMode);
    }
}
//# sourceMappingURL=pendingStateManager.js.map

/***/ }),
/* 112 */
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function Deque(capacity) {
    this._capacity = getCapacity(capacity);
    this._length = 0;
    this._front = 0;
    if (isArray(capacity)) {
        var len = capacity.length;
        for (var i = 0; i < len; ++i) {
            this[i] = capacity[i];
        }
        this._length = len;
    }
}

Deque.prototype.toArray = function Deque$toArray() {
    var len = this._length;
    var ret = new Array(len);
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        ret[j] = this[(front + j) & (capacity - 1)];
    }
    return ret;
};

Deque.prototype.push = function Deque$push(item) {
    var argsLength = arguments.length;
    var length = this._length;
    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = (this._front + length) & (this._capacity - 1);
                this[j] = arguments[i];
                length++;
                this._length = length;
            }
            return length;
        }
        else {
            var j = this._front;
            for (var i = 0; i < argsLength; ++i) {
                this[(j + length) & (capacity - 1)] = arguments[i];
                j++;
            }
            this._length = length + argsLength;
            return length + argsLength;
        }

    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = item;
    this._length = length + 1;
    return length + 1;
};

Deque.prototype.pop = function Deque$pop() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var i = (this._front + length - 1) & (this._capacity - 1);
    var ret = this[i];
    this[i] = void 0;
    this._length = length - 1;
    return ret;
};

Deque.prototype.shift = function Deque$shift() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var front = this._front;
    var ret = this[front];
    this[front] = void 0;
    this._front = (front + 1) & (this._capacity - 1);
    this._length = length - 1;
    return ret;
};

Deque.prototype.unshift = function Deque$unshift(item) {
    var length = this._length;
    var argsLength = arguments.length;


    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (((( this._front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
            }
            return length;
        }
        else {
            var front = this._front;
            for (var i = argsLength - 1; i >= 0; i--) {
                var j = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                front = j;
            }
            this._front = front;
            this._length = length + argsLength;
            return length + argsLength;
        }
    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var capacity = this._capacity;
    var i = (((( this._front - 1 ) &
        ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = item;
    this._length = length + 1;
    this._front = i;
    return length + 1;
};

Deque.prototype.peekBack = function Deque$peekBack() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var index = (this._front + length - 1) & (this._capacity - 1);
    return this[index];
};

Deque.prototype.peekFront = function Deque$peekFront() {
    if (this._length === 0) {
        return void 0;
    }
    return this[this._front];
};

Deque.prototype.get = function Deque$get(index) {
    var i = index;
    if ((i !== (i | 0))) {
        return void 0;
    }
    var len = this._length;
    if (i < 0) {
        i = i + len;
    }
    if (i < 0 || i >= len) {
        return void 0;
    }
    return this[(this._front + i) & (this._capacity - 1)];
};

Deque.prototype.isEmpty = function Deque$isEmpty() {
    return this._length === 0;
};

Deque.prototype.clear = function Deque$clear() {
    var len = this._length;
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        this[(front + j) & (capacity - 1)] = void 0;
    }
    this._length = 0;
    this._front = 0;
};

Deque.prototype.toString = function Deque$toString() {
    return this.toArray().toString();
};

Deque.prototype.valueOf = Deque.prototype.toString;
Deque.prototype.removeFront = Deque.prototype.shift;
Deque.prototype.removeBack = Deque.prototype.pop;
Deque.prototype.insertFront = Deque.prototype.unshift;
Deque.prototype.insertBack = Deque.prototype.push;
Deque.prototype.enqueue = Deque.prototype.push;
Deque.prototype.dequeue = Deque.prototype.shift;
Deque.prototype.toJSON = Deque.prototype.toArray;

Object.defineProperty(Deque.prototype, "length", {
    get: function() {
        return this._length;
    },
    set: function() {
        throw new RangeError("");
    }
});

Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
    if (this._capacity < size) {
        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
    }
};

Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    if (front + length > oldCapacity) {
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    }
};


var isArray = Array.isArray;

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}

function getCapacity(capacity) {
    if (typeof capacity !== "number") {
        if (isArray(capacity)) {
            capacity = capacity.length;
        }
        else {
            return 16;
        }
    }
    return pow2AtLeast(
        Math.min(
            Math.max(16, capacity), 1073741824)
    );
}

module.exports = Deque;


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryCollection": () => (/* binding */ SummaryCollection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


var SummaryState;
(function (SummaryState) {
    SummaryState[SummaryState["Local"] = 0] = "Local";
    SummaryState[SummaryState["Broadcast"] = 1] = "Broadcast";
    SummaryState[SummaryState["Acked"] = 2] = "Acked";
    SummaryState[SummaryState["Nacked"] = -1] = "Nacked";
})(SummaryState || (SummaryState = {}));
class Summary {
    constructor(clientId, clientSequenceNumber) {
        this.clientId = clientId;
        this.clientSequenceNumber = clientSequenceNumber;
        this.state = SummaryState.Local;
        this.defSummaryOp = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.defSummaryAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
    }
    static createLocal(clientId, clientSequenceNumber) {
        return new Summary(clientId, clientSequenceNumber);
    }
    static createFromOp(op) {
        const summary = new Summary(op.clientId, op.clientSequenceNumber);
        summary.broadcast(op);
        return summary;
    }
    get summaryOp() { return this._summaryOp; }
    get summaryAckNack() { return this._summaryAckNack; }
    hasBeenAcked() {
        return this.state === SummaryState.Acked;
    }
    broadcast(op) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryState.Local, 0x175 /* "Can only broadcast if summarizer starts in local state" */);
        this._summaryOp = op;
        this.defSummaryOp.resolve();
        this.state = SummaryState.Broadcast;
        return true;
    }
    ackNack(op) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryState.Broadcast, 0x176 /* "Can only ack/nack if summarizer is in broadcasting state" */);
        this._summaryAckNack = op;
        this.defSummaryAck.resolve();
        this.state = op.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;
        return true;
    }
    async waitBroadcast() {
        await this.defSummaryOp.promise;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._summaryOp;
    }
    async waitAckNack() {
        await this.defSummaryAck.promise;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._summaryAckNack;
    }
}
/**
 * This class watches summaries created by a specific client.
 * It should be created and managed from a SummaryCollection.
 */
class ClientSummaryWatcher {
    constructor(clientId, summaryCollection) {
        this.clientId = clientId;
        this.summaryCollection = summaryCollection;
        // key: clientSeqNum
        this.localSummaries = new Map();
        this._disposed = false;
    }
    get disposed() { return this._disposed; }
    /**
     * Watches for a specific sent summary op.
     * @param clientSequenceNumber - client sequence number of sent summary op
     */
    watchSummary(clientSequenceNumber) {
        let summary = this.localSummaries.get(clientSequenceNumber);
        if (!summary) {
            summary = Summary.createLocal(this.clientId, clientSequenceNumber);
            this.localSummaries.set(summary.clientSequenceNumber, summary);
        }
        return summary;
    }
    /**
     * Waits until all of the pending summaries in the underlying SummaryCollection
     * are acked/nacked.
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    waitFlushed() {
        return this.summaryCollection.waitFlushed();
    }
    /**
     * Gets a watched summary or returns undefined if not watched.
     * @param clientSequenceNumber - client sequence number of sent summary op
     */
    tryGetSummary(clientSequenceNumber) {
        return this.localSummaries.get(clientSequenceNumber);
    }
    /**
     * Starts watching a summary made by this client.
     * @param summary - summary to start watching
     */
    setSummary(summary) {
        this.localSummaries.set(summary.clientSequenceNumber, summary);
    }
    dispose() {
        this.summaryCollection.removeWatcher(this.clientId);
        this._disposed = true;
    }
}
/**
 * Data structure that looks at the op stream to track summaries as they
 * are broadcast, acked and nacked.
 * It provides functionality for watching specific summaries.
 */
class SummaryCollection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.TypedEventEmitter {
    constructor(deltaManager, logger) {
        super();
        this.deltaManager = deltaManager;
        this.logger = logger;
        // key: clientId
        this.summaryWatchers = new Map();
        // key: summarySeqNum
        this.pendingSummaries = new Map();
        this.refreshWaitNextAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.deltaManager.on("op", (op) => this.handleOp(op));
    }
    get latestAck() { return this.lastAck; }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    get opsSinceLastAck() {
        var _a, _b;
        return this.deltaManager.lastSequenceNumber -
            ((_b = (_a = this.lastAck) === null || _a === void 0 ? void 0 : _a.summaryAck.sequenceNumber) !== null && _b !== void 0 ? _b : this.deltaManager.initialSequenceNumber);
    }
    addOpListener(listener) {
        this.deltaManager.on("op", listener);
    }
    removeOpListener(listener) {
        this.deltaManager.off("op", listener);
    }
    /**
     * Creates and returns a summary watcher for a specific client.
     * This will allow for local sent summaries to be better tracked.
     * @param clientId - client id for watcher
     */
    createWatcher(clientId) {
        const watcher = new ClientSummaryWatcher(clientId, this);
        this.summaryWatchers.set(clientId, watcher);
        return watcher;
    }
    removeWatcher(clientId) {
        this.summaryWatchers.delete(clientId);
    }
    setPendingAckTimerTimeoutCallback(maxAckWaitTime, timeoutCallback) {
        this.maxAckWaitTime = maxAckWaitTime;
        this.pendingAckTimerTimeoutCallback = timeoutCallback;
    }
    unsetPendingAckTimerTimeoutCallback() {
        this.maxAckWaitTime = undefined;
        this.pendingAckTimerTimeoutCallback = undefined;
    }
    /**
     * Returns a promise that resolves once all pending summary ops
     * have been acked or nacked.
     */
    async waitFlushed() {
        while (this.pendingSummaries.size > 0) {
            // eslint-disable-next-line @typescript-eslint/promise-function-async
            const promises = Array.from(this.pendingSummaries, ([, summary]) => summary.waitAckNack());
            await Promise.all(promises);
        }
        return this.lastAck;
    }
    /**
     * Returns a promise that resolves once a summary is acked that has a reference
     * sequence number greater than or equal to the passed in sequence number.
     * @param referenceSequenceNumber - reference sequence number to wait for
     * @returns The latest acked summary
     */
    async waitSummaryAck(referenceSequenceNumber) {
        while (!this.lastAck || this.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {
            await this.refreshWaitNextAck.promise;
        }
        return this.lastAck;
    }
    /**
     * Handler for ops; only handles ops relating to summaries.
     * @param op - op message to handle
     */
    handleOp(op) {
        var _a;
        switch (op.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Summarize: {
                this.handleSummaryOp(op);
                return;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck: {
                this.handleSummaryAck(op);
                return;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryNack: {
                this.handleSummaryNack(op);
                return;
            }
            default: {
                // If the difference between timestamp of current op and last summary op is greater than
                // the maxAckWaitTime, then we need to inform summarizer to not wait and summarize
                // immediately as we have already waited for maxAckWaitTime.
                const lastOpTimestamp = op.timestamp;
                if (this.lastSummaryTimestamp !== undefined &&
                    this.maxAckWaitTime !== undefined &&
                    lastOpTimestamp - this.lastSummaryTimestamp >= this.maxAckWaitTime) {
                    (_a = this.pendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                this.emit("default", op);
                return;
            }
        }
    }
    handleSummaryOp(op) {
        let summary;
        // Check if summary already being watched, broadcast if so
        const watcher = this.summaryWatchers.get(op.clientId);
        if (watcher) {
            summary = watcher.tryGetSummary(op.clientSequenceNumber);
            if (summary) {
                summary.broadcast(op);
            }
        }
        // If not watched, create from op
        if (!summary) {
            summary = Summary.createFromOp(op);
            if (watcher) {
                watcher.setSummary(summary);
            }
        }
        this.pendingSummaries.set(op.sequenceNumber, summary);
        this.lastSummaryTimestamp = op.timestamp;
        this.emit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.Summarize, op);
    }
    handleSummaryAck(op) {
        const seq = op.contents.summaryProposal.summarySequenceNumber;
        const summary = this.pendingSummaries.get(seq);
        if (!summary || summary.summaryOp === undefined) {
            // Summary ack without an op should be rare. We could fetch the
            // reference sequence number from the snapshot, but instead we
            // will not emit this ack. It should be the case that the summary
            // op that this ack is for is earlier than this file was loaded
            // from. i.e. initialSequenceNumber > summarySequenceNumber.
            // We really don't care about it for now, since it is older than
            // the one we loaded from.
            if (seq >= this.deltaManager.initialSequenceNumber) {
                // Potential causes for it to be later than our initialSequenceNumber
                // are that the summaryOp was nacked then acked, double-acked, or
                // the summarySequenceNumber is incorrect.
                this.logger.sendErrorEvent({
                    eventName: "SummaryAckWithoutOp",
                    sequenceNumber: op.sequenceNumber,
                    summarySequenceNumber: seq,
                    initialSequenceNumber: this.deltaManager.initialSequenceNumber,
                });
            }
            return;
        }
        summary.ackNack(op);
        this.pendingSummaries.delete(seq);
        // Track latest ack
        if (!this.lastAck || seq > this.lastAck.summaryAck.contents.summaryProposal.summarySequenceNumber) {
            this.lastAck = {
                summaryOp: summary.summaryOp,
                summaryAck: op,
            };
            this.refreshWaitNextAck.resolve();
            this.refreshWaitNextAck = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
            this.emit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryAck, op);
        }
    }
    handleSummaryNack(op) {
        const seq = op.contents.summaryProposal.summarySequenceNumber;
        const summary = this.pendingSummaries.get(seq);
        if (summary) {
            summary.ackNack(op);
            this.pendingSummaries.delete(seq);
            this.emit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.MessageType.SummaryNack, op);
        }
    }
}
//# sourceMappingURL=summaryCollection.js.map

/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrderedClientCollection": () => (/* binding */ OrderedClientCollection),
/* harmony export */   "OrderedClientElection": () => (/* binding */ OrderedClientElection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71);




/**
 * Tracks clients in the Quorum. It maintains their order using their join op
 * sequence numbers.
 * Internally, the collection of clients is maintained in a doubly-linked list,
 * with pointers to both the first and last nodes.
 * The first (root) node is a placeholder to simplify logic and reduce null checking.
 */
class OrderedClientCollection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(logger, deltaManager, quorum) {
        super();
        /** Collection of ALL clients currently in the quorum, with client ids as keys. */
        this.clientMap = new Map();
        /** Placeholder head node of linked list, for simplified null checking. */
        this.rootNode = {
            sequenceNumber: -1,
            olderClient: undefined,
            youngerClient: undefined,
        };
        /** Pointer to end of linked list, for optimized client adds. */
        this._youngestClient = this.rootNode;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, "OrderedClientCollection");
        const members = quorum.getMembers();
        for (const [clientId, client] of members) {
            this.addClient(clientId, client);
        }
        quorum.on("addMember", (clientId, client) => {
            const newClient = this.addClient(clientId, client);
            this.emit("addClient", newClient, deltaManager.lastSequenceNumber);
        });
        quorum.on("removeMember", (clientId) => {
            const sequenceNumber = deltaManager.lastSequenceNumber;
            const removeClient = this.removeClient(clientId);
            if (removeClient === undefined) {
                this.logger.sendErrorEvent({ eventName: "ClientNotFound", clientId, sequenceNumber });
            }
            else {
                this.emit("removeClient", removeClient, sequenceNumber);
            }
        });
    }
    get count() {
        return this.clientMap.size;
    }
    get oldestClient() {
        return this.rootNode.youngerClient;
    }
    addClient(clientId, client) {
        // Normal case is adding the latest client, which will bypass loop.
        // Find where it belongs otherwise (maybe possible during initial load?).
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(client.sequenceNumber > -1, 0x1f6 /* "Negative client sequence number not allowed" */);
        let currClient = this._youngestClient;
        while (currClient.sequenceNumber > client.sequenceNumber) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(currClient.olderClient !== undefined, 0x1f7 /* "Previous client should always be defined" */);
            // Note: If adding a client older than the elected client, it will not be automatically elected.
            currClient = currClient.olderClient;
        }
        // Now currClient is the node right before where the new client node should be.
        const newClient = {
            clientId,
            sequenceNumber: client.sequenceNumber,
            client: Object.assign({}, client.client),
            olderClient: currClient,
            youngerClient: currClient.youngerClient,
        };
        // Update prev node to point to this new node.
        newClient.olderClient.youngerClient = newClient;
        if (newClient.youngerClient === undefined) {
            // Update linked list end pointer to youngest client.
            this._youngestClient = newClient;
        }
        else {
            // Update next node to point back to this new node.
            newClient.youngerClient.olderClient = newClient;
        }
        this.clientMap.set(clientId, newClient);
        return newClient;
    }
    removeClient(clientId) {
        const removeClient = this.clientMap.get(clientId);
        if (removeClient === undefined) {
            return;
        }
        // Update prev node to point to next node.
        removeClient.olderClient.youngerClient = removeClient.youngerClient;
        if (removeClient.youngerClient === undefined) {
            // Update linked list end pointer to youngest client.
            this._youngestClient = removeClient.olderClient;
        }
        else {
            // Update next node to point back to previous node.
            removeClient.youngerClient.olderClient = removeClient.olderClient;
        }
        this.clientMap.delete(clientId);
        return removeClient;
    }
    /** Returns an array of all clients being tracked in order from oldest to newest. */
    getAllClients() {
        const result = [];
        let currClient = this.rootNode;
        while (currClient.youngerClient !== undefined) {
            result.push(currClient.youngerClient);
            currClient = currClient.youngerClient;
        }
        return result;
    }
}
/**
 * Adapter for OrderedClientCollection, with the purpose of deterministically maintaining
 * a currently elected client, excluding ineligible clients, in a distributed fashion.
 * This can be true as long as incrementElectedClient and resetElectedClient calls
 * are called under the same conditions for all clients.
 */
class OrderedClientElection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(logger, orderedClientCollection, 
    /** Serialized state from summary or current sequence number at time of load if new. */
    initialState, isEligibleFn) {
        super();
        this.orderedClientCollection = orderedClientCollection;
        this.isEligibleFn = isEligibleFn;
        this._eligibleCount = 0;
        let initialClient;
        let initialParent;
        for (const client of orderedClientCollection.getAllClients()) {
            this.addClient(client, 0);
            if (typeof initialState !== "number") {
                if (client.clientId === initialState.electedClientId) {
                    initialClient = client;
                    if (initialState.electedParentId === undefined &&
                        client.client.details.type !== _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType) {
                        // If there was no elected parent in the serialized data, use this one.
                        initialParent = client;
                    }
                }
                if (client.clientId === initialState.electedParentId) {
                    initialParent = client;
                }
            }
        }
        orderedClientCollection.on("addClient", (client, seq) => this.addClient(client, seq));
        orderedClientCollection.on("removeClient", (client, seq) => this.removeClient(client, seq));
        if (typeof initialState === "number") {
            this._electionSequenceNumber = initialState;
        }
        else {
            // Override the initially elected client with the initial state.
            if ((initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId) !== initialState.electedClientId) {
                // Cannot find initially elected client, so elect undefined.
                logger.sendErrorEvent({
                    eventName: "InitialElectedClientNotFound",
                    electionSequenceNumber: initialState.electionSequenceNumber,
                    expectedClientId: initialState.electedClientId,
                    electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,
                    clientCount: orderedClientCollection.count,
                });
            }
            else if (initialClient !== undefined && !isEligibleFn(initialClient)) {
                // Initially elected client is ineligible, so elect next eligible client.
                initialClient = initialParent = this.findFirstEligibleParent(initialParent);
                logger.sendErrorEvent({
                    eventName: "InitialElectedClientIneligible",
                    electionSequenceNumber: initialState.electionSequenceNumber,
                    expectedClientId: initialState.electedClientId,
                    electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,
                });
            }
            this._electedParent = initialParent;
            this._electedClient = initialClient;
            this._electionSequenceNumber = initialState.electionSequenceNumber;
        }
    }
    get eligibleCount() {
        return this._eligibleCount;
    }
    get electionSequenceNumber() {
        return this._electionSequenceNumber;
    }
    /**
     * OrderedClientCollection tracks electedClient and electedParent separately. This allows us to handle the case
     * where a new interactive parent client has been elected, but the summarizer is still doing work, so
     * a new summarizer should not yet be spawned. In this case, changing electedParent will cause SummaryManager
     * to stop the current summarizer, but a new summarizer will not be spawned until the old summarizer client has
     * left the quorum.
     *
     * Details:
     *
     * electedParent is the interactive client that has been elected to spawn a summarizer. It is typically the oldest
     * eligible interactive client in the quorum. Only the electedParent is permitted to spawn a summarizer.
     * Once elected, this client will remain the electedParent until it leaves the quorum or the summarizer that
     * it spawned stops producing summaries, at which point a new electedParent will be chosen.
     *
     * electedClient is the non-interactive summarizer client if one exists. If not, then electedClient is equal to
     * electedParent. If electedParent === electedClient, this is the signal for electedParent to spawn a new
     * electedClient. Once a summarizer client becomes electedClient, a new summarizer will not be spawned until
     * electedClient leaves the quorum.
     *
     * A typical sequence looks like this:
     * i. Begin by electing A. electedParent === A, electedClient === A.
     * ii. SummaryManager running on A spawns a summarizer client, A'. electedParent === A, electedClient === A'
     * iii. A' stops producing summaries. A new parent client, B, is elected. electedParent === B, electedClient === A'
     * iv. SummaryManager running on A detects the change to electedParent and tells the summarizer to stop, but A'
     *      is in mid-summarization. No new summarizer is spawned, as electedParent !== electedClient.
     * v. A' completes its summary, and the summarizer and backing client are torn down.
     * vi. A' leaves the quorum, and B takes its place as electedClient. electedParent === B, electedClient === B
     * vii. SummaryManager running on B spawns a summarizer client, B'. electedParent === B, electedClient === B'
     */
    get electedClient() {
        return this._electedClient;
    }
    get electedParent() {
        return this._electedParent;
    }
    /** Tries changing the elected client, raising an event if it is different.
     * Note that this function does no eligibility or suitability checks. If we get here, then
     * we will set _electedClient, and we will set _electedParent if this is an interactive client.
     */
    tryElectingClient(client, sequenceNumber) {
        let change = false;
        const isSummarizerClient = (client === null || client === void 0 ? void 0 : client.client.details.type) === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType;
        const prevClient = this._electedClient;
        if (this._electedClient !== client) {
            // Changing the elected client. Record the sequence number and note that we have to fire an event.
            this._electionSequenceNumber = sequenceNumber;
            this._electedClient = client;
            change = true;
        }
        if (this._electedParent !== client && !isSummarizerClient) {
            // Changing the elected parent as well.
            this._electedParent = client;
            change = true;
        }
        if (change) {
            this.emit("election", client, sequenceNumber, prevClient);
        }
    }
    tryElectingParent(client, sequenceNumber) {
        if (this._electedParent !== client) {
            this._electedParent = client;
            this.emit("election", this._electedClient, sequenceNumber, this._electedClient);
        }
    }
    /**
     * Helper function to find the first eligible parent client starting with the passed in client,
     * or undefined if none are eligible.
     * @param client - client to start checking
     * @returns oldest eligible client starting with passed in client or undefined if none.
     */
    findFirstEligibleParent(client) {
        let candidateClient = client;
        while (candidateClient !== undefined &&
            (!this.isEligibleFn(candidateClient) || candidateClient.client.details.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType)) {
            candidateClient = candidateClient.youngerClient;
        }
        return candidateClient;
    }
    /**
     * Updates tracking for when a new client is added to the collection.
     * Will automatically elect that new client if none is elected currently.
     * @param client - client added to the collection
     * @param sequenceNumber - sequence number when client was added
     */
    addClient(client, sequenceNumber) {
        var _a;
        if (this.isEligibleFn(client)) {
            this._eligibleCount++;
            const newClientIsSummarizer = client.client.details.type === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType;
            const electedClientIsSummarizer = ((_a = this._electedClient) === null || _a === void 0 ? void 0 : _a.client.details.type) === _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType;
            // Note that we allow a summarizer client to supercede an interactive client as elected client.
            if (this._electedClient === undefined || (!electedClientIsSummarizer && newClientIsSummarizer)) {
                this.tryElectingClient(client, sequenceNumber);
            }
            else if (this._electedParent === undefined && !newClientIsSummarizer) {
                // This is an odd case. If the _electedClient is set, the _electedParent should be as well.
                this.tryElectingParent(client, sequenceNumber);
            }
        }
    }
    /**
     * Updates tracking for when an existing client is removed from the collection.
     * Will automatically elect next oldest client if currently elected is removed.
     * @param client - client removed from the collection
     * @param sequenceNumber - sequence number when client was removed
     */
    removeClient(client, sequenceNumber) {
        var _a, _b, _c, _d, _e;
        if (this.isEligibleFn(client)) {
            this._eligibleCount--;
            if (this._electedClient === client) {
                // Removing the _electedClient. There are 2 possible cases:
                if (this._electedParent !== client) {
                    // 1. The _electedClient is a summarizer that we've been allowing to finish its work.
                    // Let the _electedParent become the _electedClient so that it can start its own summarizer.
                    if (this._electedClient.client.details.type !== _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType) {
                        throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError("Elected client should be a summarizer client 1");
                    }
                    this.tryElectingClient(this._electedParent, sequenceNumber);
                }
                else {
                    // 2. The _electedClient is an interactive client that has left the quorum.
                    // Automatically shift to next oldest client.
                    const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
                    this.tryElectingClient(nextClient, sequenceNumber);
                }
            }
            else if (this._electedParent === client) {
                // Removing the _electedParent (but not _electedClient).
                // Shift to the next oldest parent, but do not replace the _electedClient,
                // which is a summarizer that is still doing work.
                if (((_c = this._electedClient) === null || _c === void 0 ? void 0 : _c.client.details.type) !== _summarizerClientElection__WEBPACK_IMPORTED_MODULE_3__.summarizerClientType) {
                    throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError("Elected client should be a summarizer client 2");
                }
                const nextParent = (_e = this.findFirstEligibleParent((_d = this._electedParent) === null || _d === void 0 ? void 0 : _d.youngerClient)) !== null && _e !== void 0 ? _e : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
                this.tryElectingParent(nextParent, sequenceNumber);
            }
        }
    }
    getAllEligibleClients() {
        return this.orderedClientCollection.getAllClients().filter(this.isEligibleFn);
    }
    /** Advance election to the next-oldest client. This is called if the current parent is leaving the quorum,
     * or if the current summarizer is not responsive and we want to stop it and spawn a new one.
     */
    incrementElectedClient(sequenceNumber) {
        var _a, _b;
        const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
        if (this._electedClient === undefined || this._electedClient === this._electedParent) {
            this.tryElectingClient(nextClient, sequenceNumber);
        }
        else {
            // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.
            // Changing the _electedParent will stop the summarizer.
            this.tryElectingParent(nextClient, sequenceNumber);
        }
    }
    /** (Re-)start election with the oldest client in the quorum. This is called if we need to summarize
     * and no client has been elected.
     */
    resetElectedClient(sequenceNumber) {
        const firstClient = this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
        if (this._electedClient === undefined || this._electedClient === this._electedParent) {
            this.tryElectingClient(firstClient, sequenceNumber);
        }
        else {
            // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.
            // Changing the _electedParent will stop the summarizer.
            this.tryElectingParent(firstClient, sequenceNumber);
        }
    }
    peekNextElectedClient() {
        var _a, _b;
        return (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
    }
    serialize() {
        var _a, _b;
        return {
            electionSequenceNumber: this.electionSequenceNumber,
            electedClientId: (_a = this.electedClient) === null || _a === void 0 ? void 0 : _a.clientId,
            electedParentId: (_b = this.electedParent) === null || _b === void 0 ? void 0 : _b.clientId,
        };
    }
}
//# sourceMappingURL=orderedClientElection.js.map

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Summarizer": () => (/* binding */ Summarizer),
/* harmony export */   "SummarizingWarning": () => (/* binding */ SummarizingWarning),
/* harmony export */   "createSummarizingWarning": () => (/* binding */ createSummarizingWarning)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(119);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(120);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(8);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(32);
/* harmony import */ var _summarizerClientElection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(71);
/* harmony import */ var _summarizerHandle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(118);
/* harmony import */ var _runningSummarizer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(121);
/* harmony import */ var _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(122);
/* harmony import */ var _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */












const summarizingError = "summarizingError";
class SummarizingWarning extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError {
    constructor(errorMessage, logged = false) {
        super(errorMessage);
        this.logged = logged;
        this.errorType = summarizingError;
        this.canRetry = true;
    }
    static wrap(error, logged = false, logger) {
        const newErrorFn = (errMsg) => new SummarizingWarning(errMsg, logged);
        return (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.wrapErrorAndLog)(error, newErrorFn, logger);
    }
}
const createSummarizingWarning = (errorMessage, logged) => new SummarizingWarning(errorMessage, logged);
/**
 * Summarizer is responsible for coordinating when to generate and send summaries.
 * It is the main entry point for summary work.
 * It is created only by summarizing container (i.e. one with clientType === "summarizer")
 */
class Summarizer extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(url, 
    /** Reference to runtime that created this object.
     * i.e. runtime with clientType === "summarizer"
     */
    runtime, configurationGetter, 
    /** Represents an object that can generate summary.
     * In practical terms, it's same runtime (this.runtime) with clientType === "summarizer".
    */
    internalsProvider, handleContext, summaryCollection, runCoordinatorCreateFn) {
        super();
        this.runtime = runtime;
        this.configurationGetter = configurationGetter;
        this.internalsProvider = internalsProvider;
        this.summaryCollection = summaryCollection;
        this.runCoordinatorCreateFn = runCoordinatorCreateFn;
        this._disposed = false;
        this.starting = false;
        this.stopDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        this.summarizeOnDemand = (...args) => {
            var _a;
            try {
                if (this._disposed || ((_a = this.runningSummarizer) === null || _a === void 0 ? void 0 : _a.disposed)) {
                    throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("Summarizer is already disposed.");
                }
                if (this.runtime.summarizerClientId !== undefined &&
                    this.runtime.summarizerClientId !== this.runtime.clientId) {
                    // If there is an elected summarizer, and it's not this one, don't allow on-demand summary.
                    // This is to prevent the on-demand summary and heuristic-based summary from stepping on
                    // each other.
                    throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("On-demand summary attempted while an elected summarizer is present");
                }
                const builder = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder();
                if (this.runningSummarizer) {
                    // Summarizer is already running. Go ahead and start.
                    return this.runningSummarizer.summarizeOnDemand(builder, ...args);
                }
                // Summarizer isn't running, so we need to start it, which is an async operation.
                // Manage the promise related to creating the cancellation token here.
                // The promises related to starting, summarizing,
                // and submitting are communicated to the caller through the results builder.
                const coordinatorCreateP = this.runCoordinatorCreateFn(this.runtime);
                coordinatorCreateP.then((runCoordinator) => {
                    // Successully created the cancellation token. Start the summarizer.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const startP = this.start(this.runtime.clientId, runCoordinator);
                    startP.then(async (runningSummarizer) => {
                        // Successfully started the summarizer. Run it.
                        runningSummarizer.summarizeOnDemand(builder, ...args);
                        // Wait for a command to stop or loss of connectivity before tearing down the summarizer and client.
                        const stopReason = await Promise.race([this.stopDeferred.promise, runCoordinator.waitCancelled]);
                        await runningSummarizer.waitStop(false);
                        runCoordinator.stop(stopReason);
                        this.close();
                    }).catch((reason) => {
                        builder.fail("Failed to start summarizer", reason);
                    });
                }).catch((reason) => {
                    builder.fail("Failed to create cancellation token", reason);
                });
                return builder.build();
            }
            catch (error) {
                throw SummarizingWarning.wrap(error, false /* logged */, this.logger);
            }
        };
        this.enqueueSummarize = (...args) => {
            if (this._disposed || this.runningSummarizer === undefined || this.runningSummarizer.disposed) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("Summarizer is not running or already disposed.");
            }
            return this.runningSummarizer.enqueueSummarize(...args);
        };
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(this.runtime.logger, "Summarizer");
        this.innerHandle = new _summarizerHandle__WEBPACK_IMPORTED_MODULE_6__.SummarizerHandle(this, url, handleContext);
    }
    get IFluidLoadable() { return this; }
    get ISummarizer() { return this; }
    get handle() { return this.innerHandle; }
    /**
     * Creates a Summarizer and its underlying client.
     * Note that different implementations of ILoader will handle the URL differently.
     * ILoader provided by a ContainerRuntime is a RelativeLoader, which will treat URL's
     * starting with "/" as relative to the Container. The general ILoader
     * interface will expect an absolute URL and will not handle "/".
     * @param loader - the loader that resolves the request
     * @param url - the URL used to resolve the container
     */
    static async create(loader, url) {
        const request = {
            headers: {
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.LoaderHeader.cache]: false,
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.LoaderHeader.clientDetails]: {
                    capabilities: { interactive: false },
                    type: _summarizerClientElection__WEBPACK_IMPORTED_MODULE_8__.summarizerClientType,
                },
                [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_9__.DriverHeader.summarizingClient]: true,
                [_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.LoaderHeader.reconnect]: false,
            },
            url,
        };
        const resolvedContainer = await loader.resolve(request);
        const fluidObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__.requestFluidObject)(resolvedContainer, { url: "_summarizer" });
        if (fluidObject.ISummarizer === undefined) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("Fluid object does not implement ISummarizer");
        }
        return fluidObject.ISummarizer;
    }
    async run(onBehalfOf) {
        try {
            return await this.runCore(onBehalfOf);
        }
        catch (error) {
            this.stop("summarizerException");
            throw SummarizingWarning.wrap(error, false /* logged */, this.logger);
        }
        finally {
            this.close();
        }
    }
    /**
     * Stops the summarizer from running.  This will complete
     * the run promise, and also close the container.
     * @param reason - reason code for stopping
     */
    stop(reason) {
        this.stopDeferred.resolve(reason);
    }
    close() {
        // This will result in "summarizerClientDisconnected" stop reason recorded in telemetry,
        // unless stop() was called earlier
        this.dispose();
        this.runtime.closeFn();
    }
    async runCore(onBehalfOf) {
        const runCoordinator = await this.runCoordinatorCreateFn(this.runtime);
        // Wait for either external signal to cancel, or loss of connectivity.
        const stopP = Promise.race([runCoordinator.waitCancelled, this.stopDeferred.promise]);
        void stopP.then((reason) => {
            this.logger.sendTelemetryEvent({
                eventName: "StoppingSummarizer",
                onBehalfOf,
                reason,
            });
        });
        if (runCoordinator.cancelled) {
            return runCoordinator.waitCancelled;
        }
        const runningSummarizer = await this.start(onBehalfOf, runCoordinator);
        // Wait for either external signal to cancel, or loss of connectivity.
        const stopReason = await stopP;
        // There are two possible approaches here:
        // 1. Propagate cancellation from this.stopDeferred to runCoordinator. This will ensure that we move to the exit
        //    faster, including breaking out of the RunningSummarizer.trySummarize() faster.
        //    We could create new coordinator and pass it to waitStop() -> trySummarizeOnce("lastSummary") flow.
        //    The con of this approach is that we might cancel active summary, and lastSummary will fail because it
        //    did not wait for ack/nack from previous summary. Plus we disregard any 429 kind of info from service
        //    that way (i.e. trySummarize() loop might have been waiting for 5 min because storage told us so).
        //    In general, it's more wasted resources.
        // 2. We can not do it and make waitStop() do last summary only if there was no active summary. This ensures
        //    that client behaves properly (from server POV) and we do not waste resources. But, it may mean we wait
        //    substantially longer for trySummarize() retries to play out and thus this summary loop may run into
        //    conflict with new summarizer client starting on different client.
        // As of now, #2 is implemented. It's more forward looking, as issue #7279 suggests changing design for new
        // summarizer client to not be created until current summarizer fully moves to exit, and that would reduce
        // cons of #2 substantially.
        // Cleanup after running
        await runningSummarizer.waitStop(!runCoordinator.cancelled && Summarizer.stopReasonCanRunLastSummary(stopReason));
        // Propagate reason and ensure that if someone is waiting for cancellation token, they are moving to exit
        runCoordinator.stop(stopReason);
        return stopReason;
    }
    /**
     * Should we try to run a last summary for the given stop reason?
     * Currently only allows "parentNotConnected"
     * @param stopReason - SummarizerStopReason
     * @returns - true if the stop reason can run a last summary
     */
    static stopReasonCanRunLastSummary(stopReason) {
        return stopReason === "parentNotConnected";
    }
    /**
     * Put the summarizer in a started state, including creating and initializing the RunningSummarizer.
     * The start request can come either from the SummaryManager (in the auto-summarize case) or from the user
     * (in the on-demand case).
     * @param onBehalfOf - ID of the client that requested that the summarizer start
     * @param runCoordinator - cancellation token
     * @param newConfig - Summary configuration to override the existing config when invoking the RunningSummarizer.
     * @returns - Promise that is fulfilled when the RunningSummarizer is ready
     */
    async start(onBehalfOf, runCoordinator) {
        if (this.runningSummarizer) {
            if (this.runningSummarizer.disposed) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("Starting a disposed summarizer");
            }
            return this.runningSummarizer;
        }
        if (this.starting) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("Attempting to start a summarizer that is already starting");
        }
        this.starting = true;
        // Initialize values and first ack (time is not exact)
        this.logger.sendTelemetryEvent({
            eventName: "RunningSummarizer",
            onBehalfOf,
            initSummarySeqNumber: this.runtime.deltaManager.initialSequenceNumber,
            config: JSON.stringify(this.configurationGetter()),
        });
        // Summarizing container ID (with clientType === "summarizer")
        const clientId = this.runtime.clientId;
        if (clientId === undefined) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_3__.UsageError("clientId should be defined if connected.");
        }
        const runningSummarizer = await _runningSummarizer__WEBPACK_IMPORTED_MODULE_11__.RunningSummarizer.start(this.logger, this.summaryCollection.createWatcher(clientId), this.configurationGetter(), async (...args) => this.internalsProvider.submitSummary(...args), // submitSummaryCallback
        new _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_12__.SummarizeHeuristicData(this.runtime.deltaManager.lastSequenceNumber, {
            refSequenceNumber: this.runtime.deltaManager.initialSequenceNumber,
            summaryTime: Date.now(),
        }), (errorMessage) => {
            if (!this._disposed) {
                this.logger.sendErrorEvent({ eventName: "summarizingError" }, createSummarizingWarning(errorMessage, true));
            }
        }, this.summaryCollection, runCoordinator /* cancellationToken */, (reason) => runCoordinator.stop(reason));
        this.runningSummarizer = runningSummarizer;
        this.starting = false;
        // Handle summary acks
        // Note: no exceptions are thrown from handleSummaryAcks handler as it handles all exceptions
        this.handleSummaryAcks().catch((error) => {
            this.logger.sendErrorEvent({ eventName: "HandleSummaryAckFatalError" }, error);
        });
        // Listen for ops
        this.systemOpListener = (op) => runningSummarizer.handleSystemOp(op);
        this.runtime.deltaManager.inbound.on("op", this.systemOpListener);
        this.opListener = (error, op) => runningSummarizer.handleOp(error, op);
        this.runtime.on("batchEnd", this.opListener);
        return runningSummarizer;
    }
    /**
     * Disposes of resources after running.  This cleanup will
     * clear any outstanding timers and reset some of the state
     * properties.
     * Called by ContainerRuntime when it is disposed, as well as at the end the run().
     */
    dispose() {
        // Given that the call can come from own ContainerRuntime, ensure that we stop all the processes.
        this.stop("summarizerClientDisconnected");
        this._disposed = true;
        if (this.runningSummarizer) {
            this.runningSummarizer.dispose();
            this.runningSummarizer = undefined;
        }
        if (this.systemOpListener) {
            this.runtime.deltaManager.inbound.off("op", this.systemOpListener);
        }
        if (this.opListener) {
            this.runtime.removeListener("batchEnd", this.opListener);
        }
    }
    async handleSummaryAcks() {
        var _a, _b, _c, _d, _e;
        let refSequenceNumber = this.runtime.deltaManager.initialSequenceNumber;
        let ack;
        while (this.runningSummarizer) {
            const summaryLogger = (_a = this.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber)) !== null && _a !== void 0 ? _a : this.logger;
            try {
                // Initialize ack with undefined if exception happens inside of waitSummaryAck on second iteration,
                // we record undefined, not previous handles.
                ack = undefined;
                ack = await this.summaryCollection.waitSummaryAck(refSequenceNumber);
                refSequenceNumber = ack.summaryOp.referenceSequenceNumber;
                const summaryOpHandle = ack.summaryOp.contents.handle;
                const summaryAckHandle = ack.summaryAck.contents.handle;
                // Make sure we block any summarizer from being executed/enqueued while
                // executing the refreshLatestSummaryAck.
                // https://dev.azure.com/fluidframework/internal/_workitems/edit/779
                await this.runningSummarizer.lockedRefreshSummaryAckAction(async () => this.internalsProvider.refreshLatestSummaryAck(summaryOpHandle, summaryAckHandle, refSequenceNumber, summaryLogger).catch(async (error) => {
                    // If the error is 404, so maybe the fetched version no longer exists on server. We just
                    // ignore this error in that case, as that means we will have another summaryAck for the
                    // latest version with which we will refresh the state. However in case of single commit
                    // summary, we might me missing a summary ack, so in that case we are still fine as the
                    // code in `submitSummary` function in container runtime, will refresh the latest state
                    // by calling `refreshLatestSummaryAckFromServer` and we will be fine.
                    if ((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_13__.isFluidError)(error)
                        && error.errorType === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_14__.DriverErrorType.fileNotFoundOrAccessDeniedError) {
                        summaryLogger.sendTelemetryEvent({
                            eventName: "HandleSummaryAckErrorIgnored",
                            referenceSequenceNumber: refSequenceNumber,
                            proposalHandle: summaryOpHandle,
                            ackHandle: summaryAckHandle,
                        }, error);
                    }
                    else {
                        throw error;
                    }
                }));
            }
            catch (error) {
                summaryLogger.sendErrorEvent({
                    eventName: "HandleSummaryAckError",
                    referenceSequenceNumber: refSequenceNumber,
                    handle: (_c = (_b = ack === null || ack === void 0 ? void 0 : ack.summaryOp) === null || _b === void 0 ? void 0 : _b.contents) === null || _c === void 0 ? void 0 : _c.handle,
                    ackHandle: (_e = (_d = ack === null || ack === void 0 ? void 0 : ack.summaryAck) === null || _d === void 0 ? void 0 : _d.contents) === null || _e === void 0 ? void 0 : _e.handle,
                }, error);
            }
            refSequenceNumber++;
        }
    }
}
//# sourceMappingURL=summarizer.js.map

/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizeResultBuilder": () => (/* binding */ SummarizeResultBuilder),
/* harmony export */   "SummaryGenerator": () => (/* binding */ SummaryGenerator),
/* harmony export */   "raceTimer": () => (/* binding */ raceTimer)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





/** Helper function to wait for a promise or PromiseTimer to elapse. */
async function raceTimer(promise, timer, cancellationToken) {
    const promises = [
        promise.then((value) => ({ result: "done", value })),
        timer.then(({ timerResult: result }) => ({ result })),
    ];
    if (cancellationToken !== undefined) {
        promises.push(cancellationToken.waitCancelled.then(() => ({ result: "cancelled" })));
    }
    return Promise.race(promises);
}
// Send some telemetry if generate summary takes too long
const maxSummarizeTimeoutTime = 20000; // 20 sec
const maxSummarizeTimeoutCount = 5; // Double and resend 5 times
const summarizeErrors = {
    /**
     * Error encountered while generating the summary tree, uploading
     * it to storage, or submitting the op. It could be a result of
     * the client becoming disconnected while generating or an actual error.
     */
    submitSummaryFailure: "Error while generating, uploading, or submitting summary",
    /**
     * The summaryAckWaitTimeout time has elapsed before receiving the summarize op
     * sent by this summarize attempt. It is expected to be broadcast quickly.
     */
    summaryOpWaitTimeout: "Timeout while waiting for summarize op broadcast",
    /**
     * The summaryAckWaitTimeout time has elapsed before receiving either a
     * summaryAck or summaryNack op from the server in response to this
     * summarize attempt. It is expected that the server should respond.
     */
    summaryAckWaitTimeout: "Timeout while waiting for summaryAck/summaryNack op",
    /**
     * The server responded with a summaryNack op, thus rejecting this
     * summarize attempt.
     */
    summaryNack: "Server rejected summary via summaryNack op",
    disconnect: "Summary cancelled due to summarizer or main client disconnect",
};
class SummarizeResultBuilder {
    constructor() {
        this.summarySubmitted = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.summaryOpBroadcasted = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.receivedSummaryAckOrNack = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
    }
    fail(message, error, nackSummaryResult, retryAfterSeconds) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.receivedSummaryAckOrNack.isCompleted, 0x25e /* "no reason to call fail if all promises have been completed" */);
        const result = { success: false, message, data: undefined, error, retryAfterSeconds };
        this.summarySubmitted.resolve(result);
        this.summaryOpBroadcasted.resolve(result);
        this.receivedSummaryAckOrNack.resolve(Object.assign(Object.assign({}, result), { data: nackSummaryResult }));
    }
    build() {
        return {
            summarySubmitted: this.summarySubmitted.promise,
            summaryOpBroadcasted: this.summaryOpBroadcasted.promise,
            receivedSummaryAckOrNack: this.receivedSummaryAckOrNack.promise,
        };
    }
}
/**
 * This class generates and tracks a summary attempt.
 */
class SummaryGenerator {
    constructor(pendingAckTimer, heuristicData, submitSummaryCallback, raiseSummarizingError, successfulSummaryCallback, summaryWatcher, logger) {
        this.pendingAckTimer = pendingAckTimer;
        this.heuristicData = heuristicData;
        this.submitSummaryCallback = submitSummaryCallback;
        this.raiseSummarizingError = raiseSummarizingError;
        this.successfulSummaryCallback = successfulSummaryCallback;
        this.summaryWatcher = summaryWatcher;
        this.logger = logger;
        this.summarizeTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));
    }
    /**
     * Generates summary and listens for broadcast and ack/nack.
     * Returns true for ack, false for nack, and undefined for failure or timeout.
     * @param reason - reason for summarizing
     * @param options - refreshLatestAck to fetch summary ack info from server,
     * fullTree to generate tree without any summary handles even if unchanged
     */
    summarize(summarizeProps, options, cancellationToken, resultsBuilder = new SummarizeResultBuilder()) {
        this.summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken)
            .catch((error) => {
            const message = "UnexpectedSummarizeError";
            this.logger.sendErrorEvent(Object.assign({ eventName: message }, summarizeProps), error);
            resultsBuilder.fail(message, error);
        });
        return resultsBuilder.build();
    }
    async summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken) {
        const { refreshLatestAck, fullTree } = options;
        const logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, undefined, { all: summarizeProps });
        // Note: timeSinceLastAttempt and timeSinceLastSummary for the
        // first summary are basically the time since the summarizer was loaded.
        const timeSinceLastAttempt = Date.now() - this.heuristicData.lastAttempt.summaryTime;
        const timeSinceLastSummary = Date.now() - this.heuristicData.lastSuccessfulSummary.summaryTime;
        let summarizeTelemetryProps = {
            fullTree,
            timeSinceLastAttempt,
            timeSinceLastSummary,
        };
        const summarizeEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.start(logger, Object.assign({ eventName: "Summarize", refreshLatestAck }, summarizeTelemetryProps));
        // Helper functions to report failures and return.
        const getFailMessage = (errorCode) => `${errorCode}: ${summarizeErrors[errorCode]}`;
        const fail = (errorCode, error, properties, nackSummaryResult) => {
            this.raiseSummarizingError(summarizeErrors[errorCode]);
            // UploadSummary may fail with 429 and retryAfter - respect that
            // Summary Nack also can have retryAfter, it's parsed below and comes as a property.
            const retryAfterSeconds = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getRetryDelaySecondsFromError)(error);
            // Report any failure as an error unless it was due to cancellation (like "disconnected" error)
            // If failure happened on upload, we may not yet realized that socket disconnected, so check
            // offlineError too.
            const category = cancellationToken.cancelled || (error === null || error === void 0 ? void 0 : error.errorType) === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_5__.DriverErrorType.offlineError ?
                "generic" : "error";
            summarizeEvent.cancel(Object.assign(Object.assign({}, properties), { reason: errorCode, category,
                retryAfterSeconds }), error);
            resultsBuilder.fail(getFailMessage(errorCode), error, nackSummaryResult, retryAfterSeconds);
        };
        // Wait to generate and send summary
        this.summarizeTimer.start();
        // Use record type to prevent unexpected value types
        let summaryData;
        try {
            summaryData = await this.submitSummaryCallback({
                fullTree,
                refreshLatestAck,
                summaryLogger: logger,
                cancellationToken,
            });
            // Cumulatively add telemetry properties based on how far generateSummary went.
            const referenceSequenceNumber = summaryData.referenceSequenceNumber;
            const opsSinceLastSummary = referenceSequenceNumber - this.heuristicData.lastSuccessfulSummary.refSequenceNumber;
            summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { referenceSequenceNumber, minimumSequenceNumber: summaryData.minimumSequenceNumber, opsSinceLastAttempt: referenceSequenceNumber - this.heuristicData.lastAttempt.refSequenceNumber, opsSinceLastSummary });
            if (summaryData.stage !== "base") {
                summarizeTelemetryProps = Object.assign(Object.assign(Object.assign({}, summarizeTelemetryProps), summaryData.summaryStats), { generateDuration: summaryData.generateDuration });
                if (summaryData.stage !== "generate") {
                    summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { handle: summaryData.handle, uploadDuration: summaryData.uploadDuration });
                    if (summaryData.stage !== "upload") {
                        summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { clientSequenceNumber: summaryData.clientSequenceNumber });
                    }
                }
            }
            if (summaryData.stage !== "submit") {
                return fail("submitSummaryFailure", summaryData.error, summarizeTelemetryProps);
            }
            /**
             * With incremental summaries, if the full tree was not summarized, only data stores that changed should
             * be summarized. A data store is considered changed if either or both of the following is true:
             * - It has received an op.
             * - Its reference state changed, i.e., it went from referenced to unreferenced or vice-versa.
             *
             * In the extreme case, every op can be for a different data store and each op can result in the reference
             * state change of multiple data stores. So, the total number of data stores that are summarized should not
             * exceed the number of ops since last summary + number of data store whose reference state changed.
             */
            if (!fullTree && !summaryData.forcedFullTree) {
                const { summarizedDataStoreCount, gcStateUpdatedDataStoreCount = 0 } = summaryData.summaryStats;
                if (summarizedDataStoreCount > gcStateUpdatedDataStoreCount + opsSinceLastSummary) {
                    logger.sendErrorEvent({
                        eventName: "IncrementalSummaryViolation",
                        summarizedDataStoreCount,
                        gcStateUpdatedDataStoreCount,
                        opsSinceLastSummary,
                    });
                }
            }
            // Log event here on summary success only, as Summarize_cancel duplicates failure logging.
            summarizeEvent.reportEvent("generate", Object.assign({}, summarizeTelemetryProps));
            resultsBuilder.summarySubmitted.resolve({ success: true, data: summaryData });
        }
        catch (error) {
            return fail("submitSummaryFailure", error);
        }
        finally {
            this.heuristicData.recordAttempt(summaryData === null || summaryData === void 0 ? void 0 : summaryData.referenceSequenceNumber);
            this.summarizeTimer.clear();
        }
        try {
            const pendingTimeoutP = this.pendingAckTimer.start();
            const summary = this.summaryWatcher.watchSummary(summaryData.clientSequenceNumber);
            // Wait for broadcast
            const waitBroadcastResult = await raceTimer(summary.waitBroadcast(), pendingTimeoutP, cancellationToken);
            if (waitBroadcastResult.result === "cancelled") {
                return fail("disconnect");
            }
            if (waitBroadcastResult.result !== "done") {
                return fail("summaryOpWaitTimeout");
            }
            const summarizeOp = waitBroadcastResult.value;
            const broadcastDuration = Date.now() - this.heuristicData.lastAttempt.summaryTime;
            resultsBuilder.summaryOpBroadcasted.resolve({
                success: true,
                data: { summarizeOp, broadcastDuration },
            });
            this.heuristicData.lastAttempt.summarySequenceNumber = summarizeOp.sequenceNumber;
            logger.sendTelemetryEvent({
                eventName: "Summarize_Op",
                duration: broadcastDuration,
                referenceSequenceNumber: summarizeOp.referenceSequenceNumber,
                summarySequenceNumber: summarizeOp.sequenceNumber,
                handle: summarizeOp.contents.handle,
            });
            // Wait for ack/nack
            const waitAckNackResult = await raceTimer(summary.waitAckNack(), pendingTimeoutP, cancellationToken);
            if (waitAckNackResult.result === "cancelled") {
                return fail("disconnect");
            }
            if (waitAckNackResult.result !== "done") {
                return fail("summaryAckWaitTimeout");
            }
            const ackNackOp = waitAckNackResult.value;
            this.pendingAckTimer.clear();
            // Update for success/failure
            const ackNackDuration = Date.now() - this.heuristicData.lastAttempt.summaryTime;
            // adding new properties
            summarizeTelemetryProps = Object.assign({ ackWaitDuration: ackNackDuration, ackNackSequenceNumber: ackNackOp.sequenceNumber, summarySequenceNumber: ackNackOp.contents.summaryProposal.summarySequenceNumber }, summarizeTelemetryProps);
            if (ackNackOp.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.SummaryAck) {
                this.heuristicData.markLastAttemptAsSuccessful();
                this.successfulSummaryCallback();
                summarizeEvent.end(Object.assign(Object.assign({}, summarizeTelemetryProps), { handle: ackNackOp.contents.handle }));
                resultsBuilder.receivedSummaryAckOrNack.resolve({ success: true, data: {
                        summaryAckOp: ackNackOp,
                        ackNackDuration,
                    } });
            }
            else {
                // Check for retryDelay in summaryNack response.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(ackNackOp.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.SummaryNack, 0x274 /* "type check" */);
                const summaryNack = ackNackOp.contents;
                const message = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.message;
                const retryAfterSeconds = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.retryAfter;
                // pre-0.58 error message prefix: summaryNack
                const error = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError(`Received summaryNack: ${message}`, { retryAfterSeconds });
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getRetryDelaySecondsFromError)(error) === retryAfterSeconds, 0x25f /* "retryAfterSeconds" */);
                // This will only set resultsBuilder.receivedSummaryAckOrNack, as other promises are already set.
                return fail("summaryNack", error, Object.assign(Object.assign({}, summarizeTelemetryProps), { nackRetryAfter: retryAfterSeconds }), { summaryNackOp: ackNackOp, ackNackDuration });
            }
        }
        finally {
            this.pendingAckTimer.clear();
        }
    }
    summarizeTimerHandler(time, count) {
        this.logger.sendPerformanceEvent({
            eventName: "SummarizeTimeout",
            timeoutTime: time,
            timeoutCount: count,
        });
        if (count < maxSummarizeTimeoutCount) {
            // Double and start a new timer
            const nextTime = time * 2;
            this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));
        }
    }
    dispose() {
        this.summarizeTimer.clear();
    }
}
//# sourceMappingURL=summaryGenerator.js.map

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AuthorizationError": () => (/* binding */ AuthorizationError),
/* harmony export */   "DeltaStreamConnectionForbiddenError": () => (/* binding */ DeltaStreamConnectionForbiddenError),
/* harmony export */   "GenericNetworkError": () => (/* binding */ GenericNetworkError),
/* harmony export */   "NetworkErrorBasic": () => (/* binding */ NetworkErrorBasic),
/* harmony export */   "NonRetryableError": () => (/* binding */ NonRetryableError),
/* harmony export */   "OnlineStatus": () => (/* binding */ OnlineStatus),
/* harmony export */   "RetryableError": () => (/* binding */ RetryableError),
/* harmony export */   "ThrottlingError": () => (/* binding */ ThrottlingError),
/* harmony export */   "canRetryOnError": () => (/* binding */ canRetryOnError),
/* harmony export */   "createGenericNetworkError": () => (/* binding */ createGenericNetworkError),
/* harmony export */   "createWriteError": () => (/* binding */ createWriteError),
/* harmony export */   "getRetryDelayFromError": () => (/* binding */ getRetryDelayFromError),
/* harmony export */   "getRetryDelaySecondsFromError": () => (/* binding */ getRetryDelaySecondsFromError),
/* harmony export */   "isOnline": () => (/* binding */ isOnline)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;


var OnlineStatus;
(function (OnlineStatus) {
    OnlineStatus[OnlineStatus["Offline"] = 0] = "Offline";
    OnlineStatus[OnlineStatus["Online"] = 1] = "Online";
    OnlineStatus[OnlineStatus["Unknown"] = 2] = "Unknown";
})(OnlineStatus || (OnlineStatus = {}));
// It tells if we have local connection only - we might not have connection to web.
// No solution for node.js (other than resolve dns names / ping specific sites)
// Can also use window.addEventListener("online" / "offline")
function isOnline() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.onLine === "boolean") {
        return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;
    }
    return OnlineStatus.Unknown;
}
/**
 * Generic network error class.
 */
class GenericNetworkError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, canRetry, props) {
        super(message, props);
        this.canRetry = canRetry;
        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.genericNetworkError;
    }
}
// Todo GH #6214: Remove after next drive def bump. This is necessary as there is no
// compatible way to augment an enum, as it can't be optional. So for now
// we need to duplicate the value here. We likely need to rethink our
// DriverErrorType strategy so that it supports extension with optional
// value.
const deltaStreamConnectionForbiddenStr = "deltaStreamConnectionForbidden";
class DeltaStreamConnectionForbiddenError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, props) {
        super(message, Object.assign(Object.assign({}, props), { statusCode: 400 }));
        this.errorType = DeltaStreamConnectionForbiddenError.errorType;
        this.canRetry = false;
    }
}
DeltaStreamConnectionForbiddenError.errorType = (_a = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType[deltaStreamConnectionForbiddenStr]) !== null && _a !== void 0 ? _a : deltaStreamConnectionForbiddenStr;
class AuthorizationError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, claims, tenantId, props) {
        // don't log claims or tenantId
        super(message, props, new Set(["claims", "tenantId"]));
        this.claims = claims;
        this.tenantId = tenantId;
        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.authorizationError;
        this.canRetry = false;
    }
}
class NetworkErrorBasic extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, errorType, canRetry, props) {
        super(message, props);
        this.errorType = errorType;
        this.canRetry = canRetry;
    }
}
class NonRetryableError extends NetworkErrorBasic {
    constructor(message, errorType, props) {
        super(message, errorType, false, props);
        this.errorType = errorType;
    }
}
class RetryableError extends NetworkErrorBasic {
    constructor(message, errorType, props) {
        super(message, errorType, true, props);
        this.errorType = errorType;
    }
}
/**
 * Throttling error class - used to communicate all throttling errors
 */
class ThrottlingError extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.LoggingError {
    constructor(message, retryAfterSeconds, props) {
        super(message, props);
        this.retryAfterSeconds = retryAfterSeconds;
        this.errorType = _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.throttlingError;
        this.canRetry = true;
    }
}
const createWriteError = (message, props) => new NonRetryableError(message, _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.DriverErrorType.writeError, props);
function createGenericNetworkError(message, retryInfo, props) {
    if (retryInfo.retryAfterMs !== undefined && retryInfo.canRetry) {
        return new ThrottlingError(message, retryInfo.retryAfterMs / 1000, props);
    }
    return new GenericNetworkError(message, retryInfo.canRetry, props);
}
/**
 * Check if a connection error can be retried.  Unless explicitly allowed, retry is disallowed.
 * I.e. asserts or unexpected exceptions in our code result in container failure.
 * @param error - The error to inspect for ability to retry
 */
const canRetryOnError = (error) => (error === null || error === void 0 ? void 0 : error.canRetry) === true;
/** Check retryAfterSeconds property on error */
const getRetryDelaySecondsFromError = (error) => error === null || error === void 0 ? void 0 : error.retryAfterSeconds;
/** Check retryAfterSeconds property on error and convert to ms */
const getRetryDelayFromError = (error) => (error === null || error === void 0 ? void 0 : error.retryAfterSeconds) !== undefined ?
    error.retryAfterSeconds * 1000 : undefined;
//# sourceMappingURL=network.js.map

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizerHandle": () => (/* binding */ SummarizerHandle)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

// TODO #2425 Expose Summarizer handle as FluidObjectHandle w/ tests
class SummarizerHandle extends _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidObjectHandle {
    async get() {
        throw Error("Do not try to get a summarizer object from the handle. Reference it directly.");
    }
    attach() {
        return;
    }
    bind(handle) {
        return;
    }
}
//# sourceMappingURL=summarizerHandle.js.map

/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoaderHeader": () => (/* binding */ LoaderHeader)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Accepted header keys for requests coming to the Loader
 */
var LoaderHeader;
(function (LoaderHeader) {
    /**
     * Override the Loader's default caching behavior for this container.
     */
    LoaderHeader["cache"] = "fluid-cache";
    LoaderHeader["clientDetails"] = "fluid-client-details";
    /**
     * Start the container in a paused, unconnected state. Defaults to false
     */
    LoaderHeader["loadMode"] = "loadMode";
    LoaderHeader["reconnect"] = "fluid-reconnect";
    LoaderHeader["sequenceNumber"] = "fluid-sequence-number";
    /**
     * One of the following:
     * null or "null": use ops, no snapshots
     * undefined: fetch latest snapshot
     * otherwise, version sha to load snapshot
     */
    LoaderHeader["version"] = "version";
})(LoaderHeader || (LoaderHeader = {}));
//# sourceMappingURL=loader.js.map

/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DriverHeader": () => (/* binding */ DriverHeader)
/* harmony export */ });
/**
 * Additional key in the loader request header
 */
var DriverHeader;
(function (DriverHeader) {
    // Key to indicate whether the request for summarizer
    DriverHeader["summarizingClient"] = "fluid-client-summarizer";
    // createNew information, specific to each driver
    DriverHeader["createNew"] = "createNew";
})(DriverHeader || (DriverHeader = {}));
//# sourceMappingURL=urlResolver.js.map

/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RunningSummarizer": () => (/* binding */ RunningSummarizer)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(123);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);
/* harmony import */ var _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






const maxSummarizeAckWaitTime = 10 * 60 * 1000; // 10 minutes
/**
 * An instance of RunningSummarizer manages the heuristics for summarizing.
 * Until disposed, the instance of RunningSummarizer can assume that it is
 * in a state of running, meaning it is connected and initialized.  It keeps
 * track of summaries that it is generating as they are broadcast and acked/nacked.
 * This object is created and controlled by Summarizer object.
 */
class RunningSummarizer {
    constructor(baseLogger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {
        this.summaryWatcher = summaryWatcher;
        this.configuration = configuration;
        this.submitSummaryCallback = submitSummaryCallback;
        this.heuristicData = heuristicData;
        this.raiseSummarizingError = raiseSummarizingError;
        this.summaryCollection = summaryCollection;
        this.cancellationToken = cancellationToken;
        this.stopSummarizerCallback = stopSummarizerCallback;
        this.stopping = false;
        this._disposed = false;
        this.tryWhileSummarizing = false;
        this.summarizeCount = 0;
        this.totalSuccessfulAttempts = 0;
        /**
         * RunningSummarizer's logger includes the sequenced index of the current summary on each event.
         * If some other Summarizer code wants that event on their logs they can get it here,
         * but only if they're logging about that same summary.
         * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct
         */
        this.tryGetCorrelatedLogger = (summaryOpRefSeq) => this.heuristicData.lastAttempt.refSequenceNumber === summaryOpRefSeq
            ? this.logger
            : undefined;
        const telemetryProps = {
            summarizeCount: () => this.summarizeCount,
            summarizerSuccessfulAttempts: () => this.totalSuccessfulAttempts,
        };
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(baseLogger, "Running", {
            all: telemetryProps,
        });
        if (configuration.state !== "disableHeuristics") {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.configuration.state === "enabled", 0x2ea /* "Configuration state should be enabled" */);
            this.heuristicRunner = new _summarizerHeuristics__WEBPACK_IMPORTED_MODULE_2__.SummarizeHeuristicRunner(heuristicData, this.configuration, (reason) => this.trySummarize(reason), this.logger);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.configuration.state !== "disabled", 0x2eb /* "Summary not supported with configuration disabled" */);
        // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime
        // configuration.maxAckWaitTime is composed from defaults, server values, and runtime overrides
        const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);
        this.pendingAckTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.PromiseTimer(maxAckWaitTime, () => {
            // pre-0.58 error message: summaryAckWaitTimeout
            this.raiseSummarizingError("Pending summary ack not received in time");
            // Note: summarizeCount (from ChildLogger definition) may be 0,
            // since this code path is hit when RunningSummarizer first starts up,
            // before this instance has kicked off a new summarize run.
            this.logger.sendErrorEvent({
                eventName: "SummaryAckWaitTimeout",
                maxAckWaitTime,
                referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,
                summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,
                timePending: Date.now() - this.heuristicData.lastAttempt.summaryTime,
            });
        });
        // Set up pending ack timeout by op timestamp differences for previous summaries.
        summaryCollection.setPendingAckTimerTimeoutCallback(maxAckWaitTime, () => {
            if (this.pendingAckTimer.hasTimer) {
                this.logger.sendTelemetryEvent({
                    eventName: "MissingSummaryAckFoundByOps",
                    referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,
                    summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,
                });
                this.pendingAckTimer.clear();
            }
        });
        this.generator = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummaryGenerator(this.pendingAckTimer, this.heuristicData, this.submitSummaryCallback, this.raiseSummarizingError, () => { this.totalSuccessfulAttempts++; }, this.summaryWatcher, this.logger);
    }
    static async start(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {
        var _a;
        const summarizer = new RunningSummarizer(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback);
        await summarizer.waitStart();
        // Run the heuristics after starting
        (_a = summarizer.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();
        return summarizer;
    }
    get disposed() { return this._disposed; }
    dispose() {
        var _a;
        this.summaryWatcher.dispose();
        (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.dispose();
        this.heuristicRunner = undefined;
        this.generator.dispose();
        this.pendingAckTimer.clear();
        this.disposeEnqueuedSummary();
        this._disposed = true;
        this.stopping = true;
    }
    handleSystemOp(op) {
        switch (op.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.ClientLeave:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.ClientJoin:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.Propose: {
                // Synchronously handle quorum ops like regular ops
                this.handleOp(undefined, op);
                return;
            }
            default: {
                return;
            }
        }
    }
    handleOp(error, { sequenceNumber, type, clientId, contents }) {
        var _a;
        if (error !== undefined) {
            return;
        }
        this.heuristicData.lastOpSequenceNumber = sequenceNumber;
        // Check for enqueued on-demand summaries; Intentionally do nothing otherwise
        if (!this.tryRunEnqueuedSummary()) {
            (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();
        }
    }
    async waitStop(allowLastSummary) {
        var _a;
        if (this.stopping) {
            return;
        }
        this.stopping = true;
        this.disposeEnqueuedSummary();
        // This will try to run lastSummary if needed.
        if (allowLastSummary && ((_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.shouldRunLastSummary())) {
            if (this.summarizingLock === undefined) {
                this.trySummarizeOnce(
                // summarizeProps
                { reason: "lastSummary" }, 
                // ISummarizeOptions, using defaults: { refreshLatestAck: false, fullTree: false }
                {});
            }
        }
        // Note that trySummarizeOnce() call above returns right away, without waiting.
        // So we need to wait for its completion, otherwise it would be destroyed right away.
        // That said, if summary lock was taken upfront, this wait might wait on  multiple retries to
        // submit summary. We should reconsider this flow and make summarizer move to exit faster.
        // This resolves when the current pending summary gets an ack or fails.
        await this.summarizingLock;
    }
    async waitStart() {
        // Wait no longer than ack timeout for all pending
        const waitStartResult = await (0,_summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.raceTimer)(this.summaryWatcher.waitFlushed(), this.pendingAckTimer.start());
        this.pendingAckTimer.clear();
        // Remove pending ack wait timeout by op timestamp comparison, because
        // it has race conditions with summaries submitted by this same client.
        this.summaryCollection.unsetPendingAckTimerTimeoutCallback();
        if (waitStartResult.result === "done" && waitStartResult.value !== undefined) {
            this.heuristicData.updateWithLastSummaryAckInfo({
                refSequenceNumber: waitStartResult.value.summaryOp.referenceSequenceNumber,
                // This will be the Summarizer starting point so only use timestamps from client's machine.
                summaryTime: Date.now(),
                summarySequenceNumber: waitStartResult.value.summaryOp.sequenceNumber,
            });
        }
    }
    /**
     * Blocks a new summarizer from running in case RefreshSummaryAck is being processed.
     * Assumes that caller checked upfront for lack of concurrent action (this.refreshSummaryAckLock)
     * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.
     * Note: The refreshSummaryAckLock makes sure no summarizer gets enqueued or processed
     * until the refresh has completed. One can't rely uniquely on the summarizingLock as the
     * refreshLatestSummaryAck also happens during the time summarizingLock !== undefined.
     * Ex. Summarizer submits a summay + op and then waits for the Summary Ack to proceed
     * with the refreshLatestSummaryAck and complete the summary.
     * @param action - action to perform.
     * @returns - result of action.
     */
    async lockedRefreshSummaryAckAction(action) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.refreshSummaryAckLock === undefined, "Refresh Summary Ack - Caller is responsible for checking lock");
        const refreshSummaryAckLock = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.Deferred();
        this.refreshSummaryAckLock = refreshSummaryAckLock.promise;
        return action().finally(() => {
            refreshSummaryAckLock.resolve();
            this.refreshSummaryAckLock = undefined;
        });
    }
    /**
     * Runs single summary action that prevents any other concurrent actions.
     * Assumes that caller checked upfront for lack of concurrent action (this.summarizingLock)
     * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.
     * @param action - action to perform.
     * @returns - result of action.
     */
    async lockedSummaryAction(action) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.summarizingLock === undefined, 0x25b /* "Caller is responsible for checking lock" */);
        const summarizingLock = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.Deferred();
        this.summarizingLock = summarizingLock.promise;
        this.summarizeCount++;
        // Make sure the RefreshLatestSummaryAck is not being executed.
        await this.refreshSummaryAckLock;
        return action().finally(() => {
            var _a;
            summarizingLock.resolve();
            this.summarizingLock = undefined;
            const retry = this.tryWhileSummarizing;
            this.tryWhileSummarizing = false;
            // After summarizing, we should check to see if we need to summarize again.
            // Rerun the heuristics and check for enqueued summaries.
            if (!this.stopping && !this.tryRunEnqueuedSummary() && retry) {
                (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();
            }
        });
    }
    /**
     * Runs single summarize attempt
     * @param summarizeProps - props to log with each telemetry event associated with this attempt
     * @param options - summary options
     * @param cancellationToken - cancellation token to use to be able to cancel this summary, if needed
     * @param resultsBuilder - optional, result builder to use.
     * @returns ISummarizeResult - result of running a summary.
     */
    trySummarizeOnce(summarizeProps, options, cancellationToken = this.cancellationToken, resultsBuilder = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder()) {
        this.lockedSummaryAction(async () => {
            const summarizeResult = this.generator.summarize(summarizeProps, options, cancellationToken, resultsBuilder);
            // ensure we wait till the end of the process
            return summarizeResult.receivedSummaryAckOrNack;
        }).catch((error) => {
            // SummaryGenerator.summarize() does not throw exceptions - it converts them to failed result
            // on resultsBuilder
            // We do not care about exceptions on receivedSummaryAckOrNack - caller should check results
            // and take a appropriate action.
        });
        return resultsBuilder.build();
    }
    /** Heuristics summarize attempt. */
    trySummarize(reason, cancellationToken = this.cancellationToken) {
        if (this.summarizingLock !== undefined) {
            // lockedSummaryAction() will retry heuristic-based summary at the end of current attempt
            // if it's still needed
            this.tryWhileSummarizing = true;
            return;
        }
        this.lockedSummaryAction(async () => {
            const attempts = [
                { refreshLatestAck: false, fullTree: false },
                { refreshLatestAck: true, fullTree: false },
                { refreshLatestAck: true, fullTree: false, delaySeconds: 2 * 60 },
                { refreshLatestAck: true, fullTree: true, delaySeconds: 10 * 60 },
            ];
            let overrideDelaySeconds;
            let summaryAttempts = 0;
            let summaryAttemptsPerPhase = 0;
            let lastResult;
            for (let summaryAttemptPhase = 0; summaryAttemptPhase < attempts.length;) {
                if (this.cancellationToken.cancelled) {
                    return;
                }
                // We only want to attempt 1 summary when reason is "lastSummary"
                if (++summaryAttempts > 1 && reason === "lastSummary") {
                    return;
                }
                summaryAttemptsPerPhase++;
                const _a = attempts[summaryAttemptPhase], { delaySeconds: regularDelaySeconds = 0 } = _a, options = __rest(_a, ["delaySeconds"]);
                const delaySeconds = overrideDelaySeconds !== null && overrideDelaySeconds !== void 0 ? overrideDelaySeconds : regularDelaySeconds;
                const summarizeProps = Object.assign({ reason,
                    summaryAttempts,
                    summaryAttemptsPerPhase, summaryAttemptPhase: summaryAttemptPhase + 1 }, options);
                if (delaySeconds > 0) {
                    this.logger.sendPerformanceEvent(Object.assign({ eventName: "SummarizeAttemptDelay", duration: delaySeconds, summaryNackDelay: overrideDelaySeconds !== undefined }, summarizeProps));
                    await (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.delay)(delaySeconds * 1000);
                }
                // Make sure the refresh Summary Ack is not being executed.
                await this.refreshSummaryAckLock;
                // Note: no need to account for cancellationToken.waitCancelled here, as
                // this is accounted SummaryGenerator.summarizeCore that controls receivedSummaryAckOrNack.
                const resultSummarize = this.generator.summarize(summarizeProps, options, cancellationToken);
                const result = await resultSummarize.receivedSummaryAckOrNack;
                if (result.success) {
                    return;
                }
                // Check for retryDelay that can come from summaryNack or upload summary flow.
                // Retry the same step only once per retryAfter response.
                overrideDelaySeconds = result.retryAfterSeconds;
                if (overrideDelaySeconds === undefined || summaryAttemptsPerPhase > 1) {
                    summaryAttemptPhase++;
                    summaryAttemptsPerPhase = 0;
                }
                lastResult = result;
            }
            // If all attempts failed, log error (with last attempt info) and close the summarizer container
            this.logger.sendErrorEvent({
                eventName: "FailToSummarize",
                reason,
                message: lastResult === null || lastResult === void 0 ? void 0 : lastResult.message,
            }, lastResult === null || lastResult === void 0 ? void 0 : lastResult.error);
            this.stopSummarizerCallback("failToSummarize");
        }).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "UnexpectedSummarizeError" }, error);
        });
    }
    /** {@inheritdoc (ISummarizer:interface).summarizeOnDemand} */
    summarizeOnDemand(resultsBuilder = new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder(), _a) {
        var { reason } = _a, options = __rest(_a, ["reason"]);
        if (this.stopping) {
            resultsBuilder.fail("RunningSummarizer stopped or disposed", undefined);
            return resultsBuilder.build();
        }
        // Check for concurrent summary attempts. If one is found,
        // return a promise that caller can await before trying again.
        if (this.summarizingLock !== undefined) {
            // The heuristics are blocking concurrent summarize attempts.
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.UsageError("Attempted to run an already-running summarizer on demand");
        }
        const result = this.trySummarizeOnce({ reason: `onDemand/${reason}` }, options, this.cancellationToken, resultsBuilder);
        return result;
    }
    /** {@inheritdoc (ISummarizer:interface).enqueueSummarize} */
    enqueueSummarize(_a) {
        var { reason, afterSequenceNumber = 0, override = false } = _a, options = __rest(_a, ["reason", "afterSequenceNumber", "override"]);
        const onDemandReason = `enqueue;${reason}`;
        let overridden = false;
        if (this.enqueuedSummary !== undefined) {
            if (!override) {
                return { alreadyEnqueued: true };
            }
            // Override existing enqueued summarize attempt.
            this.enqueuedSummary.resultsBuilder.fail("Aborted; overridden by another enqueue summarize attempt", undefined);
            this.enqueuedSummary = undefined;
            overridden = true;
        }
        this.enqueuedSummary = {
            reason: onDemandReason,
            afterSequenceNumber,
            options,
            resultsBuilder: new _summaryGenerator__WEBPACK_IMPORTED_MODULE_4__.SummarizeResultBuilder(),
        };
        const results = this.enqueuedSummary.resultsBuilder.build();
        this.tryRunEnqueuedSummary();
        return overridden ? Object.assign(Object.assign({}, results), { alreadyEnqueued: true, overridden: true }) : results;
    }
    tryRunEnqueuedSummary() {
        if (this.stopping) {
            this.disposeEnqueuedSummary();
            return false;
        }
        if (this.enqueuedSummary === undefined
            || this.heuristicData.lastOpSequenceNumber < this.enqueuedSummary.afterSequenceNumber
            || this.summarizingLock !== undefined) {
            // If no enqueued summary is ready or a summary is already in progress, take no action.
            return false;
        }
        const { reason, resultsBuilder, options } = this.enqueuedSummary;
        // Set to undefined first, so that subsequent enqueue attempt while summarize will occur later.
        this.enqueuedSummary = undefined;
        this.trySummarizeOnce({ reason: `enqueuedSummary/${reason}` }, options, this.cancellationToken, resultsBuilder);
        return true;
    }
    disposeEnqueuedSummary() {
        if (this.enqueuedSummary !== undefined) {
            this.enqueuedSummary.resultsBuilder.fail("RunningSummarizer stopped or disposed", undefined);
            this.enqueuedSummary = undefined;
        }
    }
}
//# sourceMappingURL=runningSummarizer.js.map

/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarizeHeuristicData": () => (/* binding */ SummarizeHeuristicData),
/* harmony export */   "SummarizeHeuristicRunner": () => (/* binding */ SummarizeHeuristicRunner)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/** Simple implementation of class for tracking summarize heuristic data. */
class SummarizeHeuristicData {
    constructor(lastOpSequenceNumber, 
    /** Baseline attempt data used for comparisons with subsequent attempts/calculations. */
    attemptBaseline) {
        this.lastOpSequenceNumber = lastOpSequenceNumber;
        this._lastAttempt = attemptBaseline;
        this._lastSuccessfulSummary = Object.assign({}, attemptBaseline);
    }
    get lastAttempt() {
        return this._lastAttempt;
    }
    get lastSuccessfulSummary() {
        return this._lastSuccessfulSummary;
    }
    updateWithLastSummaryAckInfo(lastSummary) {
        this._lastAttempt = lastSummary;
        this._lastSuccessfulSummary = Object.assign({}, lastSummary);
    }
    recordAttempt(refSequenceNumber) {
        this._lastAttempt = {
            refSequenceNumber: refSequenceNumber !== null && refSequenceNumber !== void 0 ? refSequenceNumber : this.lastOpSequenceNumber,
            summaryTime: Date.now(),
        };
    }
    markLastAttemptAsSuccessful() {
        this._lastSuccessfulSummary = Object.assign({}, this.lastAttempt);
    }
}
/**
 * This class contains the heuristics for when to summarize.
 */
class SummarizeHeuristicRunner {
    constructor(heuristicData, configuration, trySummarize, logger) {
        this.heuristicData = heuristicData;
        this.configuration = configuration;
        this.trySummarize = trySummarize;
        this.logger = logger;
        this.idleTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Timer(this.configuration.idleTime, () => this.trySummarize("idle"));
        this.minOpsForLastSummaryAttempt = this.configuration.minOpsForLastSummaryAttempt;
    }
    get opsSinceLastAck() {
        return this.heuristicData.lastOpSequenceNumber - this.heuristicData.lastSuccessfulSummary.refSequenceNumber;
    }
    run() {
        const timeSinceLastSummary = Date.now() - this.heuristicData.lastSuccessfulSummary.summaryTime;
        const opsSinceLastAck = this.opsSinceLastAck;
        if (timeSinceLastSummary > this.configuration.maxTime) {
            this.idleTimer.clear();
            this.trySummarize("maxTime");
        }
        else if (opsSinceLastAck > this.configuration.maxOps) {
            this.idleTimer.clear();
            this.trySummarize("maxOps");
        }
        else {
            this.idleTimer.restart();
        }
    }
    shouldRunLastSummary() {
        const opsSinceLastAck = this.opsSinceLastAck;
        const minOpsForLastSummaryAttempt = this.minOpsForLastSummaryAttempt;
        this.logger.sendTelemetryEvent({
            eventName: "ShouldRunLastSummary",
            opsSinceLastAck,
            minOpsForLastSummaryAttempt,
        });
        return opsSinceLastAck >= minOpsForLastSummaryAttempt;
    }
    dispose() {
        this.idleTimer.clear();
    }
}
//# sourceMappingURL=summarizerHeuristics.js.map

/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delay": () => (/* binding */ delay)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Returns a promise that resolves after timeMs
 * @param timeMs - time in milliseconds to wait
 */
const delay = async (timeMs) => new Promise((resolve) => setTimeout(() => resolve(), timeMs));
//# sourceMappingURL=delay.js.map

/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RunWhileConnectedCoordinator": () => (/* binding */ RunWhileConnectedCoordinator),
/* harmony export */   "neverCancelledSummaryToken": () => (/* binding */ neverCancelledSummaryToken)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Can be useful in testing as well as in places where caller does not use cancellation.
 * This object implements ISummaryCancellationToken interface but cancellation is never leveraged.
 */
const neverCancelledSummaryToken = {
    cancelled: false,
    waitCancelled: new Promise(() => { }),
};
/**
 * Helper class to coordinate something that needs to run only while connected.
 * This provides promises that resolve as it starts or stops.  Stopping happens
 * when disconnected or if stop() is called.
 */
class RunWhileConnectedCoordinator {
    constructor(runtime) {
        this.runtime = runtime;
        this._cancelled = false;
        this.stopDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
    }
    get cancelled() {
        if (!this._cancelled) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runtime.deltaManager.active, 0x25d /* "We should never connect as 'read'" */);
            // This check can't be enabled in current design due to lastSummary flow, where
            // summarizer for closed container stays around and can produce one more summary.
            // Currently we solve the problem of overlapping summarizer by doing wait in
            // SummaryManager.createSummarizer()
            // Better solution would involve these steps:
            // 1. Summarizer selection logic should chose summarizing client (with clientType === "summarizer")
            // if such client exists.
            // 2. Summarizer should be updated about such changes (to update onBehalfOfClientId)
            //
            // assert(this.runtime.summarizerClientId === this.onBehalfOfClientId ||
            //    this.runtime.summarizerClientId === this.runtime.clientId, "onBehalfOfClientId");
        }
        return this._cancelled;
    }
    /**
     * Returns a promise that resolves once stopped either externally or by disconnect.
     */
    get waitCancelled() {
        return this.stopDeferred.promise;
    }
    static async create(runtime) {
        const obj = new RunWhileConnectedCoordinator(runtime);
        await obj.waitStart();
        return obj;
    }
    /**
     * Starts and waits for a promise which resolves when connected.
     * The promise will also resolve if stopped either externally or by disconnect.
     *
     * We only listen on disconnected event for clientType === "summarizer" container!
     * And only do it here - no other place should check it! That way we have only one place
     * that controls policy and it's easy to change policy in the future if we want to!
     * We do not listen for "main" (aka interactive) container disconnect here, as it's
     * responsibility of SummaryManager to decide if that's material or not. There are cases
     * like "lastSummary", or main client experiencing nacks / disconnects due to hitting limit
     * of non-summarized ops, where can make determination to continue with summary even if main
     * client is disconnected.
     */
    async waitStart() {
        if (this.runtime.disposed) {
            this.stop("summarizerClientDisconnected");
            return;
        }
        this.runtime.once("dispose", () => this.stop("summarizerClientDisconnected"));
        if (!this.runtime.connected) {
            const waitConnected = new Promise((resolve) => this.runtime.once("connected", resolve));
            await Promise.race([waitConnected, this.waitCancelled]);
        }
        this.runtime.once("disconnected", () => this.stop("summarizerClientDisconnected"));
    }
    /**
     * Stops running.
     */
    stop(reason) {
        if (!this._cancelled) {
            this._cancelled = true;
            this.stopDeferred.resolve(reason);
        }
    }
}
//# sourceMappingURL=runWhileConnectedCoordinator.js.map

/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryManager": () => (/* binding */ SummaryManager),
/* harmony export */   "SummaryManagerState": () => (/* binding */ SummaryManagerState)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



const defaultInitialDelayMs = 5000;
const defaultOpsToBypassInitialDelay = 4000;
var SummaryManagerState;
(function (SummaryManagerState) {
    SummaryManagerState[SummaryManagerState["Off"] = 0] = "Off";
    SummaryManagerState[SummaryManagerState["Starting"] = 1] = "Starting";
    SummaryManagerState[SummaryManagerState["Running"] = 2] = "Running";
    SummaryManagerState[SummaryManagerState["Stopping"] = 3] = "Stopping";
})(SummaryManagerState || (SummaryManagerState = {}));
/**
 * SummaryManager is created by parent container (i.e. interactive container with clientType !== "summarizer") only.
 * It observes changes in calculated summarizer and reacts to changes by either creating summarizer client or
 * stopping existing summarizer client.
 */
class SummaryManager {
    constructor(clientElection, connectedState, summaryCollection, parentLogger, 
    /** Creates summarizer by asking interactive container to spawn summarizing container and
     * get back its Summarizer instance. */
    requestSummarizerFn, startThrottler, { initialDelayMs = defaultInitialDelayMs, opsToBypassInitialDelay = defaultOpsToBypassInitialDelay, } = {}, disableHeuristics) {
        this.clientElection = clientElection;
        this.connectedState = connectedState;
        this.summaryCollection = summaryCollection;
        this.requestSummarizerFn = requestSummarizerFn;
        this.startThrottler = startThrottler;
        this.disableHeuristics = disableHeuristics;
        this.state = SummaryManagerState.Off;
        this._disposed = false;
        this.handleConnected = (clientId) => {
            this.latestClientId = clientId;
            // If we have a summarizer, it should have been either cancelled on disconnected by now.
            // But because of lastSummary process, it can still hang around, so there is not much we can
            // check or assert.
            this.refreshSummarizer();
        };
        this.handleDisconnected = () => {
            this.refreshSummarizer();
        };
        this.refreshSummarizer = () => {
            // Transition states depending on shouldSummarize, which is a calculated property
            // that is only true if this client is connected and is the elected summarizer.
            const shouldSummarizeState = this.getShouldSummarizeState();
            switch (this.state) {
                case SummaryManagerState.Off: {
                    if (shouldSummarizeState.shouldSummarize) {
                        this.startSummarization();
                    }
                    return;
                }
                case SummaryManagerState.Starting: {
                    // Cannot take any action until summarizer is created
                    // state transition will occur after creation
                    return;
                }
                case SummaryManagerState.Running: {
                    if (shouldSummarizeState.shouldSummarize === false) {
                        this.stop(shouldSummarizeState.stopReason);
                    }
                    return;
                }
                case SummaryManagerState.Stopping: {
                    // Cannot take any action until running summarizer finishes
                    // state transition will occur after it stops
                    return;
                }
                default: {
                    return;
                }
            }
        };
        this.summarizeOnDemand = (...args) => {
            if (this.summarizer === undefined) {
                throw Error("No running summarizer client");
                // TODO: could spawn a summarizer client temporarily.
            }
            return this.summarizer.summarizeOnDemand(...args);
        };
        this.enqueueSummarize = (...args) => {
            if (this.summarizer === undefined) {
                throw Error("No running summarizer client");
                // TODO: could spawn a summarizer client temporarily.
            }
            return this.summarizer.enqueueSummarize(...args);
        };
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(parentLogger, "SummaryManager", { all: { clientId: () => this.latestClientId } });
        this.connectedState.on("connected", this.handleConnected);
        this.connectedState.on("disconnected", this.handleDisconnected);
        this.latestClientId = this.connectedState.clientId;
        this.opsToBypassInitialDelay = opsToBypassInitialDelay;
        this.initialDelayMs = initialDelayMs;
    }
    get disposed() {
        return this._disposed;
    }
    get currentState() { return this.state; }
    /**
     * Until start is called, the SummaryManager won't begin attempting to start summarization.  This ensures there's
     * a window between construction and starting where the caller can attach listeners.
     */
    start() {
        this.clientElection.on("electedSummarizerChanged", this.refreshSummarizer);
        this.refreshSummarizer();
    }
    getShouldSummarizeState() {
        // Note that if we're in the Running state, the electedClient may be a summarizer client, so we can't
        // enforce connectedState.clientId === clientElection.electedClientId. But once we're Running, we should
        // only transition to Stopping when the electedParentId changes. Stopping the summarizer without
        // changing the electedParent will just cause us to transition to Starting again.
        if (this.connectedState.clientId !== this.clientElection.electedParentId ||
            (this.state !== SummaryManagerState.Running &&
                this.connectedState.clientId !== this.clientElection.electedClientId)) {
            return { shouldSummarize: false, stopReason: "parentShouldNotSummarize" };
        }
        else if (!this.connectedState.connected) {
            return { shouldSummarize: false, stopReason: "parentNotConnected" };
        }
        else if (this.disposed) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(false, 0x260 /* "Disposed should mean disconnected!" */);
        }
        else {
            return { shouldSummarize: true };
        }
    }
    startSummarization() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryManagerState.Off, 0x261 /* "Expected: off" */);
        this.state = SummaryManagerState.Starting;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.summarizer === undefined, 0x262 /* "Old summarizer is still working!" */);
        this.delayBeforeCreatingSummarizer().then(async (startWithInitialDelay) => {
            // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore
            // but only if creation was delayed. If it was not, then we want to ensure we always create
            // a summarizer to kick off lastSummary. Without that, we would not be able to summarize and get
            // document out of broken state if it has too many ops and ordering service keeps nacking main
            // container (and thus it goes into cycle of reconnects)
            if (startWithInitialDelay && this.getShouldSummarizeState().shouldSummarize === false) {
                return "early exit";
            }
            // We transition to Running before requesting the summarizer, because after requesting we can't predict
            // when the electedClient will be replaced with the new summarizer client.
            // The alternative would be to let connectedState.clientId !== clientElection.electedClientId when
            // state === Starting || state === Running.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state === SummaryManagerState.Starting, 0x263 /* "Expected: starting" */);
            this.state = SummaryManagerState.Running;
            const summarizer = await this.requestSummarizerFn();
            this.summarizer = summarizer;
            // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore
            const shouldSummarizeState = this.getShouldSummarizeState();
            if (shouldSummarizeState.shouldSummarize === false) {
                this.state = SummaryManagerState.Starting;
                summarizer.stop(shouldSummarizeState.stopReason);
                return "early exit after starting summarizer";
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const clientId = this.latestClientId;
            return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.PerformanceEvent.timedExecAsync(this.logger, { eventName: "RunningSummarizer", attempt: this.startThrottler.numAttempts }, async () => summarizer.run(clientId, this.disableHeuristics));
        }).then((reason) => {
            this.logger.sendTelemetryEvent({
                eventName: "EndingSummarizer",
                reason,
            });
        }).catch((error) => {
            this.logger.sendTelemetryEvent({
                eventName: "EndingSummarizer",
                reason: "exception",
            }, error);
            // Most of exceptions happen due to container being closed while loading it, due to
            // summarizer container loosing connection while load.
            // Not worth reporting such errors as errors. That said, we might miss some real errors if
            // we ignore blindly, so try to narrow signature we are looking for - skip logging
            // error only if this client should no longer be a summarizer (which in practice
            // means it also lost connection), and error happened on load (we do not have summarizer).
            // We could annotate the error raised in Container.load where the container closed during load with no error
            // and check for that case here, but that does not seem to be necessary.
            if (this.getShouldSummarizeState().shouldSummarize || this.summarizer !== undefined) {
                // Report any failure as an error unless it was due to cancellation (like "disconnected" error)
                // If failure happened on container load, we may not yet realized that socket disconnected, so check
                // offlineError.
                const category = (error === null || error === void 0 ? void 0 : error.errorType) === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__.DriverErrorType.offlineError ? "generic" : "error";
                this.logger.sendTelemetryEvent({
                    eventName: "SummarizerException",
                    category,
                }, error);
            }
        }).finally(() => {
            var _a;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.state !== SummaryManagerState.Off, 0x264 /* "Expected: Not Off" */);
            this.state = SummaryManagerState.Off;
            (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.close();
            this.summarizer = undefined;
            if (this.getShouldSummarizeState().shouldSummarize) {
                this.startSummarization();
            }
        });
    }
    stop(reason) {
        var _a;
        if (!SummaryManager.isStartingOrRunning(this.state)) {
            return;
        }
        this.state = SummaryManagerState.Stopping;
        // Stopping the running summarizer client should trigger a change
        // in states when the running summarizer closes
        (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.stop(reason);
    }
    /**
     * Implements initial delay before creating summarizer
     * @returns true, if creation is delayed due to heuristics (not many ops to summarize).
     *          False if summarizer should start immediately due to too many unsummarized ops.
     */
    async delayBeforeCreatingSummarizer() {
        // throttle creation of new summarizer containers to prevent spamming the server with websocket connections
        let delayMs = this.startThrottler.getDelay();
        // We have been elected the summarizer. Some day we may be able to summarize with a live document but for
        // now we play it safe and launch a second copy.
        this.logger.sendTelemetryEvent({
            eventName: "CreatingSummarizer",
            throttlerDelay: delayMs,
            initialDelay: this.initialDelayMs,
            startThrottlerMaxDelayMs: this.startThrottler.maxDelayMs,
            opsSinceLastAck: this.summaryCollection.opsSinceLastAck,
            opsToBypassInitialDelay: this.opsToBypassInitialDelay,
        });
        // This delay helps ensure that last summarizer that might be left from previous client
        // has enough time to complete its last summary and thus new summarizer not conflict with previous one.
        // If, however, there are too many unsummarized ops, try to resolve it as quickly as possible, with
        // understanding that we may see nacks because of such quick action.
        // A better design would be for summarizer election logic to always select current summarizer as
        // summarizing client (i.e. clientType === "summarizer" can be elected) to ensure that nobody else can
        // summarizer while it finishes its work and moves to exit.
        // It also helps with pure boot scenario (single client) to offset expensive work a bit out from
        // critical boot sequence.
        let startWithInitialDelay = false;
        if (this.summaryCollection.opsSinceLastAck < this.opsToBypassInitialDelay) {
            startWithInitialDelay = true;
            delayMs = Math.max(delayMs, this.initialDelayMs);
        }
        if (delayMs > 0) {
            let timer;
            let resolveOpPromiseFn;
            // Create a listener that will break the delay if we've exceeded the initial delay ops count.
            const opsListenerFn = () => {
                if (this.summaryCollection.opsSinceLastAck >= this.opsToBypassInitialDelay) {
                    clearTimeout(timer);
                    resolveOpPromiseFn();
                }
            };
            // Create a Promise that will resolve when the delay expires.
            const delayPromise = new Promise((resolve) => {
                timer = setTimeout(() => resolve(), delayMs);
            });
            // Create a Promise that will resolve if the ops count passes the threshold.
            const opPromise = new Promise((resolve) => { resolveOpPromiseFn = resolve; });
            this.summaryCollection.addOpListener(opsListenerFn);
            await Promise.race([delayPromise, opPromise]);
            this.summaryCollection.removeOpListener(opsListenerFn);
        }
        return startWithInitialDelay;
    }
    dispose() {
        this.clientElection.off("electedSummarizerChanged", this.refreshSummarizer);
        this.connectedState.off("connected", this.handleConnected);
        this.connectedState.off("disconnected", this.handleDisconnected);
        this._disposed = true;
    }
}
SummaryManager.isStartingOrRunning = (state) => state === SummaryManagerState.Starting || state === SummaryManagerState.Running;
//# sourceMappingURL=summaryManager.js.map

/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Throttler": () => (/* binding */ Throttler),
/* harmony export */   "formExponentialFn": () => (/* binding */ formExponentialFn),
/* harmony export */   "formExponentialFnWithAttemptOffset": () => (/* binding */ formExponentialFnWithAttemptOffset),
/* harmony export */   "formLinearFn": () => (/* binding */ formLinearFn),
/* harmony export */   "formLinearFnWithAttemptOffset": () => (/* binding */ formLinearFnWithAttemptOffset)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Used to give increasing delay times for throttling a single functionality.
 * Delay is based on previous attempts within specified time window, subtracting delay time.
 */
class Throttler {
    constructor(
    /** Width of sliding delay window in milliseconds. */
    delayWindowMs, 
    /** Maximum delay allowed in milliseconds. */
    maxDelayMs, 
    /**
     * Delay function used to calculate what the delay should be.
     * The input is the number of attempts that occurred within the sliding window.
     * The result is the calculated delay in milliseconds.
     */
    delayFn) {
        this.delayWindowMs = delayWindowMs;
        this.maxDelayMs = maxDelayMs;
        this.delayFn = delayFn;
        this.startTimes = [];
    }
    get numAttempts() {
        return this.startTimes.length;
    }
    /**
     * Gets all attempt start times after compensating for the delay times
     * by adding the delay times to the actual times.
     */
    getAttempts() {
        return [...this.startTimes];
    }
    /**
     * Latest attempt time after compensating for the delay time itself
     * by adding the delay time to the actual time.
     */
    get latestAttemptTime() {
        return this.startTimes.length > 0 ? this.startTimes[this.startTimes.length - 1] : undefined;
    }
    getDelay() {
        const now = Date.now();
        const latestAttemptTime = this.latestAttemptTime;
        if (latestAttemptTime !== undefined) {
            // If getDelay was called sooner than the most recent delay,
            // subtract the remaining time, since we previously added it.
            const earlyMs = latestAttemptTime - now;
            if (earlyMs > 0) {
                this.startTimes = this.startTimes.map((t) => t - earlyMs);
            }
        }
        // Remove all attempts that have already fallen out of the window.
        this.startTimes = this.startTimes.filter((t) => (now - t) < this.delayWindowMs);
        // Compute delay, but do not exceed the specified max delay.
        const delayMs = Math.min(this.delayFn(this.startTimes.length), this.maxDelayMs);
        // Record this attempt start time.
        this.startTimes.push(now);
        // Account for the delay time, by effectively removing it from the delay window.
        this.startTimes = this.startTimes.map((t) => t + delayMs);
        if (delayMs === this.maxDelayMs) {
            // We hit max delay, so adding more won't affect anything.
            // Shift off oldest time to stop this array from growing forever.
            this.startTimes.shift();
        }
        return delayMs;
    }
}
/**
 * Helper function to generate simple exponential throttle functions.
 * f(n) = [coefficient] x ([multiplier]^n) + [flatOffset]
 * where n = number of attempts, and f(n) = delay time in milliseconds.
 * If not provided, coefficient will default to 1, multiplier to 2,
 * minimum delay to 0, and the offset to 0, yielding:
 * 0 ms, 2 ms, 4 ms, 8 ms, ..., 2^n ms
 * where M = multiplier; an exponential back-off.
 * Use initialDelay to decide what should happen when numAttempts is 0,
 * leave it undefined to not special case.
 */
const formExponentialFn = ({ multiplier = 2, coefficient = 1, offset = 0, initialDelay = undefined, } = {}) => (numAttempts) => Math.max(0, numAttempts <= 0 && initialDelay !== undefined
    ? initialDelay
    : coefficient * (Math.pow(multiplier, numAttempts)) + offset);
/** f(n) = C x (B^(n+A)) + F = (C x B^A) x B^n + F */
const formExponentialFnWithAttemptOffset = (attemptOffset, { multiplier = 2, coefficient = 1, offset = 0, initialDelay = undefined, } = {}) => formExponentialFn({
    multiplier,
    coefficient: coefficient * Math.pow(multiplier, attemptOffset),
    offset,
    initialDelay,
});
/**
 * Helper function to generate simple linear throttle functions.
 * f(n) = [coefficient] x n + [flatOffset]
 * where n = number of attempts, and f(n) = delay time in milliseconds.
 * If not provided, coefficient will default to 1, and offset to 0, yielding:
 * 0 ms, 1 ms, 2 ms, 3 ms, ..., n ms delays; a linear back-off.
 */
const formLinearFn = ({ coefficient = 1, offset = 0, } = {}) => (numAttempts) => Math.max(0, coefficient * numAttempts + offset);
/** f(n) = C x (n+A) + F = C x n + (C x A + F) */
const formLinearFnWithAttemptOffset = (attemptOffset, { coefficient = 1, offset = 0, } = {}) => formLinearFn({
    coefficient,
    offset: coefficient * attemptOffset + offset,
});
//# sourceMappingURL=throttler.js.map

/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchTracker": () => (/* binding */ BatchTracker),
/* harmony export */   "BindBatchTracker": () => (/* binding */ BindBatchTracker)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


class BatchTracker {
    constructor(batchEventEmitter, logger, batchLengthThreshold, batchCountSamplingRate, dateTimeProvider = () => _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now()) {
        this.batchEventEmitter = batchEventEmitter;
        this.trackedBatchCount = 0;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(logger, "Batching");
        this.batchEventEmitter.on("batchBegin", (message) => {
            this.startBatchSequenceNumber = message.sequenceNumber;
            this.batchProcessingStartTimeStamp = dateTimeProvider();
            this.trackedBatchCount++;
        });
        this.batchEventEmitter.on("batchEnd", (error, message) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startBatchSequenceNumber !== undefined && this.batchProcessingStartTimeStamp !== undefined, 0x2ba /* "batchBegin must fire before batchEnd" */);
            const length = message.sequenceNumber - this.startBatchSequenceNumber + 1;
            if (length >= batchLengthThreshold) {
                this.logger.sendErrorEvent({
                    eventName: "LengthTooBig",
                    length,
                    threshold: batchLengthThreshold,
                    batchEndSequenceNumber: message.sequenceNumber,
                    duration: dateTimeProvider() - this.batchProcessingStartTimeStamp,
                    batchError: error !== undefined,
                });
            }
            if (this.trackedBatchCount % batchCountSamplingRate === 0) {
                this.logger.sendPerformanceEvent({
                    eventName: "Length",
                    length,
                    samplingRate: batchCountSamplingRate,
                    batchEndSequenceNumber: message.sequenceNumber,
                    duration: dateTimeProvider() - this.batchProcessingStartTimeStamp,
                });
            }
            this.startBatchSequenceNumber = undefined;
            this.batchProcessingStartTimeStamp = undefined;
        });
    }
}
/**
 * Track batch sizes in terms of op counts and processing times
 *
 * @param batchEventEmitter - event emitter which tracks the lifecycle of batch operations
 * @param logger - logger
 * @param batchLengthThreshold - threshold for the length of a batch when to send an error event
 * @param batchCountSamplingRate - rate for batches for which to send an event with its characteristics
 * @returns
 */
const BindBatchTracker = (batchEventEmitter, logger, batchLengthThreshold = 1000, batchCountSamplingRate = 1000) => new BatchTracker(batchEventEmitter, logger, batchLengthThreshold, batchCountSamplingRate);
//# sourceMappingURL=batchTracker.js.map

/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OpTracker": () => (/* binding */ OpTracker)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class OpTracker {
    constructor(deltaManager, disabled) {
        /**
         * Used for storing the message content size when
         * the message is pushed onto the inbound queue.
         */
        this.messageSize = new Map();
        this._nonSystemOpCount = 0;
        this._opsSizeAccumulator = 0;
        if (disabled) {
            return;
        }
        // Record the message content size when we receive it.
        // We should not log this value, as summarization can happen between the time the message
        // is received and until it is processed (the 'op' event).
        deltaManager.inbound.on("push", (message) => {
            var _a;
            // Some messages my already have string contents at this point,
            // so stringifying them again will add inaccurate overhead.
            const messageContent = typeof message.contents === "string" ?
                message.contents :
                (_a = JSON.stringify(message.contents)) !== null && _a !== void 0 ? _a : "";
            const messageData = OpTracker.messageHasData(message) ? message.data : "";
            this.messageSize[OpTracker.messageId(message)] = messageContent.length + messageData.length;
        });
        deltaManager.on("op", (message) => {
            var _a;
            this._nonSystemOpCount += !(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.isRuntimeMessage)(message) ? 0 : 1;
            const id = OpTracker.messageId(message);
            this._opsSizeAccumulator += (_a = this.messageSize[id]) !== null && _a !== void 0 ? _a : 0;
            this.messageSize.delete(id);
        });
    }
    get nonSystemOpCount() {
        return this._nonSystemOpCount;
    }
    get opsSizeAccumulator() {
        return this._opsSizeAccumulator;
    }
    static messageId(message) {
        return message.sequenceNumber;
    }
    static messageHasData(message) {
        return message.data !== undefined;
    }
    reset() {
        this._nonSystemOpCount = 0;
        this._opsSizeAccumulator = 0;
    }
}
//# sourceMappingURL=opTelemetry.js.map

/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SerializedSnapshotStorage": () => (/* binding */ SerializedSnapshotStorage)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(130);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * A storage wrapper that can serialize blobs from a snapshot tree and then use them to rehydrate.
 * Used in offline load/attached dehydration to save snapshot blobs that are still needed but may have been deleted.
 */
class SerializedSnapshotStorage {
    constructor(storageGetter, blobs) {
        this.storageGetter = storageGetter;
        this.blobs = blobs;
    }
    static async serializeTree(snapshot, storage) {
        const blobs = {};
        await this.serializeTreeCore(snapshot, blobs, storage);
        return blobs;
    }
    static async serializeTreeCore(tree, blobs, storage) {
        const treePs = [];
        for (const subTree of Object.values(tree.trees)) {
            treePs.push(this.serializeTreeCore(subTree, blobs, storage));
        }
        for (const id of Object.values(tree.blobs)) {
            const blob = await storage.readBlob(id);
            // ArrayBufferLike will not survive JSON.stringify()
            blobs[id] = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, "utf8");
        }
        return Promise.all(treePs);
    }
    static serializeTreeWithBlobContents(snapshot) {
        const blobs = {};
        this.serializeTreeWithBlobContentsCore(snapshot, blobs);
        return blobs;
    }
    static serializeTreeWithBlobContentsCore(tree, blobs) {
        for (const subTree of Object.values(tree.trees)) {
            this.serializeTreeWithBlobContentsCore(subTree, blobs);
        }
        for (const id of Object.values(tree.blobs)) {
            const blob = tree.blobsContents[id];
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!blob, 0x2ec /* "Blob must be present in blobsContents" */);
            // ArrayBufferLike will not survive JSON.stringify()
            blobs[id] = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.bufferToString)(blob, "utf8");
        }
    }
    get storage() {
        // avoid calling it until we need it since it will be undefined if we're not connected
        // and we shouldn't need it in this case anyway
        if (this._storage) {
            return this._storage;
        }
        this._storage = this.storageGetter();
        return this._storage;
    }
    get repositoryUrl() { return this.storage.repositoryUrl; }
    /**
     * Reads the object with the given ID, returns content in arrayBufferLike
     */
    async readBlob(id) {
        if (this.blobs[id] !== undefined) {
            return (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBuffer)(this.blobs[id], "utf8");
        }
        return this.storage.readBlob(id);
    }
    /**
     * Returns the snapshot tree.
     */
    // eslint-disable-next-line @rushstack/no-new-null
    async getSnapshotTree(version) {
        return this.storage.getSnapshotTree(version);
    }
    /**
     * Retrieves all versions of the document starting at the specified versionId - or null if from the head
     */
    // eslint-disable-next-line @rushstack/no-new-null
    async getVersions(versionId, count) {
        return this.storage.getVersions(versionId, count);
    }
    /**
     * Creates a blob out of the given buffer
     */
    async createBlob(file) {
        return this.storage.createBlob(file);
    }
    /**
     * Uploads a summary tree to storage using the given context for reference of previous summary handle.
     * The ISummaryHandles in the uploaded tree should have paths to indicate which summary object they are
     * referencing from the previously acked summary.
     * Returns the uploaded summary handle.
     */
    async uploadSummaryWithContext(summary, context) {
        return this.storage.uploadSummaryWithContext(summary, context);
    }
    /**
     * Retrieves the commit that matches the packfile handle. If the packfile has already been committed and the
     * server has deleted it this call may result in a broken promise.
     */
    async downloadSummary(handle) {
        return this.storage.downloadSummary(handle);
    }
}
//# sourceMappingURL=serializedSnapshotStorage.js.map

/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FluidDataStoreRegistry": () => (/* binding */ FluidDataStoreRegistry)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class FluidDataStoreRegistry {
    constructor(namedEntries) {
        this.map = new Map();
        for (const entry of namedEntries) {
            if (this.map.has(entry[0])) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_0__.UsageError("Duplicate entry names exist");
            }
            this.map.set(entry[0], entry[1]);
        }
    }
    get IFluidDataStoreRegistry() { return this; }
    async get(name) {
        if (this.map.has(name)) {
            return this.map.get(name);
        }
        return undefined;
    }
}
//# sourceMappingURL=dataStoreRegistry.js.map

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "connectedEventName": () => (/* binding */ connectedEventName),
/* harmony export */   "disconnectedEventName": () => (/* binding */ disconnectedEventName),
/* harmony export */   "raiseConnectedEvent": () => (/* binding */ raiseConnectedEvent),
/* harmony export */   "safeRaiseEvent": () => (/* binding */ safeRaiseEvent)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const connectedEventName = "connected";
const disconnectedEventName = "disconnected";
function safeRaiseEvent(emitter, logger, event, ...args) {
    try {
        emitter.emit(event, ...args);
    }
    catch (error) {
        logger.sendErrorEvent({ eventName: "RaiseEventError", event }, error);
    }
}
function raiseConnectedEvent(logger, emitter, connected, clientId) {
    try {
        if (connected) {
            emitter.emit(connectedEventName, clientId);
        }
        else {
            emitter.emit(disconnectedEventName);
        }
    }
    catch (error) {
        logger.sendErrorEvent({ eventName: "RaiseConnectedEventError" }, error);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trace": () => (/* binding */ Trace)
/* harmony export */ });
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper class for tracing performance of events
 * Time measurements are in milliseconds as a floating point with a decimal
 */
class Trace {
    constructor(startTick) {
        this.startTick = startTick;
        this.lastTick = startTick;
    }
    static start() {
        const startTick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        return new Trace(startTick);
    }
    trace() {
        const tick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        const event = {
            totalTimeElapsed: tick - this.startTick,
            duration: tick - this.lastTick,
            tick,
        };
        this.lastTick = tick;
        return event;
    }
}
//# sourceMappingURL=trace.js.map

/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "seqFromTree": () => (/* binding */ seqFromTree)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Fetches the sequence number of the snapshot tree by examining the protocol.
 * @param tree - snapshot tree to examine
 * @param readAndParseBlob - function to read blob contents from storage
 * and parse the result from JSON.
 */
async function seqFromTree(tree, readAndParseBlob) {
    const attributesHash = tree.trees[".protocol"].blobs.attributes;
    const attrib = await readAndParseBlob(attributesHash);
    return attrib.sequenceNumber;
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummarySerializer": () => (/* binding */ SummarySerializer)
/* harmony export */ });
/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Serializer implementation for serializing handles during summary.
 */
class SummarySerializer extends _serializer__WEBPACK_IMPORTED_MODULE_0__.FluidSerializer {
    constructor() {
        super(...arguments);
        this.serializedRoutes = new Set();
    }
    getSerializedRoutes() {
        return Array.from(this.serializedRoutes);
    }
    serializeHandle(handle, bind) {
        this.serializedRoutes.add(handle.absolutePath);
        return super.serializeHandle(handle, bind);
    }
}
//# sourceMappingURL=summarySerializer.js.map

/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalValueMaker": () => (/* binding */ LocalValueMaker),
/* harmony export */   "PlainLocalValue": () => (/* binding */ PlainLocalValue),
/* harmony export */   "makeSerializable": () => (/* binding */ makeSerializable)
/* harmony export */ });
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(137);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

function makeSerializable(localValue, serializer, bind) {
    const value = localValue.makeSerialized(serializer, bind);
    return {
        type: value.type,
        value: value.value && JSON.parse(value.value),
    };
}
/**
 * Manages a contained plain value.  May also contain shared object handles.
 */
class PlainLocalValue {
    /**
     * Create a new PlainLocalValue.
     * @param value - The value to store, which may contain shared object handles
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * {@inheritDoc ILocalValue."type"}
     */
    get type() {
        return _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Plain];
    }
    /**
     * {@inheritDoc ILocalValue.makeSerialized}
     */
    makeSerialized(serializer, bind) {
        // Stringify to convert to the serialized handle values - and then parse in order to create
        // a POJO for the op
        const value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.serializeHandles)(this.value, serializer, bind);
        return {
            type: this.type,
            value,
        };
    }
}
/**
 * A LocalValueMaker enables a container type DDS to produce and store local values with minimal awareness of how
 * those objects are stored, serialized, and deserialized.
 */
class LocalValueMaker {
    /**
     * Create a new LocalValueMaker.
     * @param serializer - The serializer to serialize / parse handles.
     */
    constructor(serializer) {
        this.serializer = serializer;
    }
    /**
     * Create a new local value from an incoming serialized value.
     * @param serializable - The serializable value to make local
     */
    fromSerializable(serializable) {
        // Migrate from old shared value to handles
        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Shared]) {
            serializable.type = _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.ValueType.Plain];
            const handle = {
                type: "__fluid_handle__",
                url: serializable.value,
            };
            serializable.value = handle;
        }
        const translatedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.parseHandles)(serializable.value, this.serializer);
        return new PlainLocalValue(translatedValue);
    }
    /**
     * Create a new local value containing a given plain object.
     * @param value - The value to store
     * @returns An ILocalValue containing the value
     */
    fromInMemory(value) {
        return new PlainLocalValue(value);
    }
}
//# sourceMappingURL=localValues.js.map

/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueType": () => (/* binding */ ValueType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * enum representing the possible types of a shared object
 */
var ValueType;
(function (ValueType) {
    /**
     * The value is a shared object
     * @deprecated Instead store the handle of the shared object, rather than the shared object itself.
     */
    ValueType[ValueType["Shared"] = 0] = "Shared";
    /**
     * The value is a plain JavaScript object or handle.  If a plain object, it may contain handles deeper within.
     */
    ValueType[ValueType["Plain"] = 1] = "Plain";
})(ValueType || (ValueType = {}));
//# sourceMappingURL=valueType.js.map

/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSingleBlobSummary": () => (/* binding */ createSingleBlobSummary),
/* harmony export */   "makeHandlesSerializable": () => (/* binding */ makeHandlesSerializable),
/* harmony export */   "parseHandles": () => (/* binding */ parseHandles),
/* harmony export */   "serializeHandles": () => (/* binding */ serializeHandles)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Given a mostly-plain object that may have handle objects embedded within, return a string representation of an object
 * where the handle objects have been replaced with a serializable form.
 * @param value - The mostly-plain object
 * @param serializer - The serializer that knows how to convert handles into serializable format
 * @param context - The handle context for the container
 * @param bind - Bind any other handles we find in the object against this given handle.
 * @returns Result of strigifying an object
 */
function serializeHandles(value, serializer, bind) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return value !== undefined
        ? serializer.stringify(value, bind)
        : value;
}
/**
 * Given a mostly-plain object that may have handle objects embedded within, will return a fully-plain object
 * where any embedded IFluidHandles have been replaced with a serializable form.
 *
 * The original `input` object is not mutated.  This method will shallowly clones all objects in the path from
 * the root to any replaced handles.  (If no handles are found, returns the original object.)
 *
 * @param input - The mostly-plain object
 * @param context - The handle context for the container
 * @param bind - Bind any other handles we find in the object against this given handle.
 * @returns The fully-plain object
 */
function makeHandlesSerializable(value, serializer, bind) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return serializer.encode(value, bind);
}
/**
 * Given a fully-plain object that may have serializable-form handles within, will return the mostly-plain object
 * with handle objects created instead.
 * @param value - The fully-plain object
 * @param serializer - The serializer that knows how to convert serializable-form handles into handle objects
 * @param context - The handle context for the container
 * @returns The mostly-plain object with handle objects within
 */
function parseHandles(value, serializer) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return value !== undefined ? serializer.parse(JSON.stringify(value)) : value;
}
/**
 * Create a new summary containing one blob
 * @param key - the key for the blob in the summary
 * @param content - blob content
 * @returns The summary containing the blob
 */
function createSingleBlobSummary(key, content) {
    const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.SummaryTreeBuilder();
    builder.addBlob(key, content);
    return builder.getSummaryTree();
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapFactory": () => (/* binding */ MapFactory),
/* harmony export */   "SharedMap": () => (/* binding */ SharedMap)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(140);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _mapKernel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(143);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;






const snapshotFileName = "header";
/**
 * The factory that defines the map.
 * @sealed
 */
class MapFactory {
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
     */
    get type() {
        return MapFactory.Type;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
     */
    get attributes() {
        return MapFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const map = new SharedMap(id, runtime, attributes);
        await map.load(services);
        return map;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}
     */
    create(runtime, id) {
        const map = new SharedMap(id, runtime, MapFactory.Attributes);
        map.initializeLocal();
        return map;
    }
}
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
 */
MapFactory.Type = "https://graph.microsoft.com/types/map";
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
 */
MapFactory.Attributes = {
    type: MapFactory.Type,
    snapshotFormatVersion: "0.2",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion,
};
/**
 * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting
 * and retrieving values that JavaScript developers are accustomed to with the
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.
 * However, the keys of a SharedMap must be strings.
 */
class SharedMap extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.SharedObject {
    /**
     * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.
     *
     * @param id - String identifier.
     * @param runtime - Data store runtime.
     * @param attributes - The attributes for the map.
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes, "fluid_map_");
        /**
         * String representation for the class.
         */
        this[_a] = "SharedMap";
        this.kernel = new _mapKernel__WEBPACK_IMPORTED_MODULE_2__.MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), this);
    }
    /**
     * Create a new shared map.
     * @param runtime - The data store runtime that the new shared map belongs to.
     * @param id - Optional name of the shared map.
     * @returns Newly created shared map.
     *
     * @example
     * To create a `SharedMap`, call the static create method:
     *
     * ```typescript
     * const myMap = SharedMap.create(this.runtime, id);
     * ```
     */
    static create(runtime, id) {
        return runtime.createChannel(id, MapFactory.Type);
    }
    /**
     * Get a factory for SharedMap to register with the data store.
     * @returns A factory that creates SharedMaps and loads them from storage.
     */
    static getFactory() {
        return new MapFactory();
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.kernel.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        return this.kernel.entries();
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        return this.kernel.values();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.kernel.entries();
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.kernel.size;
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.kernel.forEach(callbackFn);
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        return this.kernel.get(key);
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.kernel.has(key);
    }
    /**
     * {@inheritDoc ISharedMap.set}
     */
    set(key, value) {
        this.kernel.set(key, value);
        return this;
    }
    /**
     * Delete a key from the map.
     * @param key - Key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        return this.kernel.delete(key);
    }
    /**
     * Clear all data from the map.
     */
    clear() {
        this.kernel.clear();
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}
     * @internal
     */
    summarizeCore(serializer, telemetryContext) {
        let currentSize = 0;
        let counter = 0;
        let headerBlob = {};
        const blobs = [];
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__.SummaryTreeBuilder();
        const data = this.kernel.getSerializedStorage(serializer);
        // If single property exceeds this size, it goes into its own blob
        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;
        // Maximum blob size for multiple map properties
        // Should be bigger than MinValueSizeSeparateSnapshotBlob
        const MaxSnapshotBlobSize = 16 * 1024;
        // Partitioning algorithm:
        // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.
        //    Naming (across snapshots) of such blob does not have to be stable across snapshots,
        //    As de-duping process (in driver) should not care about paths, only content.
        // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.
        //    This process does not produce stable partitioning. This means
        //    modification (including addition / deletion) of property can shift properties across blobs
        //    and result in non-incremental snapshot.
        //    This can be improved in the future, without being format breaking change, as loading sequence
        //    loads all blobs at once and partitioning schema has no impact on that process.
        for (const key of Object.keys(data)) {
            const value = data[key];
            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {
                const blobName = `blob${counter}`;
                counter++;
                blobs.push(blobName);
                const content = {
                    [key]: {
                        type: value.type,
                        value: JSON.parse(value.value),
                    },
                };
                builder.addBlob(blobName, JSON.stringify(content));
            }
            else {
                currentSize += value.type.length + 21; // Approximation cost of property header
                if (value.value) {
                    currentSize += value.value.length;
                }
                if (currentSize > MaxSnapshotBlobSize) {
                    const blobName = `blob${counter}`;
                    counter++;
                    blobs.push(blobName);
                    builder.addBlob(blobName, JSON.stringify(headerBlob));
                    headerBlob = {};
                    currentSize = 0;
                }
                headerBlob[key] = {
                    type: value.type,
                    value: value.value === undefined ? undefined : JSON.parse(value.value),
                };
            }
        }
        const header = {
            blobs,
            content: headerBlob,
        };
        builder.addBlob(snapshotFileName, JSON.stringify(header));
        return builder.getSummaryTree();
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     * @internal
     */
    async loadCore(storage) {
        const json = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(storage, snapshotFileName);
        const newFormat = json;
        if (Array.isArray(newFormat.blobs)) {
            this.kernel.populateFromSerializable(newFormat.content);
            await Promise.all(newFormat.blobs.map(async (value) => {
                const content = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(storage, value);
                this.kernel.populateFromSerializable(content);
            }));
        }
        else {
            this.kernel.populateFromSerializable(json);
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}
     * @internal
     */
    onDisconnect() { }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}
     * @internal
     */
    reSubmitCore(content, localOpMetadata) {
        this.kernel.trySubmitMessage(content, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}
     * @internal
     */
    applyStashedOp(content) {
        this.kernel.tryProcessMessage(content, false, undefined);
        return this.kernel.tryGetStashedOpLocalMetadata(content);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}
     * @internal
     */
    processCore(message, local, localOpMetadata) {
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_5__.MessageType.Operation) {
            this.kernel.tryProcessMessage(message.contents, local, localOpMetadata);
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}
     * @internal
    */
    rollback(content, localOpMetadata) {
        this.kernel.rollback(content, localOpMetadata);
    }
}
//# sourceMappingURL=map.js.map

/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapKernel": () => (/* binding */ MapKernel)
/* harmony export */ });
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(137);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



function isMapKeyLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        (metadata.type === "add" || metadata.type === "edit");
}
function isClearLocalOpMetadata(metadata) {
    return metadata !== undefined && metadata.type === "clear" && typeof metadata.pendingMessageId === "number";
}
function isMapLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        (metadata.type === "add" || metadata.type === "edit" || metadata.type === "clear");
}
/**
 * A SharedMap is a map-like distributed data structure.
 */
class MapKernel {
    /**
     * Create a new shared map kernel.
     * @param serializer - The serializer to serialize / parse handles
     * @param handle - The handle of the shared object using the kernel
     * @param submitMessage - A callback to submit a message through the shared object
     * @param isAttached - To query whether the shared object should generate ops
     * @param valueTypes - The value types to register
     * @param eventEmitter - The object that will emit map events
     */
    constructor(serializer, handle, submitMessage, isAttached, eventEmitter) {
        this.serializer = serializer;
        this.handle = handle;
        this.submitMessage = submitMessage;
        this.isAttached = isAttached;
        this.eventEmitter = eventEmitter;
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        /**
         * The in-memory data the map is storing.
         */
        this.data = new Map();
        /**
         * Keys that have been modified locally but not yet ack'd from the server.
         */
        this.pendingKeys = new Map();
        /**
         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.
         */
        this.pendingMessageId = -1;
        /**
         * The pending ids of any clears that have been performed locally but not yet ack'd from the server
         */
        this.pendingClearMessageIds = [];
        this.localValueMaker = new _localValues__WEBPACK_IMPORTED_MODULE_0__.LocalValueMaker(serializer);
        this.messageHandlers = this.getMessageHandlers();
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.data.size;
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.data.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        const localEntriesIterator = this.data.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        const localValuesIterator = this.data.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: nextVal.value.value, done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.data.forEach((localValue, key, m) => {
            callbackFn(localValue.value, key, m);
        });
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        const localValue = this.data.get(key);
        return localValue === undefined ? undefined : localValue.value;
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.data.has(key);
    }
    /**
     * {@inheritDoc ISharedMap.set}
     */
    set(key, value) {
        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.
        if (key === undefined || key === null) {
            throw new Error("Undefined and null keys are not supported");
        }
        // Create a local value and serialize it.
        const localValue = this.localValueMaker.fromInMemory(value);
        const serializableValue = (0,_localValues__WEBPACK_IMPORTED_MODULE_0__.makeSerializable)(localValue, this.serializer, this.handle);
        // Set the value locally.
        const previousValue = this.setCore(key, localValue, true);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return;
        }
        const op = {
            key,
            type: "set",
            value: serializableValue,
        };
        this.submitMapKeyMessage(op, previousValue);
    }
    /**
     * Delete a key from the map.
     * @param key - Key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        // Delete the key locally first.
        const previousValue = this.deleteCore(key, true);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return previousValue !== undefined;
        }
        const op = {
            key,
            type: "delete",
        };
        this.submitMapKeyMessage(op, previousValue);
        return previousValue !== undefined;
    }
    /**
     * Clear all data from the map.
     */
    clear() {
        const copy = this.isAttached() ? new Map(this.data) : undefined;
        // Clear the data locally first.
        this.clearCore(true);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return;
        }
        const op = {
            type: "clear",
        };
        this.submitMapClearMessage(op, copy);
    }
    /**
     * Serializes the data stored in the shared map to a JSON string
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns A JSON string containing serialized map data
     */
    getSerializedStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);
        });
        return serializableMapData;
    }
    getSerializableStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = (0,_localValues__WEBPACK_IMPORTED_MODULE_0__.makeSerializable)(localValue, serializer, this.handle);
        });
        return serializableMapData;
    }
    serialize(serializer) {
        return JSON.stringify(this.getSerializableStorage(serializer));
    }
    /**
     * Populate the kernel with the given map data.
     * @param data - A JSON string containing serialized map data
     */
    populateFromSerializable(json) {
        for (const [key, serializable] of Object.entries(json)) {
            const localValue = {
                key,
                value: this.makeLocal(key, serializable),
            };
            this.data.set(localValue.key, localValue.value);
        }
    }
    populate(json) {
        this.populateFromSerializable(JSON.parse(json));
    }
    /**
     * Submit the given op if a handler is registered.
     * @param op - The operation to attempt to submit
     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     * @returns True if the operation was submitted, false otherwise.
     */
    trySubmitMessage(op, localOpMetadata) {
        const handler = this.messageHandlers.get(op.type);
        if (handler === undefined) {
            return false;
        }
        handler.submit(op, localOpMetadata);
        return true;
    }
    tryGetStashedOpLocalMetadata(op) {
        const handler = this.messageHandlers.get(op.type);
        if (handler === undefined) {
            throw new Error("no apply stashed op handler");
        }
        return handler.getStashedOpLocalMetadata(op);
    }
    /**
     * Process the given op if a handler is registered.
     * @param op - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation was processed, false otherwise.
     */
    tryProcessMessage(op, local, localOpMetadata) {
        const handler = this.messageHandlers.get(op.type);
        if (handler === undefined) {
            return false;
        }
        handler.process(op, local, localOpMetadata);
        return true;
    }
    /**
     * Rollback a local op
     * @param op - The operation to rollback
     * @param localOpMetadata - The local metadata associated with the op.
     */
    rollback(op, localOpMetadata) {
        if (!isMapLocalOpMetadata(localOpMetadata)) {
            throw new Error("Invalid localOpMetadata");
        }
        if (op.type === "clear" && localOpMetadata.type === "clear") {
            if (localOpMetadata.previousMap === undefined) {
                throw new Error("Cannot rollback without previous map");
            }
            localOpMetadata.previousMap.forEach((localValue, key) => {
                this.setCore(key, localValue, true);
            });
            const lastPendingClearId = this.pendingClearMessageIds.pop();
            if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {
                throw new Error("Rollback op does match last clear");
            }
        }
        else if (op.type === "delete" || op.type === "set") {
            if (localOpMetadata.type === "add") {
                this.deleteCore(op.key, true);
            }
            else if (localOpMetadata.type === "edit" && localOpMetadata.previousValue !== undefined) {
                this.setCore(op.key, localOpMetadata.previousValue, true);
            }
            else {
                throw new Error("Cannot rollback without previous value");
            }
            const pendingMessageIds = this.pendingKeys.get(op.key);
            const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();
            if (!pendingMessageIds || lastPendingMessageId !== localOpMetadata.pendingMessageId) {
                throw new Error("Rollback op does not match last pending");
            }
            if (pendingMessageIds.length === 0) {
                this.pendingKeys.delete(op.key);
            }
        }
        else {
            throw new Error("Unsupported op for rollback");
        }
    }
    /**
     * Set implementation used for both locally sourced sets as well as incoming remote sets.
     * @param key - The key being set
     * @param value - The value being set
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key, if any
     */
    setCore(key, value, local) {
        const previousLocalValue = this.data.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        this.data.set(key, value);
        this.eventEmitter.emit("valueChanged", { key, previousValue }, local, this.eventEmitter);
        return previousLocalValue;
    }
    /**
     * Clear implementation used for both locally sourced clears as well as incoming remote clears.
     * @param local - Whether the message originated from the local client
     */
    clearCore(local) {
        this.data.clear();
        this.eventEmitter.emit("clear", local, this.eventEmitter);
    }
    /**
     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.
     * @param key - The key being deleted
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key if it existed, undefined if it did not exist
     */
    deleteCore(key, local) {
        const previousLocalValue = this.data.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        const successfullyRemoved = this.data.delete(key);
        if (successfullyRemoved) {
            this.eventEmitter.emit("valueChanged", { key, previousValue }, local, this.eventEmitter);
        }
        return previousLocalValue;
    }
    /**
     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.
     */
    clearExceptPendingKeys() {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        this.pendingKeys.forEach((value, key) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            temp.set(key, this.data.get(key));
        });
        this.clearCore(false);
        temp.forEach((value, key) => {
            this.setCore(key, value, true);
        });
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will
     * have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's
     * job is to convert that information into a real object for local usage.
     * @param key - The key that the caller intends to store the local value into (used for ops later).  But
     * doesn't actually store the local value into that key.  So better not lie!
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, serializable) {
        if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType.Plain] || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.ValueType.Shared]) {
            return this.localValueMaker.fromSerializable(serializable);
        }
        else {
            throw new Error("Unknown local value type");
        }
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessKeyOperation(op, local, localOpMetadata) {
        if (this.pendingClearMessageIds.length > 0) {
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata) &&
                    localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x013 /* "Received out of order op when there is an unackd clear message" */);
            }
            // If we have an unack'd clear, we can ignore all ops.
            return false;
        }
        const pendingKeyMessageId = this.pendingKeys.get(op.key);
        if (pendingKeyMessageId !== undefined) {
            // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's
            // and don't process the op.
            if (local) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata), 0x014 /* pendingMessageId is missing from the local client's operation */);
                const pendingMessageIds = this.pendingKeys.get(op.key);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2fa /* Unexpected pending message received */);
                pendingMessageIds.shift();
                if (pendingMessageIds.length === 0) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    /**
     * Get the message handlers for the map.
     * @returns A map of string op names to IMapMessageHandlers for those ops
     */
    getMessageHandlers() {
        const messageHandlers = new Map();
        messageHandlers.set("clear", {
            process: (op, local, localOpMetadata) => {
                if (local) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x015 /* "pendingMessageId is missing from the local client's clear operation" */);
                    const pendingClearMessageId = this.pendingClearMessageIds.shift();
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fb /* pendingMessageId does not match */);
                    return;
                }
                if (this.pendingKeys.size !== 0) {
                    this.clearExceptPendingKeys();
                    return;
                }
                this.clearCore(local);
            },
            submit: (op, localOpMetadata) => {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isClearLocalOpMetadata(localOpMetadata), 0x2fc /* Invalid localOpMetadata for clear */);
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                const pendingClearMessageId = this.pendingClearMessageIds.shift();
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fd /* pendingMessageId does not match */);
                this.submitMapClearMessage(op, localOpMetadata.previousMap);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                return { type: "clear", pendingMessageId: this.getMapClearMessageId() };
            },
        });
        messageHandlers.set("delete", {
            process: (op, local, localOpMetadata) => {
                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {
                    return;
                }
                this.deleteCore(op.key, local);
            },
            submit: (op, localOpMetadata) => {
                this.resubmitMapKeyMessage(op, localOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                return { type: "edit", pendingMessageId: this.getMapKeyMessageId(op) };
            },
        });
        messageHandlers.set("set", {
            process: (op, local, localOpMetadata) => {
                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {
                    return;
                }
                // needProcessKeyOperation should have returned false if local is true
                const context = this.makeLocal(op.key, op.value);
                this.setCore(op.key, context, local);
            },
            submit: (op, localOpMetadata) => {
                this.resubmitMapKeyMessage(op, localOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                return { type: "edit", pendingMessageId: this.getMapKeyMessageId(op) };
            },
        });
        return messageHandlers;
    }
    getMapClearMessageId() {
        const pendingMessageId = ++this.pendingMessageId;
        this.pendingClearMessageIds.push(pendingMessageId);
        return pendingMessageId;
    }
    /**
     * Submit a clear message to remote clients.
     * @param op - The clear message
     */
    submitMapClearMessage(op, previousMap) {
        const metadata = { type: "clear", pendingMessageId: this.getMapClearMessageId(), previousMap };
        this.submitMessage(op, metadata);
    }
    getMapKeyMessageId(op) {
        const pendingMessageId = ++this.pendingMessageId;
        const pendingMessageIds = this.pendingKeys.get(op.key);
        if (pendingMessageIds !== undefined) {
            pendingMessageIds.push(pendingMessageId);
        }
        else {
            this.pendingKeys.set(op.key, [pendingMessageId]);
        }
        return pendingMessageId;
    }
    /**
     * Submit a map key message to remote clients.
     * @param op - The map key message
     * @param previousValue - The value of the key before this op
     */
    submitMapKeyMessage(op, previousValue) {
        const pendingMessageId = this.getMapKeyMessageId(op);
        const localMetadata = previousValue ?
            { type: "edit", pendingMessageId, previousValue } :
            { type: "add", pendingMessageId };
        this.submitMessage(op, localMetadata);
    }
    /**
     * Submit a map key message to remote clients based on a previous submit.
     * @param op - The map key message
     * @param localOpMetadata - Metadata from the previous submit
     */
    resubmitMapKeyMessage(op, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isMapKeyLocalOpMetadata(localOpMetadata), 0x2fe /* Invalid localOpMetadata in submit */);
        // clear the old pending message id
        const pendingMessageIds = this.pendingKeys.get(op.key);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2ff /* Unexpected pending message received */);
        pendingMessageIds.shift();
        if (pendingMessageIds.length === 0) {
            this.pendingKeys.delete(op.key);
        }
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const pendingMessageId = this.getMapKeyMessageId(op);
        const localMetadata = localOpMetadata.type === "edit" ?
            { type: "edit", pendingMessageId, previousValue: localOpMetadata.previousValue } :
            { type: "add", pendingMessageId };
        this.submitMessage(op, localMetadata);
    }
}
//# sourceMappingURL=mapKernel.js.map

/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isDataObjectClass": () => (/* binding */ isDataObjectClass),
/* harmony export */   "isSharedObjectClass": () => (/* binding */ isSharedObjectClass),
/* harmony export */   "parseDataObjectsFromSharedObjects": () => (/* binding */ parseDataObjectsFromSharedObjects)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Runtime check to determine if a class is a DataObject type
 */
const isDataObjectClass = (obj) => {
    return (obj === null || obj === void 0 ? void 0 : obj.factory) !== undefined;
};
/**
 * Runtime check to determine if a class is a SharedObject type
 */
const isSharedObjectClass = (obj) => {
    return (obj === null || obj === void 0 ? void 0 : obj.getFactory) !== undefined;
};
/**
 * The ContainerSchema consists of initialObjects and dynamicObjectTypes. These types can be
 * of both SharedObject or DataObject. This function seperates the two and returns a registery
 * of DataObject types and an array of SharedObjects.
 */
const parseDataObjectsFromSharedObjects = (schema) => {
    var _a;
    const registryEntries = new Set();
    const sharedObjects = new Set();
    const tryAddObject = (obj) => {
        if (isSharedObjectClass(obj)) {
            sharedObjects.add(obj.getFactory());
        }
        else if (isDataObjectClass(obj)) {
            registryEntries.add([
                obj.factory.type,
                Promise.resolve(obj.factory),
            ]);
        }
        else {
            throw new Error(`Entry is neither a DataObject or a SharedObject`);
        }
    };
    // Add the object types that will be initialized
    const dedupedObjects = new Set([
        ...Object.values(schema.initialObjects),
        ...((_a = schema.dynamicObjectTypes) !== null && _a !== void 0 ? _a : []),
    ]);
    dedupedObjects.forEach(tryAddObject);
    if (registryEntries.size === 0 && sharedObjects.size === 0) {
        throw new Error("Container cannot be initialized without any DataTypes");
    }
    return [Array.from(registryEntries), Array.from(sharedObjects)];
};
//# sourceMappingURL=utils.js.map

/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContainerRuntimeFactory": () => (/* binding */ BaseContainerRuntimeFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(131);
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
/* harmony import */ var _fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(149);
/* harmony import */ var _fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(146);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





/**
 * BaseContainerRuntimeFactory produces container runtimes with a given data store and service registry, as well as
 * given request handlers.  It can be subclassed to implement a first-time initialization procedure for the containers
 * it creates.
 */
class BaseContainerRuntimeFactory extends _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.RuntimeFactoryHelper {
    /**
     * @param registryEntries - The data store registry for containers produced
     * @param serviceRegistry - The service registry for containers produced
     * @param requestHandlers - Request handlers for containers produced
     * @param runtimeOptions - The runtime options passed to the ContainerRuntime when instantiating it
     */
    constructor(registryEntries, dependencyContainer, requestHandlers = [], runtimeOptions) {
        super();
        this.registryEntries = registryEntries;
        this.dependencyContainer = dependencyContainer;
        this.requestHandlers = requestHandlers;
        this.runtimeOptions = runtimeOptions;
        this.registry = new _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_1__.FluidDataStoreRegistry(registryEntries);
    }
    get IFluidDataStoreRegistry() { return this.registry; }
    async instantiateFirstTime(runtime) {
        await this.containerInitializingFirstTime(runtime);
        await this.containerHasInitialized(runtime);
    }
    async instantiateFromExisting(runtime) {
        await this.containerHasInitialized(runtime);
    }
    async preInitialize(context, existing) {
        const scope = context.scope;
        const dc = new _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__.DependencyContainer(this.dependencyContainer, scope.IFluidDependencySynthesizer);
        scope.IFluidDependencySynthesizer = dc;
        const runtime = await _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__.ContainerRuntime.load(context, this.registryEntries, (0,_fluidframework_request_handler__WEBPACK_IMPORTED_MODULE_4__.buildRuntimeRequestHandler)(...this.requestHandlers), this.runtimeOptions, scope, existing);
        // we register the runtime so developers of providers can use it in the factory pattern.
        dc.register(_fluidframework_container_runtime_definitions__WEBPACK_IMPORTED_MODULE_5__.IContainerRuntime, runtime);
        return runtime;
    }
    /**
     * Subclasses may override containerInitializingFirstTime to perform any setup steps at the time the container
     * is created. This likely includes creating any initial data stores that are expected to be there at the outset.
     * @param runtime - The container runtime for the container being initialized
     */
    async containerInitializingFirstTime(runtime) { }
    /**
     * Subclasses may override containerHasInitialized to perform any steps after the container has initialized.
     * This likely includes loading any data stores that are expected to be there at the outset.
     * @param runtime - The container runtime for the container being initialized
     */
    async containerHasInitialized(runtime) { }
}
//# sourceMappingURL=baseContainerRuntimeFactory.js.map

/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuntimeFactoryHelper": () => (/* binding */ RuntimeFactoryHelper)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
class RuntimeFactoryHelper {
    get IRuntimeFactory() { return this; }
    async instantiateRuntime(context, existing) {
        const fromExisting = existing === undefined
            ? context.existing === true
            : existing;
        const runtime = await this.preInitialize(context, fromExisting);
        if (fromExisting) {
            await this.instantiateFromExisting(runtime);
        }
        else {
            await this.instantiateFirstTime(runtime);
        }
        await this.hasInitialized(runtime);
        return runtime;
    }
    async instantiateFirstTime(_runtime) { }
    async instantiateFromExisting(_runtime) { }
    async hasInitialized(_runtime) { }
}
//# sourceMappingURL=runtimeFactoryHelper.js.map

/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencyContainer": () => (/* binding */ DependencyContainer)
/* harmony export */ });
/* harmony import */ var _IFluidDependencySynthesizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(148);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * DependencyContainer is similar to a IoC Container. It takes providers and will
 * synthesize an object based on them when requested.
 */
class DependencyContainer {
    constructor(...parents) {
        this.providers = new Map();
        this.parents = parents.filter((v) => v !== undefined);
    }
    get IFluidDependencySynthesizer() { return this; }
    /**
     * Add a new provider
     * @param type - Name of the Type T being provided
     * @param provider - A provider that will resolve the T correctly when asked
     * @throws - If passing a type that's already registered
     */
    register(type, provider) {
        if (this.providers.has(type)) {
            throw new Error(`Attempting to register a provider of type ${type} that already exists`);
        }
        this.providers.set(type, provider);
    }
    /**
     * Remove a provider
     * @param type - Name of the provider to remove
     */
    unregister(type) {
        if (this.providers.has(type)) {
            this.providers.delete(type);
        }
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}
     */
    synthesize(optionalTypes, requiredTypes) {
        const base = {};
        this.generateRequired(base, requiredTypes);
        this.generateOptional(base, optionalTypes);
        Object.defineProperty(base, _IFluidDependencySynthesizer__WEBPACK_IMPORTED_MODULE_0__.IFluidDependencySynthesizer, { get: () => this });
        return base;
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).has}
     * @param excludeParents - If true, exclude checking parent registries
     */
    has(type, excludeParents) {
        if (this.providers.has(type)) {
            return true;
        }
        if (excludeParents !== true) {
            return this.parents.some((p) => p.has(type));
        }
        return false;
    }
    /**
     * @deprecated - Needed for back compat
     */
    getProvider(provider) {
        // this was removed, but some partners have trouble with back compat where they
        // use invalid patterns with FluidObject and IFluidDependencySynthesizer
        // this is just for back compat until those are removed
        if (this.has(provider)) {
            if (this.providers.has(provider)) {
                return this.providers.get(provider);
            }
            for (const parent of this.parents) {
                if (parent instanceof DependencyContainer) {
                    return parent.getProvider(provider);
                }
                else {
                    // older implementations of the IFluidDependencySynthesizer exposed getProvider
                    const maybeGetProvider = parent;
                    if ((maybeGetProvider === null || maybeGetProvider === void 0 ? void 0 : maybeGetProvider.getProvider) !== undefined) {
                        return maybeGetProvider.getProvider(provider);
                    }
                }
            }
        }
    }
    generateRequired(base, types) {
        if (types === undefined) {
            return;
        }
        for (const key of Object.keys(types)) {
            const provider = this.resolveProvider(key);
            if (provider === undefined) {
                throw new Error(`Object attempted to be created without registered required provider ${key}`);
            }
            Object.defineProperty(base, key, provider);
        }
    }
    generateOptional(base, types) {
        var _a;
        if (types === undefined) {
            return;
        }
        for (const key of Object.keys(types)) {
            // back-compat: in 0.56 we allow undefined in the types, but we didn't before
            // this will keep runtime back compat, eventually we should support undefined properties
            // rather than properties that return promises that resolve to undefined
            const provider = (_a = this.resolveProvider(key)) !== null && _a !== void 0 ? _a : { get: async () => undefined };
            Object.defineProperty(base, key, provider);
        }
    }
    resolveProvider(t) {
        // If we have the provider return it
        const provider = this.providers.get(t);
        if (provider === undefined) {
            for (const parent of this.parents) {
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                const sp = { [t]: t };
                const syn = parent.synthesize(sp, {});
                const descriptor = Object.getOwnPropertyDescriptor(syn, t);
                if (descriptor !== undefined) {
                    return descriptor;
                }
            }
            return undefined;
        }
        // The double nested gets are required for lazy loading the provider resolution
        if (typeof provider === "function") {
            return {
                get() {
                    if (provider && typeof provider === "function") {
                        return Promise.resolve(this[_IFluidDependencySynthesizer__WEBPACK_IMPORTED_MODULE_0__.IFluidDependencySynthesizer])
                            .then(async (fds) => provider(fds))
                            .then((p) => p === null || p === void 0 ? void 0 : p[t]);
                    }
                },
            };
        }
        return {
            get() {
                if (provider) {
                    return Promise.resolve(provider).then((p) => {
                        if (p) {
                            return p[t];
                        }
                    });
                }
            },
        };
    }
}
//# sourceMappingURL=dependencyContainer.js.map

/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IFluidDependencySynthesizer": () => (/* binding */ IFluidDependencySynthesizer)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const IFluidDependencySynthesizer = "IFluidDependencySynthesizer";
//# sourceMappingURL=IFluidDependencySynthesizer.js.map

/***/ }),
/* 149 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(150), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IContainerRuntime = void 0;
/**
 * @deprecated - This will be removed in a later release.
 */
exports.IContainerRuntime = "IContainerRuntime";
//# sourceMappingURL=containerRuntime.js.map

/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObjectFactory": () => (/* binding */ DataObjectFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(142);
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(153);
/* harmony import */ var _pureDataObjectFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(152);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * DataObjectFactory is the IFluidDataStoreFactory for use with DataObjects.
 * It facilitates DataObject's features (such as its shared directory) by
 * ensuring relevant shared objects etc are available to the factory.
 *
 * @typeParam TObj - DataObject (concrete type)
 * @typeParam I - The input types for the DataObject
 */
class DataObjectFactory extends _pureDataObjectFactory__WEBPACK_IMPORTED_MODULE_0__.PureDataObjectFactory {
    constructor(type, ctor, sharedObjects = [], optionalProviders, registryEntries, runtimeFactory = _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_1__.FluidDataStoreRuntime) {
        const mergedObjects = [...sharedObjects];
        if (!sharedObjects.find((factory) => factory.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.DirectoryFactory.Type)) {
            // User did not register for directory
            mergedObjects.push(_fluidframework_map__WEBPACK_IMPORTED_MODULE_2__.SharedDirectory.getFactory());
        }
        // TODO: Remove SharedMap factory when compatibility with SharedMap DataObject is no longer needed in 0.10
        if (!sharedObjects.find((factory) => factory.type === _fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.MapFactory.Type)) {
            // User did not register for map
            mergedObjects.push(_fluidframework_map__WEBPACK_IMPORTED_MODULE_3__.SharedMap.getFactory());
        }
        super(type, ctor, mergedObjects, optionalProviders, registryEntries, runtimeFactory);
    }
}
//# sourceMappingURL=dataObjectFactory.js.map

/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PureDataObjectFactory": () => (/* binding */ PureDataObjectFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(153);
/* harmony import */ var _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(131);
/* harmony import */ var _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _data_objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * Proxy over PureDataObject
 * Does delayed creation & initialization of PureDataObject
*/
async function createDataObject(ctor, context, sharedObjectRegistry, optionalProviders, runtimeClassArg, existing, initProps) {
    // base
    let runtimeClass = runtimeClassArg;
    // request mixin in
    runtimeClass = (0,_fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.mixinRequestHandler)(async (request, runtimeArg) => (await _data_objects__WEBPACK_IMPORTED_MODULE_1__.PureDataObject.getDataObject(runtimeArg)).request(request), runtimeClass);
    // Create a new runtime for our data store
    // The runtime is what Fluid uses to create DDS' and route to your data store
    const runtime = new runtimeClass(context, sharedObjectRegistry, existing);
    // Create object right away.
    // This allows object to register various callbacks with runtime before runtime
    // becomes globally available. But it's not full initialization - constructor can't
    // access DDSes or other services of runtime as objects are not fully initialized.
    // In order to use object, we need to go through full initialization by calling finishInitialization().
    const scope = context.scope;
    const dependencyContainer = new _fluidframework_synthesize__WEBPACK_IMPORTED_MODULE_2__.DependencyContainer(scope.IFluidDependencySynthesizer);
    const providers = dependencyContainer.synthesize(optionalProviders, {});
    const instance = new ctor({ runtime, context, providers, initProps });
    // if it's a newly created object, we need to wait for it to finish initialization
    // as that results in creation of DDSes, before it gets attached, providing atomic
    // guarantee of creation.
    // WARNING: we can't do the same (yet) for already existing PureDataObject!
    // This will result in deadlock, as it tries to resolve internal handles, but any
    // handle resolution goes through root (container runtime), which can't route it back
    // to this data store, as it's still not initialized and not known to container runtime yet.
    // In the future, we should address it by using relative paths for handles and be able to resolve
    // local DDSes while data store is not fully initialized.
    if (!existing) {
        await instance.finishInitialization(existing);
    }
    return { instance, runtime };
}
/**
 * PureDataObjectFactory is a barebones IFluidDataStoreFactory for use with PureDataObject.
 * Consumers should typically use DataObjectFactory instead unless creating
 * another base data store factory.
 *
 * @typeParam TObj - DataObject (concrete type)
 * @typeParam I - The input types for the DataObject
 */
class PureDataObjectFactory {
    constructor(type, ctor, sharedObjects, optionalProviders, registryEntries, runtimeClass = _fluidframework_datastore__WEBPACK_IMPORTED_MODULE_0__.FluidDataStoreRuntime) {
        this.type = type;
        this.ctor = ctor;
        this.optionalProviders = optionalProviders;
        this.runtimeClass = runtimeClass;
        if (this.type === "") {
            throw new Error("undefined type member");
        }
        if (registryEntries !== undefined) {
            this.registry = new _fluidframework_container_runtime__WEBPACK_IMPORTED_MODULE_3__.FluidDataStoreRegistry(registryEntries);
        }
        this.sharedObjectRegistry = new Map(sharedObjects.map((ext) => [ext.type, ext]));
    }
    get IFluidDataStoreFactory() { return this; }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    /**
     * Convenience helper to get the data store's/factory's data store registry entry.
     * The return type hides the factory's generics, easing grouping of registry
     * entries that differ only in this way into the same array.
     * @returns The NamedFluidDataStoreRegistryEntry
     */
    get registryEntry() {
        return [this.type, Promise.resolve(this)];
    }
    /**
     * This is where we do data store setup.
     *
     * @param context - data store context used to load a data store runtime
     */
    async instantiateDataStore(context, existing) {
        const { runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, existing);
        return runtime;
    }
    /**
     * Creates a new instance of the object. Uses parent context's registry to build package path to this factory.
     * In other words, registry of context passed in has to contain this factory, with the name that matches
     * this factory's type.
     * It is intended to be used by data store objects that create sub-objects.
     * @param context - The context being used to create the runtime
     * (the created object will have its own new context created as well)
     * @param initialState - The initial state to provide to the created data store.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createChildInstance(parentContext, initialState) {
        return this.createNonRootInstanceCore(parentContext.containerRuntime, [...parentContext.packagePath, this.type], initialState);
    }
    /**
     * Creates a new instance of the object. Uses peer context's registry and its package path to identify this factory.
     * In other words, registry of context passed in has to have this factory.
     * Intended to be used by data store objects that need to create peers (similar) instances of existing objects.
     * @param context - The component context being used to create the object
     * (the created object will have its own new context created as well)
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createPeerInstance(peerContext, initialState) {
        return this.createNonRootInstanceCore(peerContext.containerRuntime, peerContext.packagePath, initialState);
    }
    /**
     * Creates a new instance of the object. Uses container's registry to find this factory.
     * It's expected that only container owners would use this functionality, as only such developers
     * have knowledge of entries in container registry.
     * The name in this registry for such record should match type of this factory.
     * @param runtime - container runtime. It's registry is used to create an object.
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createInstance(runtime, initialState) {
        return this.createNonRootInstanceCore(runtime, [this.type], initialState);
    }
    /**
     * Creates a new root instance of the object. Uses container's registry to find this factory.
     * It's expected that only container owners would use this functionality, as only such developers
     * have knowledge of entries in container registry.
     * The name in this registry for such record should match type of this factory.
     * @param runtime - container runtime. It's registry is used to create an object.
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createRootInstance(rootDataStoreId, runtime, initialState) {
        const context = runtime.createDetachedRootDataStore([this.type], rootDataStoreId);
        return this.createInstanceCore(context, initialState);
    }
    async createNonRootInstanceCore(containerRuntime, packagePath, initialState) {
        const context = containerRuntime.createDetachedDataStore(packagePath);
        return this.createInstanceCore(context, initialState);
    }
    async createInstanceCore(context, initialState) {
        const { instance, runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, false, // existing
        initialState);
        await context.attachRuntime(this, runtime);
        return instance;
    }
}
//# sourceMappingURL=pureDataObjectFactory.js.map

/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataStoreMessageType": () => (/* binding */ DataStoreMessageType),
/* harmony export */   "FluidDataStoreRuntime": () => (/* binding */ FluidDataStoreRuntime),
/* harmony export */   "mixinRequestHandler": () => (/* binding */ mixinRequestHandler),
/* harmony export */   "mixinSummaryHandler": () => (/* binding */ mixinSummaryHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(154);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(155);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(273);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(132);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(97);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(272);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(55);
/* harmony import */ var _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(21);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(24);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(25);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(103);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);
/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(266);
/* harmony import */ var _localChannelContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(157);
/* harmony import */ var _remoteChannelContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(271);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */













var DataStoreMessageType;
(function (DataStoreMessageType) {
    // Creates a new channel
    DataStoreMessageType["Attach"] = "attach";
    DataStoreMessageType["ChannelOp"] = "op";
})(DataStoreMessageType || (DataStoreMessageType = {}));
/**
 * Base data store class
 */
class FluidDataStoreRuntime extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(dataStoreContext, sharedObjectRegistry, existing) {
        super();
        this.dataStoreContext = dataStoreContext;
        this.sharedObjectRegistry = sharedObjectRegistry;
        this._disposed = false;
        this.contexts = new Map();
        this.contextsDeferred = new Map();
        this.pendingAttach = new Map();
        this.deferredAttached = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        this.localChannelContextQueue = new Map();
        this.notBoundedChannelContextSet = new Set();
        // A list of handles that are bound when the data store is not visible. We have to make them visible when the data
        // store becomes visible.
        this.pendingHandlesToMakeVisible = new Set();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!dataStoreContext.id.includes("/"), 0x30e /* Id cannot contain slashes. DataStoreContext should have validated this. */);
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(dataStoreContext.logger, "FluidDataStoreRuntime", { all: { dataStoreId: (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])() } });
        this.id = dataStoreContext.id;
        this.options = dataStoreContext.options;
        this.deltaManager = dataStoreContext.deltaManager;
        this.quorum = dataStoreContext.getQuorum();
        this.audience = dataStoreContext.getAudience();
        const tree = dataStoreContext.baseSnapshot;
        this.channelsBaseGCDetails = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.LazyPromise(async () => {
            var _a, _b, _c;
            const baseGCDetails = await ((_c = (_b = (_a = this.dataStoreContext).getBaseGCDetails) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : this.dataStoreContext.getInitialGCSummaryDetails());
            return (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.unpackChildNodesGCDetails)(baseGCDetails);
        });
        // Must always receive the data store type inside of the attributes
        if ((tree === null || tree === void 0 ? void 0 : tree.trees) !== undefined) {
            Object.keys(tree.trees).forEach((path) => {
                // Issue #4414
                if (path === "_search") {
                    return;
                }
                let channelContext;
                // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a
                // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be
                // true. In this case create a RehydratedLocalChannelContext.
                if (dataStoreContext.isLocalDataStore) {
                    channelContext = new _localChannelContext__WEBPACK_IMPORTED_MODULE_6__.RehydratedLocalChannelContext(path, this.sharedObjectRegistry, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), tree.trees[path]);
                    // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of
                    // data store, if the data store is loaded after the container is attached, then we missed making
                    // the channel visible. So do it now. Otherwise, add it to local channel context queue, so
                    // that it can be make it visible later with the data store.
                    if (dataStoreContext.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached) {
                        channelContext.makeVisible();
                    }
                    else {
                        this.localChannelContextQueue.set(path, channelContext);
                    }
                }
                else {
                    channelContext = new _remoteChannelContext__WEBPACK_IMPORTED_MODULE_8__.RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), path, tree.trees[path], this.sharedObjectRegistry, undefined /* extraBlobs */, this.dataStoreContext.getCreateChildSummarizerNodeFn(path, { type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.CreateSummarizerNodeSource.FromSummary }), async () => this.getChannelBaseGCDetails(path));
                }
                const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();
                deferred.resolve(channelContext);
                this.contexts.set(path, channelContext);
                this.contextsDeferred.set(path, deferred);
            });
        }
        this.attachListener();
        // If exists on storage or loaded from a snapshot, it should already be bound.
        this.bindState = existing ? _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.Bound : _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.NotBound;
        this._attachState = dataStoreContext.attachState;
        /**
         * If existing flag is false, this is a new data store and is not visible. The existing flag can be true in two
         * conditions:
         * 1. It's a local data store that is created when a detached container is rehydrated. In this case, the data
         *    store is locally visible because the snapshot it is loaded from contains locally visible data stores only.
         * 2. It's a remote data store that is created when an attached container is loaded is loaded from snapshot or
         *    when an attach op comes in. In both these cases, the data store is already globally visible.
         */
        if (existing) {
            this.visibilityState = dataStoreContext.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached
                ? _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.LocallyVisible : _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible;
        }
        else {
            this.visibilityState = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.NotVisible;
        }
        // If it's existing we know it has been attached.
        if (existing) {
            this.deferredAttached.resolve();
        }
    }
    /**
     * Loads the data store runtime
     * @param context - The data store context
     * @param sharedObjectRegistry - The registry of shared objects used by this data store
     * @param existing - If loading from an existing file.
     */
    static load(context, sharedObjectRegistry, existing) {
        return new FluidDataStoreRuntime(context, sharedObjectRegistry, existing);
    }
    get IFluidRouter() { return this; }
    get connected() {
        return this.dataStoreContext.connected;
    }
    get clientId() {
        return this.dataStoreContext.clientId;
    }
    get clientDetails() {
        return this.dataStoreContext.clientDetails;
    }
    get isAttached() {
        return this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached;
    }
    get attachState() {
        return this._attachState;
    }
    get absolutePath() {
        return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_10__.generateHandleContextPath)(this.id, this.routeContext);
    }
    get routeContext() {
        return this.dataStoreContext.IFluidHandleContext;
    }
    get IFluidHandleContext() { return this; }
    get rootRoutingContext() { return this; }
    get channelsRoutingContext() { return this; }
    get objectsRoutingContext() { return this; }
    get disposed() { return this._disposed; }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.emit("dispose");
        this.removeAllListeners();
    }
    async resolveHandle(request) {
        return this.request(request);
    }
    async request(request) {
        try {
            const parser = _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_11__.RequestParser.create(request);
            const id = parser.pathParts[0];
            if (id === "_channels" || id === "_custom") {
                return this.request(parser.createSubRequest(1));
            }
            // Check for a data type reference first
            if (this.contextsDeferred.has(id) && parser.isLeaf(1)) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const value = await this.contextsDeferred.get(id).promise;
                    const channel = await value.getChannel();
                    return { mimeType: "fluid/object", status: 200, value: channel };
                }
                catch (error) {
                    this.logger.sendErrorEvent({ eventName: "GetChannelFailedInRequest" }, error);
                    return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.createResponseError)(500, `Failed to get Channel: ${error}`, request);
                }
            }
            // Otherwise defer to an attached request handler
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.create404Response)(request);
        }
        catch (error) {
            return (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.exceptionToResponse)(error);
        }
    }
    async getChannel(id) {
        this.verifyNotClosed();
        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist
        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if
        // it doesn't exist
        if (!this.contextsDeferred.has(id)) {
            this.contextsDeferred.set(id, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred());
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const context = await this.contextsDeferred.get(id).promise;
        const channel = await context.getChannel();
        return channel;
    }
    createChannel(id = (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])(), type) {
        if (id.includes("/")) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.UsageError(`Id cannot contain slashes: ${id}`);
        }
        this.verifyNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.contexts.has(id), 0x179 /* "createChannel() with existing ID" */);
        this.notBoundedChannelContextSet.add(id);
        const context = new _localChannelContext__WEBPACK_IMPORTED_MODULE_6__.LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle));
        this.contexts.set(id, context);
        if (this.contextsDeferred.has(id)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.contextsDeferred.get(id).resolve(context);
        }
        else {
            const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();
            deferred.resolve(context);
            this.contextsDeferred.set(id, deferred);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!context.channel, 0x17a /* "Channel should be loaded when created!!" */);
        return context.channel;
    }
    /**
     * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.
     * If the runtime is not attached we will defer the attach until the runtime attaches.
     * @param channel - channel to be registered.
     */
    bindChannel(channel) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.notBoundedChannelContextSet.has(channel.id), 0x17b /* "Channel to be binded should be in not bounded set" */);
        this.notBoundedChannelContextSet.delete(channel.id);
        // If our data store is attached, then attach the channel.
        if (this.isAttached) {
            this.attachChannel(channel);
            return;
        }
        /**
         * If this channel is already waiting to be made visible, do nothing. This can happen during attachGraph() when
         * a channel's graph is attached. It calls bindToContext on the shared object which will end up back here.
         */
        if (this.pendingHandlesToMakeVisible.has(channel.handle)) {
            return;
        }
        this.bind(channel.handle);
        // If our data store is local then add the channel to the queue
        if (!this.localChannelContextQueue.has(channel.id)) {
            this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));
        }
    }
    /**
     * This function is called when a data store becomes root. It does the following:
     * 1. Marks the data store locally visible in the container.
     * 2. Attaches the graph of all the handles bound to it.
     * 3. Calls into the data store context to mark it visible in the container too. If the container is globally
     *    visible, it will mark us globally visible. Otherwise, it will mark us globally visible when it becomes
     *    globally visible.
     */
    makeVisibleAndAttachGraph() {
        if (this.visibilityState !== _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.NotVisible) {
            return;
        }
        this.visibilityState = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.LocallyVisible;
        this.pendingHandlesToMakeVisible.forEach((handle) => {
            handle.attachGraph();
        });
        this.pendingHandlesToMakeVisible.clear();
        this.bindToContext();
    }
    /**
     * This function is called when a handle to this data store is added to a visible DDS.
     */
    attachGraph() {
        this.makeVisibleAndAttachGraph();
    }
    /**
     * Binds this runtime to the container
     * This includes the following:
     * 1. Sending an Attach op that includes all existing state
     * 2. Attaching the graph if the data store becomes attached.
     */
    bindToContext() {
        if (this.bindState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.NotBound) {
            return;
        }
        this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.Binding;
        this.dataStoreContext.bindToContext();
        this.bindState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.BindState.Bound;
    }
    bind(handle) {
        // If visible, attach the incoming handle's graph. Else, this will be done when we become visible.
        if (this.visibilityState !== _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.NotVisible) {
            handle.attachGraph();
            return;
        }
        this.pendingHandlesToMakeVisible.add(handle);
    }
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        for (const [, object] of this.contexts) {
            object.setConnectionState(connected, clientId);
        }
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_14__.raiseConnectedEvent)(this.logger, this, connected, clientId);
    }
    getQuorum() {
        return this.quorum;
    }
    getAudience() {
        return this.audience;
    }
    async uploadBlob(blob) {
        this.verifyNotClosed();
        return this.dataStoreContext.uploadBlob(blob);
    }
    process(message, local, localOpMetadata) {
        this.verifyNotClosed();
        try {
            // catches as data processing error whether or not they come from async pending queues
            switch (message.type) {
                case DataStoreMessageType.Attach: {
                    const attachMessage = message.contents;
                    const id = attachMessage.id;
                    // If a non-local operation then go and create the object
                    // Otherwise mark it as officially attached.
                    if (local) {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pendingAttach.has(id), 0x17c /* "Unexpected attach (local) channel OP" */);
                        this.pendingAttach.delete(id);
                    }
                    else {
                        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.contexts.has(id), 0x17d);
                        const flatBlobs = new Map();
                        const snapshotTree = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);
                        const remoteChannelContext = new _remoteChannelContext__WEBPACK_IMPORTED_MODULE_8__.RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {
                            type: _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.CreateSummarizerNodeSource.FromAttach,
                            sequenceNumber: message.sequenceNumber,
                            snapshot: attachMessage.snapshot,
                        }), async () => this.getChannelBaseGCDetails(id), attachMessage.type);
                        this.contexts.set(id, remoteChannelContext);
                        if (this.contextsDeferred.has(id)) {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.contextsDeferred.get(id).resolve(remoteChannelContext);
                        }
                        else {
                            const deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();
                            deferred.resolve(remoteChannelContext);
                            this.contextsDeferred.set(id, deferred);
                        }
                    }
                    break;
                }
                case DataStoreMessageType.ChannelOp:
                    this.processChannelOp(message, local, localOpMetadata);
                    break;
                default:
            }
            this.emit("op", message);
        }
        catch (error) {
            throw _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_13__.DataProcessingError.wrapIfUnrecognized(error, "fluidDataStoreRuntimeFailedToProcessMessage", message);
        }
    }
    processSignal(message, local) {
        this.emit("signal", message, local);
    }
    isChannelAttached(id) {
        return (
        // Added in createChannel
        // Removed when bindChannel is called
        !this.notBoundedChannelContextSet.has(id)
            // Added in bindChannel only if this is not attached yet
            // Removed when this is attached by calling attachGraph
            && !this.localChannelContextQueue.has(id)
            // Added in attachChannel called by bindChannel
            // Removed when attach op is broadcast
            && !this.pendingAttach.has(id));
    }
    /**
     * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered
     * referenced and are hence outbound. This will change when we have root and non-root channel contexts.
     * The only root contexts will be considered as referenced.
     */
    getOutboundRoutes() {
        const outboundRoutes = [];
        for (const [contextId] of this.contexts) {
            outboundRoutes.push(`${this.absolutePath}/${contextId}`);
        }
        return outboundRoutes;
    }
    /**
     * Updates the GC nodes of this channel. It does the following:
     * - Adds a back route to self to all its child GC nodes.
     * - Adds a node for this channel.
     * @param builder - The builder that contains the GC nodes for this channel's children.
     */
    updateGCNodes(builder) {
        // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should
        // be considered referenced as well.
        builder.addRouteToAllNodes(this.absolutePath);
        // Get the outbound routes and add a GC node for this channel.
        builder.addNode("/", this.getOutboundRoutes());
    }
    /**
     * Generates data used for garbage collection. This includes a list of GC nodes that represent this channel
     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the
     * document. It does the following:
     * 1. Calls into each child context to get its GC data.
     * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be
     *    identified as belonging to the child.
     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent
     *    the GC data of this channel.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        const builder = new _fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.GCDataBuilder();
        // Iterate over each channel context and get their GC data.
        await Promise.all(Array.from(this.contexts)
            .filter(([contextId, _]) => {
            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference
            // graph so any references they might have won't be connected as well.
            return this.isChannelAttached(contextId);
        }).map(async ([contextId, context]) => {
            const contextGCData = await context.getGCData(fullGC);
            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.
            // This also gradually builds the id of each node to be a path from the root.
            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);
        }));
        this.updateGCNodes(builder);
        return builder.getGCData();
    }
    /**
     * After GC has run, called to notify this channel of routes that are used in it. It calls the child contexts to
     * update their used routes.
     * @param usedRoutes - The routes that are used in all contexts in this channel.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced
     * as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        var _a;
        // Get a map of channel ids to routes used in it.
        const usedContextRoutes = (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.unpackChildNodesUsedRoutes)(usedRoutes);
        // Verify that the used routes are correct.
        for (const [id] of usedContextRoutes) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.contexts.has(id), 0x17e /* "Used route does not belong to any known context" */);
        }
        // Update the used routes in each context. Used routes is empty for unused context.
        for (const [contextId, context] of this.contexts) {
            context.updateUsedRoutes((_a = usedContextRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);
        }
    }
    /**
     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify
     * all references added in the system.
     * @param srcHandle - The handle of the node that added the reference.
     * @param outboundHandle - The handle of the outbound node that is referenced.
     */
    addedGCOutboundReference(srcHandle, outboundHandle) {
        var _a, _b;
        (_b = (_a = this.dataStoreContext).addedGCOutboundReference) === null || _b === void 0 ? void 0 : _b.call(_a, srcHandle, outboundHandle);
    }
    /**
     * Returns the base GC details for the channel with the given id. This is used to initialize its GC state.
     * @param channelId - The id of the channel context that is asked for the initial GC details.
     * @returns the requested channel's base GC details.
     */
    async getChannelBaseGCDetails(channelId) {
        var _a;
        let channelBaseGCDetails = (await this.channelsBaseGCDetails).get(channelId);
        if (channelBaseGCDetails === undefined) {
            channelBaseGCDetails = {};
        }
        else if (((_a = channelBaseGCDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) !== undefined) {
            // Note: if the child channel has an explicit handle route to its parent, it will be removed here and
            // expected to be added back by the parent when getGCData is called.
            (0,_fluidframework_garbage_collector__WEBPACK_IMPORTED_MODULE_5__.removeRouteFromAllNodes)(channelBaseGCDetails.gcData.gcNodes, this.absolutePath);
        }
        // Currently, channel context's are always considered used. So, it there are no used routes for it, we still
        // need to mark it as used. Add self-route (empty string) to the channel context's used routes.
        if (channelBaseGCDetails.usedRoutes === undefined || channelBaseGCDetails.usedRoutes.length === 0) {
            channelBaseGCDetails.usedRoutes = [""];
        }
        return channelBaseGCDetails;
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = true, telemetryContext) {
        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();
        // Iterate over each data store and ask it to summarize
        await Promise.all(Array.from(this.contexts)
            .filter(([contextId, _]) => {
            const isAttached = this.isChannelAttached(contextId);
            // We are not expecting local dds! Summary may not capture local state.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(isAttached, 0x17f /* "Not expecting detached channels during summarize" */);
            // If the object is registered - and we have received the sequenced op creating the object
            // (i.e. it has a base mapping) - then we go ahead and summarize
            return isAttached;
        }).map(async ([contextId, context]) => {
            const contextSummary = await context.summarize(fullTree, trackState, telemetryContext);
            summaryBuilder.addWithStats(contextId, contextSummary);
        }));
        return summaryBuilder.getSummaryTree();
    }
    getAttachSummary(telemetryContext) {
        /**
         * back-compat 0.59.1000 - getAttachSummary() is called when making a data store globally visible (previously
         * attaching state). Ideally, attachGraph() should have already be called making it locally visible. However,
         * before visibility state was added, this may not have been the case and getAttachSummary() could be called:
         * 1) Before attaching the data store - When a detached container is attached.
         * 2) After attaching the data store - When a data store is created and bound in an attached container.
         *
         * The basic idea is that all local object should become locally visible before they are globally visible.
         */
        this.attachGraph();
        /**
         * This assert cannot be added now due to back-compat. To be uncommented when the following issue is fixed -
         * https://github.com/microsoft/FluidFramework/issues/9688.
         *
         * assert(this.visibilityState === VisibilityState.LocallyVisible,
         *   "The data store should be locally visible when generating attach summary",
         * );
         */
        const summaryBuilder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.SummaryTreeBuilder();
        // Craft the .attributes file for each shared object
        for (const [contextId, context] of this.contexts) {
            if (!(context instanceof _localChannelContext__WEBPACK_IMPORTED_MODULE_6__.LocalChannelContextBase)) {
                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError("Should only be called with local channel handles");
            }
            if (!this.notBoundedChannelContextSet.has(contextId)) {
                let summaryTree;
                if (context.isLoaded) {
                    const contextSummary = context.getAttachSummary(telemetryContext);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(contextSummary.summary.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.SummaryType.Tree, 0x180 /* "getAttachSummary should always return a tree" */);
                    summaryTree = { stats: contextSummary.stats, summary: contextSummary.summary };
                }
                else {
                    // If this channel is not yet loaded, then there should be no changes in the snapshot from which
                    // it was created as it is detached container. So just use the previous snapshot.
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!this.dataStoreContext.baseSnapshot, 0x181 /* "BaseSnapshot should be there as detached container loaded from snapshot" */);
                    summaryTree = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertSnapshotTreeToSummaryTree)(this.dataStoreContext.baseSnapshot.trees[contextId]);
                }
                summaryBuilder.addWithStats(contextId, summaryTree);
            }
        }
        return summaryBuilder.getSummaryTree();
    }
    submitMessage(type, content, localOpMetadata) {
        this.submit(type, content, localOpMetadata);
    }
    submitSignal(type, content) {
        this.verifyNotClosed();
        return this.dataStoreContext.submitSignal(type, content);
    }
    /**
     * Will return when the data store is attached.
     */
    async waitAttached() {
        return this.deferredAttached.promise;
    }
    /**
     * Attach channel should only be called after the data store has been attached
     */
    attachChannel(channel) {
        this.verifyNotClosed();
        // If this handle is already attached no need to attach again.
        if (channel.handle.isAttached) {
            return;
        }
        channel.handle.attachGraph();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.isAttached, 0x182 /* "Data store should be attached to attach the channel." */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.visibilityState === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible, 0x2d0 /* "Data store should be globally visible to attach channels." */);
        const summarizeResult = (0,_channelContext__WEBPACK_IMPORTED_MODULE_19__.summarizeChannel)(channel, true /* fullTree */, false /* trackState */);
        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.
        const snapshot = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_16__.convertSummaryTreeToITree)(summarizeResult.summary);
        const message = {
            id: channel.id,
            snapshot,
            type: channel.attributes.type,
        };
        this.pendingAttach.set(channel.id, message);
        this.submit(DataStoreMessageType.Attach, message);
        const context = this.contexts.get(channel.id);
        context.makeVisible();
    }
    submitChannelOp(address, contents, localOpMetadata) {
        const envelope = { address, contents };
        this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);
    }
    submit(type, content, localOpMetadata = undefined) {
        this.verifyNotClosed();
        this.dataStoreContext.submitMessage(type, content, localOpMetadata);
    }
    /**
     * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.
     * For all other messages, just submit it again.
     * This typically happens when we reconnect and there are unacked messages.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(type, content, localOpMetadata) {
        this.verifyNotClosed();
        switch (type) {
            case DataStoreMessageType.ChannelOp:
                {
                    // For Operations, find the right channel and trigger resubmission on it.
                    const envelope = content;
                    const channelContext = this.contexts.get(envelope.address);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x183 /* "There should be a channel context for the op" */);
                    channelContext.reSubmit(envelope.contents, localOpMetadata);
                    break;
                }
            case DataStoreMessageType.Attach:
                // For Attach messages, just submit them again.
                this.submit(type, content, localOpMetadata);
                break;
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_20__.unreachableCase)(type);
        }
    }
    /**
     * Revert a local op.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    rollback(type, content, localOpMetadata) {
        this.verifyNotClosed();
        switch (type) {
            case DataStoreMessageType.ChannelOp:
                {
                    // For Operations, find the right channel and trigger resubmission on it.
                    const envelope = content;
                    const channelContext = this.contexts.get(envelope.address);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x2ed /* "There should be a channel context for the op" */);
                    channelContext.rollback(envelope.contents, localOpMetadata);
                    break;
                }
            default:
                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError(`Can't rollback ${type} message`);
        }
    }
    async applyStashedOp(content) {
        const envelope = content;
        const channelContext = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x184 /* "There should be a channel context for the op" */);
        await channelContext.getChannel();
        return channelContext.applyStashedOp(envelope.contents);
    }
    setChannelDirty(address) {
        this.verifyNotClosed();
        this.dataStoreContext.setChannelDirty(address);
    }
    processChannelOp(message, local, localOpMetadata) {
        this.verifyNotClosed();
        const envelope = message.contents;
        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });
        const channelContext = this.contexts.get(envelope.address);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!channelContext, 0x185 /* "Channel not found" */);
        channelContext.processOp(transformed, local, localOpMetadata);
        return channelContext;
    }
    attachListener() {
        this.setMaxListeners(Number.MAX_SAFE_INTEGER);
        this.dataStoreContext.once("attaching", () => {
            /**
             * back-compat 0.59.1000 - Ideally, attachGraph() should have already been called making the data store
             * locally visible. However, before visibility state was added, this may not have been the case and data
             * store can move to "attaching" state in 2 scenarios:
             * 1) Before attachGraph() is called - When a data store is created and bound in an attached container.
             * 2) After attachGraph() is called - When a detached container is attached.
             *
             * The basic idea is that all local object should become locally visible before they are globally visible.
             */
            this.attachGraph();
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Attaching;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.visibilityState === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.LocallyVisible, 0x2d1 /* "Data store should be locally visible before it can become globally visible." */);
            // Mark the data store globally visible and make its child channels visible as well.
            this.visibilityState = _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible;
            this.localChannelContextQueue.forEach((channel) => {
                channel.makeVisible();
            });
            this.localChannelContextQueue.clear();
            // This promise resolution will be moved to attached event once we fix the scheduler.
            this.deferredAttached.resolve();
            this.emit("attaching");
        });
        this.dataStoreContext.once("attached", () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.visibilityState === _fluidframework_runtime_definitions__WEBPACK_IMPORTED_MODULE_9__.VisibilityState.GloballyVisible, 0x2d2 /* "Data store should be globally visible when its attached." */);
            this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Attached;
            this.emit("attached");
        });
    }
    verifyNotClosed() {
        if (this._disposed) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError("Runtime is closed");
        }
    }
}
/**
 * Mixin class that adds request handler to FluidDataStoreRuntime
 * Request handler is only called when data store can't resolve request, i.e. for custom requests.
 * @param Base - base class, inherits from FluidDataStoreRuntime
 * @param requestHandler - request handler to mix in
 */
const mixinRequestHandler = (requestHandler, Base = FluidDataStoreRuntime) => class RuntimeWithRequestHandler extends Base {
    async request(request) {
        const response = await super.request(request);
        if (response.status === 404) {
            return requestHandler(request, this);
        }
        return response;
    }
};
/**
 * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.
 * @param handler - handler that returns info about blob to be added to summary.
 * Or undefined not to add anything to summary.
 * @param Base - base class, inherits from FluidDataStoreRuntime
 */
const mixinSummaryHandler = (handler, Base = FluidDataStoreRuntime) => class RuntimeWithSummarizerHandler extends Base {
    addBlob(summary, path, content) {
        const firstName = path.shift();
        if (firstName === undefined) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_17__.LoggingError("Path can't be empty");
        }
        let blob = {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.SummaryType.Blob,
            content,
        };
        summary.stats.blobNodeCount++;
        summary.stats.totalBlobSize += content.length;
        for (const name of path.reverse()) {
            blob = {
                type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_18__.SummaryType.Tree,
                tree: { [name]: blob },
            };
            summary.stats.treeNodeCount++;
        }
        summary.summary.tree[firstName] = blob;
    }
    async summarize(...args) {
        const summary = await super.summarize(...args);
        const content = await handler(this);
        if (content !== undefined) {
            this.addBlob(summary, content.path, content.content);
        }
        return summary;
    }
};
//# sourceMappingURL=dataStoreRuntime.js.map

/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalChannelContext": () => (/* binding */ LocalChannelContext),
/* harmony export */   "LocalChannelContextBase": () => (/* binding */ LocalChannelContextBase),
/* harmony export */   "RehydratedLocalChannelContext": () => (/* binding */ RehydratedLocalChannelContext)
/* harmony export */ });
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(158);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(270);
/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(266);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
// eslint-disable-next-line import/no-internal-modules





/**
 * Channel context for a locally created channel
 */
class LocalChannelContextBase {
    constructor(id, registry, runtime, servicesGetter) {
        this.id = id;
        this.registry = registry;
        this.runtime = runtime;
        this.servicesGetter = servicesGetter;
        this.globallyVisible = false;
        this.pending = [];
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.id.includes("/"), 0x30f /* Channel context ID cannot contain slashes */);
    }
    async getChannel() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.channel !== undefined, 0x207 /* "Channel should be defined" */);
        return this.channel;
    }
    get isLoaded() {
        return this.channel !== undefined;
    }
    setConnectionState(connected, clientId) {
        // Connection events are ignored if the data store is not yet globallyVisible or loaded
        if (this.globallyVisible && this.isLoaded) {
            this.servicesGetter().value.deltaConnection.setConnectionState(connected);
        }
    }
    processOp(message, local, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.globallyVisible, 0x2d3 /* "Local channel must be globally visible when processing op" */);
        // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of
        // delay loading. So after the container is attached and some other client joins which start generating
        // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.
        if (this.isLoaded) {
            this.servicesGetter().value.deltaConnection.process(message, local, localOpMetadata);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(local === false, 0x189 /* "Should always be remote because a local dds shouldn't generate ops before loading" */);
            this.pending.push(message);
        }
    }
    reSubmit(content, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded, 0x18a /* "Channel should be loaded to resubmit ops" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.globallyVisible, 0x2d4 /* "Local channel must be globally visible when resubmitting op" */);
        this.servicesGetter().value.deltaConnection.reSubmit(content, localOpMetadata);
    }
    rollback(content, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded, 0x2ee /* "Channel should be loaded to rollback ops" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.globallyVisible, 0x2ef /* "Local channel must be globally visible when rolling back op" */);
        this.servicesGetter().value.deltaConnection.rollback(content, localOpMetadata);
    }
    applyStashedOp() {
        throw new Error("no stashed ops on local channel");
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = false, telemetryContext) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded && this.channel !== undefined, 0x18c /* "Channel should be loaded to summarize" */);
        return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannelAsync)(this.channel, fullTree, trackState, telemetryContext);
    }
    getAttachSummary(telemetryContext) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded && this.channel !== undefined, 0x18d /* "Channel should be loaded to take snapshot" */);
        return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannel)(this.channel, true /* fullTree */, false /* trackState */, telemetryContext);
    }
    makeVisible() {
        if (this.globallyVisible) {
            throw new Error("Channel is already globally visible");
        }
        if (this.isLoaded) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!!this.channel, 0x192 /* "Channel should be there if loaded!!" */);
            this.channel.connect(this.servicesGetter().value);
        }
        this.globallyVisible = true;
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.
     * Each node has a set of outbound routes to other GC nodes in the document. This should be called only after
     * the context has loaded.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.isLoaded && this.channel !== undefined, 0x193 /* "Channel should be loaded to run GC" */);
        return this.channel.getGCData(fullGC);
    }
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        /**
         * Currently, DDSes are always considered referenced and are not garbage collected.
         * Once we have GC at DDS level, this channel context's used routes will be updated as per the passed
         * value. See - https://github.com/microsoft/FluidFramework/issues/4611
         */
    }
}
class RehydratedLocalChannelContext extends LocalChannelContextBase {
    constructor(id, registry, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn, snapshotTree) {
        super(id, registry, runtime, () => this.services);
        this.snapshotTree = snapshotTree;
        const blobMap = new Map();
        const clonedSnapshotTree = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(this.snapshotTree);
        // 0.47 back-compat Need to sanitize if snapshotTree.blobs still contains blob contents too.
        // This is for older snapshot which is generated by loader <=0.47 version which still contains
        // the contents within blobs. After a couple of revisions we can remove it.
        if (this.isSnapshotInOldFormatAndCollectBlobs(clonedSnapshotTree, blobMap)) {
            this.sanitizeSnapshot(clonedSnapshotTree);
        }
        this.services = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Lazy(() => {
            return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger, clonedSnapshotTree, blobMap);
        });
        this.dirtyFn = () => { dirtyFn(id); };
    }
    async getChannel() {
        if (this.channel === undefined) {
            this.channel = await this.loadChannel()
                .catch((err) => {
                throw _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.DataProcessingError.wrapIfUnrecognized(err, "rehydratedLocalChannelContextFailedToLoadChannel", undefined);
            });
        }
        return this.channel;
    }
    async loadChannel() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.isLoaded, 0x18e /* "Channel must not already be loaded when loading" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(await this.services.value.objectStorage.contains(".attributes"), 0x190 /* ".attributes blob should be present" */);
        const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.readAndParse)(this.services.value.objectStorage, ".attributes");
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.factory === undefined, 0x208 /* "Factory should be undefined before loading" */);
        this.factory = this.registry.get(attributes.type);
        if (this.factory === undefined) {
            throw new Error(`Channel Factory ${attributes.type} not registered`);
        }
        // Services will be assigned during this load.
        const channel = await this.factory.load(this.runtime, this.id, this.services.value, attributes);
        // Commit changes.
        this.channel = channel;
        // Send all pending messages to the channel
        for (const message of this.pending) {
            this.services.value.deltaConnection.process(message, false, undefined /* localOpMetadata */);
        }
        return this.channel;
    }
    isSnapshotInOldFormatAndCollectBlobs(snapshotTree, blobMap) {
        let sanitize = false;
        const blobsContents = snapshotTree.blobsContents;
        Object.entries(blobsContents).forEach(([key, value]) => {
            blobMap.set(key, value);
            if (snapshotTree.blobs[key] !== undefined) {
                sanitize = true;
            }
        });
        for (const value of Object.values(snapshotTree.trees)) {
            sanitize = sanitize || this.isSnapshotInOldFormatAndCollectBlobs(value, blobMap);
        }
        return sanitize;
    }
    sanitizeSnapshot(snapshotTree) {
        const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));
        for (const [blobName, blobId] of blobMapInitial.entries()) {
            const blobValue = blobMapInitial.get(blobId);
            if (blobValue === undefined) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete snapshotTree.blobs[blobName];
            }
        }
        for (const value of Object.values(snapshotTree.trees)) {
            this.sanitizeSnapshot(value);
        }
    }
}
class LocalChannelContext extends LocalChannelContextBase {
    constructor(id, registry, type, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn) {
        super(id, registry, runtime, () => this.services);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(type !== undefined, 0x209 /* "Factory Type should be defined" */);
        this.factory = registry.get(type);
        if (this.factory === undefined) {
            throw new Error(`Channel Factory ${type} not registered`);
        }
        this.channel = this.factory.create(runtime, id);
        this.services = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Lazy(() => {
            return (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger);
        });
        this.dirtyFn = () => { dirtyFn(id); };
    }
}
//# sourceMappingURL=localChannelContext.js.map

/***/ }),
/* 158 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(159);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 159 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(160),
    arrayEach = __webpack_require__(204),
    assignValue = __webpack_require__(205),
    baseAssign = __webpack_require__(208),
    baseAssignIn = __webpack_require__(230),
    cloneBuffer = __webpack_require__(234),
    copyArray = __webpack_require__(235),
    copySymbols = __webpack_require__(236),
    copySymbolsIn = __webpack_require__(240),
    getAllKeys = __webpack_require__(244),
    getAllKeysIn = __webpack_require__(246),
    getTag = __webpack_require__(247),
    initCloneArray = __webpack_require__(252),
    initCloneByTag = __webpack_require__(253),
    initCloneObject = __webpack_require__(260),
    isArray = __webpack_require__(216),
    isBuffer = __webpack_require__(217),
    isMap = __webpack_require__(262),
    isObject = __webpack_require__(184),
    isSet = __webpack_require__(264),
    keys = __webpack_require__(210),
    keysIn = __webpack_require__(231);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 160 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(161),
    stackClear = __webpack_require__(169),
    stackDelete = __webpack_require__(170),
    stackGet = __webpack_require__(171),
    stackHas = __webpack_require__(172),
    stackSet = __webpack_require__(173);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 161 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(162),
    listCacheDelete = __webpack_require__(163),
    listCacheGet = __webpack_require__(166),
    listCacheHas = __webpack_require__(167),
    listCacheSet = __webpack_require__(168);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 162 */
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 163 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(164);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 164 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(165);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 165 */
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 166 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(164);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 167 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(164);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 168 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(164);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 169 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(161);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 170 */
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 171 */
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 172 */
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 173 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(161),
    Map = __webpack_require__(174),
    MapCache = __webpack_require__(189);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 174 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175),
    root = __webpack_require__(180);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 175 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(176),
    getValue = __webpack_require__(188);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 176 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(177),
    isMasked = __webpack_require__(185),
    isObject = __webpack_require__(184),
    toSource = __webpack_require__(187);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 177 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(178),
    isObject = __webpack_require__(184);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 178 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(179),
    getRawTag = __webpack_require__(182),
    objectToString = __webpack_require__(183);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 179 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(180);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 180 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(181);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 181 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),
/* 182 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(179);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 183 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 184 */
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 185 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(186);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 186 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(180);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 187 */
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 188 */
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 189 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(190),
    mapCacheDelete = __webpack_require__(198),
    mapCacheGet = __webpack_require__(201),
    mapCacheHas = __webpack_require__(202),
    mapCacheSet = __webpack_require__(203);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 190 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(191),
    ListCache = __webpack_require__(161),
    Map = __webpack_require__(174);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 191 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(192),
    hashDelete = __webpack_require__(194),
    hashGet = __webpack_require__(195),
    hashHas = __webpack_require__(196),
    hashSet = __webpack_require__(197);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 192 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(193);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 193 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 194 */
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 195 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(193);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 196 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(193);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 197 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(193);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 198 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(199);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 199 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(200);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 200 */
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 201 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(199);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(199);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 203 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(199);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 204 */
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 205 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(206),
    eq = __webpack_require__(165);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 206 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(207);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 207 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(209),
    keys = __webpack_require__(210);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 209 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(205),
    baseAssignValue = __webpack_require__(206);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 210 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(211),
    baseKeys = __webpack_require__(225),
    isArrayLike = __webpack_require__(229);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 211 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(212),
    isArguments = __webpack_require__(213),
    isArray = __webpack_require__(216),
    isBuffer = __webpack_require__(217),
    isIndex = __webpack_require__(219),
    isTypedArray = __webpack_require__(220);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 212 */
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 213 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(214),
    isObjectLike = __webpack_require__(215);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 214 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(178),
    isObjectLike = __webpack_require__(215);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 215 */
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 216 */
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 217 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(180),
    stubFalse = __webpack_require__(218);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),
/* 218 */
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 219 */
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 220 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(221),
    baseUnary = __webpack_require__(223),
    nodeUtil = __webpack_require__(224);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 221 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(178),
    isLength = __webpack_require__(222),
    isObjectLike = __webpack_require__(215);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 222 */
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 223 */
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 224 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(181);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),
/* 225 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(226),
    nativeKeys = __webpack_require__(227);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 226 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 227 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(228);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 228 */
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 229 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(177),
    isLength = __webpack_require__(222);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 230 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(209),
    keysIn = __webpack_require__(231);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 231 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(211),
    baseKeysIn = __webpack_require__(232),
    isArrayLike = __webpack_require__(229);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 232 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(184),
    isPrototype = __webpack_require__(226),
    nativeKeysIn = __webpack_require__(233);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 233 */
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 234 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(180);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),
/* 235 */
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 236 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(209),
    getSymbols = __webpack_require__(237);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 237 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(238),
    stubArray = __webpack_require__(239);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 238 */
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 239 */
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 240 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(209),
    getSymbolsIn = __webpack_require__(241);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 241 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(242),
    getPrototype = __webpack_require__(243),
    getSymbols = __webpack_require__(237),
    stubArray = __webpack_require__(239);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 242 */
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 243 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(228);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 244 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(245),
    getSymbols = __webpack_require__(237),
    keys = __webpack_require__(210);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 245 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(242),
    isArray = __webpack_require__(216);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 246 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(245),
    getSymbolsIn = __webpack_require__(241),
    keysIn = __webpack_require__(231);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 247 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(248),
    Map = __webpack_require__(174),
    Promise = __webpack_require__(249),
    Set = __webpack_require__(250),
    WeakMap = __webpack_require__(251),
    baseGetTag = __webpack_require__(178),
    toSource = __webpack_require__(187);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 248 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175),
    root = __webpack_require__(180);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 249 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175),
    root = __webpack_require__(180);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 250 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175),
    root = __webpack_require__(180);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 251 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(175),
    root = __webpack_require__(180);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 252 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 253 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(254),
    cloneDataView = __webpack_require__(256),
    cloneRegExp = __webpack_require__(257),
    cloneSymbol = __webpack_require__(258),
    cloneTypedArray = __webpack_require__(259);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 254 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(255);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 255 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(180);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 256 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(254);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 257 */
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 258 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(179);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 259 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(254);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 260 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(261),
    getPrototype = __webpack_require__(243),
    isPrototype = __webpack_require__(226);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 261 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(184);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 262 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(263),
    baseUnary = __webpack_require__(223),
    nodeUtil = __webpack_require__(224);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 263 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(247),
    isObjectLike = __webpack_require__(215);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 264 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(265),
    baseUnary = __webpack_require__(223),
    nodeUtil = __webpack_require__(224);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 265 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(247),
    isObjectLike = __webpack_require__(215);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 266 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attributesBlobKey": () => (/* binding */ attributesBlobKey),
/* harmony export */   "createServiceEndpoints": () => (/* binding */ createServiceEndpoints),
/* harmony export */   "summarizeChannel": () => (/* binding */ summarizeChannel),
/* harmony export */   "summarizeChannelAsync": () => (/* binding */ summarizeChannelAsync)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _channelDeltaConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(267);
/* harmony import */ var _channelStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



const attributesBlobKey = ".attributes";
function createServiceEndpoints(id, connected, submitFn, dirtyFn, addedGCOutboundReferenceFn, storageService, logger, tree, extraBlobs) {
    const deltaConnection = new _channelDeltaConnection__WEBPACK_IMPORTED_MODULE_0__.ChannelDeltaConnection(id, connected, (message, localOpMetadata) => submitFn(message, localOpMetadata), dirtyFn, addedGCOutboundReferenceFn);
    const objectStorage = new _channelStorageService__WEBPACK_IMPORTED_MODULE_1__.ChannelStorageService(tree, storageService, logger, extraBlobs);
    return {
        deltaConnection,
        objectStorage,
    };
}
function summarizeChannel(channel, fullTree = false, trackState = false, telemetryContext) {
    const summarizeResult = channel.getAttachSummary(fullTree, trackState, telemetryContext);
    // Add the channel attributes to the returned result.
    (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.addBlobToSummary)(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));
    return summarizeResult;
}
async function summarizeChannelAsync(channel, fullTree = false, trackState = false, telemetryContext) {
    const summarizeResult = await channel.summarize(fullTree, trackState, telemetryContext);
    // Add the channel attributes to the returned result.
    (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_2__.addBlobToSummary)(summarizeResult, attributesBlobKey, JSON.stringify(channel.attributes));
    return summarizeResult;
}
//# sourceMappingURL=channelContext.js.map

/***/ }),
/* 267 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelDeltaConnection": () => (/* binding */ ChannelDeltaConnection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(156);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


class ChannelDeltaConnection {
    constructor(objectId, _connected, submit, dirty, addedGCOutboundReference) {
        this.objectId = objectId;
        this._connected = _connected;
        this.submit = submit;
        this.dirty = dirty;
        this.addedGCOutboundReference = addedGCOutboundReference;
    }
    get handler() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this._handler, 0x177 /* "Missing delta handler" */);
        return this._handler;
    }
    get connected() {
        return this._connected;
    }
    attach(handler) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this._handler === undefined, 0x178 /* "Missing delta handler on attach" */);
        this._handler = handler;
    }
    setConnectionState(connected) {
        this._connected = connected;
        this.handler.setConnectionState(connected);
    }
    process(message, local, localOpMetadata) {
        try {
            // catches as data processing error whether or not they come from async pending queues
            this.handler.process(message, local, localOpMetadata);
        }
        catch (error) {
            throw _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataProcessingError.wrapIfUnrecognized(error, "channelDeltaConnectionFailedToProcessMessage", message);
        }
    }
    reSubmit(content, localOpMetadata) {
        this.handler.reSubmit(content, localOpMetadata);
    }
    rollback(content, localOpMetadata) {
        if (this.handler.rollback === undefined) {
            throw new Error("Handler doesn't support rollback");
        }
        this.handler.rollback(content, localOpMetadata);
    }
    applyStashedOp(message) {
        return this.handler.applyStashedOp(message);
    }
}
//# sourceMappingURL=channelDeltaConnection.js.map

/***/ }),
/* 268 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelStorageService": () => (/* binding */ ChannelStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class ChannelStorageService {
    constructor(tree, storage, logger, extraBlobs) {
        this.tree = tree;
        this.storage = storage;
        this.logger = logger;
        this.extraBlobs = extraBlobs;
        this.flattenedTree = {};
        // Create a map from paths to blobs
        if (tree !== undefined) {
            ChannelStorageService.flattenTree("", tree, this.flattenedTree);
        }
    }
    static flattenTree(base, tree, results) {
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const path in tree.trees) {
            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);
        }
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const blob in tree.blobs) {
            results[`${base}${blob}`] = tree.blobs[blob];
        }
    }
    async contains(path) {
        return this.flattenedTree[path] !== undefined;
    }
    async readBlob(path) {
        const id = await this.getIdForPath(path);
        const blob = this.extraBlobs !== undefined
            ? this.extraBlobs.get(id)
            : undefined;
        if (blob !== undefined) {
            return blob;
        }
        const blobP = this.storage.readBlob(id);
        blobP.catch((error) => this.logger.sendErrorEvent({ eventName: "ChannelStorageBlobError" }, error));
        return blobP;
    }
    async list(path) {
        var _a;
        let tree = this.tree;
        const pathParts = (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_0__.getNormalizedObjectStoragePathParts)(path);
        while (tree !== undefined && pathParts.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const part = pathParts.shift();
            tree = tree.trees[part];
        }
        if (tree === undefined || pathParts.length !== 0) {
            throw new Error("path does not exist");
        }
        return Object.keys((_a = tree === null || tree === void 0 ? void 0 : tree.blobs) !== null && _a !== void 0 ? _a : {});
    }
    async getIdForPath(path) {
        return this.flattenedTree[path];
    }
}
//# sourceMappingURL=channelStorageService.js.map

/***/ }),
/* 269 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNormalizedObjectStoragePathParts": () => (/* binding */ getNormalizedObjectStoragePathParts),
/* harmony export */   "listBlobsAtTreePath": () => (/* binding */ listBlobsAtTreePath)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
function getNormalizedObjectStoragePathParts(path) {
    let normalizePath = path;
    if (normalizePath.startsWith("/")) {
        normalizePath = normalizePath.substr(1);
    }
    if (normalizePath.endsWith("/")) {
        normalizePath = normalizePath.substr(0, normalizePath.length - 1);
    }
    if (normalizePath.length > 0) {
        return normalizePath.split("/");
    }
    return [];
}
async function listBlobsAtTreePath(inputTree, path) {
    const pathParts = getNormalizedObjectStoragePathParts(path);
    let tree = inputTree;
    while ((tree === null || tree === void 0 ? void 0 : tree.entries) !== undefined && pathParts.length > 0) {
        const part = pathParts.shift();
        const treeEntry = tree.entries.find((value) => {
            if (value.type === "Tree" && value.path === part) {
                return true;
            }
            else {
                return false;
            }
        });
        // this check is largely superfluous due to the same check being done
        // immediately above. the type system, however, is not aware of this.
        // so we must redundantly determine that the entry's type is "Tree"
        if ((treeEntry === null || treeEntry === void 0 ? void 0 : treeEntry.type) === "Tree") {
            tree = treeEntry.value;
        }
        else {
            tree = undefined;
        }
    }
    if ((tree === null || tree === void 0 ? void 0 : tree.entries) === undefined || pathParts.length !== 0) {
        throw new Error("path does not exist");
    }
    return tree.entries.filter((e) => e.type === "Blob").map((e) => e.path);
}
//# sourceMappingURL=objectstorageutils.js.map

/***/ }),
/* 270 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lazy": () => (/* binding */ Lazy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable
  */
class Lazy {
    /**
     * Instantiates an instance of Lazy<T>
     * @param valueGenerator - the function that will generate the value when value is accessed the first time
     */
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this._evaluated = false;
    }
    /**
     * Return true if the value as been generated, otherwise false
     */
    get evaluated() {
        return this._evaluated;
    }
    /**
     * Get the value. If this is the first call the value will be generated
     */
    get value() {
        if (!this._evaluated) {
            this._evaluated = true;
            this._value = this.valueGenerator();
        }
        return this._value;
    }
}
//# sourceMappingURL=lazy.js.map

/***/ }),
/* 271 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoteChannelContext": () => (/* binding */ RemoteChannelContext)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(156);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);
/* harmony import */ var _channelContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(266);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





class RemoteChannelContext {
    constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, addedGCOutboundReferenceFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, getBaseGCDetails, attachMessageType) {
        this.runtime = runtime;
        this.dataStoreContext = dataStoreContext;
        this.id = id;
        this.registry = registry;
        this.attachMessageType = attachMessageType;
        this.isLoaded = false;
        this.pending = [];
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.id.includes("/"), 0x310 /* Channel context ID cannot contain slashes */);
        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(this.runtime.logger, "RemoteChannelContext");
        this.services = (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.createServiceEndpoints)(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), addedGCOutboundReferenceFn, storageService, this.subLogger, baseSnapshot, extraBlobs);
        const thisSummarizeInternal = async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext);
        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => getBaseGCDetails());
        this.thresholdOpsCounter = new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ThresholdCounter(RemoteChannelContext.pendingOpsCountThreshold, this.subLogger);
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    getChannel() {
        if (this.channelP === undefined) {
            this.channelP = this.loadChannel();
        }
        return this.channelP;
    }
    setConnectionState(connected, clientId) {
        // Connection events are ignored if the data store is not yet loaded
        if (!this.isLoaded) {
            return;
        }
        this.services.deltaConnection.setConnectionState(connected);
    }
    applyStashedOp(message) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLoaded, 0x194 /* "Remote channel must be loaded when rebasing op" */);
        return this.services.deltaConnection.applyStashedOp(message);
    }
    processOp(message, local, localOpMetadata) {
        this.summarizerNode.invalidate(message.sequenceNumber);
        if (this.isLoaded) {
            this.services.deltaConnection.process(message, local, localOpMetadata);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!local, 0x195 /* "Remote channel must not be local when processing op" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pending !== undefined, 0x23e /* "pending is undefined" */);
            this.pending.push(message);
            this.thresholdOpsCounter.sendIfMultiple("StorePendingOps", this.pending.length);
        }
    }
    reSubmit(content, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLoaded, 0x196 /* "Remote channel must be loaded when resubmitting op" */);
        this.services.deltaConnection.reSubmit(content, localOpMetadata);
    }
    rollback(content, localOpMetadata) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLoaded, 0x2f0 /* "Remote channel must be loaded when rolling back op" */);
        this.services.deltaConnection.rollback(content, localOpMetadata);
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = true, telemetryContext) {
        return this.summarizerNode.summarize(fullTree, trackState, telemetryContext);
    }
    async summarizeInternal(fullTree, trackState, telemetryContext) {
        const channel = await this.getChannel();
        const summarizeResult = await (0,_channelContext__WEBPACK_IMPORTED_MODULE_2__.summarizeChannelAsync)(channel, fullTree, trackState, telemetryContext);
        return Object.assign(Object.assign({}, summarizeResult), { id: this.id });
    }
    async loadChannel() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.isLoaded, 0x197 /* "Remote channel must not already be loaded when loading" */);
        let attributes;
        if (await this.services.objectStorage.contains(_channelContext__WEBPACK_IMPORTED_MODULE_2__.attributesBlobKey)) {
            attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.readAndParse)(this.services.objectStorage, _channelContext__WEBPACK_IMPORTED_MODULE_2__.attributesBlobKey);
        }
        let factory;
        // this is a backward compatibility case where
        // the attach message doesn't include
        // the attributes. Since old attach messages
        // will not have attributes we need to keep
        // this as long as we support old attach messages
        if (attributes === undefined) {
            if (this.attachMessageType === undefined) {
                // TODO: dataStoreId may require a different tag from PackageData #7488
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.DataCorruptionError("channelTypeNotAvailable", {
                    channelId: {
                        value: this.id,
                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                    },
                    dataStoreId: {
                        value: this.dataStoreContext.id,
                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                    },
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                });
            }
            factory = this.registry.get(this.attachMessageType);
            if (factory === undefined) {
                // TODO: dataStoreId may require a different tag from PackageData #7488
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.DataCorruptionError("channelFactoryNotRegisteredForAttachMessageType", {
                    channelId: {
                        value: this.id,
                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                    },
                    dataStoreId: {
                        value: this.dataStoreContext.id,
                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                    },
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                    channelFactoryType: this.attachMessageType,
                });
            }
            attributes = factory.attributes;
        }
        else {
            factory = this.registry.get(attributes.type);
            if (factory === undefined) {
                // TODO: dataStoreId may require a different tag from PackageData #7488
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_5__.DataCorruptionError("channelFactoryNotRegisteredForGivenType", {
                    channelId: {
                        value: this.id,
                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                    },
                    dataStoreId: {
                        value: this.dataStoreContext.id,
                        tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                    },
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                    channelFactoryType: attributes.type,
                });
            }
        }
        // Compare snapshot version to collaborative object version
        if (attributes.snapshotFormatVersion !== undefined
            && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {
            this.subLogger.sendTelemetryEvent({
                eventName: "ChannelAttributesVersionMismatch",
                channelType: { value: attributes.type, tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData },
                channelSnapshotVersion: {
                    value: `${attributes.snapshotFormatVersion}@${attributes.packageVersion}`,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                },
                channelCodeVersion: {
                    value: `${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`,
                    tag: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryDataTag.PackageData,
                },
            });
        }
        const channel = await factory.load(this.runtime, this.id, this.services, attributes);
        // Send all pending messages to the channel
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pending !== undefined, 0x23f /* "pending undefined" */);
        for (const message of this.pending) {
            this.services.deltaConnection.process(message, false, undefined /* localOpMetadata */);
        }
        this.thresholdOpsCounter.send("ProcessPendingOps", this.pending.length);
        // Commit changes.
        this.channel = channel;
        this.pending = undefined;
        this.isLoaded = true;
        // Because have some await between we created the service and here, the connection state might have changed
        // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.
        this.services.deltaConnection.setConnectionState(this.dataStoreContext.connected);
        return this.channel;
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.
     * Each node has a set of outbound routes to other GC nodes in the document.
     * If there is no new data in this context since the last summary, previous GC data is used.
     * If there is new data, the GC data is generated again (by calling getGCDataInternal).
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        return this.summarizerNode.getGCData(fullGC);
    }
    /**
     * Generates the data used for garbage collection. This is called when there is new data since last summary. It
     * loads the context and calls into the channel to get its GC data.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCDataInternal(fullGC = false) {
        const channel = await this.getChannel();
        return channel.getGCData(fullGC);
    }
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        /**
         * Currently, DDSes are always considered referenced and are not garbage collected. Update the summarizer node's
         * used routes to contain a route to this channel context.
         * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -
         * https://github.com/microsoft/FluidFramework/issues/4611
         */
        this.summarizerNode.updateUsedRoutes([""]);
    }
}
RemoteChannelContext.pendingOpsCountThreshold = 1000;
//# sourceMappingURL=remoteChannelContext.js.map

/***/ }),
/* 272 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 273 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 274 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceAudience": () => (/* binding */ ServiceAudience)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Base class for providing audience information for sessions interacting with FluidContainer
 * This can be extended by different service-specific client packages to additional parameters to
 * the user and client details returned in IMember
 * @typeParam M - A service-specific member type.
 */
class ServiceAudience extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(
    /**
     * Fluid Container to read the audience from.
     */
    container) {
        super();
        this.container = container;
        /**
         * Retain the most recent member list.  This is so we have more information about a member
         * leaving the audience in the removeMember event.  It allows us to match the behavior of the
         * addMember event where it only fires on a change to the members this class exposes (and would
         * actually produce a change in what getMembers returns).  It also allows us to provide the
         * client details in the event which makes it easier to find that client connection in a map
         * keyed on the userId and not clientId.
         * This map will always be up-to-date in a removeMember event because it is set once at
         * construction and in every addMember event.
         * It is mapped clientId to M to be better work with what the IAudience event provides
         */
        this.lastMembers = new Map();
        this.audience = container.audience;
        // getMembers will assign lastMembers so the removeMember event has what it needs
        // in case it would fire before getMembers otherwise gets called the first time
        this.getMembers();
        this.audience.on("addMember", (clientId, details) => {
            if (this.shouldIncludeAsMember(details)) {
                const member = this.getMember(clientId);
                this.emit("memberAdded", clientId, member);
                this.emit("membersChanged");
            }
        });
        this.audience.on("removeMember", (clientId) => {
            if (this.lastMembers.has(clientId)) {
                this.emit("memberRemoved", clientId, this.lastMembers.get(clientId));
                this.emit("membersChanged");
            }
        });
        this.container.on("connected", () => this.emit("membersChanged"));
    }
    /**
     * {@inheritDoc IServiceAudience.getMembers}
     */
    getMembers() {
        const users = new Map();
        const clientMemberMap = new Map();
        // Iterate through the members and get the user specifics.
        this.audience.getMembers().forEach((member, clientId) => {
            if (this.shouldIncludeAsMember(member)) {
                const userId = member.user.id;
                // Ensure we're tracking the user
                let user = users.get(userId);
                if (user === undefined) {
                    user = this.createServiceMember(member);
                    users.set(userId, user);
                }
                // Add this connection to their collection
                user.connections.push({ id: clientId, mode: member.mode });
                clientMemberMap.set(clientId, user);
            }
        });
        this.lastMembers = clientMemberMap;
        return users;
    }
    /**
     * {@inheritDoc IServiceAudience.getMyself}
     */
    getMyself() {
        const clientId = this.container.clientId;
        if (clientId === undefined) {
            return undefined;
        }
        return this.getMember(clientId);
    }
    getMember(clientId) {
        // Fetch the user ID assoicated with this client ID from the runtime
        const internalAudienceMember = this.audience.getMember(clientId);
        if (internalAudienceMember === undefined) {
            return undefined;
        }
        // Return the member object with any other clients associated for this user
        const allMembers = this.getMembers();
        const member = allMembers.get(internalAudienceMember === null || internalAudienceMember === void 0 ? void 0 : internalAudienceMember.user.id);
        if (member === undefined) {
            throw Error(`Attempted to fetch client ${clientId} that is not part of the current member list`);
        }
        return member;
    }
    /**
     * Provides ability for the inheriting class to include/omit specific members.
     * An example use case is omitting the summarizer client.
     * @param member - Member to be included/omitted.
     */
    shouldIncludeAsMember(member) {
        // Include only human members
        return member.details.capabilities.interactive;
    }
}
//# sourceMappingURL=serviceAudience.js.map

/***/ }),
/* 275 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectoryFactory": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.DirectoryFactory),
/* harmony export */   "LocalValueMaker": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.LocalValueMaker),
/* harmony export */   "MapFactory": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.MapFactory),
/* harmony export */   "SharedDirectory": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.SharedDirectory),
/* harmony export */   "SharedMap": () => (/* reexport safe */ _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__.SharedMap)
/* harmony export */ });
/* harmony import */ var _fluidframework_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(276);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

//# sourceMappingURL=map.js.map

/***/ }),
/* 276 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectoryFactory": () => (/* reexport safe */ _directory__WEBPACK_IMPORTED_MODULE_1__.DirectoryFactory),
/* harmony export */   "LocalValueMaker": () => (/* reexport safe */ _localValues__WEBPACK_IMPORTED_MODULE_2__.LocalValueMaker),
/* harmony export */   "MapFactory": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_0__.MapFactory),
/* harmony export */   "SharedDirectory": () => (/* reexport safe */ _directory__WEBPACK_IMPORTED_MODULE_1__.SharedDirectory),
/* harmony export */   "SharedMap": () => (/* reexport safe */ _map__WEBPACK_IMPORTED_MODULE_0__.SharedMap)
/* harmony export */ });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(142);
/* harmony import */ var _directory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * The `map` package provides interfaces and implementing classes for map-like distributed data structures.
 *
 * @remarks The following distributed data structures are defined in this package:
 *
 * - {@link SharedMap}
 *
 * - {@link SharedDirectory}
 *
 * @packageDocumentation
 */




//# sourceMappingURL=index.js.map

/***/ }),
/* 277 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interval": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.Interval),
/* harmony export */   "IntervalCollection": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.IntervalCollection),
/* harmony export */   "IntervalCollectionIterator": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.IntervalCollectionIterator),
/* harmony export */   "IntervalType": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.IntervalType),
/* harmony export */   "PaddingSegment": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.PaddingSegment),
/* harmony export */   "RunSegment": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.RunSegment),
/* harmony export */   "SequenceDeltaEvent": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceDeltaEvent),
/* harmony export */   "SequenceEvent": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceEvent),
/* harmony export */   "SequenceInterval": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceInterval),
/* harmony export */   "SequenceMaintenanceEvent": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SequenceMaintenanceEvent),
/* harmony export */   "SharedIntervalCollection": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedIntervalCollection),
/* harmony export */   "SharedIntervalCollectionFactory": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedIntervalCollectionFactory),
/* harmony export */   "SharedNumberSequence": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedNumberSequence),
/* harmony export */   "SharedNumberSequenceFactory": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedNumberSequenceFactory),
/* harmony export */   "SharedObjectSequence": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedObjectSequence),
/* harmony export */   "SharedObjectSequenceFactory": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedObjectSequenceFactory),
/* harmony export */   "SharedSegmentSequence": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSegmentSequence),
/* harmony export */   "SharedSequence": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence),
/* harmony export */   "SharedString": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedString),
/* harmony export */   "SharedStringFactory": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SharedStringFactory),
/* harmony export */   "SparseMatrix": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SparseMatrix),
/* harmony export */   "SparseMatrixFactory": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SparseMatrixFactory),
/* harmony export */   "SubSequence": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.SubSequence),
/* harmony export */   "maxCellPosition": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxCellPosition),
/* harmony export */   "maxCol": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxCol),
/* harmony export */   "maxCols": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxCols),
/* harmony export */   "maxRow": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxRow),
/* harmony export */   "maxRows": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.maxRows),
/* harmony export */   "positionToRowCol": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.positionToRowCol),
/* harmony export */   "rowColToPosition": () => (/* reexport safe */ _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__.rowColToPosition)
/* harmony export */ });
/* harmony import */ var _fluidframework_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(278);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

//# sourceMappingURL=sequence.js.map

/***/ }),
/* 278 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interval": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.Interval),
/* harmony export */   "IntervalCollection": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.IntervalCollection),
/* harmony export */   "IntervalCollectionIterator": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.IntervalCollectionIterator),
/* harmony export */   "IntervalType": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.IntervalType),
/* harmony export */   "PaddingSegment": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.PaddingSegment),
/* harmony export */   "RunSegment": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.RunSegment),
/* harmony export */   "SequenceDeltaEvent": () => (/* reexport safe */ _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceDeltaEvent),
/* harmony export */   "SequenceEvent": () => (/* reexport safe */ _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceEvent),
/* harmony export */   "SequenceInterval": () => (/* reexport safe */ _intervalCollection__WEBPACK_IMPORTED_MODULE_0__.SequenceInterval),
/* harmony export */   "SequenceMaintenanceEvent": () => (/* reexport safe */ _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceMaintenanceEvent),
/* harmony export */   "SharedIntervalCollection": () => (/* reexport safe */ _sharedIntervalCollection__WEBPACK_IMPORTED_MODULE_9__.SharedIntervalCollection),
/* harmony export */   "SharedIntervalCollectionFactory": () => (/* reexport safe */ _sharedIntervalCollection__WEBPACK_IMPORTED_MODULE_9__.SharedIntervalCollectionFactory),
/* harmony export */   "SharedNumberSequence": () => (/* reexport safe */ _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_7__.SharedNumberSequence),
/* harmony export */   "SharedNumberSequenceFactory": () => (/* reexport safe */ _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__.SharedNumberSequenceFactory),
/* harmony export */   "SharedObjectSequence": () => (/* reexport safe */ _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_6__.SharedObjectSequence),
/* harmony export */   "SharedObjectSequenceFactory": () => (/* reexport safe */ _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__.SharedObjectSequenceFactory),
/* harmony export */   "SharedSegmentSequence": () => (/* reexport safe */ _sequence__WEBPACK_IMPORTED_MODULE_2__.SharedSegmentSequence),
/* harmony export */   "SharedSequence": () => (/* reexport safe */ _sharedSequence__WEBPACK_IMPORTED_MODULE_5__.SharedSequence),
/* harmony export */   "SharedString": () => (/* reexport safe */ _sharedString__WEBPACK_IMPORTED_MODULE_1__.SharedString),
/* harmony export */   "SharedStringFactory": () => (/* reexport safe */ _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__.SharedStringFactory),
/* harmony export */   "SparseMatrix": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.SparseMatrix),
/* harmony export */   "SparseMatrixFactory": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.SparseMatrixFactory),
/* harmony export */   "SubSequence": () => (/* reexport safe */ _sharedSequence__WEBPACK_IMPORTED_MODULE_5__.SubSequence),
/* harmony export */   "maxCellPosition": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxCellPosition),
/* harmony export */   "maxCol": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxCol),
/* harmony export */   "maxCols": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxCols),
/* harmony export */   "maxRow": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxRow),
/* harmony export */   "maxRows": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.maxRows),
/* harmony export */   "positionToRowCol": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.positionToRowCol),
/* harmony export */   "rowColToPosition": () => (/* reexport safe */ _sparsematrix__WEBPACK_IMPORTED_MODULE_8__.rowColToPosition)
/* harmony export */ });
/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(279);
/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(290);
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(317);
/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(311);
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(319);
/* harmony import */ var _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(320);
/* harmony import */ var _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(321);
/* harmony import */ var _sparsematrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(322);
/* harmony import */ var _sharedIntervalCollection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(323);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Supports distributed data structures which are list-like.
 *
 * This package's main export is {@link SharedSequence}, a DDS for storing and simultaneously editing a sequence of
 * text.
 *
 * @remarks Note that SharedString is a sequence DDS but it has additional specialized features and behaviors for
 * working with text.
 *
 * @packageDocumentation
 */










//# sourceMappingURL=index.js.map

/***/ }),
/* 279 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interval": () => (/* binding */ Interval),
/* harmony export */   "IntervalCollection": () => (/* binding */ IntervalCollection),
/* harmony export */   "IntervalCollectionIterator": () => (/* binding */ IntervalCollectionIterator),
/* harmony export */   "IntervalCollectionValueType": () => (/* binding */ IntervalCollectionValueType),
/* harmony export */   "IntervalType": () => (/* binding */ IntervalType),
/* harmony export */   "LocalIntervalCollection": () => (/* binding */ LocalIntervalCollection),
/* harmony export */   "SequenceInterval": () => (/* binding */ SequenceInterval),
/* harmony export */   "SequenceIntervalCollectionValueType": () => (/* binding */ SequenceIntervalCollectionValueType),
/* harmony export */   "createIntervalIndex": () => (/* binding */ createIntervalIndex),
/* harmony export */   "defaultIntervalConflictResolver": () => (/* binding */ defaultIntervalConflictResolver)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(288);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(289);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(280);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(282);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(284);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(281);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(286);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(287);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(285);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(26);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(27);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/* eslint-disable no-bitwise */





const reservedIntervalIdKey = "intervalId";
var IntervalType;
(function (IntervalType) {
    IntervalType[IntervalType["Simple"] = 0] = "Simple";
    IntervalType[IntervalType["Nest"] = 1] = "Nest";
    /**
     * SlideOnRemove indicates that the ends of the interval will slide if the segment
     * they reference is removed and acked.
     * See `packages\dds\merge-tree\REFERENCEPOSITIONS.md` for details
     * SlideOnRemove is the default interval behavior and does not need to be specified.
     */
    IntervalType[IntervalType["SlideOnRemove"] = 2] = "SlideOnRemove";
    /**
     * @internal
     * A temporary interval, used internally
     */
    IntervalType[IntervalType["Transient"] = 4] = "Transient";
})(IntervalType || (IntervalType = {}));
/**
 * Decompress an interval after loading a summary from JSON. The exact format
 * of this compression is unspecified and subject to change
 */
function decompressInterval(interval, label) {
    return {
        start: interval[0],
        end: interval[1],
        sequenceNumber: interval[2],
        intervalType: interval[3],
        properties: Object.assign(Object.assign({}, interval[4]), { [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey]: label }),
    };
}
/**
 * Compress an interval prior to serialization as JSON. The exact format of this
 * compression is unspecified and subject to change
 */
function compressInterval(interval) {
    const { start, end, sequenceNumber, intervalType, properties } = interval;
    return [
        start,
        end,
        sequenceNumber,
        intervalType,
        Object.assign(Object.assign({}, properties), { [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey]: undefined }),
    ];
}
class Interval {
    constructor(start, end, props) {
        this.start = start;
        this.end = end;
        this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();
        this.properties = {};
        if (props) {
            this.addProperties(props);
        }
    }
    getIntervalId() {
        var _a;
        const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (id === undefined) {
            return undefined;
        }
        return `${id}`;
    }
    getAdditionalPropertySets() {
        return this.auxProps;
    }
    addPropertySet(props) {
        if (this.auxProps === undefined) {
            this.auxProps = [];
        }
        this.auxProps.push(props);
    }
    serialize(client) {
        let seq = 0;
        if (client) {
            seq = client.getCurrentSeq();
        }
        const serializedInterval = {
            end: this.end,
            intervalType: 0,
            sequenceNumber: seq,
            start: this.start,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new Interval(this.start, this.end, this.properties);
    }
    compare(b) {
        const startResult = this.compareStart(b);
        if (startResult === 0) {
            const endResult = this.compareEnd(b);
            if (endResult === 0) {
                const thisId = this.getIntervalId();
                if (thisId) {
                    const bId = b.getIntervalId();
                    if (bId) {
                        return thisId > bId ? 1 : thisId < bId ? -1 : 0;
                    }
                    return 0;
                }
                return 0;
            }
            else {
                return endResult;
            }
        }
        else {
            return startResult;
        }
    }
    compareStart(b) {
        return this.start - b.start;
    }
    compareEnd(b) {
        return this.end - b.end;
    }
    overlaps(b) {
        const result = (this.start <= b.end) &&
            (this.end >= b.start);
        return result;
    }
    union(b) {
        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);
    }
    getProperties() {
        return this.properties;
    }
    addProperties(newProps, collaborating = false, seq, op) {
        if (newProps) {
            this.initializeProperties();
            return this.propertyManager.addProperties(this.properties, newProps, op, seq, collaborating);
        }
    }
    modify(label, start, end, op) {
        const startPos = start !== null && start !== void 0 ? start : this.start;
        const endPos = end !== null && end !== void 0 ? end : this.end;
        if (this.start === startPos && this.end === endPos) {
            // Return undefined to indicate that no change is necessary.
            return;
        }
        const newInterval = new Interval(startPos, endPos);
        if (this.properties) {
            newInterval.initializeProperties();
            this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);
        }
        return newInterval;
    }
    initializeProperties() {
        if (!this.propertyManager) {
            this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();
        }
        if (!this.properties) {
            this.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.createMap)();
        }
    }
}
class SequenceInterval {
    constructor(start, end, intervalType, props) {
        this.start = start;
        this.end = end;
        this.intervalType = intervalType;
        this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();
        this.properties = {};
        if (props) {
            this.addProperties(props);
        }
    }
    /**
     * @internal
     * Subscribes to position change events on this interval if there are no current listeners.
     */
    addPositionChangeListeners(beforePositionChange, afterPositionChange) {
        var _a, _b;
        var _c, _d;
        if (this.callbacks === undefined) {
            this.callbacks = {
                beforePositionChange,
                afterPositionChange,
            };
            const startCbs = (_a = (_c = this.start).callbacks) !== null && _a !== void 0 ? _a : (_c.callbacks = {});
            const endCbs = (_b = (_d = this.end).callbacks) !== null && _b !== void 0 ? _b : (_d.callbacks = {});
            startCbs.beforeSlide = endCbs.beforeSlide = beforePositionChange;
            startCbs.afterSlide = endCbs.afterSlide = afterPositionChange;
        }
    }
    /**
     * @internal
     * Removes the currently subscribed position change listeners.
     */
    removePositionChangeListeners() {
        if (this.callbacks) {
            this.callbacks = undefined;
            this.start.callbacks = undefined;
            this.end.callbacks = undefined;
        }
    }
    serialize(client) {
        const startPosition = this.start.toPosition();
        const endPosition = this.end.toPosition();
        const serializedInterval = {
            end: endPosition,
            intervalType: this.intervalType,
            sequenceNumber: client.getCurrentSeq(),
            start: startPosition,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new SequenceInterval(this.start, this.end, this.intervalType, this.properties);
    }
    compare(b) {
        const startResult = this.compareStart(b);
        if (startResult === 0) {
            const endResult = this.compareEnd(b);
            if (endResult === 0) {
                const thisId = this.getIntervalId();
                if (thisId) {
                    const bId = b.getIntervalId();
                    if (bId) {
                        return thisId > bId ? 1 : thisId < bId ? -1 : 0;
                    }
                    return 0;
                }
                return 0;
            }
            else {
                return endResult;
            }
        }
        else {
            return startResult;
        }
    }
    compareStart(b) {
        return this.start.compare(b.start);
    }
    compareEnd(b) {
        return this.end.compare(b.end);
    }
    overlaps(b) {
        const result = (this.start.compare(b.end) <= 0) &&
            (this.end.compare(b.start) >= 0);
        return result;
    }
    getIntervalId() {
        var _a;
        const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (id === undefined) {
            return undefined;
        }
        return `${id}`;
    }
    union(b) {
        return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);
    }
    addProperties(newProps, collab = false, seq, op) {
        this.initializeProperties();
        return this.propertyManager.addProperties(this.properties, newProps, op, seq, collab);
    }
    overlapsPos(bstart, bend) {
        const startPos = this.start.toPosition();
        const endPos = this.start.toPosition();
        return (endPos > bstart) && (startPos < bend);
    }
    modify(label, start, end, op) {
        const getRefType = (baseType) => {
            let refType = baseType;
            if (op === undefined) {
                refType &= ~_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;
                refType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;
            }
            return refType;
        };
        let startRef = this.start;
        if (start !== undefined) {
            startRef = createPositionReference(this.start.getClient(), start, getRefType(this.start.refType), op);
            startRef.addProperties(this.start.properties);
        }
        let endRef = this.end;
        if (end !== undefined) {
            endRef = createPositionReference(this.end.getClient(), end, getRefType(this.end.refType), op);
            endRef.addProperties(this.end.properties);
        }
        startRef.pairedRef = endRef;
        endRef.pairedRef = startRef;
        const newInterval = new SequenceInterval(startRef, endRef, this.intervalType);
        if (this.properties) {
            newInterval.initializeProperties();
            this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);
        }
        return newInterval;
    }
    initializeProperties() {
        if (!this.propertyManager) {
            this.propertyManager = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.PropertiesManager();
        }
        if (!this.properties) {
            this.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.createMap)();
        }
    }
}
function createPositionReferenceFromSegoff(client, segoff, refType, op) {
    if (segoff.segment) {
        const ref = client.createLocalReferencePosition(segoff.segment, segoff.offset, refType, undefined);
        return ref;
    }
    else {
        if (!op && !(0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.Transient)) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_4__.UsageError("Non-transient references need segment");
        }
        return new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_5__.LocalReference(client, undefined, 0, refType);
    }
}
function createPositionReference(client, pos, refType, op) {
    let segoff;
    if (op) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)((refType & _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove) !== 0, 0x2f5 /* op create references must be SlideOnRemove */);
        segoff = client.getContainingSegment(pos, op);
        segoff = client.getSlideToSegment(segoff);
    }
    else {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)((refType & _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove) === 0, 0x2f6 /* SlideOnRemove references must be op created */);
        segoff = client.getContainingSegment(pos);
    }
    return createPositionReferenceFromSegoff(client, segoff, refType, op);
}
function createSequenceInterval(label, start, end, client, intervalType, op) {
    let beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.RangeBegin;
    let endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.RangeEnd;
    if (intervalType === IntervalType.Transient) {
        beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.Transient;
        endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.Transient;
    }
    else {
        if (intervalType === IntervalType.Nest) {
            beginRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.NestBegin;
            endRefType = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.NestEnd;
        }
        // All non-transient interval references must eventually be SlideOnRemove
        // To ensure eventual consistency, they must start as StayOnRemove when
        // pending (created locally and creation op is not acked)
        if (op) {
            beginRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;
            endRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;
        }
        else {
            beginRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;
            endRefType |= _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;
        }
    }
    const startLref = createPositionReference(client, start, beginRefType, op);
    const endLref = createPositionReference(client, end, endRefType, op);
    startLref.pairedRef = endLref;
    endLref.pairedRef = startLref;
    const rangeProp = {
        [_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey]: [label],
    };
    startLref.addProperties(rangeProp);
    endLref.addProperties(rangeProp);
    const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);
    return ival;
}
function defaultIntervalConflictResolver(a, b) {
    a.addPropertySet(b.properties);
    return a;
}
function createIntervalIndex(conflict) {
    const helpers = {
        compareEnds: compareIntervalEnds,
        create: createInterval,
    };
    const lc = new LocalIntervalCollection(undefined, "", helpers);
    if (conflict) {
        lc.addConflictResolver(conflict);
    }
    else {
        lc.addConflictResolver(defaultIntervalConflictResolver);
    }
    return lc;
}
class LocalIntervalCollection {
    constructor(client, label, helpers, 
    /** Callback invoked each time one of the endpoints of an interval slides. */
    onPositionChange) {
        this.client = client;
        this.label = label;
        this.helpers = helpers;
        this.onPositionChange = onPositionChange;
        this.intervalTree = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.IntervalTree();
        this.intervalIdMap = new Map();
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this.endIntervalTree = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.RedBlackTree(helpers.compareEnds);
    }
    addConflictResolver(conflictResolver) {
        this.conflictResolver = conflictResolver;
        this.endConflictResolver =
            (key, currentKey) => {
                const ival = conflictResolver(key, currentKey);
                return {
                    data: ival,
                    key: ival,
                };
            };
    }
    map(fn) {
        this.intervalTree.map(fn);
    }
    createLegacyId(start, end) {
        // Create a non-unique ID based on start and end to be used on intervals that come from legacy clients
        // without ID's.
        return `${LocalIntervalCollection.legacyIdPrefix}${start}-${end}`;
    }
    /**
     * Validates that a serialized interval has the ID property. Creates an ID
     * if one does not already exist
     *
     * @param serializedInterval - The interval to be checked
     * @returns The interval's existing or newly created id
     */
    ensureSerializedId(serializedInterval) {
        var _a;
        let id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (id === undefined) {
            // An interval came over the wire without an ID, so create a non-unique one based on start/end.
            // This will allow all clients to refer to this interval consistently.
            id = this.createLegacyId(serializedInterval.start, serializedInterval.end);
            const newProps = {
                [reservedIntervalIdKey]: id,
            };
            serializedInterval.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.addProperties)(serializedInterval.properties, newProps);
        }
        // Make the ID immutable for safety's sake.
        Object.defineProperty(serializedInterval.properties, reservedIntervalIdKey, {
            configurable: false,
            enumerable: true,
            writable: false,
        });
        return id;
    }
    mapUntil(fn) {
        this.intervalTree.mapUntil(fn);
    }
    gatherIterationResults(results, iteratesForward, start, end) {
        if (this.intervalTree.intervals.isEmpty()) {
            return;
        }
        if (start === undefined && end === undefined) {
            // No start/end provided. Gather the whole tree in the specified order.
            if (iteratesForward) {
                this.intervalTree.map((interval) => {
                    results.push(interval);
                });
            }
            else {
                this.intervalTree.mapBackward((interval) => {
                    results.push(interval);
                });
            }
        }
        else {
            const transientInterval = this.helpers.create("transient", start, end, this.client, IntervalType.Transient);
            if (start === undefined) {
                // Only end position provided. Since the tree is not sorted by end position,
                // walk the whole tree in the specified order, gathering intervals that match the end.
                if (iteratesForward) {
                    this.intervalTree.map((interval) => {
                        if (transientInterval.compareEnd(interval) === 0) {
                            results.push(interval);
                        }
                    });
                }
                else {
                    this.intervalTree.mapBackward((interval) => {
                        if (transientInterval.compareEnd(interval) === 0) {
                            results.push(interval);
                        }
                    });
                }
            }
            else {
                // Start and (possibly) end provided. Walk the subtrees that may contain
                // this start position.
                const compareFn = end === undefined ?
                    (node) => {
                        return transientInterval.compareStart(node.key);
                    } :
                    (node) => {
                        return transientInterval.compare(node.key);
                    };
                const continueLeftFn = (cmpResult) => cmpResult <= 0;
                const continueRightFn = (cmpResult) => cmpResult >= 0;
                const actionFn = (node) => {
                    results.push(node.key);
                };
                if (iteratesForward) {
                    this.intervalTree.intervals.walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn);
                }
                else {
                    this.intervalTree.intervals.walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn);
                }
            }
        }
    }
    findOverlappingIntervals(startPosition, endPosition) {
        if (endPosition < startPosition || this.intervalTree.intervals.isEmpty()) {
            return [];
        }
        const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, IntervalType.Transient);
        const overlappingIntervalNodes = this.intervalTree.match(transientInterval);
        return overlappingIntervalNodes.map((node) => node.key);
    }
    previousInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, IntervalType.Transient);
        const rbNode = this.endIntervalTree.floor(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    nextInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, IntervalType.Transient);
        const rbNode = this.endIntervalTree.ceil(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    removeInterval(startPosition, endPosition) {
        const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, IntervalType.Transient);
        this.intervalTree.remove(transientInterval);
        this.endIntervalTree.remove(transientInterval);
        return transientInterval;
    }
    removeIntervalFromIndex(interval) {
        this.intervalTree.removeExisting(interval);
        this.endIntervalTree.remove(interval);
        const id = interval.getIntervalId();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(id !== undefined, 0x311 /* expected id to exist on interval */);
        this.intervalIdMap.delete(id);
    }
    removeExistingInterval(interval) {
        this.removeIntervalFromIndex(interval);
        this.removeIntervalListeners(interval);
    }
    createInterval(start, end, intervalType, op) {
        return this.helpers.create(this.label, start, end, this.client, intervalType, op);
    }
    addInterval(start, end, intervalType, props, op) {
        const interval = this.createInterval(start, end, intervalType, op);
        if (interval) {
            if (!interval.properties) {
                interval.properties = (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.createMap)();
            }
            if (props) {
                interval.addProperties(props);
            }
            if (interval.properties[reservedIntervalIdKey] === undefined) {
                // Create a new ID.
                interval.properties[reservedIntervalIdKey] = (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
            }
            this.add(interval);
        }
        return interval;
    }
    addIntervalToIndex(interval) {
        const id = interval.getIntervalId();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(id !== undefined, 0x2c0 /* "ID must be created before adding interval to collection" */);
        // Make the ID immutable.
        Object.defineProperty(interval.properties, reservedIntervalIdKey, {
            configurable: false,
            enumerable: true,
            writable: false,
        });
        this.intervalTree.put(interval, this.conflictResolver);
        this.endIntervalTree.put(interval, interval, this.endConflictResolver);
        this.intervalIdMap.set(id, interval);
    }
    add(interval) {
        this.addIntervalToIndex(interval);
        this.addIntervalListeners(interval);
    }
    getIntervalById(id) {
        return this.intervalIdMap.get(id);
    }
    changeInterval(interval, start, end, op) {
        const newInterval = interval.modify(this.label, start, end, op);
        if (newInterval) {
            this.removeExistingInterval(interval);
            this.add(newInterval);
        }
        return newInterval;
    }
    serialize() {
        const client = this.client;
        const intervals = this.intervalTree.intervals.keys();
        return {
            label: this.label,
            intervals: intervals.map((interval) => compressInterval(interval.serialize(client))),
            version: 2,
        };
    }
    addIntervalListeners(interval) {
        if (interval instanceof SequenceInterval) {
            interval.addPositionChangeListeners(() => this.removeIntervalFromIndex(interval), () => {
                var _a;
                this.addIntervalToIndex(interval);
                (_a = this.onPositionChange) === null || _a === void 0 ? void 0 : _a.call(this, interval);
            });
        }
    }
    removeIntervalListeners(interval) {
        if (interval instanceof SequenceInterval) {
            interval.removePositionChangeListeners();
        }
    }
}
LocalIntervalCollection.legacyIdPrefix = "legacy";
const compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);
class SequenceIntervalCollectionFactory {
    load(emitter, raw = []) {
        const helpers = {
            compareEnds: compareSequenceIntervalEnds,
            create: createSequenceInterval,
        };
        return new IntervalCollection(helpers, true, emitter, raw);
    }
    store(value) {
        return value.serializeInternal();
    }
}
class SequenceIntervalCollectionValueType {
    get name() {
        return SequenceIntervalCollectionValueType.Name;
    }
    get factory() {
        return SequenceIntervalCollectionValueType._factory;
    }
    get ops() {
        return SequenceIntervalCollectionValueType._ops;
    }
}
SequenceIntervalCollectionValueType.Name = "sharedStringIntervalCollection";
SequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();
SequenceIntervalCollectionValueType._ops = makeOpsMap();
const compareIntervalEnds = (a, b) => a.end - b.end;
function createInterval(label, start, end, client) {
    const rangeProp = {};
    if (label && label.length > 0) {
        rangeProp[_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.reservedRangeLabelsKey] = [label];
    }
    return new Interval(start, end, rangeProp);
}
class IntervalCollectionFactory {
    load(emitter, raw = []) {
        const helpers = {
            compareEnds: compareIntervalEnds,
            create: createInterval,
        };
        const collection = new IntervalCollection(helpers, false, emitter, raw);
        collection.attachGraph(undefined, "");
        return collection;
    }
    store(value) {
        return value.serializeInternal();
    }
}
class IntervalCollectionValueType {
    get name() {
        return IntervalCollectionValueType.Name;
    }
    get factory() {
        return IntervalCollectionValueType._factory;
    }
    get ops() {
        return IntervalCollectionValueType._ops;
    }
}
IntervalCollectionValueType.Name = "sharedIntervalCollection";
IntervalCollectionValueType._factory = new IntervalCollectionFactory();
IntervalCollectionValueType._ops = makeOpsMap();
function makeOpsMap() {
    const rebase = (collection, op, localOpMetadata) => {
        const { localSeq } = localOpMetadata;
        const rebasedValue = collection.rebaseLocalInterval(op.opName, op.value, localSeq);
        const rebasedOp = Object.assign(Object.assign({}, op), { value: rebasedValue });
        return { rebasedOp, rebasedLocalOpMetadata: localOpMetadata };
    };
    return new Map([[
            "add",
            {
                process: (collection, params, local, op) => {
                    collection.ackAdd(params, local, op);
                },
                rebase,
            },
        ],
        [
            "delete",
            {
                process: (collection, params, local, op) => {
                    collection.ackDelete(params, local, op);
                },
                rebase: (collection, op, localOpMetadata) => {
                    // Deletion of intervals is based on id, so requires no rebasing.
                    return { rebasedOp: op, rebasedLocalOpMetadata: localOpMetadata };
                },
            },
        ],
        [
            "change",
            {
                process: (collection, params, local, op) => {
                    collection.ackChange(params, local, op);
                },
                rebase,
            },
        ]]);
}
class IntervalCollectionIterator {
    constructor(collection, iteratesForward = true, start, end) {
        this.results = [];
        this.index = 0;
        collection.gatherIterationResults(this.results, iteratesForward, start, end);
    }
    next() {
        let _value;
        let _done = true;
        if (this.index < this.results.length) {
            _value = this.results[this.index++];
            _done = false;
        }
        return {
            value: _value,
            done: _done,
        };
    }
}
class IntervalCollection extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.TypedEventEmitter {
    /** @internal */
    constructor(helpers, requiresClient, emitter, serializedIntervals) {
        super();
        this.helpers = helpers;
        this.requiresClient = requiresClient;
        this.emitter = emitter;
        this.pendingChangesStart = new Map();
        this.pendingChangesEnd = new Map();
        if (Array.isArray(serializedIntervals)) {
            this.savedSerializedIntervals = serializedIntervals;
        }
        else {
            this.savedSerializedIntervals =
                serializedIntervals.intervals.map((i) => decompressInterval(i, serializedIntervals.label));
        }
    }
    get attached() {
        return !!this.localCollection;
    }
    attachGraph(client, label) {
        if (this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Only supports one Sequence attach");
        }
        if ((client === undefined) && (this.requiresClient)) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Client required for this collection");
        }
        // Instantiate the local interval collection based on the saved intervals
        this.client = client;
        this.localCollection = new LocalIntervalCollection(client, label, this.helpers, (interval) => this.emit("changeInterval", interval, true, undefined));
        if (this.savedSerializedIntervals) {
            for (const serializedInterval of this.savedSerializedIntervals) {
                this.localCollection.ensureSerializedId(serializedInterval);
                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);
            }
        }
        this.savedSerializedIntervals = undefined;
    }
    /**
     * Gets the next local sequence number, modifying this client's collab window in doing so.
     */
    getNextLocalSeq() {
        return ++this.client.getCollabWindow().localSeq;
    }
    getIntervalById(id) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attach must be called before accessing intervals");
        }
        return this.localCollection.getIntervalById(id);
    }
    /**
     * Create a new interval and add it to the collection
     * @param start - interval start position
     * @param end - interval end position
     * @param intervalType - type of the interval. All intervals are SlideOnRemove. Intervals may not be Transient.
     * @param props - properties of the interval
     * @returns - the created interval
     */
    add(start, end, intervalType, props) {
        var _a, _b;
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attach must be called prior to adding intervals");
        }
        if (intervalType & IntervalType.Transient) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Can not add transient intervals");
        }
        const interval = this.localCollection.addInterval(start, end, intervalType, props);
        if (interval) {
            const serializedInterval = {
                end,
                intervalType,
                properties: interval.properties,
                sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,
                start,
            };
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            this.emitter.emit("add", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });
        }
        this.emit("addInterval", interval, true, undefined);
        return interval;
    }
    deleteExistingInterval(interval, local, op) {
        // The given interval is known to exist in the collection.
        this.localCollection.removeExistingInterval(interval);
        if (interval) {
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            if (local) {
                this.emitter.emit("delete", undefined, interval.serialize(this.client), { localSeq: this.getNextLocalSeq() });
            }
            else {
                if (this.onDeserialize) {
                    this.onDeserialize(interval);
                }
            }
        }
        this.emit("deleteInterval", interval, local, op);
    }
    removeIntervalById(id) {
        const interval = this.localCollection.getIntervalById(id);
        if (interval) {
            this.deleteExistingInterval(interval, true, undefined);
        }
        return interval;
    }
    changeProperties(id, props) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Attach must be called before accessing intervals");
        }
        if (typeof (id) !== "string") {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Change API requires an ID that is a string");
        }
        if (!props) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("changeProperties should be called with a property set");
        }
        const interval = this.getIntervalById(id);
        if (interval) {
            // Pass Unassigned as the sequence number to indicate that this is a local op that is waiting for an ack.
            const deltaProps = interval.addProperties(props, true, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_11__.UnassignedSequenceNumber);
            const serializedInterval = interval.serialize(this.client);
            // Emit a change op that will only change properties. Add the ID to
            // the property bag provided by the caller.
            serializedInterval.start = undefined;
            serializedInterval.end = undefined;
            serializedInterval.properties = props;
            serializedInterval.properties[reservedIntervalIdKey] = interval.getIntervalId();
            this.emitter.emit("change", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });
            this.emit("propertyChanged", interval, deltaProps);
        }
        this.emit("changeInterval", interval, true, undefined);
    }
    change(id, start, end) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Attach must be called before accessing intervals");
        }
        // Force id to be a string.
        if (typeof (id) !== "string") {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Change API requires an ID that is a string");
        }
        const interval = this.getIntervalById(id);
        if (interval) {
            const newInterval = this.localCollection.changeInterval(interval, start, end);
            const serializedInterval = interval.serialize(this.client);
            serializedInterval.start = start;
            serializedInterval.end = end;
            // Emit a property bag containing only the ID, as we don't intend for this op to change any properties.
            serializedInterval.properties =
                {
                    [reservedIntervalIdKey]: interval.getIntervalId(),
                };
            this.emitter.emit("change", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });
            this.addPendingChange(id, serializedInterval);
            this.emit("changeInterval", newInterval, true, undefined);
            return newInterval;
        }
        // No interval to change
        return undefined;
    }
    addPendingChange(id, serializedInterval) {
        if (serializedInterval.start !== undefined) {
            this.addPendingChangeHelper(id, this.pendingChangesStart, serializedInterval);
        }
        if (serializedInterval.end !== undefined) {
            this.addPendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);
        }
    }
    addPendingChangeHelper(id, pendingChanges, serializedInterval) {
        let entries = pendingChanges.get(id);
        if (!entries) {
            entries = [];
            pendingChanges.set(id, entries);
        }
        entries.push(serializedInterval);
    }
    removePendingChange(serializedInterval) {
        var _a;
        // Change ops always have an ID.
        const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (serializedInterval.start !== undefined) {
            this.removePendingChangeHelper(id, this.pendingChangesStart, serializedInterval);
        }
        if (serializedInterval.end !== undefined) {
            this.removePendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);
        }
    }
    removePendingChangeHelper(id, pendingChanges, serializedInterval) {
        const entries = pendingChanges.get(id);
        if (entries) {
            const pendingChange = entries.shift();
            if (entries.length === 0) {
                pendingChanges.delete(id);
            }
            if ((pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.start) !== serializedInterval.start ||
                (pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.end) !== serializedInterval.end) {
                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Mismatch in pending changes");
            }
        }
    }
    hasPendingChangeStart(id) {
        const entries = this.pendingChangesStart.get(id);
        return entries && entries.length !== 0;
    }
    hasPendingChangeEnd(id) {
        const entries = this.pendingChangesEnd.get(id);
        return entries && entries.length !== 0;
    }
    /** @deprecated - use ackChange */
    changeInterval(serializedInterval, local, op) {
        return this.ackChange(serializedInterval, local, op);
    }
    /** @internal */
    ackChange(serializedInterval, local, op) {
        var _a, _b, _c, _d;
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("Attach must be called before accessing intervals");
        }
        let interval;
        if (local) {
            // This is an ack from the server. Remove the pending change.
            this.removePendingChange(serializedInterval);
            const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
            interval = this.getIntervalById(id);
            if (interval) {
                // Let the propertyManager prune its pending change-properties set.
                (_b = interval.propertyManager) === null || _b === void 0 ? void 0 : _b.ackPendingProperties({
                    type: _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.MergeTreeDeltaType.ANNOTATE,
                    props: (_c = serializedInterval.properties) !== null && _c !== void 0 ? _c : {},
                });
                this.ackInterval(interval, op);
            }
        }
        else {
            // If there are pending changes with this ID, don't apply the remote start/end change, as the local ack
            // should be the winning change.
            // Note that the ID is in the property bag only to allow us to find the interval.
            // This API cannot change the ID, and writing to the ID property will result in an exception. So we
            // strip it out of the properties here.
            const _e = serializedInterval.properties, _f = reservedIntervalIdKey, id = _e[_f], newProps = __rest(_e, [typeof _f === "symbol" ? _f : _f + ""]);
            interval = this.getIntervalById(id);
            if (interval) {
                let start;
                let end;
                // Track pending start/end independently of one another.
                if (!this.hasPendingChangeStart(id)) {
                    start = serializedInterval.start;
                }
                if (!this.hasPendingChangeEnd(id)) {
                    end = serializedInterval.end;
                }
                if (start !== undefined || end !== undefined) {
                    // If changeInterval gives us a new interval, work with that one. Otherwise keep working with
                    // the one we originally found in the tree.
                    interval = (_d = this.localCollection.changeInterval(interval, start, end, op)) !== null && _d !== void 0 ? _d : interval;
                }
                const deltaProps = interval.addProperties(newProps, true, op.sequenceNumber);
                if (this.onDeserialize) {
                    this.onDeserialize(interval);
                }
                this.emit("propertyChanged", interval, deltaProps);
            }
        }
        if (interval) {
            this.emit("changeInterval", interval, local, op);
        }
    }
    addConflictResolver(conflictResolver) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        this.localCollection.addConflictResolver(conflictResolver);
    }
    attachDeserializer(onDeserialize) {
        // If no deserializer is specified can skip all processing work
        if (!onDeserialize) {
            return;
        }
        // Start by storing the callbacks so that any subsequent modifications make use of them
        this.onDeserialize = onDeserialize;
        // Trigger the async prepare work across all values in the collection
        this.localCollection.map((interval) => {
            onDeserialize(interval);
        });
    }
    /** @internal */
    rebaseLocalInterval(opName, serializedInterval, localSeq) {
        var _a, _b;
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        const { start, end, intervalType, properties, sequenceNumber } = serializedInterval;
        const startRebased = start === undefined ? undefined :
            this.client.rebasePosition(start, sequenceNumber, localSeq);
        const endRebased = end === undefined ? undefined :
            this.client.rebasePosition(end, sequenceNumber, localSeq);
        const intervalId = properties === null || properties === void 0 ? void 0 : properties[reservedIntervalIdKey];
        const rebased = {
            start: startRebased,
            end: endRebased,
            intervalType,
            sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,
            properties,
        };
        if (opName === "change" && (this.hasPendingChangeStart(intervalId) || this.hasPendingChangeEnd(intervalId))) {
            this.removePendingChange(serializedInterval);
            this.addPendingChange(intervalId, rebased);
        }
        return rebased;
    }
    getSlideToSegment(lref) {
        const segoff = { segment: lref.segment, offset: lref.offset };
        const newSegoff = this.client.getSlideToSegment(segoff);
        const value = (segoff.segment === newSegoff.segment && segoff.offset === newSegoff.offset) ? undefined : newSegoff;
        return value;
    }
    setSlideOnRemove(lref) {
        let refType = lref.refType;
        refType = refType & ~_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove;
        refType = refType | _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.SlideOnRemove;
        lref.refType = refType;
    }
    ackInterval(interval, op) {
        // in current usage, interval is always a SequenceInterval
        if (!(interval instanceof SequenceInterval)) {
            return;
        }
        if (!(0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(interval.start, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove) &&
            !(0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(interval.end, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.ReferenceType.StayOnRemove)) {
            return;
        }
        const newStart = this.getSlideToSegment(interval.start);
        const newEnd = this.getSlideToSegment(interval.end);
        const id = interval.properties[reservedIntervalIdKey];
        const hasPendingStartChange = this.hasPendingChangeStart(id);
        const hasPendingEndChange = this.hasPendingChangeEnd(id);
        if (!hasPendingStartChange) {
            this.setSlideOnRemove(interval.start);
        }
        if (!hasPendingEndChange) {
            this.setSlideOnRemove(interval.end);
        }
        const needsStartUpdate = newStart !== undefined && !hasPendingStartChange;
        const needsEndUpdate = newEnd !== undefined && !hasPendingEndChange;
        if (needsStartUpdate || needsEndUpdate) {
            // In this case, where we change the start or end of an interval,
            // it is necessary to remove and re-add the interval listeners.
            // This ensures that the correct listeners are added to the ReferencePosition.
            this.localCollection.removeExistingInterval(interval);
            if (needsStartUpdate) {
                const props = interval.start.properties;
                this.client.removeLocalReferencePosition(interval.start);
                interval.start = createPositionReferenceFromSegoff(this.client, newStart, interval.start.refType, op);
                if (props) {
                    interval.start.addProperties(props);
                }
            }
            if (needsEndUpdate) {
                const props = interval.end.properties;
                this.client.removeLocalReferencePosition(interval.end);
                interval.end = createPositionReferenceFromSegoff(this.client, newEnd, interval.end.refType, op);
                if (props) {
                    interval.end.addProperties(props);
                }
            }
            this.localCollection.add(interval);
        }
    }
    /** @deprecated - use ackAdd */
    addInternal(serializedInterval, local, op) {
        return this.ackAdd(serializedInterval, local, op);
    }
    /** @internal */
    ackAdd(serializedInterval, local, op) {
        var _a;
        if (local) {
            const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
            const localInterval = this.getIntervalById(id);
            if (localInterval) {
                this.ackInterval(localInterval, op);
            }
            return;
        }
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        this.localCollection.ensureSerializedId(serializedInterval);
        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties, op);
        if (interval) {
            if (this.onDeserialize) {
                this.onDeserialize(interval);
            }
        }
        this.emit("addInterval", interval, local, op);
        return interval;
    }
    /** @deprecated - use ackDelete */
    deleteInterval(serializedInterval, local, op) {
        return this.ackDelete(serializedInterval, local, op);
    }
    /** @internal */
    ackDelete(serializedInterval, local, op) {
        if (local) {
            // Local ops were applied when the message was created and there's no "pending delete"
            // state to bookkeep: remote operation application takes into account possibility of
            // locally deleted interval whenever a lookup happens.
            return;
        }
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attach must be called prior to deleting intervals");
        }
        const id = this.localCollection.ensureSerializedId(serializedInterval);
        const interval = this.localCollection.getIntervalById(id);
        if (interval) {
            this.deleteExistingInterval(interval, local, op);
        }
    }
    /**
     * @internal
     */
    serializeInternal() {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        return this.localCollection.serialize();
    }
    [Symbol.iterator]() {
        const iterator = new IntervalCollectionIterator(this);
        return iterator;
    }
    CreateForwardIteratorWithStartPosition(startPosition) {
        const iterator = new IntervalCollectionIterator(this, true, startPosition);
        return iterator;
    }
    CreateBackwardIteratorWithStartPosition(startPosition) {
        const iterator = new IntervalCollectionIterator(this, false, startPosition);
        return iterator;
    }
    CreateForwardIteratorWithEndPosition(endPosition) {
        const iterator = new IntervalCollectionIterator(this, true, undefined, endPosition);
        return iterator;
    }
    CreateBackwardIteratorWithEndPosition(endPosition) {
        const iterator = new IntervalCollectionIterator(this, false, undefined, endPosition);
        return iterator;
    }
    gatherIterationResults(results, iteratesForward, start, end) {
        if (!this.attached) {
            return;
        }
        this.localCollection.gatherIterationResults(results, iteratesForward, start, end);
    }
    findOverlappingIntervals(startPosition, endPosition) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);
    }
    map(fn) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        this.localCollection.map(fn);
    }
    previousInterval(pos) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        return this.localCollection.previousInterval(pos);
    }
    nextInterval(pos) {
        if (!this.attached) {
            throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.LoggingError("attachSequence must be called");
        }
        return this.localCollection.nextInterval(pos);
    }
}
//# sourceMappingURL=intervalCollection.js.map

/***/ }),
/* 280 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DetachedReferencePosition": () => (/* binding */ DetachedReferencePosition),
/* harmony export */   "compareReferencePositions": () => (/* binding */ compareReferencePositions),
/* harmony export */   "maxReferencePosition": () => (/* binding */ maxReferencePosition),
/* harmony export */   "minReferencePosition": () => (/* binding */ minReferencePosition),
/* harmony export */   "refGetRangeLabels": () => (/* binding */ refGetRangeLabels),
/* harmony export */   "refGetTileLabels": () => (/* binding */ refGetTileLabels),
/* harmony export */   "refHasRangeLabel": () => (/* binding */ refHasRangeLabel),
/* harmony export */   "refHasRangeLabels": () => (/* binding */ refHasRangeLabels),
/* harmony export */   "refHasTileLabel": () => (/* binding */ refHasTileLabel),
/* harmony export */   "refHasTileLabels": () => (/* binding */ refHasTileLabels),
/* harmony export */   "refTypeIncludesFlag": () => (/* binding */ refTypeIncludesFlag),
/* harmony export */   "reservedRangeLabelsKey": () => (/* binding */ reservedRangeLabelsKey),
/* harmony export */   "reservedTileLabelsKey": () => (/* binding */ reservedTileLabelsKey)
/* harmony export */ });
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

const reservedTileLabelsKey = "referenceTileLabels";
const reservedRangeLabelsKey = "referenceRangeLabels";
function refTypeIncludesFlag(refPosOrType, flags) {
    const refType = typeof refPosOrType === "number" ? refPosOrType : refPosOrType.refType;
    // eslint-disable-next-line no-bitwise
    return (refType & flags) !== 0;
}
const refGetTileLabels = (refPos) => refTypeIncludesFlag(refPos, _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.Tile)
    && refPos.properties ? refPos.properties[reservedTileLabelsKey] : undefined;
const refGetRangeLabels = (refPos) => 
// eslint-disable-next-line no-bitwise
(refTypeIncludesFlag(refPos, _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_0__.ReferenceType.NestEnd))
    && refPos.properties ? refPos.properties[reservedRangeLabelsKey] : undefined;
function refHasTileLabel(refPos, label) {
    const tileLabels = refGetTileLabels(refPos);
    if (tileLabels) {
        for (const refLabel of tileLabels) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
function refHasRangeLabel(refPos, label) {
    const rangeLabels = refGetRangeLabels(refPos);
    if (rangeLabels) {
        for (const refLabel of rangeLabels) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
function refHasTileLabels(refPos) {
    return refGetTileLabels(refPos) !== undefined;
}
function refHasRangeLabels(refPos) {
    return refGetRangeLabels(refPos) !== undefined;
}
const DetachedReferencePosition = -1;
function minReferencePosition(a, b) {
    if (compareReferencePositions(a, b) < 0) {
        return a;
    }
    else {
        return b;
    }
}
function maxReferencePosition(a, b) {
    if (compareReferencePositions(a, b) > 0) {
        return a;
    }
    else {
        return b;
    }
}
function compareReferencePositions(a, b) {
    const aSeg = a.getSegment();
    const bSeg = b.getSegment();
    if (aSeg === bSeg) {
        return a.getOffset() - b.getOffset();
    }
    else {
        if (aSeg === undefined
            || (bSeg !== undefined &&
                aSeg.ordinal < bSeg.ordinal)) {
            return -1;
        }
        else {
            return 1;
        }
    }
}
//# sourceMappingURL=referencePositions.js.map

/***/ }),
/* 281 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MergeTreeDeltaType": () => (/* binding */ MergeTreeDeltaType),
/* harmony export */   "ReferenceType": () => (/* binding */ ReferenceType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var ReferenceType;
(function (ReferenceType) {
    ReferenceType[ReferenceType["Simple"] = 0] = "Simple";
    ReferenceType[ReferenceType["Tile"] = 1] = "Tile";
    ReferenceType[ReferenceType["NestBegin"] = 2] = "NestBegin";
    ReferenceType[ReferenceType["NestEnd"] = 4] = "NestEnd";
    ReferenceType[ReferenceType["RangeBegin"] = 16] = "RangeBegin";
    ReferenceType[ReferenceType["RangeEnd"] = 32] = "RangeEnd";
    ReferenceType[ReferenceType["SlideOnRemove"] = 64] = "SlideOnRemove";
    ReferenceType[ReferenceType["StayOnRemove"] = 128] = "StayOnRemove";
    ReferenceType[ReferenceType["Transient"] = 256] = "Transient";
})(ReferenceType || (ReferenceType = {}));
// Note: Assigned positive integers to avoid clashing with MergeTreeMaintenanceType
const MergeTreeDeltaType = {
    INSERT: 0,
    REMOVE: 1,
    ANNOTATE: 2,
    GROUP: 3,
};
//# sourceMappingURL=ops.js.map

/***/ }),
/* 282 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertiesManager": () => (/* binding */ PropertiesManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(283);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(285);
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(284);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */



class PropertiesManager {
    constructor() {
        this.pendingRewriteCount = 0;
    }
    ackPendingProperties(annotateOp) {
        var _a, _b;
        if (annotateOp.combiningOp && annotateOp.combiningOp.name === "rewrite") {
            this.pendingRewriteCount--;
        }
        for (const key of Object.keys(annotateOp.props)) {
            if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) !== undefined) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.pendingKeyUpdateCount[key] > 0, 0x05c /* "Trying to update more annotate props than do exist!" */);
                this.pendingKeyUpdateCount[key]--;
                if (((_b = this.pendingKeyUpdateCount) === null || _b === void 0 ? void 0 : _b[key]) === 0) {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete this.pendingKeyUpdateCount[key];
                }
            }
        }
    }
    addProperties(oldProps, newProps, op, seq, collaborating = false) {
        var _a;
        if (!this.pendingKeyUpdateCount) {
            this.pendingKeyUpdateCount = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.createMap)();
        }
        // There are outstanding local rewrites, so block all non-local changes
        if (this.pendingRewriteCount > 0 && seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber && collaborating) {
            return undefined;
        }
        const rewrite = (op && op.name === "rewrite");
        const combiningOp = !rewrite ? op ? op : undefined : undefined;
        const shouldModifyKey = (key) => {
            var _a;
            if (seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber
                || ((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined
                || combiningOp) {
                return true;
            }
            return false;
        };
        const deltas = {};
        if (rewrite) {
            if (collaborating && seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                this.pendingRewriteCount++;
            }
            // We are re-writing so delete all the properties
            // not in the new props
            for (const key of Object.keys(oldProps)) {
                if (!newProps[key] && shouldModifyKey(key)) {
                    deltas[key] = oldProps[key];
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete oldProps[key];
                }
            }
        }
        for (const key of Object.keys(newProps)) {
            if (collaborating) {
                if (seq === _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                    if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {
                        this.pendingKeyUpdateCount[key] = 0;
                    }
                    this.pendingKeyUpdateCount[key]++;
                }
                else if (!shouldModifyKey(key)) {
                    continue;
                }
            }
            const previousValue = oldProps[key];
            // The delta should be null if undefined, as thats how we encode delete
            deltas[key] = (previousValue === undefined) ? null : previousValue;
            let newValue;
            if (combiningOp) {
                newValue = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.combine)(combiningOp, previousValue, newValue, seq);
            }
            else {
                newValue = newProps[key];
            }
            if (newValue === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete oldProps[key];
            }
            else {
                oldProps[key] = newValue;
            }
        }
        return deltas;
    }
    copyTo(oldProps, newProps, newManager) {
        if (oldProps) {
            if (!newProps) {
                // eslint-disable-next-line no-param-reassign
                newProps = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.createMap)();
            }
            if (!newManager) {
                throw new Error("Must provide new PropertyManager");
            }
            for (const key of Object.keys(oldProps)) {
                newProps[key] = oldProps[key];
            }
            newManager.pendingRewriteCount = this.pendingRewriteCount;
            newManager.pendingKeyUpdateCount = (0,_properties__WEBPACK_IMPORTED_MODULE_1__.createMap)();
            for (const key of Object.keys(this.pendingKeyUpdateCount)) {
                newManager.pendingKeyUpdateCount[key] = this.pendingKeyUpdateCount[key];
            }
        }
        return newProps;
    }
    hasPendingProperties() {
        return this.pendingRewriteCount > 0 || Object.keys(this.pendingKeyUpdateCount).length > 0;
    }
}
//# sourceMappingURL=segmentPropertiesManager.js.map

/***/ }),
/* 283 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 284 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addProperties": () => (/* binding */ addProperties),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "combine": () => (/* binding */ combine),
/* harmony export */   "createMap": () => (/* binding */ createMap),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "extendIfUndefined": () => (/* binding */ extendIfUndefined),
/* harmony export */   "matchProperties": () => (/* binding */ matchProperties)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
function combine(combiningInfo, currentValue, newValue, seq) {
    let _currentValue = currentValue;
    if (_currentValue === undefined) {
        _currentValue = combiningInfo.defaultValue;
    }
    // Fixed set of operations for now
    switch (combiningInfo.name) {
        case "incr":
            _currentValue += newValue;
            if (combiningInfo.minValue) {
                if (_currentValue < combiningInfo.minValue) {
                    _currentValue = combiningInfo.minValue;
                }
            }
            break;
        case "consensus":
            if (_currentValue === undefined) {
                const cv = {
                    value: newValue,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    seq: seq,
                };
                _currentValue = cv;
            }
            else {
                const cv = _currentValue;
                if (cv.seq === -1) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    cv.seq = seq;
                }
            }
            break;
        default:
            break;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return _currentValue;
}
function matchProperties(a, b) {
    if (a) {
        if (!b) {
            return false;
        }
        else {
            // For now, straightforward; later use hashing
            // eslint-disable-next-line no-restricted-syntax
            for (const key in a) {
                if (b[key] === undefined) {
                    return false;
                }
                else if (typeof b[key] === "object") {
                    if (!matchProperties(a[key], b[key])) {
                        return false;
                    }
                }
                else if (b[key] !== a[key]) {
                    return false;
                }
            }
            // eslint-disable-next-line no-restricted-syntax
            for (const key in b) {
                if (a[key] === undefined) {
                    return false;
                }
            }
        }
    }
    else {
        if (b) {
            return false;
        }
    }
    return true;
}
function extend(base, extension, combiningOp, seq) {
    if (extension !== undefined) {
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const key in extension) {
            const v = extension[key];
            if (v === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete base[key];
            }
            else {
                if (combiningOp && (combiningOp.name !== "rewrite")) {
                    base[key] = combine(combiningOp, base[key], v, seq);
                }
                else {
                    base[key] = v;
                }
            }
        }
    }
    return base;
}
function clone(extension) {
    if (extension === undefined) {
        return undefined;
    }
    const cloneMap = createMap();
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const key in extension) {
        const v = extension[key];
        if (v !== null) {
            cloneMap[key] = v;
        }
    }
    return cloneMap;
}
function addProperties(oldProps, newProps, op, seq) {
    let _oldProps = oldProps;
    if ((!_oldProps) || (op && (op.name === "rewrite"))) {
        _oldProps = createMap();
    }
    extend(_oldProps, newProps, op, seq);
    return _oldProps;
}
function extendIfUndefined(base, extension) {
    if (extension !== undefined) {
        // eslint-disable-next-line no-restricted-syntax
        for (const key in extension) {
            if (base[key] === undefined) {
                base[key] = extension[key];
            }
        }
    }
    return base;
}
// Create a MapLike with good performance.
function createMap() {
    return Object.create(null);
}
//# sourceMappingURL=properties.js.map

/***/ }),
/* 285 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalClientId": () => (/* binding */ LocalClientId),
/* harmony export */   "NonCollabClient": () => (/* binding */ NonCollabClient),
/* harmony export */   "TreeMaintenanceSequenceNumber": () => (/* binding */ TreeMaintenanceSequenceNumber),
/* harmony export */   "UnassignedSequenceNumber": () => (/* binding */ UnassignedSequenceNumber),
/* harmony export */   "UniversalSequenceNumber": () => (/* binding */ UniversalSequenceNumber)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Sequence numbers for shared segments start at 1 or greater.  Every segment marked
 * with sequence number zero will be counted as part of the requested string.
 */
const UniversalSequenceNumber = 0;
const UnassignedSequenceNumber = -1;
const TreeMaintenanceSequenceNumber = -2;
const LocalClientId = -1;
const NonCollabClient = -2;
//# sourceMappingURL=constants.js.map

/***/ }),
/* 286 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalReference": () => (/* binding */ LocalReference),
/* harmony export */   "LocalReferenceCollection": () => (/* binding */ LocalReferenceCollection),
/* harmony export */   "_validateReferenceType": () => (/* binding */ _validateReferenceType)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(283);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51);
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(287);
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(281);
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(284);
/* harmony import */ var _referencePositions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(280);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */






/**
 * @internal
 */
function _validateReferenceType(refType) {
    let exclusiveCount = 0;
    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Transient)) {
        ++exclusiveCount;
    }
    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.SlideOnRemove)) {
        ++exclusiveCount;
    }
    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.StayOnRemove)) {
        ++exclusiveCount;
    }
    if (exclusiveCount > 1) {
        throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_2__.UsageError("Reference types can only be one of Transient, SlideOnRemove, and StayOnRemove");
    }
}
/**
 * @deprecated - Use LocalReferencePosition
 */
class LocalReference {
    /**
     * @deprecated - use createReferencePosition
     */
    constructor(client, initSegment, 
    /**
     * @deprecated - use getOffset
     */
    offset = 0, refType = _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Simple, properties) {
        this.client = client;
        this.offset = offset;
        this.refType = refType;
        _validateReferenceType(refType);
        this.segment = initSegment;
        this.properties = properties;
    }
    /**
     * @deprecated - use minReferencePosition
     */
    min(b) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.minReferencePosition)(this, b);
    }
    /**
     * @deprecated - use maxReferencePosition
     */
    max(b) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.maxReferencePosition)(this, b);
    }
    /**
     * @deprecated - use compareReferencePositions
     */
    compare(b) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.compareReferencePositions)(this, b);
    }
    /**
     * @deprecated - use getLocalReferencePosition
     */
    toPosition() {
        return this.getClient().localReferencePositionToPosition(this);
    }
    /**
     * @deprecated - use refHasTileLabels
     */
    hasTileLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(this);
    }
    /**
     * @deprecated - use refHasRangeLabels
     */
    hasRangeLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(this);
    }
    /**
     * @deprecated - use refHasTileLabel
     */
    hasTileLabel(label) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabel)(this, label);
    }
    /**
     * @deprecated - use refHasRangeLabel
     */
    hasRangeLabel(label) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabel)(this, label);
    }
    /**
     * @deprecated - use refGetTileLabels
     */
    getTileLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refGetTileLabels)(this);
    }
    /**
     * @deprecated - use refGetRangeLabels
     */
    getRangeLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refGetRangeLabels)(this);
    }
    isLeaf() {
        return false;
    }
    addProperties(newProps, op) {
        this.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_3__.addProperties)(this.properties, newProps, op);
    }
    /**
     * @deprecated - no longer supported
     */
    getClient() {
        return this.client;
    }
    getSegment() {
        return this.segment;
    }
    getOffset() {
        return this.offset;
    }
    getProperties() {
        return this.properties;
    }
}
/**
 * @deprecated - use DetachedReferencePosition
 */
LocalReference.DetachedPosition = -1;
function assertLocalReferences(lref) {
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(lref instanceof LocalReference, 0x2e0 /* "lref not a Local Reference" */);
}
/**
 * Represents a collection of {@link ReferencePosition}s associated with one segment in a merge-tree.
 */
class LocalReferenceCollection {
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    constructor(
    /** Segment this `LocalReferenceCollection` is associated to. */
    segment, initialRefsByfOffset = new Array(segment.cachedLength)) {
        this.segment = segment;
        /**
         *
         * @internal - this method should only be called by mergeTree
         */
        this.hierRefCount = 0;
        this.refCount = 0;
        // Since javascript arrays are sparse the above won't populate any of the
        // indices, but it will ensure the length property of the array matches
        // the length of the segment.
        this.refsByOffset = initialRefsByfOffset;
    }
    static append(seg1, seg2) {
        if (seg2.localRefs && !seg2.localRefs.empty) {
            if (!seg1.localRefs) {
                seg1.localRefs = new LocalReferenceCollection(seg1);
            }
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(seg1.localRefs.refsByOffset.length === seg1.cachedLength, 0x2be /* "LocalReferences array contains a gap" */);
            seg1.localRefs.append(seg2.localRefs);
        }
        else if (seg1.localRefs) {
            // Since creating the LocalReferenceCollection, we may have appended
            // segments that had no local references. Account for them now by padding the array.
            seg1.localRefs.refsByOffset.length += seg2.cachedLength;
        }
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    [Symbol.iterator]() {
        const subiterators = [];
        for (const refs of this.refsByOffset) {
            if (refs) {
                if (refs.before) {
                    subiterators.push(refs.before[Symbol.iterator]());
                }
                if (refs.at) {
                    subiterators.push(refs.at[Symbol.iterator]());
                }
                if (refs.after) {
                    subiterators.push(refs.after[Symbol.iterator]());
                }
            }
        }
        const iterator = {
            next() {
                while (subiterators.length > 0) {
                    const next = subiterators[0].next();
                    if (next.done === true) {
                        subiterators.shift();
                    }
                    else {
                        return next;
                    }
                }
                return { value: undefined, done: true };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    clear() {
        this.refCount = 0;
        this.hierRefCount = 0;
        const detachSegments = (refs) => {
            if (refs) {
                for (const r of refs) {
                    if (r.segment === this.segment) {
                        r.segment = undefined;
                    }
                }
            }
        };
        for (let i = 0; i < this.refsByOffset.length; i++) {
            const refsAtOffset = this.refsByOffset[i];
            if (refsAtOffset) {
                detachSegments(refsAtOffset.before);
                detachSegments(refsAtOffset.at);
                detachSegments(refsAtOffset.before);
                this.refsByOffset[i] = undefined;
            }
        }
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    get empty() {
        return this.refCount === 0;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    createLocalRef(offset, refType, properties, client) {
        const ref = new LocalReference(client, this.segment, offset, refType, properties);
        if (!(0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(ref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Transient)) {
            this.addLocalRef(ref);
        }
        return ref;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    addLocalRef(lref) {
        var _a, _b;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!(0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.Transient), 0x2df /* "transient references cannot be bound to segments" */);
        assertLocalReferences(lref);
        const refsAtOffset = this.refsByOffset[lref.offset] =
            (_a = this.refsByOffset[lref.offset]) !== null && _a !== void 0 ? _a : { at: (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)() };
        const atRefs = refsAtOffset.at =
            (_b = refsAtOffset.at) !== null && _b !== void 0 ? _b : (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)();
        atRefs.enqueue(lref);
        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {
            this.hierRefCount++;
        }
        this.refCount++;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    removeLocalRef(lref) {
        assertLocalReferences(lref);
        const tryRemoveRef = (refs) => {
            if (refs) {
                let node = refs;
                do {
                    node = node.next;
                    if (node.data === lref) {
                        (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListRemoveEntry)(node);
                        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {
                            this.hierRefCount--;
                        }
                        this.refCount--;
                        return lref;
                    }
                } while (!node.isHead);
            }
        };
        const refAtOffset = this.refsByOffset[lref.offset];
        if (refAtOffset !== undefined) {
            let ref = tryRemoveRef(refAtOffset.before);
            if (ref) {
                return ref;
            }
            ref = tryRemoveRef(refAtOffset.at);
            if (ref) {
                return ref;
            }
            ref = tryRemoveRef(refAtOffset.after);
            if (ref) {
                return ref;
            }
        }
    }
    /**
     * @internal - this method should only be called by mergeTree
     *
     * Called by 'append()' implementations to append local refs from the given 'other' segment to the
     * end of 'this' segment.
     *
     * Note: This method should be invoked after the caller has ensured that segments can be merged,
     *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs
     *       will be incorrect.
     */
    append(other) {
        if (!other || other.empty) {
            return;
        }
        this.hierRefCount += other.hierRefCount;
        this.refCount += other.refCount;
        other.hierRefCount = 0;
        for (const lref of other) {
            lref.segment = this.segment;
            lref.offset += this.refsByOffset.length;
        }
        this.refsByOffset.push(...other.refsByOffset);
    }
    /**
     * @internal - this method should only be called by mergeTree
     *
     * Splits this `LocalReferenceCollection` into the intervals [0, offset) and [offset, originalLength).
     * Local references in the former half of this split will remain associated with the segment used on construction.
     * Local references in the latter half of this split will be transferred to `splitSeg`,
     * and its `localRefs` field will be set.
     * @param offset - Offset into the original segment at which the collection should be split
     * @param splitSeg - Split segment which originally corresponded to the indices [offset, originalLength)
     * before splitting.
     */
    split(offset, splitSeg) {
        if (!this.empty) {
            const localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));
            splitSeg.localRefs = localRefs;
            for (const lref of localRefs) {
                lref.segment = splitSeg;
                lref.offset -= offset;
                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {
                    this.hierRefCount--;
                    localRefs.hierRefCount++;
                }
                this.refCount--;
                localRefs.refCount++;
            }
        }
        else {
            // shrink the offset array when empty and splitting
            this.refsByOffset.length = offset;
        }
    }
    addBeforeTombstones(...refs) {
        var _a, _b, _c, _d, _e;
        const beforeRefs = (_b = (_a = this.refsByOffset[0]) === null || _a === void 0 ? void 0 : _a.before) !== null && _b !== void 0 ? _b : (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)();
        for (const iterable of refs) {
            for (const lref of iterable) {
                assertLocalReferences(lref);
                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.SlideOnRemove)) {
                    beforeRefs.push(lref);
                    lref.segment = this.segment;
                    lref.offset = 0;
                    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {
                        this.hierRefCount++;
                    }
                    this.refCount++;
                }
                else {
                    lref.segment = undefined;
                }
            }
        }
        if (!beforeRefs.empty() && ((_c = this.refsByOffset[0]) === null || _c === void 0 ? void 0 : _c.before) === undefined) {
            const refsAtOffset = this.refsByOffset[0] =
                (_d = this.refsByOffset[0]) !== null && _d !== void 0 ? _d : { before: beforeRefs };
            refsAtOffset.before = (_e = refsAtOffset.before) !== null && _e !== void 0 ? _e : beforeRefs;
        }
    }
    addAfterTombstones(...refs) {
        var _a, _b, _c, _d, _e;
        const lastOffset = this.refsByOffset.length - 1;
        const afterRefs = (_b = (_a = this.refsByOffset[lastOffset]) === null || _a === void 0 ? void 0 : _a.after) !== null && _b !== void 0 ? _b : (0,_collections__WEBPACK_IMPORTED_MODULE_5__.ListMakeHead)();
        for (const iterable of refs) {
            for (const lref of iterable) {
                assertLocalReferences(lref);
                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.SlideOnRemove)) {
                    afterRefs.push(lref);
                    lref.segment = this.segment;
                    lref.offset = this.segment.cachedLength - 1;
                    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasRangeLabels)(lref) || (0,_referencePositions__WEBPACK_IMPORTED_MODULE_0__.refHasTileLabels)(lref)) {
                        this.hierRefCount++;
                    }
                    this.refCount++;
                }
                else {
                    lref.segment = undefined;
                }
            }
        }
        if (!afterRefs.empty() && ((_c = this.refsByOffset[lastOffset]) === null || _c === void 0 ? void 0 : _c.after) === undefined) {
            const refsAtOffset = this.refsByOffset[lastOffset] =
                (_d = this.refsByOffset[lastOffset]) !== null && _d !== void 0 ? _d : { after: afterRefs };
            refsAtOffset.after = (_e = refsAtOffset.after) !== null && _e !== void 0 ? _e : afterRefs;
        }
    }
}
//# sourceMappingURL=localReference.js.map

/***/ }),
/* 287 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Heap": () => (/* binding */ Heap),
/* harmony export */   "IntervalTree": () => (/* binding */ IntervalTree),
/* harmony export */   "List": () => (/* binding */ List),
/* harmony export */   "ListMakeHead": () => (/* binding */ ListMakeHead),
/* harmony export */   "ListRemoveEntry": () => (/* binding */ ListRemoveEntry),
/* harmony export */   "RBColor": () => (/* binding */ RBColor),
/* harmony export */   "RedBlackTree": () => (/* binding */ RedBlackTree),
/* harmony export */   "Stack": () => (/* binding */ Stack),
/* harmony export */   "TST": () => (/* binding */ TST),
/* harmony export */   "integerRangeToString": () => (/* binding */ integerRangeToString)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
class Stack {
    constructor() {
        this.items = [];
    }
    push(val) {
        this.items.push(val);
    }
    empty() {
        return this.items.length === 0;
    }
    top() {
        return this.items[this.items.length - 1];
    }
    pop() {
        return this.items.pop();
    }
}
function ListRemoveEntry(entry) {
    if (entry === undefined) {
        return undefined;
    }
    else if (entry.isHead) {
        return undefined;
    }
    else {
        entry.next.prev = entry.prev;
        entry.prev.next = entry.next;
    }
    return (entry);
}
function ListMakeEntry(data) {
    return new List(false, data);
}
function ListMakeHead() {
    return new List(true, undefined);
}
class List {
    constructor(isHead, data) {
        this.isHead = isHead;
        this.data = data;
        this.prev = this;
        this.next = this;
    }
    clear() {
        if (this.isHead) {
            this.prev = this;
            this.next = this;
        }
    }
    add(data) {
        const entry = ListMakeEntry(data);
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return (entry);
    }
    dequeue() {
        if (!this.empty()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const removedEntry = ListRemoveEntry(this.next);
            return removedEntry.data;
        }
    }
    enqueue(data) {
        return this.add(data);
    }
    walk(fn) {
        for (let entry = this.next; !(entry.isHead); entry = entry.next) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            fn(entry.data, entry);
        }
    }
    some(fn, rev) {
        const rtn = [];
        const start = rev ? this.prev : this.next;
        for (let entry = start; !(entry.isHead); entry = rev ? entry.prev : entry.next) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const data = entry.data;
            if (fn(data, entry)) {
                if (rev) {
                    // preserve list order when in reverse
                    rtn.unshift(data);
                }
                else {
                    rtn.push(data);
                }
            }
        }
        return rtn;
    }
    count() {
        let entry;
        let i;
        entry = this.next;
        for (i = 0; !(entry.isHead); i++) {
            entry = entry.next;
        }
        return (i);
    }
    first() {
        if (!this.empty()) {
            return (this.next.data);
        }
    }
    last() {
        if (!this.empty()) {
            return (this.prev.data);
        }
    }
    empty() {
        return (this.next === this);
    }
    /**
     * @deprecated - use unshift
     */
    push(data) {
        this.unshift(data);
    }
    unshift(data) {
        const entry = ListMakeEntry(data);
        entry.data = data;
        entry.isHead = false;
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
    }
    [Symbol.iterator]() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let node = this;
        const iterator = {
            next() {
                while (node && node.next.isHead === false) {
                    node = node.next;
                    if (node.data !== undefined) {
                        return { value: node.data, done: false };
                    }
                }
                return { value: undefined, done: true };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
}
class Heap {
    constructor(a, comp) {
        this.comp = comp;
        this.L = [comp.min];
        for (let i = 0, len = a.length; i < len; i++) {
            this.add(a[i]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    peek() {
        return this.L[1];
    }
    get() {
        const x = this.L[1];
        this.L[1] = this.L[this.count()];
        this.L.pop();
        this.fixDown(1);
        return x;
    }
    add(x) {
        this.L.push(x);
        this.fixup(this.count());
    }
    /* eslint-disable no-bitwise */
    fixup(k) {
        let _k = k;
        while (_k > 1 && (this.comp.compare(this.L[_k >> 1], this.L[_k]) > 0)) {
            const tmp = this.L[_k >> 1];
            this.L[_k >> 1] = this.L[_k];
            this.L[_k] = tmp;
            _k = _k >> 1;
        }
    }
    fixDown(k) {
        let _k = k;
        while ((_k << 1) <= (this.count())) {
            let j = _k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[_k], this.L[j]) <= 0) {
                break;
            }
            const tmp = this.L[_k];
            this.L[_k] = this.L[j];
            this.L[j] = tmp;
            _k = j;
        }
    }
}
const RBColor = {
    RED: 0,
    BLACK: 1,
};
class RedBlackTree {
    constructor(compareKeys, aug) {
        this.compareKeys = compareKeys;
        this.aug = aug;
    }
    makeNode(key, data, color, size) {
        return { key, data, color, size };
    }
    isRed(node) {
        return !!node && (node.color === RBColor.RED);
    }
    nodeSize(node) {
        return node ? node.size : 0;
    }
    size() {
        return this.nodeSize(this.root);
    }
    isEmpty() {
        return !this.root;
    }
    get(key) {
        if (key !== undefined) {
            return this.nodeGet(this.root, key);
        }
    }
    nodeGet(node, key) {
        let _node = node;
        while (_node) {
            const cmp = this.compareKeys(key, _node.key);
            if (cmp < 0) {
                _node = _node.left;
            }
            else if (cmp > 0) {
                _node = _node.right;
            }
            else {
                return _node;
            }
        }
    }
    contains(key) {
        return this.get(key);
    }
    gather(key, matcher) {
        const results = [];
        if (key !== undefined) {
            this.nodeGather(this.root, results, key, matcher);
        }
        return results;
    }
    nodeGather(node, results, key, matcher) {
        if (node) {
            if (matcher.continueSubtree(node.left, key)) {
                this.nodeGather(node.left, results, key, matcher);
            }
            if (matcher.matchNode(node, key)) {
                results.push(node);
            }
            if (matcher.continueSubtree(node.right, key)) {
                this.nodeGather(node.right, results, key, matcher);
            }
        }
    }
    walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn) {
        this.nodeWalkExactMatchesForward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);
    }
    nodeWalkExactMatchesForward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {
        if (!node) {
            return;
        }
        const result = compareFn(node);
        if (continueLeftFn(result)) {
            this.nodeWalkExactMatchesForward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
        if (result === 0) {
            actionFn(node);
        }
        if (continueRightFn(result)) {
            this.nodeWalkExactMatchesForward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
    }
    walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn) {
        this.nodeWalkExactMatchesBackward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);
    }
    nodeWalkExactMatchesBackward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {
        if (!node) {
            return;
        }
        const result = compareFn(node);
        if (continueRightFn(result)) {
            this.nodeWalkExactMatchesBackward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
        if (result === 0) {
            actionFn(node);
        }
        if (continueLeftFn(result)) {
            this.nodeWalkExactMatchesBackward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
    }
    put(key, data, conflict) {
        if (key !== undefined) {
            if (data === undefined) {
                this.remove(key);
            }
            else {
                this.root = this.nodePut(this.root, key, data, conflict);
                this.root.color = RBColor.BLACK;
            }
        }
    }
    nodePut(node, key, data, conflict) {
        let _node = node;
        if (!_node) {
            return this.makeNode(key, data, RBColor.RED, 1);
        }
        else {
            const cmp = this.compareKeys(key, _node.key);
            if (cmp < 0) {
                _node.left = this.nodePut(_node.left, key, data, conflict);
            }
            else if (cmp > 0) {
                _node.right = this.nodePut(_node.right, key, data, conflict);
            }
            else {
                if (conflict) {
                    const kd = conflict(key, _node.key, data, _node.data);
                    if (kd.key) {
                        _node.key = kd.key;
                    }
                    if (kd.data) {
                        _node.data = kd.data;
                    }
                    else {
                        _node.data = data;
                    }
                }
                else {
                    _node.data = data;
                }
            }
            if (this.isRed(_node.right) && (!this.isRed(_node.left))) {
                _node = this.rotateLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (this.isRed(_node.left) && this.isRed(_node.left.left)) {
                _node = this.rotateRight(_node);
            }
            if (this.isRed(_node.left) && this.isRed(_node.right)) {
                this.flipColors(_node);
            }
            _node.size = this.nodeSize(_node.left) + this.nodeSize(_node.right) + 1;
            if (this.aug) {
                this.updateLocal(_node);
            }
            return _node;
        }
    }
    updateLocal(node) {
        if (this.aug) {
            if (this.isRed(node.left)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.aug.update(node.left);
            }
            if (this.isRed(node.right)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.aug.update(node.right);
            }
            this.aug.update(node);
        }
    }
    nodeRemoveMin(node) {
        let _node = node;
        if (_node.left) {
            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {
                _node = this.moveRedLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.left = this.nodeRemoveMin(_node.left);
            return this.balance(_node);
        }
    }
    remove(key) {
        if (key !== undefined) {
            if (!this.contains(key)) {
                return;
            }
            this.removeExisting(key);
        }
        // TODO: error on undefined key
    }
    removeExisting(key) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.root.color = RBColor.RED;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.root = this.nodeRemove(this.root, key);
    }
    nodeRemove(node, key) {
        let _node = node;
        if (this.compareKeys(key, _node.key) < 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {
                _node = this.moveRedLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.left = this.nodeRemove(_node.left, key);
        }
        else {
            if (this.isRed(_node.left)) {
                _node = this.rotateRight(_node);
            }
            if ((this.compareKeys(key, _node.key) === 0) && (!_node.right)) {
                return undefined;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {
                _node = this.moveRedRight(_node);
            }
            if (this.compareKeys(key, _node.key) === 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const subtreeMin = this.nodeMin(_node.right);
                _node.key = subtreeMin.key;
                _node.data = subtreeMin.data;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _node.right = this.nodeRemoveMin(_node.right);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _node.right = this.nodeRemove(_node.right, key);
            }
        }
        return this.balance(_node);
    }
    floor(key) {
        if (!this.isEmpty()) {
            return this.nodeFloor(this.root, key);
        }
    }
    nodeFloor(node, key) {
        if (node) {
            const cmp = this.compareKeys(key, node.key);
            if (cmp === 0) {
                return node;
            }
            else if (cmp < 0) {
                return this.nodeFloor(node.left, key);
            }
            else {
                const rightFloor = this.nodeFloor(node.right, key);
                if (rightFloor) {
                    return rightFloor;
                }
                else {
                    return node;
                }
            }
        }
    }
    ceil(key) {
        if (!this.isEmpty()) {
            return this.nodeCeil(this.root, key);
        }
    }
    nodeCeil(node, key) {
        if (node) {
            const cmp = this.compareKeys(key, node.key);
            if (cmp === 0) {
                return node;
            }
            else if (cmp > 0) {
                return this.nodeCeil(node.right, key);
            }
            else {
                const leftCeil = this.nodeCeil(node.left, key);
                if (leftCeil) {
                    return leftCeil;
                }
                else {
                    return node;
                }
            }
        }
    }
    min() {
        if (this.root) {
            return this.nodeMin(this.root);
        }
    }
    nodeMin(node) {
        if (!node.left) {
            return node;
        }
        else {
            return this.nodeMin(node.left);
        }
    }
    max() {
        if (this.root) {
            return this.nodeMax(this.root);
        }
    }
    nodeMax(node) {
        if (!node.right) {
            return node;
        }
        else {
            return this.nodeMax(node.right);
        }
    }
    rotateRight(node) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const leftChild = node.left;
        node.left = leftChild.right;
        leftChild.right = node;
        leftChild.color = leftChild.right.color;
        leftChild.right.color = RBColor.RED;
        leftChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(leftChild);
        }
        return leftChild;
    }
    rotateLeft(node) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const rightChild = node.right;
        node.right = rightChild.left;
        rightChild.left = node;
        rightChild.color = rightChild.left.color;
        rightChild.left.color = RBColor.RED;
        rightChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(rightChild);
        }
        return rightChild;
    }
    oppositeColor(c) {
        return (c === RBColor.BLACK) ? RBColor.RED : RBColor.BLACK;
    }
    flipColors(node) {
        node.color = this.oppositeColor(node.color);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node.left.color = this.oppositeColor(node.left.color);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node.right.color = this.oppositeColor(node.right.color);
    }
    moveRedLeft(node) {
        let _node = node;
        this.flipColors(_node);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(_node.right.left)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.right = this.rotateRight(_node.right);
            _node = this.rotateLeft(_node);
            this.flipColors(_node);
        }
        return _node;
    }
    moveRedRight(node) {
        let _node = node;
        this.flipColors(_node);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(_node.left.left)) {
            _node = this.rotateRight(_node);
            this.flipColors(_node);
        }
        return _node;
    }
    balance(input) {
        let node = input;
        if (this.isRed(node.right)) {
            node = this.rotateLeft(node);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(node.left) && this.isRed(node.left.left)) {
            node = this.rotateRight(node);
        }
        if (this.isRed(node.left) && (this.isRed(node.right))) {
            this.flipColors(node);
        }
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.aug.update(node);
        }
        return node;
    }
    mapRange(action, accum, start, end) {
        this.nodeMap(this.root, action, start, end);
    }
    map(action, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, action, accum);
    }
    keys() {
        const keyList = [];
        const actions = {
            showStructure: true,
            infix: (node) => {
                keyList.push(node.key);
                return true;
            },
        };
        this.walk(actions);
        return keyList;
    }
    /**
     * Depth-first traversal with custom action; if action returns
     * false, traversal is halted.
     * @param action - action to apply to each node
     */
    walk(actions) {
        this.nodeWalk(this.root, actions);
    }
    walkBackward(actions) {
        this.nodeWalkBackward(this.root, actions);
    }
    nodeWalk(node, actions) {
        let go = true;
        if (node) {
            if (actions.pre) {
                if (actions.showStructure || (node.color === RBColor.BLACK)) {
                    go = actions.pre(node);
                }
            }
            if (node.left) {
                go = this.nodeWalk(node.left, actions);
            }
            if (go && actions.infix) {
                if (actions.showStructure || (node.color === RBColor.BLACK)) {
                    go = actions.infix(node);
                }
            }
            if (go) {
                go = this.nodeWalk(node.right, actions);
            }
            if (go && actions.post) {
                if (actions.showStructure || (node.color === RBColor.BLACK)) {
                    go = actions.post(node);
                }
            }
        }
        return go;
    }
    nodeWalkBackward(node, actions) {
        let go = true;
        if (node) {
            if (actions.pre) {
                if (actions.showStructure || (node.color === RBColor.BLACK)) {
                    go = actions.pre(node);
                }
            }
            if (node.right) {
                go = this.nodeWalkBackward(node.right, actions);
            }
            if (go && actions.infix) {
                if (actions.showStructure || (node.color === RBColor.BLACK)) {
                    go = actions.infix(node);
                }
            }
            if (go) {
                go = this.nodeWalkBackward(node.left, actions);
            }
            if (go && actions.post) {
                if (actions.showStructure || (node.color === RBColor.BLACK)) {
                    go = actions.post(node);
                }
            }
        }
        return go;
    }
    nodeMap(node, action, accum, start, end) {
        let _start = start;
        let _end = end;
        if (!node) {
            return true;
        }
        if (_start === undefined) {
            _start = this.nodeMin(node).key;
        }
        if (_end === undefined) {
            _end = this.nodeMax(node).key;
        }
        const cmpStart = this.compareKeys(_start, node.key);
        const cmpEnd = this.compareKeys(_end, node.key);
        let go = true;
        if (cmpStart < 0) {
            go = this.nodeMap(node.left, action, accum, _start, _end);
        }
        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {
            // REVIEW: test for black node here
            go = action(node, accum);
        }
        if (go && (cmpEnd > 0)) {
            go = this.nodeMap(node.right, action, accum, _start, _end);
        }
        return go;
    }
}
const integerRangeToString = (range) => `[${range.start},${range.end})`;
const intervalComparer = (a, b) => a.compare(b);
class IntervalTree {
    constructor() {
        this.intervals = new RedBlackTree(intervalComparer, this);
    }
    remove(x) {
        this.intervals.remove(x);
    }
    removeExisting(x) {
        this.intervals.removeExisting(x);
    }
    put(x, conflict) {
        let rbConflict;
        if (conflict) {
            rbConflict = (key, currentKey) => {
                const ival = conflict(key, currentKey);
                return {
                    key: ival,
                };
            };
        }
        this.intervals.put(x, { minmax: x.clone() }, rbConflict);
    }
    map(fn) {
        const actions = {
            infix: (node) => {
                fn(node.key);
                return true;
            },
            showStructure: true,
        };
        this.intervals.walk(actions);
    }
    mapUntil(fn) {
        const actions = {
            infix: (node) => {
                return fn(node.key);
            },
            showStructure: true,
        };
        this.intervals.walk(actions);
    }
    mapBackward(fn) {
        const actions = {
            infix: (node) => {
                fn(node.key);
                return true;
            },
            showStructure: true,
        };
        this.intervals.walkBackward(actions);
    }
    // TODO: toString()
    match(x) {
        return this.intervals.gather(x, this);
    }
    matchNode(node, key) {
        return !!node && node.key.overlaps(key);
    }
    continueSubtree(node, key) {
        return !!node && node.data.minmax.overlaps(key);
    }
    update(node) {
        if (node.left && node.right) {
            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));
        }
        else {
            if (node.left) {
                node.data.minmax = node.key.union(node.left.data.minmax);
            }
            else if (node.right) {
                node.data.minmax = node.key.union(node.right.data.minmax);
            }
            else {
                node.data.minmax = node.key.clone();
            }
        }
    }
}
class TST {
    constructor() {
        this.n = 0;
    }
    size() {
        return this.n;
    }
    contains(key) {
        return this.get(key);
    }
    get(key) {
        const x = this.nodeGet(this.root, key, 0);
        if (x === undefined) {
            return undefined;
        }
        return x.val;
    }
    nodeGet(x, key, d) {
        if (x === undefined) {
            return undefined;
        }
        const c = key.charAt(d);
        if (c < x.c) {
            return this.nodeGet(x.left, key, d);
        }
        else if (c > x.c) {
            return this.nodeGet(x.right, key, d);
        }
        else if (d < (key.length - 1)) {
            return this.nodeGet(x.mid, key, d + 1);
        }
        else {
            return x;
        }
    }
    put(key, val) {
        if (!this.contains(key)) {
            this.n++;
        }
        this.root = this.nodePut(this.root, key, val, 0);
    }
    nodePut(x, key, val, d) {
        let _x = x;
        const c = key.charAt(d);
        if (_x === undefined) {
            _x = { c };
        }
        if (c < _x.c) {
            _x.left = this.nodePut(_x.left, key, val, d);
        }
        else if (c > _x.c) {
            _x.right = this.nodePut(_x.right, key, val, d);
        }
        else if (d < (key.length - 1)) {
            _x.mid = this.nodePut(_x.mid, key, val, d + 1);
        }
        else {
            _x.val = val;
        }
        return _x;
    }
    neighbors(text, distance = 2) {
        let q = [];
        this.nodeProximity(this.root, { text: "" }, 0, text, distance, q);
        q = q.filter((value) => (value.text.length > 0));
        return q;
    }
    keysWithPrefix(text) {
        const q = [];
        const x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push(text);
        }
        this.collect(x.mid, { text }, q);
        return q;
    }
    collect(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collect(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push(prefix.text + x.c);
        }
        this.collect(x.mid, { text: prefix.text + x.c }, q);
        this.collect(x.right, prefix, q);
    }
    mapNode(x, prefix, fn) {
        if (x === undefined) {
            return;
        }
        const key = prefix.text + x.c;
        this.mapNode(x.left, prefix, fn);
        if (x.val) {
            fn(key, x.val);
        }
        this.mapNode(x.mid, { text: key }, fn);
        this.mapNode(x.right, prefix, fn);
    }
    map(fn) {
        this.mapNode(this.root, { text: "" }, fn);
    }
    pairsWithPrefix(text) {
        const q = [];
        const x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push({ key: text, val: x.val });
        }
        this.collectPairs(x.mid, { text }, q);
        return q;
    }
    collectPairs(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collectPairs(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push({ key: prefix.text + x.c, val: x.val });
        }
        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);
        this.collectPairs(x.right, prefix, q);
    }
    nodeProximity(x, prefix, d, pattern, distance, q) {
        if ((x === undefined) || (distance < 0)) {
            return;
        }
        const c = pattern.charAt(d);
        if ((distance > 0) || (c < x.c)) {
            this.nodeProximity(x.left, prefix, d, pattern, distance, q);
        }
        if (x.val !== undefined) {
            const remD = distance - (pattern.length - d);
            if (remD >= 0) {
                let invD = distance;
                if (c !== x.c) {
                    invD--;
                }
                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });
            }
        }
        const recurD = (d < (pattern.length - 1)) ? d + 1 : d;
        if (c === x.c) {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);
        }
        else {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);
        }
        if ((distance > 0) || (c > x.c)) {
            this.nodeProximity(x.right, prefix, d, pattern, distance, q);
        }
    }
}
//# sourceMappingURL=collections.js.map

/***/ }),
/* 288 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 289 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 290 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedString": () => (/* binding */ SharedString)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(294);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(305);
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(291);
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * The Shared String is a specialized data structure for handling collaborative
 * text. It is based on a more general Sequence data structure but has
 * additional features that make working with text easier.
 *
 * In addition to text, a Shared String can also contain markers. Markers can be
 * used to store metadata at positions within the text, like the details of an
 * image or Fluid object that should be rendered with the text.
 *
 */
class SharedString extends _sequence__WEBPACK_IMPORTED_MODULE_0__.SharedSegmentSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory.segmentFromSpec);
        this.id = id;
        this.mergeTreeTextHelper = this.client.createTextHelper();
    }
    /**
     * Create a new shared string.
     * @param runtime - data store runtime the new shared string belongs to
     * @param id - optional name of the shared string
     * @returns newly create shared string (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory.Type);
    }
    /**
     * Get a factory for SharedString to register with the data store.
     * @returns a factory that creates and load SharedString
     */
    static getFactory() {
        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedStringFactory();
    }
    get ISharedString() {
        return this;
    }
    /**
     * Inserts a marker at a relative position.
     * @param relativePos1 - The relative position to insert the marker at
     * @param refType - The reference type of the marker
     * @param props - The properties of the marker
     */
    insertMarkerRelative(relativePos1, refType, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Marker(refType);
        if (props) {
            segment.addProperties(props);
        }
        const pos = this.posFromRelativePos(relativePos1);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * {@inheritDoc ISharedString.insertMarker}
     */
    insertMarker(pos, refType, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Marker(refType);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
        return insertOp;
    }
    /**
     * Inserts the text at the position.
     * @param relativePos1 - The relative position to insert the text at
     * @param text - The text to insert
     * @param props - The properties of text
     */
    insertTextRelative(relativePos1, text, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment(text);
        if (props) {
            segment.addProperties(props);
        }
        const pos = this.posFromRelativePos(relativePos1);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * {@inheritDoc ISharedString.insertText}
     */
    insertText(pos, text, props) {
        const segment = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment(text);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * Replaces a range with the provided text.
     * @param start - The inclusive start of the range to replace
     * @param end - The exclusive end of the range to replace
     * @param text - The text to replace the range with
     * @param props - Optional. The properties of the replacement text
     */
    replaceText(start, end, text, props) {
        this.replaceRange(start, end, _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_3__.TextSegment.make(text, props));
    }
    /**
     * Removes the text in the given range.
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to replace
     * @returns the message sent.
     */
    removeText(start, end) {
        return this.removeRange(start, end);
    }
    /**
     * Annotates the marker with the provided properties and calls the callback on consensus.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param consensusCallback - The callback called when consensus is reached
     */
    annotateMarkerNotifyConsensus(marker, props, callback) {
        const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    /**
     * Annotates the marker with the provided properties.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     */
    annotateMarker(marker, props, combiningOp) {
        const annotateOp = this.client.annotateMarker(marker, props, combiningOp);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    findTile(startPos, tileLabel, preceding = true) {
        return this.client.findTile(startPos, tileLabel, preceding);
    }
    getTextAndMarkers(label) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);
    }
    /**
     * Retrieve text from the SharedString in string format.
     * @param start - The starting index of the text to retrieve, or 0 if omitted.
     * @param end - The ending index of the text to retrieve, or the end of the string if omitted
     * @returns The requested text content as a string.
     */
    getText(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, "", start, end);
    }
    /**
     * Adds spaces for markers and handles, so that position calculations account for them.
     */
    getTextWithPlaceholders() {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ");
    }
    getTextRangeWithPlaceholders(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ", start, end);
    }
    getTextRangeWithMarkers(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, "*", start, end);
    }
    getMarkerFromId(id) {
        return this.client.getMarkerFromId(id);
    }
}
//# sourceMappingURL=sharedString.js.map

/***/ }),
/* 291 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedSegmentSequence": () => (/* binding */ SharedSegmentSequence)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(292);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(314);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(288);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(316);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(293);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(281);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(284);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(300);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(286);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(91);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(315);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(138);
/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(279);
/* harmony import */ var _defaultMap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(312);
/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(311);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */









const snapshotFileName = "header";
const contentPath = "content";
class SharedSegmentSequence extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.SharedObject {
    constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {
        super(id, dataStoreRuntime, attributes, "fluid_sequence_");
        this.dataStoreRuntime = dataStoreRuntime;
        this.id = id;
        this.segmentFromSpec = segmentFromSpec;
        // Deferred that triggers once the object is loaded
        this.loadedDeferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        // cache out going ops created when partial loading
        this.loadedDeferredOutgoingOps = [];
        // cache incoming ops that arrive when partial loading
        this.deferIncomingOps = true;
        this.loadedDeferredIncomingOps = [];
        this.messagesSinceMSNChange = [];
        this.loadedDeferred.promise.catch((error) => {
            this.logger.sendErrorEvent({ eventName: "SequenceLoadFailed" }, error);
        });
        this.client = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_2__.Client(segmentFromSpec, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.ChildLogger.create(this.logger, "SharedSegmentSequence.MergeTreeClient"), dataStoreRuntime.options);
        super.on("newListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (!this.client.mergeTreeDeltaCallback) {
                        this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {
                            this.emit("sequenceDelta", new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);
                        };
                    }
                    break;
                case "maintenance":
                    if (!this.client.mergeTreeMaintenanceCallback) {
                        this.client.mergeTreeMaintenanceCallback = (args, opArgs) => {
                            this.emit("maintenance", new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__.SequenceMaintenanceEvent(opArgs, args, this.client), this);
                        };
                    }
                    break;
                default:
            }
        });
        super.on("removeListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTreeDeltaCallback = undefined;
                    }
                    break;
                case "maintenance":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTreeMaintenanceCallback = undefined;
                    }
                    break;
                default:
                    break;
            }
        });
        this.intervalCollections = new _defaultMap__WEBPACK_IMPORTED_MODULE_5__.DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new _intervalCollection__WEBPACK_IMPORTED_MODULE_6__.SequenceIntervalCollectionValueType());
    }
    get loaded() {
        return this.loadedDeferred.promise;
    }
    static createOpsFromDelta(event) {
        var _a, _b;
        const ops = [];
        for (const r of event.ranges) {
            switch (event.deltaOperation) {
                case _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.ANNOTATE: {
                    const lastAnnotate = ops[ops.length - 1];
                    const props = {};
                    for (const key of Object.keys(r.propertyDeltas)) {
                        props[key] = (_b = (_a = r.segment.properties) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;
                    }
                    if (lastAnnotate && lastAnnotate.pos2 === r.position &&
                        (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_8__.matchProperties)(lastAnnotate.props, props)) {
                        lastAnnotate.pos2 += r.segment.cachedLength;
                    }
                    else {
                        ops.push((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createAnnotateRangeOp)(r.position, r.position + r.segment.cachedLength, props, undefined));
                    }
                    break;
                }
                case _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.INSERT:
                    ops.push((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createInsertOp)(r.position, r.segment.clone().toJSONObject()));
                    break;
                case _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.REMOVE: {
                    const lastRem = ops[ops.length - 1];
                    if ((lastRem === null || lastRem === void 0 ? void 0 : lastRem.pos1) === r.position) {
                        lastRem.pos2 += r.segment.cachedLength;
                    }
                    else {
                        ops.push((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createRemoveRangeOp)(r.position, r.position + r.segment.cachedLength));
                    }
                    break;
                }
                default:
            }
        }
        return ops;
    }
    /**
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    removeRange(start, end) {
        const removeOp = this.client.removeRangeLocal(start, end);
        if (removeOp) {
            this.submitSequenceMessage(removeOp);
        }
        return removeOp;
    }
    groupOperation(groupOp) {
        this.client.localTransaction(groupOp);
        this.submitSequenceMessage(groupOp);
    }
    getContainingSegment(pos) {
        return this.client.getContainingSegment(pos);
    }
    /**
     * Returns the length of the current sequence for the client
     */
    getLength() {
        return this.client.getLength();
    }
    /**
     * Returns the current position of a segment, and -1 if the segment
     * does not exist in this sequence
     * @param segment - The segment to get the position of
     */
    getPosition(segment) {
        return this.client.getPosition(segment);
    }
    /**
     * Annotates the range with the provided properties
     *
     * @param start - The inclusive start position of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     *
     */
    annotateRange(start, end, props, combiningOp) {
        const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    getPropertiesAtPosition(pos) {
        return this.client.getPropertiesAtPosition(pos);
    }
    getRangeExtentsOfPosition(pos) {
        return this.client.getRangeExtentsOfPosition(pos);
    }
    /**
     * @deprecated - use createLocalReferencePosition
     */
    createPositionReference(segment, offset, refType) {
        const lref = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_10__.LocalReference(this.client, segment, offset, refType);
        if (refType !== _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.ReferenceType.Transient) {
            this.addLocalReference(lref);
        }
        return lref;
    }
    createLocalReferencePosition(segment, offset, refType, properties) {
        return this.client.createLocalReferencePosition(segment, offset, refType, properties);
    }
    /**
     * @deprecated - use localReferencePositionToPosition
     */
    localRefToPos(localRef) {
        return this.client.localReferencePositionToPosition(localRef);
    }
    localReferencePositionToPosition(lref) {
        return this.client.localReferencePositionToPosition(lref);
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence. The client ref seq must be above the minimum sequence number
     * or the return value will be undefined.
     * Generally this method is used in conjunction with signals which provide
     * point in time values for the below parameters, and is useful for things
     * like displaying user position. It should not be used with persisted values
     * as persisted values will quickly become invalid as the remoteClientRefSeq
     * moves below the minimum sequence number
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);
    }
    submitSequenceMessage(message) {
        if (!this.isAttached()) {
            return;
        }
        const translated = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__.makeHandlesSerializable)(message, this.serializer, this.handle);
        const metadata = this.client.peekPendingSegmentGroups(message.type === _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_7__.MergeTreeDeltaType.GROUP ? message.ops.length : 1);
        // if loading isn't complete, we need to cache
        // local ops until loading is complete, and then
        // they will be resent
        if (!this.loadedDeferred.isCompleted) {
            this.loadedDeferredOutgoingOps.push([translated, metadata]);
        }
        else {
            this.submitLocalMessage(translated, metadata);
        }
    }
    /**
     * @deprecated - use createLocalReferencePosition
     */
    addLocalReference(lref) {
        return this.client.addLocalReference(lref);
    }
    /**
     * @deprecated - use removeLocalReferencePosition
     */
    removeLocalReference(lref) {
        return this.client.removeLocalReferencePosition(lref);
    }
    removeLocalReferencePosition(lref) {
        return this.client.removeLocalReferencePosition(lref);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     */
    posFromRelativePos(relativePos) {
        return this.client.posFromRelativePos(relativePos);
    }
    /**
     * Walk the underlying segments of the sequence.
     * The walked segments may extend beyond the range
     * if the segments cross the ranges start or end boundaries.
     * Set split range to true to ensure only segments within the
     * range are walked.
     *
     * @param handler - The function to handle each segment
     * @param start - Optional. The start of range walk.
     * @param end - Optional. The end of range walk
     * @param accum - Optional. An object that will be passed to the handler for accumulation
     * @param splitRange - Optional. Splits boundary segments on the range boundaries
     */
    walkSegments(handler, start, end, accum, splitRange = false) {
        return this.client.walkSegments(handler, start, end, accum, splitRange);
    }
    getStackContext(startPos, rangeLabels) {
        return this.client.getStackContext(startPos, rangeLabels);
    }
    getCurrentSeq() {
        return this.client.getCurrentSeq();
    }
    insertAtReferencePosition(pos, segment) {
        const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates
     * are supported. Use `getIntervalCollection` instead.
     */
    async waitIntervalCollection(label) {
        return this.intervalCollections.get(label);
    }
    getIntervalCollection(label) {
        return this.intervalCollections.get(label);
    }
    /**
     * @returns an iterable object that enumerates the IntervalCollection labels
     * Usage:
     * const iter = this.getIntervalCollectionKeys();
     * for (key of iter)
     *     const collection = this.getIntervalCollection(key);
     *     ...
    */
    getIntervalCollectionLabels() {
        return this.intervalCollections.keys();
    }
    summarizeCore(serializer, telemetryContext) {
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_12__.SummaryTreeBuilder();
        // conditionally write the interval collection blob
        // only if it has entries
        if (this.intervalCollections.size > 0) {
            builder.addBlob(snapshotFileName, this.intervalCollections.serialize(serializer));
        }
        builder.addWithStats(contentPath, this.summarizeMergeTree(serializer));
        return builder.getSummaryTree();
    }
    /**
     * Runs serializer over the GC data for this SharedMatrix.
     * All the IFluidHandle's represent routes to other objects.
     */
    processGCDataCore(serializer) {
        if (this.intervalCollections.size > 0) {
            this.intervalCollections.serialize(serializer);
        }
        this.client.serializeGCData(this.handle, serializer);
    }
    /**
     * Replace the range specified from start to end with the provided segment
     * This is done by inserting the segment at the end of the range, followed
     * by removing the contents of the range
     * For a zero or reverse range (start \>= end), insert at end do not remove anything
     * @param start - The start of the range to replace
     * @param end - The end of the range to replace
     * @param segment - The segment that will replace the range
     */
    replaceRange(start, end, segment) {
        // Insert at the max end of the range when start > end, but still remove the range later
        const insertIndex = Math.max(start, end);
        // Insert first, so local references can slide to the inserted seg if any
        const insert = this.client.insertSegmentLocal(insertIndex, segment);
        if (insert) {
            if (start < end) {
                const remove = this.client.removeRangeLocal(start, end);
                this.submitSequenceMessage((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createGroupOp)(insert, remove));
            }
            else {
                this.submitSequenceMessage(insert);
            }
        }
    }
    onConnect() {
        // Update merge tree collaboration information with new client ID and then resend pending ops
        this.client.startOrUpdateCollaboration(this.runtime.clientId);
    }
    onDisconnect() { }
    reSubmitCore(content, localOpMetadata) {
        if (!this.intervalCollections.tryResubmitMessage(content, localOpMetadata)) {
            this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        var _a;
        if (await storage.contains(snapshotFileName)) {
            const blob = await storage.readBlob(snapshotFileName);
            const header = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_13__.bufferToString)(blob, "utf8");
            this.intervalCollections.populate(header);
        }
        try {
            // this will load the header, and return a promise
            // that will resolve when the body is loaded
            // and the catchup ops are available.
            const { catchupOpsP } = await this.client.load(this.runtime, new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_14__.ObjectStoragePartition(storage, contentPath), this.serializer);
            // setup a promise to process the
            // catch up ops, and finishing the loading process
            const loadCatchUpOps = catchupOpsP
                .then((msgs) => {
                msgs.forEach((m) => {
                    const collabWindow = this.client.getCollabWindow();
                    if (m.minimumSequenceNumber < collabWindow.minSeq
                        || m.referenceSequenceNumber < collabWindow.minSeq
                        || m.sequenceNumber <= collabWindow.minSeq
                        || m.sequenceNumber <= collabWindow.currentSeq) {
                        throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({
                            op: {
                                seq: m.sequenceNumber,
                                minSeq: m.minimumSequenceNumber,
                                refSeq: m.referenceSequenceNumber,
                            },
                            collabWindow: {
                                seq: collabWindow.currentSeq,
                                minSeq: collabWindow.minSeq,
                            },
                        })}`);
                    }
                    this.processMergeTreeMsg(m);
                });
                this.loadFinished();
            })
                .catch((error) => {
                this.loadFinished(error);
            });
            if (((_a = this.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {
                // if we not doing partial load, await the catch up ops,
                // and the finalization of the load
                await loadCatchUpOps;
            }
        }
        catch (error) {
            this.loadFinished(error);
        }
    }
    processCore(message, local, localOpMetadata) {
        // if loading isn't complete, we need to cache all
        // incoming ops to be applied after loading is complete
        if (this.deferIncomingOps) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(!local, 0x072 /* "Unexpected local op when loading not finished" */);
            this.loadedDeferredIncomingOps.push(message);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.MessageType.Operation, 0x073 /* "Sequence message not operation" */);
            const handled = this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);
            if (!handled) {
                this.processMergeTreeMsg(message, local);
            }
        }
    }
    didAttach() {
        var _a;
        // If we are not local, and we've attached we need to start generating and sending ops
        // so start collaboration and provide a default client id incase we are not connected
        if (this.isAttached()) {
            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : "attached");
        }
    }
    initializeLocalCore() {
        super.initializeLocalCore();
        this.loadFinished();
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}
     */
    applyStashedOp(content) {
        return this.client.applyStashedOp(content);
    }
    summarizeMergeTree(serializer) {
        // Are we fully loaded? If not, things will go south
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(this.loadedDeferred.isCompleted, 0x074 /* "Snapshot called when not fully loaded" */);
        const minSeq = this.runtime.deltaManager.minimumSequenceNumber;
        this.processMinSequenceNumberChanged(minSeq);
        this.messagesSinceMSNChange.forEach((m) => { m.minimumSequenceNumber = minSeq; });
        return this.client.summarize(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);
    }
    processMergeTreeMsg(rawMessage, local) {
        var _a, _b;
        const message = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_11__.parseHandles)(rawMessage, this.serializer);
        const ops = [];
        function transformOps(event) {
            ops.push(...SharedSegmentSequence.createOpsFromDelta(event));
        }
        const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;
        let stashMessage = message;
        if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {
            if (needsTransformation) {
                this.on("sequenceDelta", transformOps);
            }
        }
        this.client.applyMsg(message, local);
        if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {
            if (needsTransformation) {
                this.removeListener("sequenceDelta", transformOps);
                // shallow clone the message as we only overwrite top level properties,
                // like referenceSequenceNumber and content only
                stashMessage = Object.assign(Object.assign({}, message), { referenceSequenceNumber: stashMessage.sequenceNumber - 1, contents: ops.length !== 1 ? (0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_9__.createGroupOp)(...ops) : ops[0] });
            }
            this.messagesSinceMSNChange.push(stashMessage);
            // Do GC every once in a while...
            if (this.messagesSinceMSNChange.length > 20
                && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {
                this.processMinSequenceNumberChanged(message.minimumSequenceNumber);
            }
        }
    }
    processMinSequenceNumberChanged(minSeq) {
        let index = 0;
        for (; index < this.messagesSinceMSNChange.length; index++) {
            if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {
                break;
            }
        }
        if (index !== 0) {
            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);
        }
    }
    loadFinished(error) {
        if (!this.loadedDeferred.isCompleted) {
            // Initialize the interval collections
            this.initializeIntervalCollections();
            if (error) {
                this.loadedDeferred.reject(error);
                throw error;
            }
            else {
                // it is important this series remains synchronous
                // first we stop deferring incoming ops, and apply then all
                this.deferIncomingOps = false;
                for (const message of this.loadedDeferredIncomingOps) {
                    this.processCore(message, false, undefined);
                }
                this.loadedDeferredIncomingOps.length = 0;
                // then resolve the loaded promise
                // and resubmit all the outstanding ops, as the snapshot
                // is fully loaded, and all outstanding ops are applied
                this.loadedDeferred.resolve();
                for (const [messageContent, opMetadata] of this.loadedDeferredOutgoingOps) {
                    this.reSubmitCore(messageContent, opMetadata);
                }
                this.loadedDeferredOutgoingOps.length = 0;
            }
        }
    }
    initializeIntervalCollections() {
        // Listen and initialize new SharedIntervalCollections
        this.intervalCollections.eventEmitter.on("create", ({ key, previousValue }, local) => {
            const intervalCollection = this.intervalCollections.get(key);
            if (!intervalCollection.attached) {
                intervalCollection.attachGraph(this.client, key);
            }
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_15__.assert)(previousValue === undefined, 0x2c1 /* "Creating an interval collection that already exists?" */);
            this.emit("createIntervalCollection", key, local, this);
        });
        // Initialize existing SharedIntervalCollections
        for (const key of this.intervalCollections.keys()) {
            const intervalCollection = this.intervalCollections.get(key);
            intervalCollection.attachGraph(this.client, key);
        }
    }
}
//# sourceMappingURL=sequence.js.map

/***/ }),
/* 292 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),
/* 293 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Client": () => (/* binding */ Client)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(304);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(301);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(283);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(303);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(285);
/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(286);
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);
/* harmony import */ var _opBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(300);
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(281);
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(307);
/* harmony import */ var _snapshotLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(310);
/* harmony import */ var _textSegment__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(305);
/* harmony import */ var _snapshotV1__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(306);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */













function elapsedMicroseconds(trace) {
    return trace.trace().duration * 1000;
}
class Client {
    constructor(
    // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence
    specToSegment, logger, options) {
        this.specToSegment = specToSegment;
        this.logger = logger;
        this.measureOps = false;
        this.accumTime = 0;
        this.localTime = 0;
        this.localOps = 0;
        this.accumWindowTime = 0;
        this.accumWindow = 0;
        this.accumOps = 0;
        this.maxWindowTime = 0;
        this.clientNameToIds = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareStrings);
        this.shortClientIdMap = [];
        this.pendingConsensus = new Map();
        this.mergeTree = new _mergeTree__WEBPACK_IMPORTED_MODULE_1__.MergeTree(options);
    }
    get mergeTreeDeltaCallback() { return this.mergeTree.mergeTreeDeltaCallback; }
    set mergeTreeDeltaCallback(callback) {
        this.mergeTree.mergeTreeDeltaCallback = callback;
    }
    get mergeTreeMaintenanceCallback() {
        return this.mergeTree.mergeTreeMaintenanceCallback;
    }
    set mergeTreeMaintenanceCallback(callback) {
        this.mergeTree.mergeTreeMaintenanceCallback = callback;
    }
    /**
     * The merge tree maintains a queue of segment groups for each local operation.
     * These segment groups track segments modified by an operation.
     * This method peeks the tail of that queue, and returns the segments groups there.
     * It is used to get the segment group(s) for the previous operations.
     * @param count - The number segment groups to get peek from the tail of the queue. Default 1.
     */
    peekPendingSegmentGroups(count = 1) {
        var _a, _b;
        if (count === 1) {
            return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();
        }
        let taken = 0;
        return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {
            if (taken < count) {
                taken++;
                return true;
            }
            return false;
        }, true);
    }
    /**
     * Annotate a marker and call the callback on consensus.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param consensusCallback - The callback called when consensus is reached
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateMarkerNotifyConsensus(marker, props, consensusCallback) {
        const combiningOp = {
            name: "consensus",
        };
        const annotateOp = this.annotateMarker(marker, props, combiningOp);
        if (annotateOp) {
            const consensusInfo = {
                callback: consensusCallback,
                marker,
            };
            this.pendingConsensus.set(marker.getId(), consensusInfo);
            return annotateOp;
        }
        else {
            return undefined;
        }
    }
    /**
     * Annotates the markers with the provided properties
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateMarker(marker, props, combiningOp) {
        const annotateOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateMarkerOp)(marker, props, combiningOp);
        if (this.applyAnnotateRangeOp({ op: annotateOp })) {
            return annotateOp;
        }
        else {
            return undefined;
        }
    }
    /**
     * Annotates the range with the provided properties
     * @param start - The inclusive start position of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Specifies how to combine values for the property, such as "incr" for increment.
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateRangeLocal(start, end, props, combiningOp) {
        const annotateOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateRangeOp)(start, end, props, combiningOp);
        if (this.applyAnnotateRangeOp({ op: annotateOp })) {
            return annotateOp;
        }
        return undefined;
    }
    /**
     * Removes the range
     *
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    removeRangeLocal(start, end) {
        const removeOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createRemoveRangeOp)(start, end);
        if (this.applyRemoveRangeOp({ op: removeOp })) {
            return removeOp;
        }
        return undefined;
    }
    /**
     * @param pos - The position to insert the segment at
     * @param segment - The segment to insert
     */
    insertSegmentLocal(pos, segment) {
        if (segment.cachedLength <= 0) {
            return undefined;
        }
        const insertOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp)(pos, segment);
        if (this.applyInsertOp({ op: insertOp })) {
            return insertOp;
        }
        return undefined;
    }
    /**
     * @param refPos - The reference position to insert the segment at
     * @param segment - The segment to insert
     */
    insertAtReferencePositionLocal(refPos, segment) {
        const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());
        if (pos === _localReference__WEBPACK_IMPORTED_MODULE_3__.LocalReference.DetachedPosition) {
            return undefined;
        }
        const op = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp)(pos, segment);
        const opArgs = { op };
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);
        this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), { start: op.pos1 }, traceStart);
        return op;
    }
    walkSegments(handler, start, end, accum, splitRange = false) {
        this.mergeTree.mapRange({
            leaf: handler,
        }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);
    }
    /**
     * Serializes the data required for garbage collection. The IFluidHandles stored in all segments that haven't
     * been removed represent routes to other objects. We serialize the data in these segments using the passed in
     * serializer which keeps track of all serialized handles.
     */
    serializeGCData(handle, handleCollectingSerializer) {
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            // Only serialize segments that have not been removed.
            if (seg.removedSeq === undefined) {
                handleCollectingSerializer.stringify(seg.clone().toJSONObject(), handle);
            }
            return true;
        });
    }
    getCollabWindow() {
        return this.mergeTree.getCollabWindow();
    }
    /**
     * Returns the current position of a segment, and -1 if the segment
     * does not exist in this merge tree
     * @param segment - The segment to get the position of
     */
    getPosition(segment) {
        if ((segment === null || segment === void 0 ? void 0 : segment.parent) === undefined) {
            return -1;
        }
        return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());
    }
    /**
     * @deprecated - use createReferencePosition instead
     */
    addLocalReference(lref) {
        return this.mergeTree.addLocalReference(lref);
    }
    /**
     * @deprecated - use removeReferencePosition instead
     */
    removeLocalReference(lref) {
        return this.removeLocalReferencePosition(lref);
    }
    createLocalReferencePosition(segment, offset, refType, properties) {
        return this.mergeTree.createLocalReferencePosition(segment, offset, refType, properties, this);
    }
    removeLocalReferencePosition(lref) {
        return this.mergeTree.removeLocalReferencePosition(lref);
    }
    localReferencePositionToPosition(lref) {
        return this.mergeTree.referencePositionToLocalPosition(lref);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     */
    posFromRelativePos(relativePos) {
        return this.mergeTree.posFromRelativePos(relativePos);
    }
    getMarkerFromId(id) {
        return this.mergeTree.getMarkerFromId(id);
    }
    /**
     * Performs the remove based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the remove was applied. False if it could not be.
     */
    applyRemoveRangeOp(opArgs) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE, 0x02d /* "Unexpected op type on range remove!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     * Performs the annotate based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the annotate was applied. False if it could not be.
     */
    applyAnnotateRangeOp(opArgs) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE, 0x02e /* "Unexpected op type on range annotate!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     * Performs the insert based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the insert was applied. False if it could not be.
     */
    applyInsertOp(opArgs) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT, 0x02f /* "Unexpected op type on range insert!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let segments;
        if (op.seg) {
            segments = [this.specToSegment(op.seg)];
        }
        if (!segments || segments.length === 0) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     *
     * @param opArgs - The op args of the op to complete
     * @param clientArgs - The client args for the op
     * @param range - The range the op applied to
     * @param clockStart - Optional. The clock start if timing data should be updated.
     */
    completeAndLogOp(opArgs, clientArgs, range, traceStart) {
        if (!opArgs.sequencedMessage) {
            if (traceStart) {
                this.localTime += elapsedMicroseconds(traceStart);
                this.localOps++;
            }
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, 0x030 /* "Incoming remote op sequence# <= local collabWindow's currentSequence#" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, 0x031 /* "Incoming remote op minSequence# < local collabWindow's minSequence#" */);
            if (traceStart) {
                this.accumTime += elapsedMicroseconds(traceStart);
                this.accumOps++;
                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);
            }
        }
    }
    /**
     * Returns a valid range for the op, or undefined
     * @param op - The op to generate the range for
     * @param clientArgs - The client args for the op
     */
    getValidOpRange(op, clientArgs) {
        let start = op.pos1;
        if (start === undefined && op.relativePos1) {
            start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);
        }
        let end = op.pos2;
        if (end === undefined && op.relativePos2) {
            end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);
        }
        // Validate if local op
        if (clientArgs.clientId === this.getClientId()) {
            const length = this.getLength();
            const invalidPositions = [];
            // Validate start position
            //
            if (start === undefined
                || start < 0
                || start > length
                || start === length && op.type !== _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT) {
                invalidPositions.push("start");
            }
            // Validate end if not insert, or insert has end
            //
            if (op.type !== _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT || end !== undefined) {
                if (end === undefined || end <= start) {
                    invalidPositions.push("end");
                }
            }
            if (invalidPositions.length > 0) {
                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.LoggingError("RangeOutOfBounds", {
                    usageError: true,
                    end,
                    invalidPositions: invalidPositions.toString(),
                    length,
                    opPos1: op.pos1,
                    opPos1Relative: op.relativePos1 !== undefined,
                    opPos2: op.pos2,
                    opPos2Relative: op.relativePos2 !== undefined,
                    opType: op.type,
                    start,
                });
            }
        }
        // start and end are guaranteed to be non-null here, otherwise we throw above.
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return { start, end };
    }
    /**
     * Gets the client args from the op if remote, otherwise uses the local clients info
     * @param sequencedMessage - The sequencedMessage to get the client sequence args for
     */
    getClientSequenceArgsForMessage(sequencedMessage) {
        // If there this no sequenced message, then the op is local
        // and unacked, so use this clients sequenced args
        //
        if (!sequencedMessage) {
            const segWindow = this.getCollabWindow();
            return {
                clientId: segWindow.clientId,
                referenceSequenceNumber: segWindow.currentSeq,
                sequenceNumber: this.getLocalSequenceNumber(),
            };
        }
        else {
            return {
                clientId: this.getOrAddShortClientId(sequencedMessage.clientId),
                referenceSequenceNumber: sequencedMessage.referenceSequenceNumber,
                sequenceNumber: sequencedMessage.sequenceNumber,
            };
        }
    }
    /**
     * Gets the client args from the op if remote, otherwise uses the local clients info
     * @param opArgs - The op arg to get the client sequence args for
     */
    getClientSequenceArgs(opArgs) {
        return this.getClientSequenceArgsForMessage(opArgs.sequencedMessage);
    }
    ackPendingSegment(opArgs) {
        const ackOp = (deltaOpArgs) => {
            let trace;
            if (this.measureOps) {
                trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
            }
            this.mergeTree.ackPendingSegment(deltaOpArgs);
            if (deltaOpArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE) {
                if (deltaOpArgs.op.combiningOp && (deltaOpArgs.op.combiningOp.name === "consensus")) {
                    this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);
                }
            }
            if (trace) {
                this.accumTime += elapsedMicroseconds(trace);
                this.accumOps++;
                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);
            }
        };
        if (opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP) {
            for (const memberOp of opArgs.op.ops) {
                ackOp({
                    groupOp: opArgs.op,
                    op: memberOp,
                    sequencedMessage: opArgs.sequencedMessage,
                });
            }
        }
        else {
            ackOp(opArgs);
        }
    }
    // as functions are modified move them above the eslint-disabled waterline and lint them
    cloneFromSegments() {
        const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);
        const segments = [];
        const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);
        clone.mergeTree.root = newRoot;
        return clone;
    }
    getOrAddShortClientId(longClientId) {
        if (!this.clientNameToIds.get(longClientId)) {
            this.addLongClientId(longClientId);
        }
        return this.getShortClientId(longClientId);
    }
    getShortClientId(longClientId) {
        return this.clientNameToIds.get(longClientId).data;
    }
    getLongClientId(shortClientId) {
        if (shortClientId >= 0) {
            return this.shortClientIdMap[shortClientId];
        }
        else {
            return "original";
        }
    }
    addLongClientId(longClientId) {
        this.clientNameToIds.put(longClientId, this.shortClientIdMap.length);
        this.shortClientIdMap.push(longClientId);
    }
    /**
     * During reconnect, we must find the positions to pending segments
     * relative to other pending segments. This methods computes that
     * position relative to a localSeq. Pending segments above the localSeq
     * will be ignored.
     *
     * @param segment - The segment to find the position for
     * @param localSeq - The localSeq to find the position of the segment at
     */
    findReconnectionPosition(segment, localSeq) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x032 /* "localSeq greater than collab window" */);
        let segmentPosition = 0;
        /*
            Walk the segments up to the current segment, and calculate it's
            position taking into account local segments that were modified,
            after the current segment.

            TODO: Consider embedding this information into the tree for
            more efficient look up of pending segment positions.
        */
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            // If we've found the desired segment, terminate the walk and return 'segmentPosition'.
            if (seg === segment) {
                return false;
            }
            // Otherwise, advance segmentPosition if the segment has been inserted and not removed
            // with respect to the given 'localSeq'.
            //
            // Note that all ACKed / remote ops are applied and we only need concern ourself with
            // determining if locally pending ops fall before/after the given 'localSeq'.
            if ((seg.localSeq === undefined || seg.localSeq <= localSeq) // Is inserted
                && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed
            ) {
                segmentPosition += seg.cachedLength;
            }
            return true;
        });
        return segmentPosition;
    }
    /**
     * Rebases a (local) position from the perspective `{ seq: seqNumberFrom, localSeq }` to the perspective
     * of the current sequence number. This is desirable when rebasing operations for reconnection.
     *
     * If the position refers to a segment/offset that was removed by some operation between `seqNumberFrom` and
     * the current sequence number, the returned position will align with the position of a reference given
     * `SlideOnRemove` semantics.
     */
    rebasePosition(pos, seqNumberFrom, localSeq) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x300 /* localSeq greater than collab window */);
        let segment;
        let posAccumulated = 0;
        let offset = pos;
        const isInsertedInView = (seg) => (seg.seq !== undefined && seg.seq !== _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber && seg.seq <= seqNumberFrom)
            || (seg.localSeq !== undefined && seg.localSeq <= localSeq);
        const isRemovedFromView = ({ removedSeq, localRemovedSeq }) => (removedSeq !== undefined && removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber && removedSeq <= seqNumberFrom)
            || (localRemovedSeq !== undefined && localRemovedSeq <= localSeq);
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(seg.seq !== undefined || seg.localSeq !== undefined, 0x301 /* Either seq or localSeq should be defined */);
            segment = seg;
            if (isInsertedInView(seg) && !isRemovedFromView(seg)) {
                posAccumulated += seg.cachedLength;
                if (offset >= seg.cachedLength) {
                    offset -= seg.cachedLength;
                }
            }
            // Keep going while we've yet to reach the segment at the desired position
            return posAccumulated <= pos;
        });
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segment !== undefined, 0x302 /* No segment found */);
        const seqNumberTo = this.getCollabWindow().currentSeq;
        if ((segment.removedSeq !== undefined &&
            segment.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber &&
            segment.removedSeq <= seqNumberTo)
            || (segment.localRemovedSeq !== undefined && segment.localRemovedSeq <= localSeq)) {
            // Segment that the position was in has been removed: null out offset.
            offset = 0;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(0 <= offset && offset < segment.cachedLength, 0x303 /* Invalid offset */);
        return this.findReconnectionPosition(segment, localSeq) + offset;
    }
    resetPendingDeltaToOps(resetOp, segmentGroup) {
        var _a, _b;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!segmentGroup, 0x033 /* "Segment group undefined" */);
        const NACKedSegmentGroup = (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.dequeue();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segmentGroup === NACKedSegmentGroup, 0x034 /* "Segment group not at head of merge tree pending queue" */);
        const opList = [];
        // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.
        // The reason they need them sorted, as they have the same local sequence number and which means
        // farther segments will  take into account nearer segments when calculating their position.
        // By sorting we ensure the nearer segment will be applied and sequenced before the father segments
        // so their recalculated positions will be correct.
        for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {
            const segmentSegGroup = segment.segmentGroups.dequeue();
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segmentGroup === segmentSegGroup, 0x035 /* "Segment group not at head of segment pending queue" */);
            const segmentPosition = this.findReconnectionPosition(segment, segmentGroup.localSeq);
            let newOp;
            switch (resetOp.type) {
                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(((_b = segment.propertyManager) === null || _b === void 0 ? void 0 : _b.hasPendingProperties()) === true, 0x036 /* "Segment has no pending properties" */);
                    // if the segment has been removed, there's no need to send the annotate op
                    // unless the remove was local, in which case the annotate must have come
                    // before the remove
                    if (segment.removedSeq === undefined || segment.localRemovedSeq !== undefined) {
                        newOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createAnnotateRangeOp)(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);
                    }
                    break;
                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(segment.seq === _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber, 0x037 /* "Segment already has assigned sequence number" */);
                    let segInsertOp = segment;
                    if (typeof resetOp.seg === "object" && resetOp.seg.props !== undefined) {
                        segInsertOp = segment.clone();
                        segInsertOp.properties = resetOp.seg.props;
                    }
                    newOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createInsertSegmentOp)(segmentPosition, segInsertOp);
                    break;
                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:
                    if (segment.localRemovedSeq !== undefined) {
                        newOp = (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createRemoveRangeOp)(segmentPosition, segmentPosition + segment.cachedLength);
                    }
                    break;
                default:
                    throw new Error(`Invalid op type`);
            }
            if (newOp) {
                const newSegmentGroup = { segments: [], localSeq: segmentGroup.localSeq };
                segment.segmentGroups.enqueue(newSegmentGroup);
                this.mergeTree.pendingSegments.enqueue(newSegmentGroup);
                opList.push(newOp);
            }
        }
        return opList;
    }
    applyRemoteOp(opArgs) {
        const op = opArgs.op;
        const msg = opArgs.sequencedMessage;
        this.getOrAddShortClientId(msg.clientId);
        switch (op.type) {
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:
                this.applyInsertOp(opArgs);
                break;
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:
                this.applyRemoveRangeOp(opArgs);
                break;
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:
                this.applyAnnotateRangeOp(opArgs);
                break;
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP: {
                for (const memberOp of op.ops) {
                    this.applyRemoteOp({
                        op: memberOp,
                        groupOp: op,
                        sequencedMessage: msg,
                    });
                }
                break;
            }
            default:
                break;
        }
    }
    applyStashedOp(op) {
        let metadata;
        switch (op.type) {
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:
                this.applyInsertOp({ op });
                metadata = this.peekPendingSegmentGroups();
                break;
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:
                this.applyRemoveRangeOp({ op });
                metadata = this.peekPendingSegmentGroups();
                break;
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:
                this.applyAnnotateRangeOp({ op });
                metadata = this.peekPendingSegmentGroups();
                break;
            case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP:
                return op.ops.map((o) => this.applyStashedOp(o));
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.unreachableCase)(op, "unrecognized op type");
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!metadata, 0x2db /* "Applying op must generate a pending segment" */);
        return metadata;
    }
    applyMsg(msg, local = false) {
        var _a;
        // Ensure client ID is registered
        this.getOrAddShortClientId(msg.clientId);
        // Apply if an operation message
        if (msg.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_10__.MessageType.Operation) {
            const opArgs = {
                op: msg.contents,
                sequencedMessage: msg,
            };
            if (((_a = opArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.clientId) === this.longClientId || local) {
                this.ackPendingSegment(opArgs);
            }
            else {
                this.applyRemoteOp(opArgs);
            }
        }
        this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);
    }
    updateSeqNumbers(min, seq) {
        const collabWindow = this.mergeTree.getCollabWindow();
        // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(collabWindow.currentSeq <= seq, 0x038 /* "Incoming op sequence# < local collabWindow's currentSequence#" */);
        collabWindow.currentSeq = seq;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(min <= seq, 0x039 /* "Incoming op sequence# < minSequence#" */);
        this.updateMinSeq(min);
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);
        return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);
    }
    /**
     *  Given an pending operation and segment group, regenerate the op, so it
     *  can be resubmitted
     * @param resetOp - The op to reset
     * @param segmentGroup - The segment group associated with the op
     */
    regeneratePendingOp(resetOp, segmentGroup) {
        const opList = [];
        if (resetOp.type === _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP) {
            if (Array.isArray(segmentGroup)) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.ops.length === segmentGroup.length, 0x03a /* "Number of ops in 'resetOp' must match the number of segment groups provided." */);
                for (let i = 0; i < resetOp.ops.length; i++) {
                    opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));
                }
            }
            else {
                // A group op containing a single op will pass a direct reference to 'segmentGroup'
                // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.ops.length === 1, 0x03b /* "Number of ops in 'resetOp' must match the number of segment groups provided." */);
                opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));
            }
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(resetOp.type !== _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.GROUP, 0x03c /* "Reset op has 'group' delta type!" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!Array.isArray(segmentGroup), 0x03d /* "segmentGroup is array rather than singleton!" */);
            opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));
        }
        return opList.length === 1 ? opList[0] : (0,_opBuilder__WEBPACK_IMPORTED_MODULE_2__.createGroupOp)(...opList);
    }
    createTextHelper() {
        return new _textSegment__WEBPACK_IMPORTED_MODULE_11__.MergeTreeTextHelper(this.mergeTree);
    }
    summarize(runtime, handle, serializer, catchUpMsgs) {
        var _a;
        const deltaManager = runtime.deltaManager;
        const minSeq = deltaManager.minimumSequenceNumber;
        // Catch up to latest MSN, if we have not had a chance to do it.
        // Required for case where FluidDataStoreRuntime.attachChannel()
        // generates summary right after loading data store.
        this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber);
        // One of the summaries (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!
        // Not sure why - need to catch it sooner
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(this.getCollabWindow().minSeq === minSeq, 0x03e /* "minSeq mismatch between collab window and delta manager!" */);
        // Must continue to support legacy
        //       (See https://github.com/microsoft/FluidFramework/issues/84)
        if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(catchUpMsgs === undefined || catchUpMsgs.length === 0, 0x03f /* "New format should not emit catchup ops" */);
            const snap = new _snapshotV1__WEBPACK_IMPORTED_MODULE_12__.SnapshotV1(this.mergeTree, this.logger, (id) => this.getLongClientId(id));
            snap.extractSync();
            return snap.emit(serializer, handle);
        }
        else {
            const snap = new _snapshotlegacy__WEBPACK_IMPORTED_MODULE_13__.SnapshotLegacy(this.mergeTree, this.logger);
            snap.extractSync();
            return snap.emit(catchUpMsgs, serializer, handle);
        }
    }
    async load(runtime, storage, serializer) {
        const loader = new _snapshotLoader__WEBPACK_IMPORTED_MODULE_14__.SnapshotLoader(runtime, this, this.mergeTree, this.logger, serializer);
        return loader.initialize(storage);
    }
    getStackContext(startPos, rangeLabels) {
        return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);
    }
    getLocalSequenceNumber() {
        const segWindow = this.getCollabWindow();
        if (segWindow.collaborating) {
            return _constants__WEBPACK_IMPORTED_MODULE_8__.UnassignedSequenceNumber;
        }
        else {
            return _constants__WEBPACK_IMPORTED_MODULE_8__.UniversalSequenceNumber;
        }
    }
    localTransaction(groupOp) {
        for (const op of groupOp.ops) {
            const opArgs = {
                op,
                groupOp,
            };
            switch (op.type) {
                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.INSERT:
                    this.applyInsertOp(opArgs);
                    break;
                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.ANNOTATE:
                    this.applyAnnotateRangeOp(opArgs);
                    break;
                case _ops__WEBPACK_IMPORTED_MODULE_6__.MergeTreeDeltaType.REMOVE:
                    this.applyRemoveRangeOp(opArgs);
                    break;
                default:
                    break;
            }
        }
    }
    updateConsensusProperty(op, msg) {
        const markerId = op.relativePos1.id;
        const consensusInfo = this.pendingConsensus.get(markerId);
        if (consensusInfo) {
            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);
        }
        this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));
    }
    updateMinSeq(minSeq) {
        let trace;
        if (this.measureOps) {
            trace = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.Trace.start();
        }
        this.mergeTree.setMinSeq(minSeq);
        if (trace) {
            const elapsed = elapsedMicroseconds(trace);
            this.accumWindowTime += elapsed;
            if (elapsed > this.maxWindowTime) {
                this.maxWindowTime = elapsed;
            }
        }
    }
    getContainingSegment(pos, op) {
        const args = this.getClientSequenceArgsForMessage(op);
        return this.mergeTree.getContainingSegment(pos, args.referenceSequenceNumber, args.clientId);
    }
    /**
     * Returns the position to slide a reference to if a slide is required.
     * @param segoff - The segment and offset to slide from
     * @returns - segment and offset to slide the reference to
     */
    getSlideToSegment(segoff) {
        return this.mergeTree._getSlideToSegment(segoff);
    }
    getPropertiesAtPosition(pos) {
        let propertiesAtPosition;
        const segoff = this.getContainingSegment(pos);
        const seg = segoff.segment;
        if (seg) {
            propertiesAtPosition = seg.properties;
        }
        return propertiesAtPosition;
    }
    getRangeExtentsOfPosition(pos) {
        let posStart;
        let posAfterEnd;
        const segoff = this.getContainingSegment(pos);
        const seg = segoff.segment;
        if (seg) {
            posStart = this.getPosition(seg);
            posAfterEnd = posStart + seg.cachedLength;
        }
        return { posStart, posAfterEnd };
    }
    getCurrentSeq() {
        return this.getCollabWindow().currentSeq;
    }
    getClientId() {
        return this.getCollabWindow().clientId;
    }
    getLength() { return this.mergeTree.length; }
    startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0) {
        // we should always have a client id if we are collaborating
        // if the client id is undefined we are likely bound to a detached
        // container, so we should keep going in local mode. once
        // the container attaches this will be called again on connect with the
        // client id
        if (longClientId !== undefined) {
            if (this.longClientId === undefined) {
                this.longClientId = longClientId;
                this.addLongClientId(this.longClientId);
                this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq);
            }
            else {
                const oldClientId = this.longClientId;
                const oldData = this.clientNameToIds.get(oldClientId).data;
                this.longClientId = longClientId;
                this.clientNameToIds.put(longClientId, oldData);
                this.shortClientIdMap[oldData] = longClientId;
            }
        }
    }
    findTile(startPos, tileLabel, preceding = true) {
        const clientId = this.getClientId();
        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);
    }
}
//# sourceMappingURL=client.js.map

/***/ }),
/* 294 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseSegment": () => (/* binding */ BaseSegment),
/* harmony export */   "CollaborationWindow": () => (/* binding */ CollaborationWindow),
/* harmony export */   "IncrementalExecOp": () => (/* binding */ IncrementalExecOp),
/* harmony export */   "IncrementalMapState": () => (/* binding */ IncrementalMapState),
/* harmony export */   "Marker": () => (/* binding */ Marker),
/* harmony export */   "MaxNodesInBlock": () => (/* binding */ MaxNodesInBlock),
/* harmony export */   "MergeBlock": () => (/* binding */ MergeBlock),
/* harmony export */   "MergeNode": () => (/* binding */ MergeNode),
/* harmony export */   "MergeTree": () => (/* binding */ MergeTree),
/* harmony export */   "clientSeqComparer": () => (/* binding */ clientSeqComparer),
/* harmony export */   "compareNumbers": () => (/* binding */ compareNumbers),
/* harmony export */   "compareStrings": () => (/* binding */ compareStrings),
/* harmony export */   "internedSpaces": () => (/* binding */ internedSpaces),
/* harmony export */   "ordinalToArray": () => (/* binding */ ordinalToArray),
/* harmony export */   "reservedMarkerIdKey": () => (/* binding */ reservedMarkerIdKey),
/* harmony export */   "reservedMarkerSimpleTypeKey": () => (/* binding */ reservedMarkerSimpleTypeKey),
/* harmony export */   "toRemovalInfo": () => (/* binding */ toRemovalInfo)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(283);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(51);
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(287);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(285);
/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(286);
/* harmony import */ var _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(298);
/* harmony import */ var _mergeTreeTracking__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(296);
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(281);
/* harmony import */ var _partialLengths__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(299);
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(284);
/* harmony import */ var _referencePositions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(280);
/* harmony import */ var _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(295);
/* harmony import */ var _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(282);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/consistent-type-assertions */
/* eslint-disable @typescript-eslint/prefer-optional-chain, no-bitwise */













function toRemovalInfo(maybe) {
    if ((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) !== undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) !== undefined) {
        return maybe;
    }
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) === undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) === undefined, 0x2bf /* "both removedClientIds and removedSeq should be set or not set" */);
}
function isRemoved(segment) {
    return toRemovalInfo(segment) !== undefined;
}
function isRemovedAndAcked(segment) {
    const removalInfo = toRemovalInfo(segment);
    return removalInfo !== undefined && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber;
}
class MergeNode {
    constructor() {
        this.index = 0;
        this.ordinal = "";
        this.cachedLength = 0;
    }
    isLeaf() {
        return false;
    }
}
function addTile(tile, tiles) {
    const tileLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(tile);
    if (tileLabels) {
        for (const tileLabel of tileLabels) {
            tiles[tileLabel] = tile;
        }
    }
}
function addTileIfNotPresent(tile, tiles) {
    const tileLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(tile);
    if (tileLabels) {
        for (const tileLabel of tileLabels) {
            if (tiles[tileLabel] === undefined) {
                tiles[tileLabel] = tile;
            }
        }
    }
}
function applyStackDelta(currentStackMap, deltaStackMap) {
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const label in deltaStackMap) {
        const deltaStack = deltaStackMap[label];
        if (!deltaStack.empty()) {
            let currentStack = currentStackMap[label];
            if (currentStack === undefined) {
                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_3__.Stack();
                currentStackMap[label] = currentStack;
            }
            for (const delta of deltaStack.items) {
                applyRangeReference(currentStack, delta);
            }
        }
    }
}
function applyRangeReference(stack, delta) {
    if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(delta, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin)) {
        stack.push(delta);
        return true;
    }
    else {
        // Assume delta is end reference
        const top = stack.top();
        // TODO: match end with begin
        if (top && ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(top, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin))) {
            stack.pop();
        }
        else {
            stack.push(delta);
        }
        return false;
    }
}
function addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {
    var _a;
    function updateRangeInfo(label, refPos) {
        let stack = rangeStacks[label];
        if (stack === undefined) {
            stack = new _collections__WEBPACK_IMPORTED_MODULE_3__.Stack();
            rangeStacks[label] = stack;
        }
        applyRangeReference(stack, refPos);
    }
    if (node.isLeaf()) {
        const segment = node;
        if (((_a = mergeTree.localNetLength(segment)) !== null && _a !== void 0 ? _a : 0) > 0) {
            if (Marker.is(segment)) {
                const markerId = segment.getId();
                // Also in insertMarker but need for reload segs case
                // can add option for this only from reload segs
                if (markerId) {
                    mergeTree.mapIdToSegment(markerId, segment);
                }
                if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(segment, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Tile)) {
                    addTile(segment, rightmostTiles);
                    addTileIfNotPresent(segment, leftmostTiles);
                }
                if (segment.refType & (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {
                    const rangeLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(segment);
                    if (rangeLabels) {
                        for (const label of rangeLabels) {
                            updateRangeInfo(label, segment);
                        }
                    }
                }
            }
            else {
                const baseSegment = node;
                if (baseSegment.localRefs && (baseSegment.localRefs.hierRefCount !== undefined) &&
                    (baseSegment.localRefs.hierRefCount > 0)) {
                    for (const lref of baseSegment.localRefs) {
                        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Tile)) {
                            addTile(lref, rightmostTiles);
                            addTileIfNotPresent(lref, leftmostTiles);
                        }
                        if (lref.refType & (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {
                            for (const label of (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(lref)) {
                                updateRangeInfo(label, lref);
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        const block = node;
        applyStackDelta(rangeStacks, block.rangeStacks);
        (0,_properties__WEBPACK_IMPORTED_MODULE_5__.extend)(rightmostTiles, block.rightmostTiles);
        (0,_properties__WEBPACK_IMPORTED_MODULE_5__.extendIfUndefined)(leftmostTiles, block.leftmostTiles);
    }
}
function ordinalToArray(ord) {
    const a = [];
    if (ord) {
        for (let i = 0, len = ord.length; i < len; i++) {
            a.push(ord.charCodeAt(i));
        }
    }
    return a;
}
// Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because
// the MergeTree always inserts first, then checks for overflow and splits if the child count equals
// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to
// facilitate splits.)
const MaxNodesInBlock = 8;
class MergeBlock extends MergeNode {
    constructor(childCount) {
        super();
        this.childCount = childCount;
        this.children = new Array(MaxNodesInBlock);
    }
    hierBlock() {
        return undefined;
    }
    setOrdinal(child, index) {
        let childCount = this.childCount;
        if (childCount === 8) {
            childCount = 7;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((childCount >= 1) && (childCount <= 7), 0x040 /* "Child count is not within [1,7] range!" */);
        let localOrdinal;
        const ordinalWidth = 1 << (MaxNodesInBlock - (childCount + 1));
        if (index === 0) {
            localOrdinal = ordinalWidth - 1;
        }
        else {
            const prevOrd = this.children[index - 1].ordinal;
            const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);
            localOrdinal = prevOrdCode + ordinalWidth;
        }
        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(child.ordinal.length === (this.ordinal.length + 1), 0x041 /* "Unexpected child ordinal length!" */);
        if (index > 0) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(child.ordinal > this.children[index - 1].ordinal, 0x042);
        }
    }
    assignChild(child, index, updateOrdinal = true) {
        child.parent = this;
        child.index = index;
        if (updateOrdinal) {
            this.setOrdinal(child, index);
        }
        this.children[index] = child;
    }
}
class HierMergeBlock extends MergeBlock {
    constructor(childCount) {
        super(childCount);
        this.rightmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();
        this.leftmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();
        this.rangeStacks = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();
    }
    addNodeReferences(mergeTree, node) {
        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);
    }
    hierBlock() {
        return this;
    }
    hierToString(indentCount) {
        let strbuf = "";
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const key in this.rangeStacks) {
            const stack = this.rangeStacks[key];
            strbuf += internedSpaces(indentCount);
            strbuf += `${key}: `;
            for (const item of stack.items) {
                strbuf += `${item.toString()} `;
            }
            strbuf += "\n";
        }
        return strbuf;
    }
}
function nodeTotalLength(mergeTree, node) {
    if (!node.isLeaf()) {
        return node.cachedLength;
    }
    return mergeTree.localNetLength(node);
}
class BaseSegment extends MergeNode {
    constructor() {
        super(...arguments);
        this.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId;
        this.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;
        this.segmentGroups = new _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_6__.SegmentGroupCollection(this);
        this.trackingCollection = new _mergeTreeTracking__WEBPACK_IMPORTED_MODULE_7__.TrackingGroupCollection(this);
    }
    addProperties(newProps, op, seq, collabWindow) {
        if (!this.propertyManager) {
            this.propertyManager = new _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_8__.PropertiesManager();
        }
        if (!this.properties) {
            this.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();
        }
        return this.propertyManager.addProperties(this.properties, newProps, op, seq, collabWindow && collabWindow.collaborating);
    }
    hasProperty(key) {
        return !!this.properties && (this.properties[key] !== undefined);
    }
    isLeaf() {
        return true;
    }
    cloneInto(b) {
        var _a;
        b.clientId = this.clientId;
        // TODO: deep clone properties
        b.properties = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.clone)(this.properties);
        b.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();
        // TODO: copy removed client overlap and branch removal info
        b.removedSeq = this.removedSeq;
        b.seq = this.seq;
    }
    canAppend(segment) {
        return false;
    }
    addSerializedProps(jseg) {
        if (this.properties) {
            jseg.props = this.properties;
        }
    }
    ack(segmentGroup, opArgs, mergeTree) {
        const currentSegmentGroup = this.segmentGroups.dequeue();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(currentSegmentGroup === segmentGroup, 0x043 /* "On ack, unexpected segmentGroup!" */);
        switch (opArgs.op.type) {
            case _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.ANNOTATE:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.propertyManager, 0x044 /* "On annotate ack, missing segment property manager!" */);
                this.propertyManager.ackPendingProperties(opArgs.op);
                return true;
            case _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.INSERT:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, 0x045 /* "On insert, seq number already assigned!" */);
                this.seq = opArgs.sequencedMessage.sequenceNumber;
                this.localSeq = undefined;
                return true;
            case _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.REMOVE:
                const removalInfo = toRemovalInfo(this);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(removalInfo !== undefined, 0x046 /* "On remove ack, missing removal info!" */);
                this.localRemovedSeq = undefined;
                if (removalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {
                    removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;
                    return true;
                }
                return false;
            default:
                throw new Error(`${opArgs.op.type} is in unrecognized operation type`);
        }
    }
    splitAt(pos) {
        var _a;
        if (pos > 0) {
            const leafSegment = this.createSplitSegmentAt(pos);
            if (leafSegment) {
                this.copyPropertiesTo(leafSegment);
                leafSegment.parent = this.parent;
                // Give the leaf a temporary yet valid ordinal.
                // when this segment is put in the tree, it will get it's real ordinal,
                // but this ordinal meets all the necessary invariants for now.
                leafSegment.ordinal = this.ordinal + String.fromCharCode(0);
                leafSegment.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();
                leafSegment.removedSeq = this.removedSeq;
                leafSegment.localRemovedSeq = this.localRemovedSeq;
                leafSegment.seq = this.seq;
                leafSegment.localSeq = this.localSeq;
                leafSegment.clientId = this.clientId;
                this.segmentGroups.copyTo(leafSegment);
                this.trackingCollection.copyTo(leafSegment);
                if (this.localRefs) {
                    this.localRefs.split(pos, leafSegment);
                }
            }
            return leafSegment;
        }
    }
    copyPropertiesTo(other) {
        if (this.propertyManager) {
            if (this.properties) {
                other.propertyManager = new _segmentPropertiesManager__WEBPACK_IMPORTED_MODULE_8__.PropertiesManager();
                other.properties = this.propertyManager.copyTo(this.properties, other.properties, other.propertyManager);
            }
        }
    }
}
const reservedMarkerIdKey = "markerId";
const reservedMarkerSimpleTypeKey = "markerSimpleType";
class Marker extends BaseSegment {
    constructor(refType) {
        super();
        this.refType = refType;
        this.type = Marker.type;
        this.cachedLength = 1;
    }
    static is(segment) {
        return segment.type === Marker.type;
    }
    static make(refType, props) {
        const marker = new Marker(refType);
        if (props) {
            marker.addProperties(props);
        }
        return marker;
    }
    toJSONObject() {
        const obj = { marker: { refType: this.refType } };
        super.addSerializedProps(obj);
        return obj;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "marker" in spec) {
            return Marker.make(spec.marker.refType, spec.props);
        }
        return undefined;
    }
    clone() {
        const b = Marker.make(this.refType, this.properties);
        this.cloneInto(b);
        return b;
    }
    getSegment() {
        return this;
    }
    getOffset() {
        return 0;
    }
    hasSimpleType(simpleTypeName) {
        return !!this.properties &&
            this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;
    }
    getProperties() {
        return this.properties;
    }
    getId() {
        if (this.properties && this.properties[reservedMarkerIdKey]) {
            return this.properties[reservedMarkerIdKey];
        }
    }
    /**
     * @deprecated - use refHasTileLabels
     */
    hasTileLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabels)(this);
    }
    /**
     * @deprecated - use refHasRangeLabels
     */
    hasRangeLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasRangeLabels)(this);
    }
    /**
     * @deprecated - use refHasTileLabel
     */
    hasTileLabel(label) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabel)(this, label);
    }
    /**
     * @deprecated - use refHasRangeLabel
     */
    hasRangeLabel(label) {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasRangeLabel)(this, label);
    }
    /**
     * @deprecated - use refGetTileLabels
     */
    getTileLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(this);
    }
    /**
     * @deprecated - use refGetRangeLabels
     */
    getRangeLabels() {
        return (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(this);
    }
    toString() {
        let bbuf = "";
        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Tile)) {
            bbuf += "Tile";
        }
        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin)) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeBegin";
        }
        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeEnd";
        }
        let lbuf = "";
        const id = this.getId();
        if (id) {
            bbuf += ` (${id}) `;
        }
        const tileLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetTileLabels)(this);
        if (tileLabels) {
            lbuf += "tile -- ";
            for (let i = 0, len = tileLabels.length; i < len; i++) {
                const tileLabel = tileLabels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += tileLabel;
            }
        }
        const rangeLabels = (0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refGetRangeLabels)(this);
        if (rangeLabels) {
            let rangeKind = "begin";
            if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(this, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {
                rangeKind = "end";
            }
            if (tileLabels) {
                lbuf += " ";
            }
            lbuf += `range ${rangeKind} -- `;
            const labels = rangeLabels;
            for (let i = 0, len = labels.length; i < len; i++) {
                const rangeLabel = labels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += rangeLabel;
            }
        }
        let pbuf = "";
        if (this.properties) {
            pbuf += JSON.stringify(this.properties, (key, value) => {
                // Avoid circular reference when stringifying makers containing handles.
                // (Substitute a debug string instead.)
                const handle = !!value && value.IFluidHandle;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return handle
                    ? `#Handle(${handle.routeContext.path}/${handle.path})`
                    : value;
            });
        }
        return `M ${bbuf}: ${lbuf} ${pbuf}`;
    }
    createSplitSegmentAt(pos) {
        return undefined;
    }
    canAppend(segment) {
        return false;
    }
    append() { throw new Error("Can not append to marker"); }
}
Marker.type = "Marker";
var IncrementalExecOp;
(function (IncrementalExecOp) {
    IncrementalExecOp[IncrementalExecOp["Go"] = 0] = "Go";
    IncrementalExecOp[IncrementalExecOp["Stop"] = 1] = "Stop";
    IncrementalExecOp[IncrementalExecOp["Yield"] = 2] = "Yield";
})(IncrementalExecOp || (IncrementalExecOp = {}));
class IncrementalMapState {
    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {
        this.block = block;
        this.actions = actions;
        this.pos = pos;
        this.refSeq = refSeq;
        this.clientId = clientId;
        this.context = context;
        this.start = start;
        this.end = end;
        this.childIndex = childIndex;
        this.op = IncrementalExecOp.Go;
    }
}
class CollaborationWindow {
    constructor() {
        this.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId;
        this.collaborating = false;
        // Lowest-numbered segment in window; no client can reference a state before this one
        this.minSeq = 0;
        // Highest-numbered segment in window and current
        // reference segment for this client
        this.currentSeq = 0;
        this.localSeq = 0;
    }
    loadFrom(a) {
        this.clientId = a.clientId;
        this.collaborating = a.collaborating;
        this.minSeq = a.minSeq;
        this.currentSeq = a.currentSeq;
    }
}
const compareNumbers = (a, b) => a - b;
const compareStrings = (a, b) => a.localeCompare(b);
const indentStrings = ["", " ", "  "];
function internedSpaces(n) {
    if (indentStrings[n] === undefined) {
        indentStrings[n] = "";
        for (let i = 0; i < n; i++) {
            indentStrings[n] += " ";
        }
    }
    return indentStrings[n];
}
const clientSeqComparer = {
    min: { refSeq: -1, clientId: "" },
    compare: (a, b) => a.refSeq - b.refSeq,
};
const LRUSegmentComparer = {
    min: { maxSeq: -2 },
    compare: (a, b) => a.maxSeq - b.maxSeq,
};
function applyLeafRangeMarker(marker, searchInfo) {
    for (const rangeLabel of searchInfo.rangeLabels) {
        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasRangeLabel)(marker, rangeLabel)) {
            let currentStack = searchInfo.stacks[rangeLabel];
            if (currentStack === undefined) {
                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_3__.Stack();
                searchInfo.stacks[rangeLabel] = currentStack;
            }
            applyRangeReference(currentStack, marker);
        }
    }
}
function recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (Marker.is(segment)) {
        if (segment.refType &
            (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {
            applyLeafRangeMarker(segment, searchInfo);
        }
    }
    return false;
}
function rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    var _a;
    if (node.isLeaf()) {
        const seg = node;
        if ((((_a = searchInfo.mergeTree.localNetLength(seg)) !== null && _a !== void 0 ? _a : 0) > 0) && Marker.is(seg)) {
            if (seg.refType &
                (_ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestBegin | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.NestEnd)) {
                applyLeafRangeMarker(seg, searchInfo);
            }
        }
    }
    else {
        const block = node;
        applyStackDelta(searchInfo.stacks, block.rangeStacks);
    }
    return true;
}
function recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (Marker.is(segment)) {
        if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabel)(segment, searchInfo.tileLabel)) {
            searchInfo.tile = segment;
        }
    }
    return false;
}
function tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    if (node.isLeaf()) {
        const seg = node;
        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {
            if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refHasTileLabel)(seg, searchInfo.tileLabel)) {
                searchInfo.tile = seg;
            }
        }
    }
    else {
        const block = node;
        let marker;
        if (searchInfo.posPrecedesTile) {
            marker = block.rightmostTiles[searchInfo.tileLabel];
        }
        else {
            marker = block.leftmostTiles[searchInfo.tileLabel];
        }
        if (marker !== undefined) {
            searchInfo.tile = marker;
        }
    }
    return true;
}
const minListenerComparer = {
    min: { minRequired: Number.MIN_VALUE, onMinGE: () => { (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 0x048 /* "onMinGE()" */); } },
    compare: (a, b) => a.minRequired - b.minRequired,
};
// Represents a sequence of text segments
class MergeTree {
    // TODO: make and use interface describing options
    constructor(options) {
        this.options = options;
        this.blockUpdateActions = MergeTree.initBlockUpdateActions;
        this.collabWindow = new CollaborationWindow();
        // TODO: add remove on segment remove
        // for now assume only markers have ids and so point directly at the Segment
        // if we need to have pointers to non-markers, we can change to point at local refs
        this.idToSegment = new Map();
        this.splitLeafSegment = (segment, pos) => {
            if (!(pos > 0 && segment)) {
                return {};
            }
            const next = segment.splitAt(pos);
            if (this.mergeTreeMaintenanceCallback) {
                this.mergeTreeMaintenanceCallback({
                    operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.SPLIT,
                    deltaSegments: [{ segment }, { segment: next }],
                }, undefined);
            }
            return { next };
        };
        this.root = this.makeBlock(0);
    }
    makeBlock(childCount) {
        const block = new HierMergeBlock(childCount);
        block.ordinal = "";
        return block;
    }
    clone() {
        const b = new MergeTree(this.options);
        // For now assume that b will not collaborate
        b.root = b.blockClone(this.root);
    }
    blockClone(block, segments) {
        const bBlock = this.makeBlock(block.childCount);
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.isLeaf()) {
                const segment = this.segmentClone(child);
                bBlock.assignChild(segment, i);
                if (segments) {
                    segments.push(segment);
                }
            }
            else {
                bBlock.assignChild(this.blockClone(child, segments), i);
            }
        }
        this.nodeUpdateLengthNewStructure(bBlock);
        this.nodeUpdateOrdinals(bBlock);
        return bBlock;
    }
    segmentClone(segment) {
        const b = segment.clone();
        return b;
    }
    localNetLength(segment) {
        const removalInfo = toRemovalInfo(segment);
        if (removalInfo !== undefined) {
            return 0;
        }
        else {
            return segment.cachedLength;
        }
    }
    // TODO: remove id when segment removed
    mapIdToSegment(id, segment) {
        this.idToSegment.set(id, segment);
    }
    addNode(block, node) {
        const index = block.childCount++;
        block.assignChild(node, index, false);
        return index;
    }
    /* eslint-disable max-len */
    reloadFromSegments(segments) {
        // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.collabWindow.collaborating, 0x049 /* "Trying to reload from segments while collaborating!" */);
        const maxChildren = MaxNodesInBlock - 1;
        // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.
        const buildMergeBlock = (nodes) => {
            const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree
            const blocks = new Array(blockCount); // Pre-alloc array to collect nodes
            // For each block in this level of the B-Tree...
            for (let nodeIndex = 0, blockIndex = 0; // Start with the first block and first node
             blockIndex < blockCount; // If we have more blocks, we also have more nodes to insert
             blockIndex++ // Advance to next block in this layer.
            ) {
                const block = blocks[blockIndex] = this.makeBlock(0);
                // For each child of the current block, insert a node (while we have nodes left)
                // and update the block's info.
                for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length; // While we still have children & nodes left
                 childIndex++, nodeIndex++ // Advance to next child & node
                ) {
                    // Insert the next node into the current block
                    this.addNode(block, nodes[nodeIndex]);
                }
                // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,
                // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the
                // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.
                this.blockUpdate(block);
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return blocks.length === 1 // If there is only one block at this layer...
                ? blocks[0] // ...then we're done.  Return the root.
                : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.
        };
        if (segments.length > 0) {
            this.root = buildMergeBlock(segments);
            this.nodeUpdateOrdinals(this.root);
        }
        else {
            this.root = this.makeBlock(0);
        }
    }
    /* eslint-enable max-len */
    // For now assume min starts at zero
    startCollaboration(localClientId, minSeq, currentSeq) {
        this.collabWindow.clientId = localClientId;
        this.collabWindow.minSeq = minSeq;
        this.collabWindow.collaborating = true;
        this.collabWindow.currentSeq = currentSeq;
        this.segmentsToScour = new _collections__WEBPACK_IMPORTED_MODULE_3__.Heap([], LRUSegmentComparer);
        this.pendingSegments = (0,_collections__WEBPACK_IMPORTED_MODULE_3__.ListMakeHead)();
        this.nodeUpdateLengthNewStructure(this.root, true);
    }
    addToLRUSet(segment, seq) {
        // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),
        // add the segment and mark the mark the node now.
        // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed
        //       segments from a snapshot.  We currently skip these for now.
        if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {
            segment.parent.needsScour = true;
            this.segmentsToScour.add({ segment, maxSeq: seq });
        }
    }
    underflow(node) {
        return node.childCount < (MaxNodesInBlock / 2);
    }
    scourNode(node, holdNodes) {
        let prevSegment;
        for (let k = 0; k < node.childCount; k++) {
            const childNode = node.children[k];
            if (childNode.isLeaf()) {
                const segment = childNode;
                if (segment.segmentGroups.empty) {
                    if (segment.removedSeq !== undefined) {
                        if (segment.removedSeq > this.collabWindow.minSeq) {
                            holdNodes.push(segment);
                        }
                        else if (!segment.trackingCollection.empty) {
                            holdNodes.push(segment);
                        }
                        else {
                            // Notify maintenance event observers that the segment is being unlinked from the MergeTree
                            if (this.mergeTreeMaintenanceCallback) {
                                this.mergeTreeMaintenanceCallback({
                                    operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.UNLINK,
                                    deltaSegments: [{ segment }],
                                }, undefined);
                            }
                            segment.parent = undefined;
                        }
                        prevSegment = undefined;
                    }
                    else {
                        if (segment.seq <= this.collabWindow.minSeq) {
                            const canAppend = prevSegment
                                && prevSegment.canAppend(segment)
                                && (0,_properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties)(prevSegment.properties, segment.properties)
                                && prevSegment.trackingCollection.matches(segment.trackingCollection)
                                && this.localNetLength(segment) > 0;
                            if (canAppend) {
                                prevSegment.append(segment);
                                if (this.mergeTreeMaintenanceCallback) {
                                    this.mergeTreeMaintenanceCallback({
                                        operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.APPEND,
                                        deltaSegments: [{ segment: prevSegment }, { segment }],
                                    }, undefined);
                                }
                                segment.parent = undefined;
                                segment.trackingCollection.trackingGroups.forEach((tg) => tg.unlink(segment));
                            }
                            else {
                                holdNodes.push(segment);
                                if (this.localNetLength(segment) > 0) {
                                    prevSegment = segment;
                                }
                                else {
                                    prevSegment = undefined;
                                }
                            }
                        }
                        else {
                            holdNodes.push(segment);
                            prevSegment = undefined;
                        }
                    }
                }
                else {
                    holdNodes.push(segment);
                    prevSegment = undefined;
                }
            }
            else {
                holdNodes.push(childNode);
                prevSegment = undefined;
            }
        }
    }
    // Interior node with all node children
    packParent(parent) {
        const children = parent.children;
        let childIndex;
        let childBlock;
        const holdNodes = [];
        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
            // Debug assert not isLeaf()
            childBlock = children[childIndex];
            this.scourNode(childBlock, holdNodes);
            // Will replace this block with a packed block
            childBlock.parent = undefined;
        }
        const totalNodeCount = holdNodes.length;
        const halfCount = MaxNodesInBlock / 2;
        let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));
        if (childCount < 1) {
            childCount = 1;
        }
        const baseCount = Math.floor(totalNodeCount / childCount);
        let extraCount = totalNodeCount % childCount;
        const packedBlocks = new Array(MaxNodesInBlock);
        let readCount = 0;
        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {
            let nodeCount = baseCount;
            if (extraCount > 0) {
                nodeCount++;
                extraCount--;
            }
            const packedBlock = this.makeBlock(nodeCount);
            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {
                const nodeToPack = holdNodes[readCount++];
                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);
            }
            packedBlock.parent = parent;
            packedBlocks[nodeIndex] = packedBlock;
            this.nodeUpdateLengthNewStructure(packedBlock);
        }
        parent.children = packedBlocks;
        for (let j = 0; j < childCount; j++) {
            parent.assignChild(packedBlocks[j], j, false);
        }
        parent.childCount = childCount;
        if (this.underflow(parent) && (parent.parent)) {
            this.packParent(parent.parent);
        }
        else {
            this.nodeUpdateOrdinals(parent);
            this.blockUpdatePathLengths(parent, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, -1, true);
        }
    }
    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {
        if (!this.collabWindow.collaborating) {
            return;
        }
        for (let i = 0; i < zamboniSegmentsMaxCount; i++) {
            let segmentToScour = this.segmentsToScour.peek();
            if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {
                break;
            }
            segmentToScour = this.segmentsToScour.get();
            // Only skip scouring if needs scour is explicitly false, not true or undefined
            if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {
                const block = segmentToScour.segment.parent;
                const childrenCopy = [];
                this.scourNode(block, childrenCopy);
                // This will avoid the cost of re-scouring nodes
                // that have recently been scoured
                block.needsScour = false;
                const newChildCount = childrenCopy.length;
                if (newChildCount < block.childCount) {
                    block.childCount = newChildCount;
                    block.children = childrenCopy;
                    for (let j = 0; j < newChildCount; j++) {
                        block.assignChild(childrenCopy[j], j, false);
                    }
                    if (this.underflow(block) && block.parent) {
                        this.packParent(block.parent);
                    }
                    else {
                        this.nodeUpdateOrdinals(block);
                        this.blockUpdatePathLengths(block, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, -1, true);
                    }
                }
            }
        }
    }
    getCollabWindow() {
        return this.collabWindow;
    }
    getStats() {
        const nodeGetStats = (block) => {
            const stats = {
                maxHeight: 0,
                nodeCount: 0,
                leafCount: 0,
                removedLeafCount: 0,
                liveCount: 0,
                histo: [],
            };
            for (let k = 0; k < MaxNodesInBlock; k++) {
                stats.histo[k] = 0;
            }
            for (let i = 0; i < block.childCount; i++) {
                const child = block.children[i];
                let height = 1;
                if (!child.isLeaf()) {
                    const childStats = nodeGetStats(child);
                    height = 1 + childStats.maxHeight;
                    stats.nodeCount += childStats.nodeCount;
                    stats.leafCount += childStats.leafCount;
                    stats.removedLeafCount += childStats.removedLeafCount;
                    stats.liveCount += childStats.liveCount;
                    for (let j = 0; j < MaxNodesInBlock; j++) {
                        stats.histo[j] += childStats.histo[j];
                    }
                }
                else {
                    stats.leafCount++;
                    const segment = child;
                    if (segment.removedSeq !== undefined) {
                        stats.removedLeafCount++;
                    }
                }
                if (height > stats.maxHeight) {
                    stats.maxHeight = height;
                }
            }
            stats.histo[block.childCount]++;
            stats.nodeCount++;
            stats.liveCount += block.childCount;
            return stats;
        };
        const rootStats = nodeGetStats(this.root);
        return rootStats;
    }
    getLength(refSeq, clientId) {
        return this.blockLength(this.root, refSeq, clientId);
    }
    /**
     * Returns the current length of the MergeTree for the local client.
     */
    get length() { return this.root.cachedLength; }
    getPosition(node, refSeq, clientId) {
        var _a;
        let totalOffset = 0;
        let parent = node.parent;
        let prevParent;
        while (parent) {
            const children = parent.children;
            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {
                const child = children[childIndex];
                if ((prevParent && (child === prevParent)) || (child === node)) {
                    break;
                }
                totalOffset += (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            }
            prevParent = parent;
            parent = parent.parent;
        }
        return totalOffset;
    }
    getContainingSegment(pos, refSeq, clientId) {
        let segment;
        let offset;
        const leaf = (leafSeg, segpos, _refSeq, _clientId, start) => {
            segment = leafSeg;
            offset = start;
            return false;
        };
        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf }, undefined);
        return { segment, offset };
    }
    /**
     * @internal must only be used by client
     * @param segoff - The segment and offset to slide from
     * @returns The segment and offset to slide to
     */
    _getSlideToSegment(segoff) {
        if (!segoff.segment || !isRemovedAndAcked(segoff.segment)) {
            return segoff;
        }
        let slideToSegment;
        const goFurtherToFindSlideToSegment = (seg) => {
            if (seg.seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber && !isRemovedAndAcked(seg)) {
                slideToSegment = seg;
                return false;
            }
            return true;
        };
        // Slide to the next farthest valid segment in the tree.
        this.rightExcursion(segoff.segment, goFurtherToFindSlideToSegment);
        if (slideToSegment) {
            return { segment: slideToSegment, offset: 0 };
        }
        // If no such segment is found, slide to the last valid segment.
        this.leftExcursion(segoff.segment, goFurtherToFindSlideToSegment);
        // Workaround TypeScript issue (https://github.com/microsoft/TypeScript/issues/9998)
        slideToSegment = slideToSegment;
        if (slideToSegment) {
            // If slid nearer then offset should be at the end of the segment
            return { segment: slideToSegment, offset: slideToSegment.cachedLength - 1 };
        }
        return { segment: undefined, offset: 0 };
    }
    /**
     * This method should only be called when the current client sequence number is
     * max(remove segment sequence number, add reference sequence number).
     * Otherwise eventual consistency is not guaranteed.
     * See `packages\dds\merge-tree\REFERENCEPOSITIONS.md`
     */
    slideReferences(segment, refsToSlide) {
        var _a, _b, _c, _d, _e;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(isRemovedAndAcked(segment), 0x2f1 /* slideReferences from a segment which has not been removed and acked */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!segment.localRefs, 0x2f2 /* Ref not in the segment localRefs */);
        const newSegoff = this._getSlideToSegment({ segment, offset: 0 });
        const newSegment = newSegoff.segment;
        if (newSegment && !newSegment.localRefs) {
            newSegment.localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReferenceCollection(newSegment);
        }
        for (const ref of refsToSlide) {
            (_b = (_a = ref.callbacks) === null || _a === void 0 ? void 0 : _a.beforeSlide) === null || _b === void 0 ? void 0 : _b.call(_a);
            const removedRef = segment.localRefs.removeLocalRef(ref);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(ref === removedRef, 0x2f3 /* Ref not in the segment localRefs */);
            if (!newSegment) {
                // No valid segments (all nodes removed or not yet created)
                ref.segment = undefined;
                ref.offset = 0;
            }
            else {
                ref.segment = newSegment;
                ref.offset = (_c = newSegoff.offset) !== null && _c !== void 0 ? _c : 0;
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!newSegment.localRefs, 0x2f4 /* localRefs must be allocated */);
                newSegment.localRefs.addLocalRef(ref);
            }
            (_e = (_d = ref.callbacks) === null || _d === void 0 ? void 0 : _d.afterSlide) === null || _e === void 0 ? void 0 : _e.call(_d);
        }
        // TODO is it required to update the path lengths?
        if (newSegment) {
            this.blockUpdatePathLengths(newSegment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);
        }
    }
    updateSegmentRefsAfterMarkRemoved(segment, pending) {
        if (!segment.localRefs || segment.localRefs.empty) {
            return;
        }
        const refsToSlide = [];
        const refsToStay = [];
        for (const lref of segment.localRefs) {
            if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.StayOnRemove)) {
                refsToStay.push(lref);
            }
            else if ((0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(lref, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.SlideOnRemove)) {
                if (pending) {
                    refsToStay.push(lref);
                }
                else {
                    refsToSlide.push(lref);
                }
            }
        }
        // Rethink implementation of keeping and sliding refs once other reference
        // changes are complete. This works but is fragile and possibly slow.
        if (!pending) {
            this.slideReferences(segment, refsToSlide);
        }
        segment.localRefs.clear();
        for (const lref of refsToStay) {
            lref.segment = segment;
            segment.localRefs.addLocalRef(lref);
        }
    }
    blockLength(node, refSeq, clientId) {
        if ((this.collabWindow.collaborating) && (clientId !== this.collabWindow.clientId)) {
            return node.partialLengths.getPartialLength(refSeq, clientId);
        }
        else {
            return node.cachedLength;
        }
    }
    nodeLength(node, refSeq, clientId) {
        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId === clientId)) {
            // Local client sees all segments, even when collaborating
            if (!node.isLeaf()) {
                return node.cachedLength;
            }
            else {
                return this.localNetLength(node);
            }
        }
        else {
            // Sequence number within window
            if (!node.isLeaf()) {
                return node.partialLengths.getPartialLength(refSeq, clientId);
            }
            else {
                const segment = node;
                const removalInfo = toRemovalInfo(segment);
                if (removalInfo !== undefined
                    && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber
                    && removalInfo.removedSeq <= refSeq) {
                    // this segment is a tombstone eligible for zamboni
                    // so should never be considered, as it may not exist
                    // on other clients
                    return undefined;
                }
                if (((segment.clientId === clientId) ||
                    ((segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {
                    // Segment happened by reference sequence number or segment from requesting client
                    if (removalInfo !== undefined) {
                        if (removalInfo.removedClientIds.includes(clientId)) {
                            return 0;
                        }
                        else {
                            return segment.cachedLength;
                        }
                    }
                    else {
                        return segment.cachedLength;
                    }
                }
                else {
                    // the segment was inserted and removed before the
                    // this context, so it will never exist for this
                    // context
                    if (removalInfo !== undefined
                        && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {
                        return undefined;
                    }
                    // Segment invisible to client at reference sequence number/branch id/client id of op
                    return 0;
                }
            }
        }
    }
    addMinSeqListener(minRequired, onMinGE) {
        if (!this.minSeqListeners) {
            this.minSeqListeners = new _collections__WEBPACK_IMPORTED_MODULE_3__.Heap([], minListenerComparer);
        }
        this.minSeqListeners.add({ minRequired, onMinGE });
    }
    notifyMinSeqListeners() {
        if (this.minSeqListeners) {
            while ((this.minSeqListeners.count() > 0) &&
                (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {
                const minListener = this.minSeqListeners.get();
                minListener.onMinGE(this.collabWindow.minSeq);
            }
        }
    }
    setMinSeq(minSeq) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(minSeq <= this.collabWindow.currentSeq, 0x04e);
        // Only move forward
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this.collabWindow.minSeq <= minSeq, 0x04f /* "minSeq of collab window > target minSeq!" */);
        if (minSeq > this.collabWindow.minSeq) {
            this.collabWindow.minSeq = minSeq;
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
            this.notifyMinSeqListeners();
        }
    }
    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {
        const seg = refPos.getSegment();
        if (seg && seg.parent) {
            const offset = !seg.removedSeq ? refPos.getOffset() : 0;
            return offset + this.getPosition(seg, refSeq, clientId);
        }
        return _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReference.DetachedPosition;
    }
    getStackContext(startPos, clientId, rangeLabels) {
        const searchInfo = {
            mergeTree: this,
            stacks: (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)(),
            rangeLabels,
        };
        this.search(startPos, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);
        return searchInfo.stacks;
    }
    // TODO: filter function
    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {
        const searchInfo = {
            mergeTree: this,
            posPrecedesTile,
            tileLabel,
        };
        if (posPrecedesTile) {
            this.search(startPos, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        else {
            this.backwardSearch(startPos, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        if (searchInfo.tile) {
            let pos;
            if (searchInfo.tile.isLeaf()) {
                const marker = searchInfo.tile;
                pos = this.getPosition(marker, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, clientId);
            }
            else {
                const localRef = searchInfo.tile;
                pos = localRef.toPosition();
            }
            return { tile: searchInfo.tile, pos };
        }
    }
    search(pos, refSeq, clientId, actions, clientData) {
        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);
    }
    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {
        var _a;
        let _pos = pos;
        let _segpos = segpos;
        const children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, _segpos, refSeq, clientId, undefined, undefined, clientData);
        }
        const contains = actions && actions.contains;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            if ((!contains && _pos < len)
                || (contains && contains(child, _pos, refSeq, clientId, undefined, undefined, clientData))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    return this.searchBlock(child, _pos, _segpos, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, _segpos, refSeq, clientId, _pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, _segpos, refSeq, clientId, _pos, undefined, clientData);
                }
                _pos -= len;
                _segpos += len;
            }
        }
        if (actions && actions.post) {
            actions.post(block, _segpos, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    backwardSearch(pos, refSeq, clientId, actions, clientData) {
        const len = this.getLength(refSeq, clientId);
        if (pos > len) {
            return undefined;
        }
        return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);
    }
    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {
        var _a;
        let _segEnd = segEnd;
        const children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
        const contains = actions && actions.contains;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            const child = children[childIndex];
            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            const segpos = _segEnd - len;
            if (((!contains) && (pos >= segpos)) ||
                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    return this.backwardSearchBlock(child, pos, _segEnd, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);
                }
                _segEnd = segpos;
            }
        }
        if (actions && actions.post) {
            actions.post(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    updateRoot(splitNode) {
        if (splitNode !== undefined) {
            const newRoot = this.makeBlock(2);
            newRoot.assignChild(this.root, 0, false);
            newRoot.assignChild(splitNode, 1, false);
            this.root = newRoot;
            this.nodeUpdateOrdinals(this.root);
            this.nodeUpdateLengthNewStructure(this.root);
        }
    }
    /**
     * Assign sequence number to existing segment; update partial lengths to reflect the change
     * @param seq - sequence number given by server to pending segment
     */
    ackPendingSegment(opArgs) {
        const seq = opArgs.sequencedMessage.sequenceNumber;
        const pendingSegmentGroup = this.pendingSegments.dequeue();
        const nodesToUpdate = [];
        let overwrite = false;
        if (pendingSegmentGroup !== undefined) {
            const deltaSegments = [];
            pendingSegmentGroup.segments.map((pendingSegment) => {
                const overlappingRemove = !pendingSegment.ack(pendingSegmentGroup, opArgs, this);
                overwrite = overlappingRemove || overwrite;
                if (!overlappingRemove && opArgs.op.type === _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.REMOVE) {
                    this.updateSegmentRefsAfterMarkRemoved(pendingSegment, false);
                }
                if (MergeTree.options.zamboniSegments) {
                    this.addToLRUSet(pendingSegment, seq);
                }
                if (!nodesToUpdate.includes(pendingSegment.parent)) {
                    nodesToUpdate.push(pendingSegment.parent);
                }
                deltaSegments.push({
                    segment: pendingSegment,
                });
            });
            if (this.mergeTreeMaintenanceCallback) {
                this.mergeTreeMaintenanceCallback({
                    deltaSegments,
                    operation: _mergeTreeDeltaCallback__WEBPACK_IMPORTED_MODULE_9__.MergeTreeMaintenanceType.ACKNOWLEDGED,
                }, opArgs);
            }
            const clientId = this.collabWindow.clientId;
            for (const node of nodesToUpdate) {
                this.blockUpdatePathLengths(node, seq, clientId, overwrite);
                // NodeUpdatePathLengths(node, seq, clientId, true);
            }
        }
        if (MergeTree.options.zamboniSegments) {
            this.zamboniSegments();
        }
    }
    addToPendingList(segment, segmentGroup, localSeq) {
        let _segmentGroup = segmentGroup;
        if (_segmentGroup === undefined) {
            // TODO: review the cast
            _segmentGroup = { segments: [], localSeq };
            this.pendingSegments.enqueue(_segmentGroup);
        }
        segment.segmentGroups.enqueue(_segmentGroup);
        return _segmentGroup;
    }
    // TODO: error checking
    getMarkerFromId(id) {
        return this.idToSegment.get(id);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     * @param refseq - The reference sequence number at which to compute the position.
     * @param clientId - The client id with which to compute the position.
     */
    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {
        let pos = -1;
        let marker;
        if (relativePos.id) {
            marker = this.getMarkerFromId(relativePos.id);
        }
        if (marker) {
            pos = this.getPosition(marker, refseq, clientId);
            if (!relativePos.before) {
                pos += marker.cachedLength;
                if (relativePos.offset !== undefined) {
                    pos += relativePos.offset;
                }
            }
            else {
                if (relativePos.offset !== undefined) {
                    pos -= relativePos.offset;
                }
            }
        }
        return pos;
    }
    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {
        this.ensureIntervalBoundary(pos, refSeq, clientId);
        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments);
        // opArgs == undefined => loading snapshot or test code
        if (this.mergeTreeDeltaCallback && opArgs !== undefined) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.INSERT,
                deltaSegments: segments.map((segment) => ({ segment })),
            });
        }
        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&
            (seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {
            this.zamboniSegments();
        }
    }
    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {
        if (insertSegment.cachedLength === 0) {
            return;
        }
        if (insertSegment.parent
            || insertSegment.removedSeq
            || insertSegment.seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber) {
            throw new Error("Cannot insert segment that has already been inserted.");
        }
        const rebalanceTree = (segment) => {
            // Blocks should never be left full
            // if the inserts makes the block full
            // then we need to walk up the chain of parents
            // and split the blocks until we find a block with
            // room
            let block = segment.parent;
            let ordinalUpdateNode = block;
            while (block !== undefined) {
                if (block.childCount >= MaxNodesInBlock) {
                    const splitNode = this.split(block);
                    if (block === this.root) {
                        this.updateRoot(splitNode);
                        // Update root already updates all it's children ordinals
                        ordinalUpdateNode = undefined;
                    }
                    else {
                        this.insertChildNode(block.parent, splitNode, block.index + 1);
                        ordinalUpdateNode = splitNode.parent;
                        this.blockUpdateLength(block.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, clientId);
                    }
                }
                else {
                    this.blockUpdateLength(block, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber, clientId);
                }
                block = block.parent;
            }
            // Only update ordinals once, for all children,
            // on the path
            if (ordinalUpdateNode) {
                this.nodeUpdateOrdinals(ordinalUpdateNode);
            }
        };
        const clientId = this.collabWindow.clientId;
        const refSegment = referencePosition.getSegment();
        const refOffset = referencePosition.getOffset();
        const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);
        let startSeg = refSegment;
        // if the change isn't at a boundary, we need to split the segment
        if (refOffset !== 0 && refSegLen !== undefined && refSegLen !== 0) {
            const splitSeg = this.splitLeafSegment(refSegment, refOffset);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!splitSeg.next, 0x050 /* "Next segment changes are undefined!" */);
            this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);
            rebalanceTree(splitSeg.next);
            startSeg = splitSeg.next;
        }
        // walk back from the segment, to see if there is a previous tie break seg
        this.leftExcursion(startSeg, (backSeg) => {
            if (!backSeg.isLeaf()) {
                return true;
            }
            const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId);
            // ignore removed segments
            if (backLen === undefined) {
                return true;
            }
            // Find the nearest 0 length seg we can insert over, as all other inserts
            // go near to far
            if (backLen === 0) {
                if (this.breakTie(0, backSeg, _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {
                    startSeg = backSeg;
                }
                return true;
            }
            return false;
        });
        if (this.collabWindow.collaborating) {
            insertSegment.localSeq = ++this.collabWindow.localSeq;
            insertSegment.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber;
        }
        else {
            insertSegment.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;
        }
        insertSegment.clientId = clientId;
        if (Marker.is(insertSegment)) {
            const markerId = insertSegment.getId();
            if (markerId) {
                this.mapIdToSegment(markerId, insertSegment);
            }
        }
        this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);
        rebalanceTree(insertSegment);
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                deltaSegments: [{ segment: insertSegment }],
                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.INSERT,
            });
        }
        if (this.collabWindow.collaborating) {
            this.addToPendingList(insertSegment, undefined, insertSegment.localSeq);
        }
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence. The client ref seq must be above the minimum sequence number
     * or the return value will be undefined.
     * Generally this method is used in conjunction with signals which provide
     * point in time values for the below parameters, and is useful for things
     * like displaying user position. It should not be used with persisted values
     * as persisted values will quickly become invalid as the remoteClientRefSeq
     * moves below the minimum sequence number
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        if (remoteClientRefSeq < this.collabWindow.minSeq) {
            return undefined;
        }
        const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);
        const segwindow = this.getCollabWindow();
        if (segmentInfo && segmentInfo.segment) {
            const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);
            return segmentPosition + segmentInfo.offset;
        }
        else {
            if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {
                return this.getLength(segwindow.currentSeq, segwindow.clientId);
            }
        }
    }
    insertChildNode(block, child, childIndex) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(block.childCount < MaxNodesInBlock, 0x051 /* "Too many children on merge block!" */);
        for (let i = block.childCount; i > childIndex; i--) {
            block.children[i] = block.children[i - 1];
            block.children[i].index = i;
        }
        block.childCount++;
        block.assignChild(child, childIndex, false);
    }
    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {
        let segIsLocal = false;
        const checkSegmentIsLocal = (segment) => {
            if (segment.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {
                segIsLocal = true;
            }
            // Only need to look at first segment that follows finished node
            return false;
        };
        const continueFrom = (node) => {
            segIsLocal = false;
            this.rightExcursion(node, checkSegmentIsLocal);
            return segIsLocal;
        };
        let segmentGroup;
        const saveIfLocal = (locSegment) => {
            // Save segment so can assign sequence number when acked by server
            if (this.collabWindow.collaborating) {
                if ((locSegment.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {
                    segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq);
                    // eslint-disable-next-line @typescript-eslint/brace-style
                }
                // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()
                // In all other cases this has to be true (checked by addToLRUSet):
                // locSegment.seq > this.collabWindow.currentSeq
                else if ((locSegment.seq > this.collabWindow.minSeq) &&
                    MergeTree.options.zamboniSegments) {
                    this.addToLRUSet(locSegment, locSegment.seq);
                }
            }
        };
        const onLeaf = (segment, _pos, context) => {
            const segmentChanges = {};
            if (segment) {
                // Insert before segment
                segmentChanges.replaceCurrent = context.candidateSegment;
                segmentChanges.next = segment;
            }
            else {
                segmentChanges.next = context.candidateSegment;
            }
            return segmentChanges;
        };
        // TODO: build tree from segs and insert all at once
        let insertPos = pos;
        for (const newSegment of newSegments) {
            segIsLocal = false;
            if (newSegment.cachedLength > 0) {
                newSegment.seq = seq;
                newSegment.localSeq = localSeq;
                newSegment.clientId = clientId;
                if (Marker.is(newSegment)) {
                    const markerId = newSegment.getId();
                    if (markerId) {
                        this.mapIdToSegment(markerId, newSegment);
                    }
                }
                const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });
                if (newSegment.parent === undefined) {
                    throw new Error(`MergeTree insert failed: ${JSON.stringify({
                        currentSeq: this.collabWindow.currentSeq,
                        minSeq: this.collabWindow.minSeq,
                        segSeq: newSegment.seq,
                    })}`);
                }
                this.updateRoot(splitNode);
                saveIfLocal(newSegment);
                insertPos += newSegment.cachedLength;
            }
        }
    }
    ensureIntervalBoundary(pos, refSeq, clientId) {
        const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, { leaf: this.splitLeafSegment });
        this.updateRoot(splitNode);
    }
    // Assume called only when pos == len
    breakTie(pos, node, seq) {
        var _a;
        if (node.isLeaf()) {
            if (pos === 0) {
                // normalize the seq numbers
                // if the new seg is local (UnassignedSequenceNumber) give it the highest possible
                // seq for comparison, as it will get a seq higher than any other seq once sequences
                // if the current seg is local (UnassignedSequenceNumber) give it the second highest
                // possible seq, as the highest is reserved for the previous.
                const newSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER : seq;
                const segSeq = node.seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER - 1 : (_a = node.seq) !== null && _a !== void 0 ? _a : 0;
                return newSeq > segSeq;
            }
            return false;
        }
        else {
            return true;
        }
    }
    // Visit segments starting from node's left siblings, then up to node's parent
    leftExcursion(node, leafAction) {
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            const children = parent.children;
            let childIndex;
            let _node;
            let matchedStart = false;
            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {
                _node = children[childIndex];
                if (matchedStart) {
                    if (!_node.isLeaf()) {
                        const childBlock = _node;
                        go = this.nodeMapReverse(childBlock, leafAction, 0, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, this.collabWindow.clientId);
                    }
                    else {
                        go = leafAction(_node, 0, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === _node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    /**
     * Visit segments starting from node's right siblings, then up to node's parent.
     * All segments past `node` are visited, regardless of their visibility.
     */
    rightExcursion(node, leafAction) {
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            const children = parent.children;
            let childIndex;
            let _node;
            let matchedStart = false;
            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
                _node = children[childIndex];
                if (matchedStart) {
                    if (!_node.isLeaf()) {
                        const childBlock = _node;
                        go = this.walkAllSegments(childBlock, leafAction);
                    }
                    else {
                        go = leafAction(_node);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === _node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    insertingWalk(block, pos, refSeq, clientId, seq, context) {
        let _pos = pos;
        const children = block.children;
        let childIndex;
        let child;
        let newNode;
        let fromSplit;
        for (childIndex = 0; childIndex < block.childCount; childIndex++) {
            child = children[childIndex];
            const len = this.nodeLength(child, refSeq, clientId);
            if (len === undefined) {
                // if the seg len in undefined, the segment
                // will be removed, so should just be skipped for now
                continue;
            }
            if ((_pos < len) || ((_pos === len) && this.breakTie(_pos, child, seq))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    const childBlock = child;
                    // Internal node
                    const splitNode = this.insertingWalk(childBlock, _pos, refSeq, clientId, seq, context);
                    if (splitNode === undefined) {
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        else {
                            this.blockUpdateLength(block, seq, clientId);
                        }
                        return undefined;
                    }
                    else if (splitNode === MergeTree.theUnfinishedNode) {
                        _pos -= len; // Act as if shifted segment
                        continue;
                    }
                    else {
                        newNode = splitNode;
                        fromSplit = splitNode;
                        childIndex++; // Insert after
                    }
                }
                else {
                    const segment = child;
                    const segmentChanges = context.leaf(segment, _pos, context);
                    if (segmentChanges.replaceCurrent) {
                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);
                        segmentChanges.replaceCurrent.ordinal = child.ordinal;
                    }
                    if (segmentChanges.next) {
                        newNode = segmentChanges.next;
                        childIndex++; // Insert after
                    }
                    else {
                        // No change
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        return undefined;
                    }
                }
                break;
            }
            else {
                _pos -= len;
            }
        }
        if (!newNode) {
            if (_pos === 0) {
                if ((seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) && context.continuePredicate &&
                    context.continuePredicate(block)) {
                    return MergeTree.theUnfinishedNode;
                }
                else {
                    const segmentChanges = context.leaf(undefined, _pos, context);
                    newNode = segmentChanges.next;
                    // Assert segmentChanges.replaceCurrent === undefined
                }
            }
        }
        if (newNode) {
            for (let i = block.childCount; i > childIndex; i--) {
                block.children[i] = block.children[i - 1];
                block.children[i].index = i;
            }
            block.assignChild(newNode, childIndex, false);
            block.childCount++;
            block.setOrdinal(newNode, childIndex);
            if (block.childCount < MaxNodesInBlock) {
                if (fromSplit) {
                    this.nodeUpdateOrdinals(fromSplit);
                }
                if (context.structureChange) {
                    this.nodeUpdateLengthNewStructure(block);
                }
                else {
                    this.blockUpdateLength(block, seq, clientId);
                }
                return undefined;
            }
            else {
                // Don't update ordinals because higher block will do it
                return this.split(block);
            }
        }
        else {
            return undefined;
        }
    }
    split(node) {
        const halfCount = MaxNodesInBlock / 2;
        const newNode = this.makeBlock(halfCount);
        node.childCount = halfCount;
        // Update ordinals to reflect lowered child count
        this.nodeUpdateOrdinals(node);
        for (let i = 0; i < halfCount; i++) {
            newNode.assignChild(node.children[halfCount + i], i, false);
            node.children[halfCount + i] = undefined;
        }
        this.nodeUpdateLengthNewStructure(node);
        this.nodeUpdateLengthNewStructure(newNode);
        return newNode;
    }
    nodeUpdateOrdinals(block) {
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            block.setOrdinal(child, i);
            if (!child.isLeaf()) {
                this.nodeUpdateOrdinals(child);
            }
        }
    }
    /**
     * Annotate a range with properties
     * @param start - The inclusive start position of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     * @param refSeq - The reference sequence number to use to apply the annotate
     * @param clientId - The id of the client making the annotate
     * @param seq - The sequence number of the annotate operation
     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one
     */
    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        const deltaSegments = [];
        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        let segmentGroup;
        const annotateSegment = (segment) => {
            const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);
            deltaSegments.push({ segment, propertyDeltas });
            if (this.collabWindow.collaborating) {
                if (seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
            }
            return true;
        };
        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);
        // OpArgs == undefined => test code
        if (this.mergeTreeDeltaCallback && deltaSegments.length > 0) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.ANNOTATE,
                deltaSegments,
            });
        }
        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
    }
    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {
        let _overwrite = overwrite;
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        let segmentGroup;
        const removedSegments = [];
        const segmentsWithRefs = [];
        const localSeq = seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        const markRemoved = (segment, pos, _start, _end) => {
            const existingRemovalInfo = toRemovalInfo(segment);
            if (existingRemovalInfo !== undefined) {
                _overwrite = true;
                if (existingRemovalInfo.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber) {
                    // we removed this locally, but someone else removed it first
                    // so put them at the head of the list
                    // the list isn't ordered, but we
                    // keep first removal at the head.
                    existingRemovalInfo.removedClientIds.unshift(clientId);
                    existingRemovalInfo.removedSeq = seq;
                    segment.localRemovedSeq = undefined;
                }
                else {
                    // Do not replace earlier sequence number for remove
                    existingRemovalInfo.removedClientIds.push(clientId);
                }
            }
            else {
                segment.removedClientIds = [clientId];
                segment.removedSeq = seq;
                segment.localRemovedSeq = localSeq;
                removedSegments.push({ segment });
            }
            if (segment.localRefs && !segment.localRefs.empty) {
                segmentsWithRefs.push(segment);
            }
            // Save segment so can assign removed sequence number when acked by server
            if (this.collabWindow.collaborating) {
                if (segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
            }
            return true;
        };
        const afterMarkRemoved = (node, pos, _start, _end) => {
            if (_overwrite) {
                this.nodeUpdateLengthNewStructure(node);
            }
            else {
                this.blockUpdateLength(node, seq, clientId);
            }
            return true;
        };
        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);
        const pending = this.collabWindow.collaborating && clientId === this.collabWindow.clientId;
        for (const segment of segmentsWithRefs) {
            this.updateSegmentRefsAfterMarkRemoved(segment, pending);
        }
        // opArgs == undefined => test code
        if (this.mergeTreeDeltaCallback && removedSegments.length > 0) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: _ops__WEBPACK_IMPORTED_MODULE_4__.MergeTreeDeltaType.REMOVE,
                deltaSegments: removedSegments,
            });
        }
        if (this.collabWindow.collaborating && (seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
    }
    nodeUpdateLengthNewStructure(node, recur = false) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating) {
            node.partialLengths = _partialLengths__WEBPACK_IMPORTED_MODULE_11__.PartialSequenceLengths.combine(this, node, this.collabWindow, recur);
        }
    }
    removeLocalReferencePosition(lref) {
        var _a;
        const segment = lref.getSegment();
        if (segment) {
            const removedRefs = (_a = segment === null || segment === void 0 ? void 0 : segment.localRefs) === null || _a === void 0 ? void 0 : _a.removeLocalRef(lref);
            if (removedRefs !== undefined) {
                this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);
            }
            return removedRefs;
        }
    }
    createLocalReferencePosition(segment, offset, refType, properties, client) {
        var _a;
        if (isRemoved(segment)) {
            if (!(0,_referencePositions__WEBPACK_IMPORTED_MODULE_2__.refTypeIncludesFlag)(refType, _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.SlideOnRemove | _ops__WEBPACK_IMPORTED_MODULE_4__.ReferenceType.Transient)) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_12__.UsageError("Can only create SlideOnRemove or Transient local reference position on a removed segment");
            }
        }
        const localRefs = (_a = segment.localRefs) !== null && _a !== void 0 ? _a : new _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReferenceCollection(segment);
        segment.localRefs = localRefs;
        const segRef = localRefs.createLocalRef(offset, refType, properties, client);
        this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);
        return segRef;
    }
    /**
     * @deprecated - use removeLocalReferencePosition
     */
    removeLocalReference(segment, lref) {
        if (segment.localRefs) {
            const removedRef = segment.localRefs.removeLocalRef(lref);
            if (removedRef) {
                this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);
            }
        }
    }
    /**
     * @deprecated - use createLocalReference
     */
    addLocalReference(lref) {
        const segment = lref.segment;
        let localRefs = segment.localRefs;
        if (!localRefs) {
            localRefs = new _localReference__WEBPACK_IMPORTED_MODULE_10__.LocalReferenceCollection(segment);
            segment.localRefs = localRefs;
        }
        localRefs.addLocalRef(lref);
        this.blockUpdatePathLengths(segment.parent, _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber, _constants__WEBPACK_IMPORTED_MODULE_1__.LocalClientId);
    }
    blockUpdate(block) {
        var _a;
        let len = 0;
        const hierBlock = block.hierBlock();
        if (hierBlock) {
            hierBlock.rightmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();
            hierBlock.leftmostTiles = (0,_properties__WEBPACK_IMPORTED_MODULE_5__.createMap)();
            hierBlock.rangeStacks = {};
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            len += (_a = nodeTotalLength(this, child)) !== null && _a !== void 0 ? _a : 0;
            if (hierBlock) {
                hierBlock.addNodeReferences(this, child);
            }
            if (this.blockUpdateActions) {
                this.blockUpdateActions.child(block, i);
            }
        }
        block.cachedLength = len;
    }
    blockUpdatePathLengths(startBlock, seq, clientId, newStructure = false) {
        let block = startBlock;
        while (block !== undefined) {
            if (newStructure) {
                this.nodeUpdateLengthNewStructure(block);
            }
            else {
                this.blockUpdateLength(block, seq, clientId);
            }
            block = block.parent;
        }
    }
    blockUpdateLength(node, seq, clientId) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating
            && seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.UnassignedSequenceNumber
            && seq !== _constants__WEBPACK_IMPORTED_MODULE_1__.TreeMaintenanceSequenceNumber) {
            if (node.partialLengths !== undefined
                && MergeTree.options.incrementalUpdate
                && clientId !== _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient) {
                node.partialLengths.update(this, node, seq, clientId, this.collabWindow);
            }
            else {
                node.partialLengths = _partialLengths__WEBPACK_IMPORTED_MODULE_11__.PartialSequenceLengths.combine(this, node, this.collabWindow);
            }
        }
    }
    map(actions, refSeq, clientId, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);
    }
    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {
        if (splitRange) {
            if (start) {
                this.ensureIntervalBoundary(start, refSeq, clientId);
            }
            if (end) {
                this.ensureIntervalBoundary(end, refSeq, clientId);
            }
        }
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);
    }
    incrementalBlockMap(stateStack) {
        var _a;
        while (!stateStack.empty()) {
            // We already check the stack is not empty
            const state = stateStack.top();
            if (state.op !== IncrementalExecOp.Go) {
                return;
            }
            if (state.childIndex === 0) {
                if (state.start === undefined) {
                    state.start = 0;
                }
                if (state.end === undefined) {
                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);
                }
                if (state.actions.pre) {
                    state.actions.pre(state);
                }
            }
            if ((state.op === IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {
                const child = state.block.children[state.childIndex];
                const len = (_a = this.nodeLength(child, state.refSeq, state.clientId)) !== null && _a !== void 0 ? _a : 0;
                if ((len > 0) && (state.start < len) && (state.end > 0)) {
                    if (!child.isLeaf()) {
                        const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);
                        stateStack.push(childState);
                    }
                    else {
                        state.actions.leaf(child, state);
                    }
                }
                state.pos += len;
                state.start -= len;
                state.end -= len;
                state.childIndex++;
            }
            else {
                if (state.childIndex === state.block.childCount) {
                    if ((state.op === IncrementalExecOp.Go) && state.actions.post) {
                        state.actions.post(state);
                    }
                    stateStack.pop();
                }
            }
        }
    }
    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {
        var _a;
        let _start = start;
        let _end = end;
        let _pos = pos;
        if (_start === undefined) {
            _start = 0;
        }
        if (_end === undefined) {
            _end = this.blockLength(node, refSeq, clientId);
        }
        let go = true;
        if (actions.pre) {
            go = actions.pre(node, _pos, refSeq, clientId, _start, _end, accum);
            if (!go) {
                // Cancel this node but not entire traversal
                return true;
            }
        }
        const children = node.children;
        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {
            const child = children[childIndex];
            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            if (go && (_end > 0) && (len > 0) && (_start < len)) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    if (go) {
                        go = this.nodeMap(child, actions, _pos, refSeq, clientId, accum, _start, _end);
                    }
                }
                else {
                    if (actions.leaf) {
                        go = actions.leaf(child, _pos, refSeq, clientId, _start, _end, accum);
                    }
                }
            }
            if (!go) {
                break;
            }
            if (actions.shift) {
                actions.shift(child, _pos, refSeq, clientId, _start, _end, accum);
            }
            _pos += len;
            _start -= len;
            _end -= len;
        }
        if (go && actions.post) {
            go = actions.post(node, _pos, refSeq, clientId, _start, _end, accum);
        }
        return go;
    }
    // Invokes the leaf action for all segments.  Note that *all* segments are visited
    // regardless of if they would be visible to the current `clientId` and `refSeq`.
    walkAllSegments(block, action, accum) {
        let go = true;
        const children = block.children;
        for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            go = child.isLeaf()
                ? action(child, accum)
                : this.walkAllSegments(child, action, accum);
        }
        return go;
    }
    // Straight call every segment; goes until leaf action returns false
    nodeMapReverse(block, leafAction, pos, refSeq, clientId) {
        let go = true;
        const children = block.children;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            const child = children[childIndex];
            if (go) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    if (go) {
                        go = this.nodeMapReverse(child, leafAction, pos, refSeq, clientId);
                    }
                }
                else {
                    go = leafAction(child, pos, refSeq, clientId, 0, 0, undefined);
                }
            }
            if (!go) {
                break;
            }
        }
        return go;
    }
}
MergeTree.zamboniSegmentsMaxCount = 2;
MergeTree.options = {
    incrementalUpdate: true,
    insertAfterRemovedSegs: true,
    zamboniSegments: true,
};
MergeTree.theUnfinishedNode = { childCount: -1 };
//# sourceMappingURL=mergeTree.js.map

/***/ }),
/* 295 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentGroupCollection": () => (/* binding */ SegmentGroupCollection)
/* harmony export */ });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class SegmentGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.segmentGroups = (0,_collections__WEBPACK_IMPORTED_MODULE_0__.ListMakeHead)();
    }
    get size() {
        return this.segmentGroups.count();
    }
    get empty() {
        return this.segmentGroups.empty();
    }
    enqueue(segmentGroup) {
        this.segmentGroups.enqueue(segmentGroup);
        segmentGroup.segments.push(this.segment);
    }
    dequeue() {
        return this.segmentGroups.dequeue();
    }
    clear() {
        this.segmentGroups.clear();
    }
    copyTo(segment) {
        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));
    }
}
//# sourceMappingURL=segmentGroupCollection.js.map

/***/ }),
/* 296 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrackingGroup": () => (/* binding */ TrackingGroup),
/* harmony export */   "TrackingGroupCollection": () => (/* binding */ TrackingGroupCollection)
/* harmony export */ });
/* harmony import */ var _sortedSegmentSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(297);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class TrackingGroup {
    constructor() {
        this.segmentSet = new _sortedSegmentSet__WEBPACK_IMPORTED_MODULE_0__.SortedSegmentSet();
    }
    get segments() {
        return this.segmentSet.items;
    }
    get size() {
        return this.segmentSet.size;
    }
    has(segment) {
        return this.segmentSet.has(segment);
    }
    link(segment) {
        if (!this.segmentSet.has(segment)) {
            this.segmentSet.addOrUpdate(segment);
            segment.trackingCollection.link(this);
        }
    }
    unlink(segment) {
        if (this.segmentSet.remove(segment)) {
            segment.trackingCollection.unlink(this);
        }
    }
}
class TrackingGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.trackingGroups = new Set();
    }
    link(trackingGroup) {
        if (trackingGroup) {
            if (!this.trackingGroups.has(trackingGroup)) {
                this.trackingGroups.add(trackingGroup);
            }
            if (!trackingGroup.has(this.segment)) {
                trackingGroup.link(this.segment);
            }
        }
    }
    unlink(trackingGroup) {
        if (trackingGroup.has(this.segment)) {
            trackingGroup.unlink(this.segment);
        }
        this.trackingGroups.delete(trackingGroup);
    }
    copyTo(segment) {
        this.trackingGroups.forEach((sg) => segment.trackingCollection.link(sg));
    }
    get empty() {
        return this.trackingGroups.size === 0;
    }
    matches(trackingCollection) {
        if (!trackingCollection
            || this.trackingGroups.size !== trackingCollection.trackingGroups.size) {
            return false;
        }
        for (const tg of this.trackingGroups.values()) {
            if (!trackingCollection.trackingGroups.has(tg)) {
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=mergeTreeTracking.js.map

/***/ }),
/* 297 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SortedSegmentSet": () => (/* binding */ SortedSegmentSet)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Stores a unique and sorted set of segments, or objects with segments
 *
 * This differs from a normal sorted set in that the keys are not fixed.
 * The segments are sorted via their ordinals which can change as the merge tree is modified.
 * Even though the values of the ordinals can change their ordering and uniqueness cannot, so the order of a set of
 * segments ordered by their ordinals will always have the same order even if the ordinal values on
 * the segments changes. This invariant allows ensure the segments stay ordered and unique, and that new segments
 * can be inserted into that order.
 */
class SortedSegmentSet {
    constructor() {
        this.ordinalSortedItems = [];
    }
    get size() {
        return this.ordinalSortedItems.length;
    }
    get items() {
        return this.ordinalSortedItems;
    }
    addOrUpdate(newItem, update) {
        const position = this.findOrdinalPosition(this.getOrdinal(newItem));
        if (position.exists) {
            if (update) {
                update(this.ordinalSortedItems[position.index], newItem);
            }
        }
        else {
            this.ordinalSortedItems.splice(position.index, 0, newItem);
        }
    }
    remove(item) {
        const position = this.findOrdinalPosition(this.getOrdinal(item));
        if (position.exists) {
            this.ordinalSortedItems.splice(position.index, 1);
            return true;
        }
        return false;
    }
    has(item) {
        const position = this.findOrdinalPosition(this.getOrdinal(item));
        return position.exists;
    }
    getOrdinal(item) {
        const maybeObject = item;
        if (maybeObject === null || maybeObject === void 0 ? void 0 : maybeObject.segment) {
            return maybeObject.segment.ordinal;
        }
        const maybeSegment = item;
        return maybeSegment.ordinal;
    }
    findOrdinalPosition(ordinal, start, end) {
        if (this.ordinalSortedItems.length === 0) {
            return { exists: false, index: 0 };
        }
        if (start === undefined || end === undefined) {
            return this.findOrdinalPosition(ordinal, 0, this.ordinalSortedItems.length - 1);
        }
        const index = start + Math.floor((end - start) / 2);
        if (this.getOrdinal(this.ordinalSortedItems[index]) > ordinal) {
            if (start === index) {
                return { exists: false, index };
            }
            return this.findOrdinalPosition(ordinal, start, index - 1);
        }
        else if (this.getOrdinal(this.ordinalSortedItems[index]) < ordinal) {
            if (index === end) {
                return { exists: false, index: index + 1 };
            }
            return this.findOrdinalPosition(ordinal, index + 1, end);
        }
        return { exists: true, index };
    }
}
//# sourceMappingURL=sortedSegmentSet.js.map

/***/ }),
/* 298 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MergeTreeMaintenanceType": () => (/* binding */ MergeTreeMaintenanceType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Enum-like constant defining the types of "maintenance" events on a merge tree.
 * Maintenance events correspond to structural segment changes or acks of pending segments.
 *
 * Note: these values are assigned negative integers to avoid clashing with `MergeTreeDeltaType`.
 */
const MergeTreeMaintenanceType = {
    /**
     * Notification that a segment "append" has occurred, i.e. two adjacent segments have been merged.
     * BEWARE: `deltaSegments` on the corresponding event will contain both the merged segment and the latter
     * segment, pre-merge.
     * For example, if the merge tree originally had two adjacent segments [A][B] and called A.append(B) to get
     * segment [AB], `deltaSegments` would contain [AB] and [B].
     */
    APPEND: -1,
    /**
     * Notification that a segment has been split in two.
     * `deltaSegments` on the corresponding event will contain the resulting two segments.
     */
    SPLIT: -2,
    /**
     * Notification that a segment has been unlinked (i.e. removed) from the MergeTree.
     * This occurs on leaf segments during Zamboni when the segment's tracking collection is empty
     * (e.g., not being tracked for undo/redo).
     * It also occurs on internal merge tree segments when re-packing children to maintain tree balancing invariants.
     */
    UNLINK: -3,
    /**
     * Notification that a local change has been acknowledged by the server.
     * This means that it has made the round trip to the server and has had a sequence number assigned.
     */
    ACKNOWLEDGED: -4,
};
//# sourceMappingURL=mergeTreeDeltaCallback.js.map

/***/ }),
/* 299 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartialSequenceLengths": () => (/* binding */ PartialSequenceLengths)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(283);
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(285);
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * Returns the partial length whose sequence number is
 * the greatest sequence number within a that is
 * less than or equal to key.
 * @param a - array of partial segment lengths
 * @param key - sequence number
 */
function latestLEQ(a, key) {
    let best = -1;
    let lo = 0;
    let hi = a.length - 1;
    while (lo <= hi) {
        const mid = lo + Math.floor((hi - lo) / 2);
        if (a[mid].seq <= key) {
            if ((best < 0) || (a[best].seq < a[mid].seq)) {
                best = mid;
            }
            lo = mid + 1;
        }
        else {
            hi = mid - 1;
        }
    }
    return best;
}
/**
 * Keep track of partial sums of segment lengths for all sequence numbers
 * in the current collaboration window (if any).  Only used during active
 * collaboration.
 */
class PartialSequenceLengths {
    constructor(minSeq) {
        this.minSeq = minSeq;
        this.minLength = 0;
        this.segmentCount = 0;
        this.partialLengths = [];
        this.clientSeqNumbers = [];
    }
    static combine(mergeTree, block, collabWindow, recur = false) {
        return PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, recur);
    }
    /**
     * Combine the partial lengths of block's children
     * @param block - an interior node; it is assumed that each interior node child of this block
     * has its partials up to date
     * @param collabWindow - segment window of the segment tree containing textSegmentBlock
     */
    static combineBranch(mergeTree, block, collabWindow, recur = false) {
        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
        PartialSequenceLengths.fromLeaves(combinedPartialLengths, block, collabWindow);
        let prevPartial;
        function cloneOverlapRemoveClients(oldTree) {
            if (!oldTree) {
                return undefined;
            }
            const newTree = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);
            oldTree.map((bProp) => {
                newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));
                return true;
            });
            return newTree;
        }
        function combineOverlapClients(a, b) {
            const overlapRemoveClientsA = a.overlapRemoveClients;
            if (overlapRemoveClientsA) {
                if (b.overlapRemoveClients) {
                    b.overlapRemoveClients.map((bProp) => {
                        const aProp = overlapRemoveClientsA.get(bProp.key);
                        if (aProp) {
                            aProp.data.seglen += bProp.data.seglen;
                        }
                        else {
                            overlapRemoveClientsA.put(bProp.data.clientId, Object.assign({}, bProp.data));
                        }
                        return true;
                    });
                }
            }
            else {
                a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);
            }
        }
        function addNext(partialLength) {
            const seq = partialLength.seq;
            let pLen = 0;
            if (prevPartial) {
                if (prevPartial.seq === partialLength.seq) {
                    prevPartial.seglen += partialLength.seglen;
                    prevPartial.len += partialLength.seglen;
                    combineOverlapClients(prevPartial, partialLength);
                    return;
                }
                else {
                    pLen = prevPartial.len;
                    // Previous sequence number is finished
                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
                }
            }
            prevPartial = {
                clientId: partialLength.clientId,
                len: pLen + partialLength.seglen,
                overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),
                seglen: partialLength.seglen,
                seq,
            };
            combinedPartialLengths.partialLengths.push(prevPartial);
        }
        const childPartials = [];
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (!child.isLeaf()) {
                const childBlock = child;
                if (recur) {
                    childBlock.partialLengths =
                        PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                childPartials.push(childBlock.partialLengths);
            }
        }
        let childPartialsLen = childPartials.length;
        if (childPartialsLen !== 0) {
            // Some children are interior nodes
            if (combinedPartialLengths.partialLengths.length > 0) {
                // Some children were leaves; add combined partials from these segments
                childPartials.push(combinedPartialLengths);
                childPartialsLen++;
                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
            }
            const indices = new Array(childPartialsLen);
            const childPartialsCounts = new Array(childPartialsLen);
            for (let i = 0; i < childPartialsLen; i++) {
                indices[i] = 0;
                childPartialsCounts[i] = childPartials[i].partialLengths.length;
                combinedPartialLengths.minLength += childPartials[i].minLength;
                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;
            }
            let outerIndexOfEarliest = 0;
            let earliestPartialLength;
            while (outerIndexOfEarliest >= 0) {
                outerIndexOfEarliest = -1;
                for (let k = 0; k < childPartialsLen; k++) {
                    // Find next earliest sequence number
                    if (indices[k] < childPartialsCounts[k]) {
                        const cpLen = childPartials[k].partialLengths[indices[k]];
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {
                            outerIndexOfEarliest = k;
                            earliestPartialLength = cpLen;
                        }
                    }
                }
                if (outerIndexOfEarliest >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    addNext(earliestPartialLength);
                    indices[outerIndexOfEarliest]++;
                }
            }
            // Add client entry for last partial, if any
            if (prevPartial) {
                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
            }
        }
        // TODO: incremental zamboni during build
        if (PartialSequenceLengths.options.zamboni) {
            combinedPartialLengths.zamboni(collabWindow);
        }
        if (PartialSequenceLengths.options.verify) {
            combinedPartialLengths.verify();
        }
        return combinedPartialLengths;
    }
    static fromLeaves(combinedPartialLengths, block, collabWindow) {
        combinedPartialLengths.minLength = 0;
        combinedPartialLengths.segmentCount = block.childCount;
        function seqLTE(seq, minSeq) {
            return seq !== undefined && seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber && seq <= minSeq;
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.isLeaf()) {
                // Leaf segment
                const segment = child;
                if (seqLTE(segment.seq, collabWindow.minSeq)) {
                    combinedPartialLengths.minLength += segment.cachedLength;
                }
                else {
                    if (segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);
                    }
                }
                const removalInfo = (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.toRemovalInfo)(segment);
                if (seqLTE(removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq, collabWindow.minSeq)) {
                    combinedPartialLengths.minLength -= segment.cachedLength;
                }
                else {
                    if (removalInfo !== undefined
                        && removalInfo.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_2__.UnassignedSequenceNumber) {
                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, removalInfo);
                    }
                }
            }
        }
        // Post-process correctly-ordered partials computing sums and creating
        // lists for each present client id
        const seqPartials = combinedPartialLengths.partialLengths;
        const seqPartialsLen = seqPartials.length;
        let prevLen = 0;
        for (let i = 0; i < seqPartialsLen; i++) {
            seqPartials[i].len = prevLen + seqPartials[i].seglen;
            prevLen = seqPartials[i].len;
            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);
        }
        if (PartialSequenceLengths.options.verify) {
            combinedPartialLengths.verify();
        }
    }
    static getOverlapClients(overlapClientIds, seglen) {
        const bst = new _collections__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree(_mergeTree__WEBPACK_IMPORTED_MODULE_1__.compareNumbers);
        for (const clientId of overlapClientIds) {
            bst.put(clientId, { clientId, seglen });
        }
        return bst;
    }
    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {
        if (partialLength.overlapRemoveClients) {
            for (const clientId of overlapRemoveClientIds) {
                const overlapClientNode = partialLength.overlapRemoveClients.get(clientId);
                if (!overlapClientNode) {
                    partialLength.overlapRemoveClients.put(clientId, { clientId, seglen });
                }
                else {
                    overlapClientNode.data.seglen += seglen;
                }
            }
        }
        else {
            partialLength.overlapRemoveClients =
                PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);
        }
    }
    static insertSegment(combinedPartialLengths, segment, removalInfo) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        let seq = segment.seq;
        let segmentLen = segment.cachedLength;
        let clientId = segment.clientId;
        let removeClientOverlap;
        if (removalInfo) {
            seq = removalInfo.removedSeq;
            segmentLen = -segmentLen;
            // this code still assume removed client id and
            // overlap clients are separate. so we need to pull
            // then apart first.
            clientId = removalInfo.removedClientIds[0];
            removeClientOverlap = removalInfo.removedClientIds.length > 1
                ? removalInfo.removedClientIds.slice(1)
                : undefined;
        }
        const seqPartials = combinedPartialLengths.partialLengths;
        const seqPartialsLen = seqPartials.length;
        // Find the first entry with sequence number greater or equal to seq
        let indexFirstGTE = 0;
        for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {
            if (seqPartials[indexFirstGTE].seq >= seq) {
                break;
            }
        }
        if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq === seq)) {
            seqPartials[indexFirstGTE].seglen += segmentLen;
            if (removeClientOverlap) {
                PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);
            }
        }
        else {
            let pLen;
            if (removeClientOverlap) {
                const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);
                pLen = { seq, clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };
            }
            else {
                pLen = { seq, clientId, len: 0, seglen: segmentLen };
            }
            if (indexFirstGTE < seqPartialsLen) {
                // Shift entries with greater sequence numbers
                // TODO: investigate performance improvement using BST
                for (let k = seqPartialsLen; k > indexFirstGTE; k--) {
                    seqPartials[k] = seqPartials[k - 1];
                }
                seqPartials[indexFirstGTE] = pLen;
            }
            else {
                seqPartials.push(pLen);
            }
        }
    }
    static addSeq(partialLengths, seq, seqSeglen, clientId) {
        let seqPartialLen;
        let penultPartialLen;
        let leqIndex = latestLEQ(partialLengths, seq);
        if (leqIndex >= 0) {
            const pLen = partialLengths[leqIndex];
            if (pLen.seq === seq) {
                seqPartialLen = pLen;
                leqIndex = latestLEQ(partialLengths, seq - 1);
                if (leqIndex >= 0) {
                    penultPartialLen = partialLengths[leqIndex];
                }
            }
            else {
                penultPartialLen = pLen;
            }
        }
        if (seqPartialLen === undefined) {
            // len will be assigned below, making this assertion true.
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            seqPartialLen = {
                clientId,
                seglen: seqSeglen,
                seq,
            };
            partialLengths.push(seqPartialLen);
        }
        else {
            seqPartialLen.seglen = seqSeglen;
            // Assert client id matches
        }
        if (penultPartialLen !== undefined) {
            seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;
        }
        else {
            seqPartialLen.len = seqPartialLen.seglen;
        }
    }
    // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment
    // with sequence number seq has been added within the sub-tree
    // TODO: assert client id matches
    update(mergeTree, node, seq, clientId, collabWindow) {
        let seqSeglen = 0;
        let segCount = 0;
        // Compute length for seq across children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.children[i];
            if (!child.isLeaf()) {
                const childBlock = child;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const branchPartialLengths = childBlock.partialLengths;
                const partialLengths = branchPartialLengths.partialLengths;
                const seqIndex = latestLEQ(partialLengths, seq);
                if (seqIndex >= 0) {
                    const leqPartial = partialLengths[seqIndex];
                    if (leqPartial.seq === seq) {
                        seqSeglen += leqPartial.seglen;
                    }
                }
                segCount += branchPartialLengths.segmentCount;
            }
            else {
                const segment = child;
                const removalInfo = (0,_mergeTree__WEBPACK_IMPORTED_MODULE_1__.toRemovalInfo)(segment);
                if (segment.seq === seq) {
                    if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) !== seq) {
                        seqSeglen += segment.cachedLength;
                    }
                }
                else {
                    if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) === seq) {
                        seqSeglen -= segment.cachedLength;
                    }
                }
                segCount++;
            }
        }
        this.segmentCount = segCount;
        PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);
        if (PartialSequenceLengths.options.zamboni) {
            this.zamboni(collabWindow);
        }
        if (PartialSequenceLengths.options.verify) {
            this.verify();
        }
    }
    getPartialLength(refSeq, clientId) {
        let pLen = this.minLength;
        const seqIndex = latestLEQ(this.partialLengths, refSeq);
        const cliLatestIndex = this.cliLatest(clientId);
        const cliSeq = this.clientSeqNumbers[clientId];
        if (seqIndex >= 0) {
            // Add the partial length up to refSeq
            pLen += this.partialLengths[seqIndex].len;
            if (cliLatestIndex >= 0) {
                const cliLatest = cliSeq[cliLatestIndex];
                if (cliLatest.seq > refSeq) {
                    // The client has local edits after refSeq, add in the length adjustments
                    pLen += cliLatest.len;
                    const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);
                    if (precedingCliIndex >= 0) {
                        pLen -= cliSeq[precedingCliIndex].len;
                    }
                }
            }
        }
        else {
            // RefSeq is before any of the partial lengths
            // so just add in all local edits of that client (which should all be after the refSeq)
            if (cliLatestIndex >= 0) {
                const cliLatest = cliSeq[cliLatestIndex];
                pLen += cliLatest.len;
            }
        }
        return pLen;
    }
    toString(glc, indentCount = 0) {
        let buf = "";
        for (const partial of this.partialLengths) {
            buf += `(${partial.seq},${partial.len}) `;
        }
        // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax
        for (const clientId in this.clientSeqNumbers) {
            if (this.clientSeqNumbers[clientId].length > 0) {
                buf += `Client `;
                if (glc) {
                    buf += `${glc(+clientId)}`;
                }
                else {
                    buf += `${clientId}`;
                }
                buf += "[";
                for (const partial of this.clientSeqNumbers[clientId]) {
                    buf += `(${partial.seq},${partial.len})`;
                }
                buf += "]";
            }
        }
        buf = `min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;
        return buf;
    }
    // Clear away partial sums for sequence numbers earlier than the current window
    zamboni(segmentWindow) {
        function copyDown(partialLengths) {
            const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);
            let minLength = 0;
            if (mindex >= 0) {
                minLength = partialLengths[mindex].len;
                const seqCount = partialLengths.length;
                if (mindex <= (seqCount - 1)) {
                    // Still some entries remaining
                    const remainingCount = (seqCount - mindex) - 1;
                    // Copy down
                    for (let i = 0; i < remainingCount; i++) {
                        partialLengths[i] = partialLengths[i + mindex + 1];
                        partialLengths[i].len -= minLength;
                    }
                    partialLengths.length = remainingCount;
                }
            }
            return minLength;
        }
        this.minLength += copyDown(this.partialLengths);
        // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax
        for (const clientId in this.clientSeqNumbers) {
            const cliPartials = this.clientSeqNumbers[clientId];
            if (cliPartials) {
                copyDown(cliPartials);
            }
        }
    }
    addClientSeqNumber(clientId, seq, seglen) {
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        const cli = this.clientSeqNumbers[clientId];
        let pLen = seglen;
        if (cli.length > 0) {
            pLen += cli[cli.length - 1].len;
        }
        cli.push({ seq, len: pLen, seglen });
    }
    // Assumes sequence number already coalesced
    addClientSeqNumberFromPartial(partialLength) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);
        if (partialLength.overlapRemoveClients) {
            partialLength.overlapRemoveClients.map((oc) => {
                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);
                return true;
            });
        }
    }
    cliLatestLEQ(clientId, refSeq) {
        const cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs) {
            return latestLEQ(cliSeqs, refSeq);
        }
        else {
            return -1;
        }
    }
    cliLatest(clientId) {
        const cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs && (cliSeqs.length > 0)) {
            return cliSeqs.length - 1;
        }
        else {
            return -1;
        }
    }
    // Debug only
    verifyPartialLengths(partialLengths, clientPartials) {
        if (partialLengths.length === 0) {
            return 0;
        }
        let lastSeqNum = 0;
        let accumSegLen = 0;
        let count = 0;
        for (const partialLength of partialLengths) {
            // Count total number of partial length
            count++;
            // Sequence number should be larger or equal to minseq
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.minSeq <= partialLength.seq, 0x054 /* "Sequence number less than minSeq!" */);
            // Sequence number should be sorted
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(lastSeqNum < partialLength.seq, 0x055 /* "Sequence number is not sorted!" */);
            lastSeqNum = partialLength.seq;
            // Len is a accumulation of all the seglen adjustments
            accumSegLen += partialLength.seglen;
            if (accumSegLen !== partialLength.len) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x056 /* "Unexpected total for accumulation of all seglen adjustments!" */);
            }
            if (clientPartials) {
                // Client partials used to track local edits so we can account for them some refSeq.
                // But the information we keep track of are since minSeq, so we keep track of more history
                // then needed, and some of them doesn't make sense to be used for length calculations
                // e.g. if you have this sequence, where the minSeq is #5 because of other clients
                //    seq 10: client 1: insert seg #1
                //    seq 11: client 2: delete seg #2 refseq: 10
                // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2
                // So if you ask for partial length for client 2 @ seq 5, we will have return -1.
                // However, that combination is invalid, since we should never see any ops with refseq < 10 for
                // client 2 after seq 11.
            }
            else {
                // Len adjustment should not make length negative
                if (this.minLength + partialLength.len < 0) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x057 /* "Negative length after length adjustment!" */);
                }
            }
            if (partialLength.overlapRemoveClients) {
                // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!clientPartials, 0x058 /* "Both overlapRemoveClients and clientPartials are set!" */);
                // Each overlap client count as one
                count += partialLength.overlapRemoveClients.size();
            }
        }
        return count;
    }
    verify() {
        if (this.clientSeqNumbers) {
            let cliCount = 0;
            for (const cliSeq of this.clientSeqNumbers) {
                if (cliSeq) {
                    cliCount += this.verifyPartialLengths(cliSeq, true);
                }
            }
            // If we have client view, we should have the flat view
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.partialLengths, 0x059 /* "Client view exists but flat view does not!" */);
            const flatCount = this.verifyPartialLengths(this.partialLengths, false);
            // The number of partial lengths on the client view and flat view should be the same
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(flatCount === cliCount, 0x05a /* "Mismatch between number of partial lengths on client and flat views!" */);
        }
        else {
            // If we don't have a client view, we shouldn't have the flat view either
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.partialLengths, 0x05b /* "Flat view exists but client view does not!" */);
        }
    }
}
PartialSequenceLengths.options = {
    verify: false,
    zamboni: true,
};
//# sourceMappingURL=partialLengths.js.map

/***/ }),
/* 300 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAnnotateMarkerOp": () => (/* binding */ createAnnotateMarkerOp),
/* harmony export */   "createAnnotateRangeOp": () => (/* binding */ createAnnotateRangeOp),
/* harmony export */   "createGroupOp": () => (/* binding */ createGroupOp),
/* harmony export */   "createInsertOp": () => (/* binding */ createInsertOp),
/* harmony export */   "createInsertSegmentOp": () => (/* binding */ createInsertSegmentOp),
/* harmony export */   "createRemoveRangeOp": () => (/* binding */ createRemoveRangeOp)
/* harmony export */ });
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Creates the op for annotating the markers with the provided properties
 * @param marker - The marker to annotate
 * @param props - The properties to annotate the marker with
 * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
 * @returns The annotate op
 */
function createAnnotateMarkerOp(marker, props, combiningOp) {
    const id = marker.getId();
    if (!id) {
        return undefined;
    }
    return {
        combiningOp,
        props,
        relativePos1: { id, before: true },
        relativePos2: { id },
        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.ANNOTATE,
    };
}
/**
 * Creates the op for annotating the range with the provided properties
 * @param start - The inclusive start position of the range to annotate
 * @param end - The exclusive end position of the range to annotate
 * @param props - The properties to annotate the range with
 * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
 * @returns The annotate op
 */
function createAnnotateRangeOp(start, end, props, combiningOp) {
    return {
        combiningOp,
        pos1: start,
        pos2: end,
        props,
        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.ANNOTATE,
    };
}
/**
 * Creates the op to remove a range
 *
 * @param start - The inclusive start of the range to remove
 * @param end - The exclusive end of the range to remove
 */
function createRemoveRangeOp(start, end) {
    return {
        pos1: start,
        pos2: end,
        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.REMOVE,
    };
}
/**
 *
 * @param pos - The position to insert the segment at
 * @param segment - The segment to insert
 */
function createInsertSegmentOp(pos, segment) {
    return createInsertOp(pos, segment.toJSONObject());
}
function createInsertOp(pos, segSpec) {
    return {
        pos1: pos,
        seg: segSpec,
        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.INSERT,
    };
}
/**
 *
 * @param ops - The ops to group
 */
function createGroupOp(...ops) {
    return {
        ops,
        type: _ops__WEBPACK_IMPORTED_MODULE_0__.MergeTreeDeltaType.GROUP,
    };
}
//# sourceMappingURL=opBuilder.js.map

/***/ }),
/* 301 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trace": () => (/* binding */ Trace)
/* harmony export */ });
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(302);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Helper class for tracing performance of events
 * Time measurements are in milliseconds as a floating point with a decimal
 */
class Trace {
    constructor(startTick) {
        this.startTick = startTick;
        this.lastTick = startTick;
    }
    static start() {
        const startTick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        return new Trace(startTick);
    }
    trace() {
        const tick = _indexNode__WEBPACK_IMPORTED_MODULE_0__.performance.now();
        const event = {
            totalTimeElapsed: tick - this.startTick,
            duration: tick - this.lastTick,
            tick,
        };
        this.lastTick = tick;
        return event;
    }
}
//# sourceMappingURL=trace.js.map

/***/ }),
/* 302 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "performance": () => (/* binding */ performance)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const performance = window.performance;
//# sourceMappingURL=performanceBrowser.js.map

/***/ }),
/* 303 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 304 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 305 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MergeTreeTextHelper": () => (/* binding */ MergeTreeTextHelper),
/* harmony export */   "TextSegment": () => (/* binding */ TextSegment)
/* harmony export */ });
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);
/* harmony import */ var _localReference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


// Maximum length of text segment to be considered to be merged with other segment.
// Maximum segment length is at least 2x of it (not taking into account initial segment creation).
// The bigger it is, the more expensive it is to break segment into sub-segments (on edits)
// The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.
// Small number also makes ReplayTool produce false positives ("same" snapshots have slightly different binary
// representations).  More measurements needs to be done, but it's very likely the right spot is somewhere between
// 1K-2K mark.  That said, we also break segments on newline and there are very few segments that are longer than 256
// because of it.  Must be an even number
const TextSegmentGranularity = 256;
class TextSegment extends _mergeTree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {
    constructor(text) {
        super();
        this.text = text;
        this.type = TextSegment.type;
        this.cachedLength = text.length;
    }
    static is(segment) {
        return segment.type === TextSegment.type;
    }
    static make(text, props) {
        const seg = new TextSegment(text);
        if (props) {
            seg.addProperties(props);
        }
        return seg;
    }
    static fromJSONObject(spec) {
        if (typeof spec === "string") {
            return new TextSegment(spec);
        }
        else if (spec && typeof spec === "object" && "text" in spec) {
            const textSpec = spec;
            return TextSegment.make(textSpec.text, textSpec.props);
        }
        return undefined;
    }
    toJSONObject() {
        // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is
        // not annotated.
        return this.properties
            ? { text: this.text, props: this.properties }
            : this.text;
    }
    clone(start = 0, end) {
        const text = this.text.substring(start, end);
        const b = TextSegment.make(text, this.properties);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return !this.text.endsWith("\n")
            && TextSegment.is(segment)
            && (this.cachedLength <= TextSegmentGranularity ||
                segment.cachedLength <= TextSegmentGranularity);
    }
    toString() {
        return this.text;
    }
    append(segment) {
        if (TextSegment.is(segment)) {
            // Note: Must call 'appendLocalRefs' before modifying this segment's length as
            // 'this.cachedLength' is used to adjust the offsets of the local refs.
            _localReference__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);
            this.text += segment.text;
            this.cachedLength = this.text.length;
        }
        else {
            throw new Error("can only append text segment");
        }
    }
    // TODO: retain removed text for undo
    // returns true if entire string removed
    removeRange(start, end) {
        let remnantString = "";
        const len = this.text.length;
        if (start > 0) {
            remnantString += this.text.substring(0, start);
        }
        if (end < len) {
            remnantString += this.text.substring(end);
        }
        this.text = remnantString;
        this.cachedLength = remnantString.length;
        return (remnantString.length === 0);
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingText = this.text.substring(pos);
            this.text = this.text.substring(0, pos);
            this.cachedLength = this.text.length;
            const leafSegment = new TextSegment(remainingText);
            return leafSegment;
        }
    }
}
TextSegment.type = "TextSegment";
function isTextAndMarkerAccumulator(accum) {
    return accum.parallelArrays === true;
}
class MergeTreeTextHelper {
    constructor(mergeTree) {
        this.mergeTree = mergeTree;
        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {
            var _a, _b;
            let _start = start;
            if (TextSegment.is(segment)) {
                let beginTags = "";
                let endTags = "";
                if (isTextAndMarkerAccumulator(accumText)) {
                    // TODO: let clients pass in function to get tag
                    const tags = [];
                    const initTags = [];
                    if ((_a = segment.properties) === null || _a === void 0 ? void 0 : _a["font-weight"]) {
                        tags.push("b");
                    }
                    if ((_b = segment.properties) === null || _b === void 0 ? void 0 : _b["text-decoration"]) {
                        tags.push("u");
                    }
                    const remTags = [];
                    if (tags.length > 0) {
                        for (const tag of tags) {
                            if (!accumText.tagsInProgress.includes(tag)) {
                                beginTags += `<${tag}>`;
                                initTags.push(tag);
                            }
                        }
                        for (const accumTag of accumText.tagsInProgress) {
                            if (!tags.includes(accumTag)) {
                                endTags += `</${accumTag}>`;
                                remTags.push(accumTag);
                            }
                        }
                        for (const initTag of initTags.reverse()) {
                            accumText.tagsInProgress.push(initTag);
                        }
                    }
                    else {
                        for (const accumTag of accumText.tagsInProgress) {
                            endTags += `</${accumTag}>`;
                            remTags.push(accumTag);
                        }
                    }
                    for (const remTag of remTags) {
                        const remdex = accumText.tagsInProgress.indexOf(remTag);
                        if (remdex >= 0) {
                            accumText.tagsInProgress.splice(remdex, 1);
                        }
                    }
                }
                accumText.textSegment.text += endTags;
                accumText.textSegment.text += beginTags;
                if ((_start <= 0) && (end >= segment.text.length)) {
                    accumText.textSegment.text += segment.text;
                }
                else {
                    if (_start < 0) {
                        _start = 0;
                    }
                    if (end >= segment.text.length) {
                        accumText.textSegment.text += segment.text.substring(_start);
                    }
                    else {
                        accumText.textSegment.text += segment.text.substring(_start, end);
                    }
                }
            }
            else {
                if (accumText.placeholder && (accumText.placeholder.length > 0)) {
                    if (accumText.placeholder === "*") {
                        const marker = segment;
                        accumText.textSegment.text += `\n${marker.toString()}`;
                    }
                    else {
                        for (let i = 0; i < segment.cachedLength; i++) {
                            accumText.textSegment.text += accumText.placeholder;
                        }
                    }
                }
                else if (isTextAndMarkerAccumulator(accumText)) {
                    const marker = segment;
                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {
                        accumText.parallelMarkers.push(marker);
                        accumText.parallelText.push(accumText.textSegment.text);
                        accumText.textSegment.text = "";
                    }
                }
            }
            return true;
        };
    }
    getTextAndMarkers(refSeq, clientId, label, start, end) {
        const range = this.getValidRange(start, end, refSeq, clientId);
        const accum = {
            parallelArrays: true,
            parallelMarkerLabel: label,
            parallelMarkers: [],
            parallelText: [],
            tagsInProgress: [],
            textSegment: new TextSegment(""),
        };
        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);
        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };
    }
    getText(refSeq, clientId, placeholder = "", start, end) {
        const range = this.getValidRange(start, end, refSeq, clientId);
        const accum = { textSegment: new TextSegment(""), placeholder };
        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);
        return accum.textSegment.text;
    }
    getValidRange(start, end, refSeq, clientId) {
        const range = {
            end: end !== null && end !== void 0 ? end : this.mergeTree.getLength(refSeq, clientId),
            start: start !== null && start !== void 0 ? start : 0,
        };
        return range;
    }
}
//# sourceMappingURL=textSegment.js.map

/***/ }),
/* 306 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnapshotV1": () => (/* binding */ SnapshotV1)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(283);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(309);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(285);
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(284);
/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(307);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */







class SnapshotV1 {
    constructor(mergeTree, logger, getLongClientId, filename, onCompletion) {
        var _a, _b;
        this.mergeTree = mergeTree;
        this.getLongClientId = getLongClientId;
        this.filename = filename;
        this.onCompletion = onCompletion;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(logger, "Snapshot");
        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotV1.chunkSize;
        const { currentSeq, minSeq } = mergeTree.getCollabWindow();
        this.header = {
            minSequenceNumber: minSeq,
            sequenceNumber: currentSeq,
            orderedChunkMetadata: [],
            totalLength: 0,
            totalSegmentCount: 0,
        };
        this.segments = [];
        this.segmentLengths = [];
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        const segments = [];
        let length = 0;
        let segmentCount = 0;
        while ((length < approxSequenceLength) && ((startIndex + segmentCount) < allSegments.length)) {
            const pseg = allSegments[startIndex + segmentCount];
            segments.push(pseg);
            length += allLengths[startIndex + segmentCount];
            segmentCount++;
        }
        return {
            version: "1",
            segmentCount,
            length,
            segments,
            startIndex,
            headerMetadata: undefined,
        };
    }
    /**
     * Emits the snapshot to an ISummarizeResult. If provided the optional IFluidSerializer will be used when
     * serializing the summary data rather than JSON.stringify.
     */
    emit(serializer, bind) {
        const chunks = [];
        this.header.totalSegmentCount = 0;
        this.header.totalLength = 0;
        do {
            const chunk = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize, this.header.totalSegmentCount);
            chunks.push(chunk);
            this.header.totalSegmentCount += chunk.segmentCount;
            this.header.totalLength += chunk.length;
        } while (this.header.totalSegmentCount < this.segments.length);
        // The do while loop should have added at least one chunk
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const headerChunk = chunks.shift();
        headerChunk.headerMetadata = this.header;
        headerChunk.headerMetadata.orderedChunkMetadata = [{ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header }];
        const blobs = [];
        chunks.forEach((chunk, index) => {
            const id = `${_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.body}_${index}`;
            this.header.orderedChunkMetadata.push({ id });
            blobs.push([id, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMaxSupportedVersion)(id, chunk, this.logger, this.mergeTree.options, serializer, bind)]);
        });
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_3__.SummaryTreeBuilder();
        builder.addBlob(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMaxSupportedVersion)(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_1__.SnapshotLegacy.header, headerChunk, this.logger, this.mergeTree.options, serializer, bind));
        blobs.forEach((value) => {
            builder.addBlob(value[0], value[1]);
        });
        return builder.getSummaryTree();
    }
    extractSync() {
        const mergeTree = this.mergeTree;
        const minSeq = this.header.minSequenceNumber;
        // Helper to add the given `MergeTreeChunkV0SegmentSpec` to the snapshot.
        const pushSegRaw = (json, length) => {
            this.segments.push(json);
            this.segmentLengths.push(length);
        };
        // Helper to serialize the given `segment` and add it to the snapshot (if a segment is provided).
        const pushSeg = (segment) => {
            if (segment) {
                pushSegRaw(segment.toJSONObject(), segment.cachedLength);
            }
        };
        let prev;
        const extractSegment = (segment) => {
            var _a;
            // Elide segments that do not need to be included in the snapshot.  A segment may be elided if
            // either condition is true:
            //   a) The segment has not yet been ACKed.  We do not need to snapshot unACKed segments because
            //      there is a pending insert op that will deliver the segment on reconnection.
            //   b) The segment was removed at or below the MSN.  Pending ops can no longer reference this
            //      segment, and therefore we can discard it.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (segment.seq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber || segment.removedSeq <= minSeq) {
                return true;
            }
            // Next determine if the snapshot needs to preserve information required for merging the segment
            // (seq, client, etc.)  This information is only needed if the segment is above the MSN (and doesn't
            // have a pending remove.)
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((segment.seq <= minSeq) // Segment is below the MSN, and...
                && (segment.removedSeq === undefined // .. Segment has not been removed, or...
                    || segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) // .. Removal op to be delivered on reconnect
            ) {
                // This segment is below the MSN, which means that future ops will not reference it.  Attempt to
                // coalesce the new segment with the previous (if any).
                if (!prev) {
                    // We do not have a previous candidate for coalescing.  Make the current segment the new candidate.
                    prev = segment;
                }
                else if (prev.canAppend(segment) && (0,_properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties)(prev.properties, segment.properties)) {
                    // We have a compatible pair.  Replace `prev` with the coalesced segment.  Clone to avoid
                    // modifying the segment instances currently in the MergeTree.
                    prev = prev.clone();
                    prev.append(segment.clone());
                }
                else {
                    // The segment pair could not be coalesced.  Record the `prev` segment in the snapshot
                    // and make the current segment the new candidate for coalescing.
                    pushSeg(prev);
                    prev = segment;
                }
            }
            else {
                // This segment needs to preserve it's metadata as it may be referenced by future ops.  It's ineligible
                // for coalescing, so emit the 'prev' segment now (if any).
                pushSeg(prev);
                prev = undefined;
                const raw = { json: segment.toJSONObject() };
                // If the segment insertion is above the MSN, record the insertion merge info.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (segment.seq > minSeq) {
                    raw.seq = segment.seq;
                    raw.client = this.getLongClientId(segment.clientId);
                }
                // We have already dispensed with removed segments below the MSN and removed segments with unassigned
                // sequence numbers.  Any remaining removal info should be preserved.
                if (segment.removedSeq !== undefined) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(segment.removedSeq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber && segment.removedSeq > minSeq, 0x065 /* "On removal info preservation, segment has invalid removed sequence number!" */);
                    raw.removedSeq = segment.removedSeq;
                    // back compat for when we split overlap and removed client
                    raw.removedClient =
                        segment.removedClientIds !== undefined
                            ? this.getLongClientId(segment.removedClientIds[0])
                            : undefined;
                    raw.removedClientIds = (_a = segment.removedClientIds) === null || _a === void 0 ? void 0 : _a.map((id) => this.getLongClientId(id));
                }
                // Sanity check that we are preserving either the seq < minSeq or a removed segment's info.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(raw.seq !== undefined && raw.client !== undefined
                    || raw.removedSeq !== undefined && raw.removedClient !== undefined, 0x066 /* "Corrupted preservation of segment metadata!" */);
                // Record the segment with it's required metadata.
                pushSegRaw(raw, segment.cachedLength);
            }
            return true;
        };
        mergeTree.walkAllSegments(mergeTree.root, extractSegment, this);
        // If the last segment in the walk was coalescable, push it now.
        pushSeg(prev);
        return this.segments;
    }
    static async loadChunk(storage, path, logger, options, serializer) {
        const blob = await storage.readBlob(path);
        const chunkAsString = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.bufferToString)(blob, "utf8");
        return SnapshotV1.processChunk(path, chunkAsString, logger, options, serializer);
    }
    static processChunk(path, chunk, logger, options, serializer) {
        const chunkObj = serializer ? serializer.parse(chunk) : JSON.parse(chunk);
        return (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.toLatestVersion)(path, chunkObj, logger, options);
    }
}
// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content
// Please note that this number has no direct relationship to anything other than size of raw text (characters).
// As we produce json for the blob (and then send over the wire compressed), this number
// is really hard to correlate with any actual metric that matters (like bytes over the wire).
// For test with small number of chunks it would be closer to blob size,
// for very chunky text, blob size can easily be 4x-8x of that number.
SnapshotV1.chunkSize = 10000;
//# sourceMappingURL=snapshotV1.js.map

/***/ }),
/* 307 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnapshotLegacy": () => (/* binding */ SnapshotLegacy)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(283);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(285);
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(284);
/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */






class SnapshotLegacy {
    constructor(mergeTree, logger, filename, onCompletion) {
        var _a, _b;
        this.mergeTree = mergeTree;
        this.filename = filename;
        this.onCompletion = onCompletion;
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.ChildLogger.create(logger, "Snapshot");
        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotLegacy.sizeOfFirstChunk;
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        const segs = [];
        let sequenceLength = 0;
        let segCount = 0;
        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {
            const pseg = allSegments[startIndex + segCount];
            segs.push(pseg);
            sequenceLength += allLengths[startIndex + segCount];
            segCount++;
        }
        return {
            version: undefined,
            chunkStartSegmentIndex: startIndex,
            chunkSegmentCount: segCount,
            chunkLengthChars: sequenceLength,
            totalLengthChars: this.header.segmentsTotalLength,
            totalSegmentCount: allSegments.length,
            chunkSequenceNumber: this.header.seq,
            segmentTexts: segs,
        };
    }
    /**
     * Emits the snapshot to an ISummarizeResult. If provided the optional IFluidSerializer will be used when
     * serializing the summary data rather than JSON.stringify.
     */
    emit(catchUpMsgs, serializer, bind) {
        var _a, _b;
        const chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize);
        let length = chunk1.chunkLengthChars;
        let segments = chunk1.chunkSegmentCount;
        const builder = new _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeBuilder();
        builder.addBlob(SnapshotLegacy.header, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMinSupportedVersion)(SnapshotLegacy.header, chunk1, this.logger, this.mergeTree.options, serializer, bind));
        if (chunk1.chunkSegmentCount < chunk1.totalSegmentCount) {
            const chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.header.segmentsTotalLength, chunk1.chunkSegmentCount);
            length += chunk2.chunkLengthChars;
            segments += chunk2.chunkSegmentCount;
            builder.addBlob(SnapshotLegacy.body, (0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_2__.serializeAsMinSupportedVersion)(SnapshotLegacy.body, chunk2, this.logger, this.mergeTree.options, serializer, bind));
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(length === this.header.segmentsTotalLength, 0x05d /* "emit: mismatch in segmentsTotalLength" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(segments === chunk1.totalSegmentCount, 0x05e /* "emit: mismatch in totalSegmentCount" */);
        if (catchUpMsgs !== undefined && catchUpMsgs.length > 0) {
            builder.addBlob((_b = (_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.catchUpBlobName) !== null && _b !== void 0 ? _b : SnapshotLegacy.catchupOps, serializer ? serializer.stringify(catchUpMsgs, bind) : JSON.stringify(catchUpMsgs));
        }
        return builder.getSummaryTree();
    }
    extractSync() {
        const collabWindow = this.mergeTree.getCollabWindow();
        this.seq = collabWindow.minSeq;
        this.header = {
            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient),
            seq: this.mergeTree.collabWindow.minSeq,
        };
        const segs = [];
        let prev;
        const extractSegment = 
        // eslint-disable-next-line max-len
        (segment, pos, refSeq, clientId, start, end) => {
            if ((segment.seq !== _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) && (segment.seq <= this.seq) &&
                ((segment.removedSeq === undefined) || (segment.removedSeq === _constants__WEBPACK_IMPORTED_MODULE_4__.UnassignedSequenceNumber) ||
                    (segment.removedSeq > this.seq))) {
                if ((prev === null || prev === void 0 ? void 0 : prev.canAppend(segment))
                    && (0,_properties__WEBPACK_IMPORTED_MODULE_5__.matchProperties)(prev.properties, segment.properties)) {
                    prev = prev.clone();
                    prev.append(segment.clone());
                }
                else {
                    if (prev) {
                        segs.push(prev);
                    }
                    prev = segment;
                }
            }
            return true;
        };
        this.mergeTree.map({ leaf: extractSegment }, this.seq, _constants__WEBPACK_IMPORTED_MODULE_4__.NonCollabClient, undefined);
        if (prev) {
            segs.push(prev);
        }
        this.segments = [];
        this.segmentLengths = [];
        let totalLength = 0;
        segs.map((segment) => {
            totalLength += segment.cachedLength;
            this.segments.push(segment.toJSONObject());
            this.segmentLengths.push(segment.cachedLength);
        });
        // We observed this.header.segmentsTotalLength < totalLength to happen in some cases
        // When this condition happens, we might not write out all segments in getSeqLengthSegs()
        // when writing out "body". Issue #1995 tracks following up on the core of the problem.
        // In the meantime, this code makes sure we will write out all segments properly
        if (this.header.segmentsTotalLength !== totalLength) {
            this.logger.sendErrorEvent({
                eventName: "SegmentsTotalLengthMismatch",
                totalLength,
                segmentsTotalLength: this.header.segmentsTotalLength,
            });
            this.header.segmentsTotalLength = totalLength;
        }
        return this.segments;
    }
}
SnapshotLegacy.header = "header";
SnapshotLegacy.body = "body";
SnapshotLegacy.catchupOps = "catchupOps";
// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content
// Please note that this number has no direct relationship to anything other than size of raw text (characters).
// As we produce json for the blob (and then send over the wire compressed), this number
// is really hard to correlate with any actual metric that matters (like bytes over the wire).
// For test with small number of chunks it would be closer to blob size,
// for very chunky text, blob size can easily be 4x-8x of that number.
SnapshotLegacy.sizeOfFirstChunk = 10000;
//# sourceMappingURL=snapshotlegacy.js.map

/***/ }),
/* 308 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasMergeInfo": () => (/* binding */ hasMergeInfo),
/* harmony export */   "serializeAsMaxSupportedVersion": () => (/* binding */ serializeAsMaxSupportedVersion),
/* harmony export */   "serializeAsMinSupportedVersion": () => (/* binding */ serializeAsMinSupportedVersion),
/* harmony export */   "toLatestVersion": () => (/* binding */ toLatestVersion)
/* harmony export */ });
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(307);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.
 */
function hasMergeInfo(spec) {
    return !!spec && typeof spec === "object" && "json" in spec;
}
function serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {
    let targetChuck;
    if (chunk.version !== undefined) {
        logger.send({
            eventName: "MergeTreeChunk:serializeAsMinSupportedVersion",
            category: "generic",
            fromChunkVersion: chunk.version,
            toChunkVersion: undefined,
        });
    }
    switch (chunk.version) {
        case undefined:
            targetChuck = chunk;
            targetChuck.headerMetadata = buildHeaderMetadataForLegacyChunk(path, targetChuck, options);
            break;
        case "1":
            const chunkV1 = chunk;
            const headerMetadata = path === _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;
            targetChuck = {
                version: undefined,
                chunkStartSegmentIndex: chunkV1.startIndex,
                chunkLengthChars: chunkV1.length,
                chunkSegmentCount: chunkV1.segmentCount,
                segmentTexts: chunkV1.segments,
                totalLengthChars: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalLength,
                totalSegmentCount: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalSegmentCount,
                chunkSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.sequenceNumber,
                chunkMinSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.minSequenceNumber,
                headerMetadata,
            };
            break;
        default:
            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);
    }
    return serializer.stringify(targetChuck, bind);
}
function serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {
    const targetChuck = toLatestVersion(path, chunk, logger, options);
    return serializer.stringify(targetChuck, bind);
}
function toLatestVersion(path, chunk, logger, options) {
    switch (chunk.version) {
        case undefined: {
            const chunkLegacy = chunk;
            return {
                version: "1",
                length: chunkLegacy.chunkLengthChars,
                segmentCount: chunkLegacy.chunkSegmentCount,
                headerMetadata: buildHeaderMetadataForLegacyChunk(path, chunkLegacy, options),
                segments: chunkLegacy.segmentTexts,
                startIndex: chunkLegacy.chunkStartSegmentIndex,
            };
        }
        case "1":
            return chunk;
        default:
            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);
    }
}
function buildHeaderMetadataForLegacyChunk(path, chunk, options) {
    if (path === _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header) {
        if (chunk.headerMetadata !== undefined) {
            return chunk.headerMetadata;
        }
        const chunkIds = [{ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.header }];
        if (chunk.chunkLengthChars < chunk.totalLengthChars) {
            chunkIds.push({ id: _snapshotlegacy__WEBPACK_IMPORTED_MODULE_0__.SnapshotLegacy.body });
        }
        return {
            orderedChunkMetadata: chunkIds,
            minSequenceNumber: chunk.chunkMinSequenceNumber,
            sequenceNumber: chunk.chunkSequenceNumber,
            totalLength: chunk.totalLengthChars,
            totalSegmentCount: chunk.totalSegmentCount,
        };
    }
    return undefined;
}
//# sourceMappingURL=snapshotChunks.js.map

/***/ }),
/* 309 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(283);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 310 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnapshotLoader": () => (/* binding */ SnapshotLoader)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(283);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(309);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(285);
/* harmony import */ var _snapshotChunks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(308);
/* harmony import */ var _snapshotV1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(306);
/* harmony import */ var _snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(307);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */







class SnapshotLoader {
    constructor(runtime, client, mergeTree, logger, serializer) {
        this.runtime = runtime;
        this.client = client;
        this.mergeTree = mergeTree;
        this.serializer = serializer;
        this.specToSegment = (spec) => {
            var _a;
            let seg;
            if ((0,_snapshotChunks__WEBPACK_IMPORTED_MODULE_0__.hasMergeInfo)(spec)) {
                seg = this.client.specToSegment(spec.json);
                // `specToSegment()` initializes `seg` with the LocalClientId.  Overwrite this with
                // the `spec` client (if specified).  Otherwise overwrite with `NonCollabClient`.
                seg.clientId = spec.client !== undefined
                    ? this.client.getOrAddShortClientId(spec.client)
                    : _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient;
                seg.seq = spec.seq !== undefined
                    ? spec.seq
                    : _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;
                if (spec.removedSeq !== undefined) {
                    seg.removedSeq = spec.removedSeq;
                }
                // this format had a bug where it didn't store all the overlap clients
                // this is for back compat, so we change the singular id to an array
                // this will only cause problems if there is an overlapping delete
                // spanning the snapshot, which should be rare
                if (spec.removedClient !== undefined) {
                    seg.removedClientIds = [this.client.getOrAddShortClientId(spec.removedClient)];
                }
                if (spec.removedClientIds !== undefined) {
                    seg.removedClientIds = (_a = spec.removedClientIds) === null || _a === void 0 ? void 0 : _a.map((sid) => this.client.getOrAddShortClientId(sid));
                }
            }
            else {
                seg = this.client.specToSegment(spec);
                seg.seq = _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber;
                // `specToSegment()` initializes `seg` with the LocalClientId.  We must overwrite this with
                // `NonCollabClient`.
                seg.clientId = _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient;
            }
            return seg;
        };
        this.logger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(logger, "SnapshotLoader");
    }
    async initialize(services) {
        const headerLoadedP = services.readBlob(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__.SnapshotLegacy.header).then((header) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(!!header, 0x05f /* "Missing blob header on legacy snapshot!" */);
            return this.loadHeader((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(header, "utf8"));
        });
        const catchupOpsP = this.loadBodyAndCatchupOps(headerLoadedP, services);
        catchupOpsP.catch((err) => this.logger.sendErrorEvent({ eventName: "CatchupOpsLoadFailure" }, err));
        await headerLoadedP;
        return { catchupOpsP };
    }
    async loadBodyAndCatchupOps(headerChunkP, services) {
        const blobsP = services.list("");
        const headerChunk = await headerChunkP;
        // TODO we shouldn't need to wait on the body being complete to finish initialization.
        // To fully support this we need to be able to process inbound ops for pending segments.
        await this.loadBody(headerChunk, services);
        const blobs = await blobsP;
        if (blobs.length === headerChunk.headerMetadata.orderedChunkMetadata.length + 1) {
            headerChunk.headerMetadata.orderedChunkMetadata.forEach((md) => blobs.splice(blobs.indexOf(md.id), 1));
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(blobs.length === 1, 0x060 /* There should be only one blob with catch up ops */);
            // TODO: The 'Snapshot.catchupOps' tree entry is purely for backwards compatibility.
            //       (See https://github.com/microsoft/FluidFramework/issues/84)
            return this.loadCatchupOps(services.readBlob(blobs[0]));
        }
        else if (blobs.length !== headerChunk.headerMetadata.orderedChunkMetadata.length) {
            throw new Error("Unexpected blobs in snapshot");
        }
        return [];
    }
    loadHeader(header) {
        var _a;
        const chunk = _snapshotV1__WEBPACK_IMPORTED_MODULE_6__.SnapshotV1.processChunk(_snapshotlegacy__WEBPACK_IMPORTED_MODULE_3__.SnapshotLegacy.header, header, this.logger, this.mergeTree.options, this.serializer);
        const segs = chunk.segments.map(this.specToSegment);
        this.mergeTree.reloadFromSegments(segs);
        if (chunk.headerMetadata === undefined) {
            throw new Error("header metadata not available");
        }
        // If we load a detached container from snapshot, then we don't supply a default clientId
        // because we don't want to start collaboration.
        if (this.runtime.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_7__.AttachState.Detached) {
            // specify a default client id, "snapshot" here as we
            // should enter collaboration/op sending mode if we load
            // a snapshot in any case (summary or attach message)
            // once we get a client id this will be called with that
            // clientId in the connected event
            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : "snapshot", 
            // TODO: Make 'minSeq' non-optional once the new snapshot format becomes the default?
            //       (See https://github.com/microsoft/FluidFramework/issues/84)
            /* minSeq: */ chunk.headerMetadata.minSequenceNumber !== undefined
                ? chunk.headerMetadata.minSequenceNumber
                : chunk.headerMetadata.sequenceNumber, 
            /* currentSeq: */ chunk.headerMetadata.sequenceNumber);
        }
        return chunk;
    }
    async loadBody(chunk1, services) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.length <= chunk1.headerMetadata.totalLength, 0x061 /* "Mismatch in totalLength" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.segmentCount <= chunk1.headerMetadata.totalSegmentCount, 0x062 /* "Mismatch in totalSegmentCount" */);
        if (chunk1.segmentCount === chunk1.headerMetadata.totalSegmentCount) {
            return;
        }
        const segs = [];
        let lengthSofar = chunk1.length;
        for (let chunkIndex = 1; chunkIndex < chunk1.headerMetadata.orderedChunkMetadata.length; chunkIndex++) {
            const chunk = await _snapshotV1__WEBPACK_IMPORTED_MODULE_6__.SnapshotV1.loadChunk(services, chunk1.headerMetadata.orderedChunkMetadata[chunkIndex].id, this.logger, this.mergeTree.options, this.serializer);
            lengthSofar += chunk.length;
            // Deserialize each chunk segment and append it to the end of the MergeTree.
            segs.push(...chunk.segments.map(this.specToSegment));
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(lengthSofar === chunk1.headerMetadata.totalLength, 0x063 /* "Mismatch in totalLength" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(chunk1.segmentCount + segs.length === chunk1.headerMetadata.totalSegmentCount, 0x064 /* "Mismatch in totalSegmentCount" */);
        // Helper to insert segments at the end of the MergeTree.
        const mergeTree = this.mergeTree;
        const append = (segments, cli, seq) => {
            mergeTree.insertSegments(mergeTree.root.cachedLength, segments, 
            /* refSeq: */ _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber, cli, seq, undefined);
        };
        // Helpers to batch-insert segments that are below the min seq
        const batch = [];
        const flushBatch = () => {
            if (batch.length > 0) {
                append(batch, _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient, _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber);
            }
        };
        for (const seg of segs) {
            const cli = seg.clientId;
            const seq = seg.seq;
            // If the segment can be batch inserted, add it to the 'batch' array.  Otherwise, flush
            // any batched segments and then insert the current segment individually.
            if (cli === _constants__WEBPACK_IMPORTED_MODULE_1__.NonCollabClient && seq === _constants__WEBPACK_IMPORTED_MODULE_1__.UniversalSequenceNumber) {
                batch.push(seg);
            }
            else {
                flushBatch();
                append([seg], cli, seq);
            }
        }
        flushBatch();
    }
    /**
     * If loading from a snapshot, get the catchup messages.
     * @param rawMessages - The messages in original encoding
     * @returns The decoded messages, but handles aren't parsed.  Matches the format that will be passed in
     * SharedObject.processCore.
     */
    async loadCatchupOps(rawMessages) {
        return JSON.parse((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(await rawMessages, "utf8"));
    }
}
//# sourceMappingURL=snapshotLoader.js.map

/***/ }),
/* 311 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SequenceDeltaEvent": () => (/* binding */ SequenceDeltaEvent),
/* harmony export */   "SequenceEvent": () => (/* binding */ SequenceEvent),
/* harmony export */   "SequenceMaintenanceEvent": () => (/* binding */ SequenceMaintenanceEvent)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(288);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(297);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.
 *
 * The properties of this object and its sub-objects represent the state of the sequence at the
 * point in time at which the operation was applied.
 * They will not take into any future modifications performed to the underlying sequence and merge tree.
 */
class SequenceEvent {
    constructor(deltaArgs, mergeTreeClient) {
        this.deltaArgs = deltaArgs;
        this.mergeTreeClient = mergeTreeClient;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(deltaArgs.deltaSegments.length > 0, 0x2d8 /* "Empty change event should not be emitted." */);
        this.isEmpty = false;
        this.deltaOperation = deltaArgs.operation;
        this.sortedRanges = new Lazy(() => {
            const set = new _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.SortedSegmentSet();
            this.deltaArgs.deltaSegments.forEach((delta) => {
                const newRange = {
                    operation: this.deltaArgs.operation,
                    position: this.mergeTreeClient.getPosition(delta.segment),
                    propertyDeltas: delta.propertyDeltas,
                    segment: delta.segment,
                };
                set.addOrUpdate(newRange);
            });
            return set;
        });
        this.pFirst = new Lazy(() => this.sortedRanges.value.items[0]);
        this.pLast = new Lazy(() => this.sortedRanges.value.items[this.sortedRanges.value.size - 1]);
    }
    /**
     * The in-order ranges affected by this delta.
     * These may not be continuous.
     */
    get ranges() {
        return this.sortedRanges.value.items;
    }
    /**
     * The client id of the client that made the change which caused the delta event
     */
    get clientId() {
        return this.mergeTreeClient.longClientId;
    }
    /**
     * The first of the modified ranges.
     */
    get first() {
        return this.pFirst.value;
    }
    /**
     * The last of the modified ranges.
     */
    get last() {
        return this.pLast.value;
    }
}
/**
 * The event object returned on sequenceDelta events.
 *
 * The properties of this object and its sub-objects represent the state of the sequence at the
 * point in time at which the operation was applied.
 * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.
 *
 * For group ops, each op will get its own event, and the group op property will be set on the op args.
 *
 * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.
 */
class SequenceDeltaEvent extends SequenceEvent {
    constructor(opArgs, deltaArgs, mergeTreeClient) {
        super(deltaArgs, mergeTreeClient);
        this.opArgs = opArgs;
        this.isLocal = opArgs.sequencedMessage === undefined;
    }
}
/**
 * The event object returned on maintenance events.
 *
 * The properties of this object and its sub-objects represent the state of the sequence at the
 * point in time at which the operation was applied.
 * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.
 */
class SequenceMaintenanceEvent extends SequenceEvent {
    constructor(opArgs, deltaArgs, mergeTreeClient) {
        super(deltaArgs, mergeTreeClient);
        this.opArgs = opArgs;
    }
}
class Lazy {
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this.pEvaluated = false;
    }
    get evaluated() {
        return this.pEvaluated;
    }
    get value() {
        if (!this.pEvaluated) {
            this.pEvaluated = true;
            this.pValue = this.valueGenerator();
        }
        return this.pValue;
    }
}
//# sourceMappingURL=sequenceDeltaEvent.js.map

/***/ }),
/* 312 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultMap": () => (/* binding */ DefaultMap)
/* harmony export */ });
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(137);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(138);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(289);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(288);
/* harmony import */ var _localValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(313);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * A DefaultMap is a map-like distributed data structure, supporting operations on values stored by
 * string key locations.
 *
 * Creation of values is implicit on access (either via `get` or a remote op application referring to
 * a collection that wasn't previously known)
 */
class DefaultMap {
    /**
     * Create a new default map.
     * @param serializer - The serializer to serialize / parse handles
     * @param handle - The handle of the shared object using the kernel
     * @param submitMessage - A callback to submit a message through the shared object
     * @param type - The value type to create at values of this map
     * @param eventEmitter - The object that will emit map events
     */
    constructor(serializer, handle, submitMessage, type, eventEmitter = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter()) {
        this.serializer = serializer;
        this.handle = handle;
        this.submitMessage = submitMessage;
        this.type = type;
        this.eventEmitter = eventEmitter;
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        /**
         * The in-memory data the map is storing.
         */
        this.data = new Map();
        this.messageHandlers = this.getMessageHandlers();
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.data.size;
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.data.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        const localEntriesIterator = this.data.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                return nextVal.done
                    ? { value: undefined, done: true }
                    : { value: [nextVal.value[0], nextVal.value[1].value], done: false }; // Unpack the stored value
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        const localValuesIterator = this.data.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                return nextVal.done
                    ? { value: undefined, done: true }
                    : { value: nextVal.value.value, done: false }; // Unpack the stored value
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.data.forEach((localValue, key, m) => {
            callbackFn(localValue.value, key, m);
        });
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        var _a;
        const localValue = (_a = this.data.get(key)) !== null && _a !== void 0 ? _a : this.createCore(key, true);
        return localValue.value;
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.data.has(key);
    }
    /**
     * Serializes the data stored in the shared map to a JSON string
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns A JSON string containing serialized map data
     */
    getSerializedStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);
        });
        return serializableMapData;
    }
    getSerializableStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = (0,_localValues__WEBPACK_IMPORTED_MODULE_1__.makeSerializable)(localValue, serializer, this.handle);
        });
        return serializableMapData;
    }
    serialize(serializer) {
        return JSON.stringify(this.getSerializableStorage(serializer));
    }
    /**
     * Populate the kernel with the given map data.
     * @param data - A JSON string containing serialized map data
     */
    populateFromSerializable(json) {
        for (const [key, serializable] of Object.entries(json)) {
            // Back-compat: legacy documents may have handles to an intervalCollection map kernel.
            // These collections should be empty, and ValueTypes are no longer supported.
            if (serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Plain]
                || serializable.type === _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Shared]) {
                continue;
            }
            // Back-compat: Sequence previously arbitrarily prefixed all interval collection keys with
            // "intervalCollections/". This would burden users trying to iterate the collection and
            // access its value, as well as those trying to match a create message to its underlying
            // collection. See https://github.com/microsoft/FluidFramework/issues/10557 for more context.
            const normalizedKey = key.startsWith("intervalCollections/") ? key.substring(20) : key;
            const localValue = {
                key: normalizedKey,
                value: this.makeLocal(key, serializable),
            };
            this.data.set(localValue.key, localValue.value);
        }
    }
    populate(json) {
        this.populateFromSerializable(JSON.parse(json));
    }
    /**
     * Submit the given op if a handler is registered.
     * @param op - The operation to attempt to submit
     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     * @returns True if the operation was submitted, false otherwise.
     */
    tryResubmitMessage(op, localOpMetadata) {
        const type = op.type;
        const handler = this.messageHandlers.get(type);
        if (handler !== undefined) {
            handler.resubmit(op, localOpMetadata);
            return true;
        }
        return false;
    }
    tryGetStashedOpLocalMetadata(op) {
        const type = op.type;
        if (this.messageHandlers.has(type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.messageHandlers.get(type).getStashedOpLocalMetadata(op);
        }
        throw new Error("no apply stashed op handler");
    }
    /**
     * Process the given op if a handler is registered.
     * @param message - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation was processed, false otherwise.
     */
    tryProcessMessage(op, local, message, localOpMetadata) {
        const handler = this.messageHandlers.get(op.type);
        if (handler !== undefined) {
            handler.process(op, local, message, localOpMetadata);
            return true;
        }
        return false;
    }
    /**
     * Initializes a default ValueType at the provided key.
     * Should be used when a map operation incurs creation.
     * @param key - The key being initialized
     * @param local - Whether the message originated from the local client
     */
    createCore(key, local) {
        const localValue = new _localValues__WEBPACK_IMPORTED_MODULE_1__.ValueTypeLocalValue(this.type.factory.load(this.makeMapValueOpEmitter(key), undefined), this.type);
        const previousValue = this.data.get(key);
        this.data.set(key, localValue);
        const event = { key, previousValue };
        this.eventEmitter.emit("create", event, local, this.eventEmitter);
        return localValue;
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will
     * have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's
     * job is to convert that information into a real object for local usage.
     * @param key - The key that the caller intends to store the local value into (used for ops later).  But
     * doesn't actually store the local value into that key.  So better not lie!
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, serializable) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(serializable.type !== _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Plain] && serializable.type !== _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType[_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_2__.ValueType.Shared], 0x2e1 /* "Support for plain value types removed." */);
        serializable.value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.parseHandles)(serializable.value, this.serializer);
        const localValue = this.type.factory.load(this.makeMapValueOpEmitter(key), serializable.value);
        return new _localValues__WEBPACK_IMPORTED_MODULE_1__.ValueTypeLocalValue(localValue, this.type);
    }
    /**
     * Get the message handlers for the map.
     * @returns A map of string op names to IMapMessageHandlers for those ops
     */
    getMessageHandlers() {
        const messageHandlers = new Map();
        // Ops with type "act" describe actions taken by custom value type handlers of whatever item is
        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has
        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone
        // watching for manipulations of that item.
        messageHandlers.set("act", {
            process: (op, local, message, localOpMetadata) => {
                var _a;
                const localValue = (_a = this.data.get(op.key)) !== null && _a !== void 0 ? _a : this.createCore(op.key, local);
                const handler = localValue.getOpHandler(op.value.opName);
                const previousValue = localValue.value;
                const translatedValue = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.parseHandles)(op.value.value, this.serializer);
                handler.process(previousValue, translatedValue, local, message, localOpMetadata);
                const event = { key: op.key, previousValue };
                this.eventEmitter.emit("valueChanged", event, local, message, this.eventEmitter);
            },
            submit: (op, localOpMetadata) => {
                this.submitMessage(op, localOpMetadata);
            },
            resubmit: (op, localOpMetadata) => {
                const localValue = this.data.get(op.key);
                const handler = localValue.getOpHandler(op.value.opName);
                const { rebasedOp, rebasedLocalOpMetadata, } = handler.rebase(localValue.value, op.value, localOpMetadata);
                this.submitMessage(Object.assign(Object.assign({}, op), { value: rebasedOp }), rebasedLocalOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false, 0x016 /* "apply stashed op not implemented for custom value type ops" */);
            },
        });
        return messageHandlers;
    }
    /**
     * Create an emitter for a value type to emit ops from the given key.
     * @alpha
     * @param key - The key of the map that the value type will be stored on
     * @returns A value op emitter for the given key
     */
    makeMapValueOpEmitter(key) {
        const emit = (opName, previousValue, params, localOpMetadata) => {
            const translatedParams = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.makeHandlesSerializable)(params, this.serializer, this.handle);
            const op = {
                key,
                type: "act",
                value: {
                    opName,
                    value: translatedParams,
                },
            };
            this.submitMessage(op, localOpMetadata);
            const event = { key, previousValue };
            this.eventEmitter.emit("valueChanged", event, true, null, this.eventEmitter);
        };
        return { emit };
    }
}
//# sourceMappingURL=defaultMap.js.map

/***/ }),
/* 313 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueTypeLocalValue": () => (/* binding */ ValueTypeLocalValue),
/* harmony export */   "makeSerializable": () => (/* binding */ makeSerializable)
/* harmony export */ });
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

function makeSerializable(localValue, serializer, bind) {
    const value = localValue.makeSerialized(serializer, bind);
    return {
        type: value.type,
        value: value.value && JSON.parse(value.value),
    };
}
/**
 * Manages a contained value type.
 *
 * @alpha
 */
class ValueTypeLocalValue {
    /**
     * Create a new ValueTypeLocalValue.
     * @param value - The instance of the value type stored within
     * @param valueType - The type object of the value type stored within
     */
    constructor(value, valueType) {
        this.value = value;
        this.valueType = valueType;
    }
    /**
     * {@inheritDoc ILocalValue."type"}
     */
    get type() {
        return this.valueType.name;
    }
    /**
     * {@inheritDoc ILocalValue.makeSerialized}
     */
    makeSerialized(serializer, bind) {
        const storedValueType = this.valueType.factory.store(this.value);
        const value = (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_0__.serializeHandles)(storedValueType, serializer, bind);
        return {
            type: this.type,
            value,
        };
    }
    /**
     * Get the handler for a given op of this value type.
     * @param opName - The name of the operation that needs processing
     * @returns The object which can process the given op
     */
    getOpHandler(opName) {
        const handler = this.valueType.ops.get(opName);
        if (!handler) {
            throw new Error("Unknown type message");
        }
        return handler;
    }
}
//# sourceMappingURL=localValues.js.map

/***/ }),
/* 314 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(288);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 315 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectStoragePartition": () => (/* binding */ ObjectStoragePartition)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Returns a new IChannelStorageService that resolves the given `path` as root.
 */
class ObjectStoragePartition {
    constructor(storage, path) {
        this.storage = storage;
        this.path = path;
        // `path` must not include the trailing separator.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!path.endsWith("/"), 0x19c /* "storage service path has trailing separator" */);
    }
    async readBlob(path) {
        return this.storage.readBlob(`${this.path}/${path}`);
    }
    async contains(path) {
        return this.storage.contains(`${this.path}/${path}`);
    }
    async list(path) {
        return this.storage.list(`${this.path}/${path}`);
    }
}
//# sourceMappingURL=objectstoragepartition.js.map

/***/ }),
/* 316 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 317 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedNumberSequenceFactory": () => (/* binding */ SharedNumberSequenceFactory),
/* harmony export */   "SharedObjectSequenceFactory": () => (/* binding */ SharedObjectSequenceFactory),
/* harmony export */   "SharedStringFactory": () => (/* binding */ SharedStringFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(305);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(294);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(318);
/* harmony import */ var _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(321);
/* harmony import */ var _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(320);
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(319);
/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(290);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */






class SharedStringFactory {
    static segmentFromSpec(spec) {
        const maybeText = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.TextSegment.fromJSONObject(spec);
        if (maybeText) {
            return maybeText;
        }
        const maybeMarker = _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.Marker.fromJSONObject(spec);
        if (maybeMarker) {
            return maybeMarker;
        }
    }
    get type() {
        return SharedStringFactory.Type;
    }
    get attributes() {
        return SharedStringFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_2__.SharedString(runtime, id, attributes);
        await sharedString.load(services);
        return sharedString;
    }
    create(document, id) {
        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_2__.SharedString(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically
// load code
SharedStringFactory.Type = "https://graph.microsoft.com/types/mergeTree";
SharedStringFactory.Attributes = {
    type: SharedStringFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,
};
/**
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedObjectSequenceFactory {
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static segmentFromSpec(segSpec) {
        const runSegment = segSpec;
        if (runSegment.items) {
            const seg = new _sharedSequence__WEBPACK_IMPORTED_MODULE_4__.SubSequence(runSegment.items);
            if (runSegment.props) {
                seg.addProperties(runSegment.props);
            }
            return seg;
        }
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get type() {
        return SharedObjectSequenceFactory.Type;
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get attributes() {
        return SharedObjectSequenceFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     *
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    async load(runtime, id, services, attributes) {
        const sharedSeq = new _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence(runtime, id, attributes);
        await sharedSeq.load(services);
        return sharedSeq;
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    create(document, id) {
        const sharedString = new _sharedObjectSequence__WEBPACK_IMPORTED_MODULE_5__.SharedObjectSequence(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
/**
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedObjectSequenceFactory.Type = "https://graph.microsoft.com/types/mergeTree/object-sequence";
/**
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedObjectSequenceFactory.Attributes = {
    type: SharedObjectSequenceFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,
};
/**
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedNumberSequenceFactory {
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static segmentFromSpec(segSpec) {
        const runSegment = segSpec;
        if (runSegment.items) {
            const seg = new _sharedSequence__WEBPACK_IMPORTED_MODULE_4__.SubSequence(runSegment.items);
            if (runSegment.props) {
                seg.addProperties(runSegment.props);
            }
            return seg;
        }
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get type() {
        return SharedNumberSequenceFactory.Type;
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get attributes() {
        return SharedNumberSequenceFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     *
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    async load(runtime, id, services, attributes) {
        const sharedSeq = new _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__.SharedNumberSequence(runtime, id, attributes);
        await sharedSeq.load(services);
        return sharedSeq;
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    create(document, id) {
        const sharedString = new _sharedNumberSequence__WEBPACK_IMPORTED_MODULE_6__.SharedNumberSequence(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
/**
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedNumberSequenceFactory.Type = "https://graph.microsoft.com/types/mergeTree/number-sequence";
/**
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedNumberSequenceFactory.Attributes = {
    type: SharedNumberSequenceFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion,
};
//# sourceMappingURL=sequenceFactory.js.map

/***/ }),
/* 318 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/sequence";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 319 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedSequence": () => (/* binding */ SharedSequence),
/* harmony export */   "SubSequence": () => (/* binding */ SubSequence)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(291);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


const MaxRun = 128;
class SubSequence extends _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {
    constructor(items) {
        super();
        this.items = items;
        this.type = SubSequence.typeString;
        this.cachedLength = items.length;
    }
    static is(segment) {
        return segment.type === SubSequence.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "items" in spec) {
            const segment = new SubSequence(spec.items);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    toJSONObject() {
        const obj = { items: this.items };
        super.addSerializedProps(obj);
        return obj;
    }
    clone(start = 0, end) {
        const clonedItems = this.items.slice(start, end);
        const b = new SubSequence(clonedItems);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return SubSequence.is(segment)
            && (this.cachedLength <= MaxRun || segment.cachedLength <= MaxRun);
    }
    toString() {
        return this.items.toString();
    }
    append(segment) {
        if (!SubSequence.is(segment)) {
            throw new Error("can only append another run segment");
        }
        // Note: Must call 'appendLocalRefs' before modifying this segment's length as
        //       'this.cachedLength' is used to adjust the offsets of the local refs.
        _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);
        this.items = this.items.concat(segment.items);
        this.cachedLength = this.items.length;
    }
    // TODO: retain removed items for undo
    // returns true if entire run removed
    removeRange(start, end) {
        let remnantItems = [];
        const len = this.items.length;
        if (start > 0) {
            remnantItems = remnantItems.concat(this.items.slice(0, start));
        }
        if (end < len) {
            remnantItems = remnantItems.concat(this.items.slice(end));
        }
        this.items = remnantItems;
        this.cachedLength = this.items.length;
        return (this.items.length === 0);
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingItems = this.items.slice(pos);
            this.items = this.items.slice(0, pos);
            this.cachedLength = this.items.length;
            const leafSegment = new SubSequence(remainingItems);
            return leafSegment;
        }
    }
}
SubSequence.typeString = "SubSequence";
class SharedSequence extends _sequence__WEBPACK_IMPORTED_MODULE_2__.SharedSegmentSequence {
    constructor(document, id, attributes, specToSegment) {
        super(document, id, attributes, specToSegment);
        this.id = id;
    }
    /**
     * @param pos - The position to insert the items at.
     * @param items - The items to insert.
     * @param props - Optional. Properties to set on the inserted items.
     */
    insert(pos, items, props) {
        const segment = new SubSequence(items);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    remove(start, end) {
        this.removeRange(start, end);
    }
    /**
     * Returns the total count of items in the sequence
     */
    getItemCount() {
        return this.getLength();
    }
    /**
     * Gets the items in the specified range
     *
     * @param start - The inclusive start of the range
     * @param end - The exclusive end of the range
     */
    getItems(start, end) {
        const items = [];
        let firstSegment;
        // Return if the range is incorrect.
        if (end !== undefined && end <= start) {
            return items;
        }
        this.walkSegments((segment) => {
            if (SubSequence.is(segment)) {
                if (firstSegment === undefined) {
                    firstSegment = segment;
                }
                items.push(...segment.items);
            }
            return true;
        }, start, end);
        // The above call to walkSegments adds all the items in the walked
        // segments. However, we only want items beginning at |start| in
        // the first segment. Similarly, if |end| is passed in, we only
        // want items until |end| in the last segment. Remove the rest of
        // the items.
        if (firstSegment !== undefined) {
            items.splice(0, start - this.getPosition(firstSegment));
        }
        if (end !== undefined) {
            items.splice(end - start);
        }
        return items;
    }
}
//# sourceMappingURL=sharedSequence.js.map

/***/ }),
/* 320 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedObjectSequence": () => (/* binding */ SharedObjectSequence)
/* harmony export */ });
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(319);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * The SharedObjectSequence holds a sequence of serializable objects. Each object will be stored
 * at a position within the sequence. See the
 * {@link https://fluidframework.com/docs/data-structures/sequences/ | sequence documentation}
 * for details on working with sequences.
 *
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedObjectSequence extends _sharedSequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence {
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    constructor(document, id, attributes) {
        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new shared object sequence
     *
     * @param runtime - data store runtime the new shared object sequence belongs to
     * @param id - optional name of the shared object sequence
     * @returns newly create shared object sequence (but not attached yet)
     *
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory.Type);
    }
    /**
     * Get a factory for SharedObjectSequence to register with the data store.
     *
     * @returns a factory that creates and load SharedObjectSequence
     *
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static getFactory() {
        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedObjectSequenceFactory();
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
//# sourceMappingURL=sharedObjectSequence.js.map

/***/ }),
/* 321 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedNumberSequence": () => (/* binding */ SharedNumberSequence)
/* harmony export */ });
/* harmony import */ var _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(317);
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(319);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * The SharedNumberSequence holds a sequence of numbers. Each number will be stored
 * at a position within the sequence. See the
 * {@link https://fluidframework.com/docs/data-structures/sequences/ | sequence documentation}
 * for details on working with sequences.
 *
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedNumberSequence extends _sharedSequence__WEBPACK_IMPORTED_MODULE_0__.SharedSequence {
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    constructor(document, id, attributes) {
        super(document, id, attributes, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new shared number sequence
     *
     * @param runtime - data store runtime the new shared number sequence belongs to
     * @param id - optional name of the shared number sequence
     * @returns newly create shared number sequence (but not attached yet)
     *
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory.Type);
    }
    /**
     * Get a factory for SharedNumberSequence to register with the data store.
     *
     * @returns a factory that creates and load SharedNumberSequence
     *
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static getFactory() {
        return new _sequenceFactory__WEBPACK_IMPORTED_MODULE_1__.SharedNumberSequenceFactory();
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
//# sourceMappingURL=sharedNumberSequence.js.map

/***/ }),
/* 322 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PaddingSegment": () => (/* binding */ PaddingSegment),
/* harmony export */   "RunSegment": () => (/* binding */ RunSegment),
/* harmony export */   "SparseMatrix": () => (/* binding */ SparseMatrix),
/* harmony export */   "SparseMatrixFactory": () => (/* binding */ SparseMatrixFactory),
/* harmony export */   "maxCellPosition": () => (/* binding */ maxCellPosition),
/* harmony export */   "maxCol": () => (/* binding */ maxCol),
/* harmony export */   "maxCols": () => (/* binding */ maxCols),
/* harmony export */   "maxRow": () => (/* binding */ maxRow),
/* harmony export */   "maxRows": () => (/* binding */ maxRows),
/* harmony export */   "positionToRowCol": () => (/* binding */ positionToRowCol),
/* harmony export */   "rowColToPosition": () => (/* binding */ rowColToPosition)
/* harmony export */ });
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(286);
/* harmony import */ var _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(300);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(318);
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(291);
/* harmony import */ var _sharedSequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(319);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




/**
 * An empty segment that occupies 'cachedLength' positions.  SparseMatrix uses PaddingSegment
 * to "pad" a run of unoccupied cells.
 *
 * @deprecated PaddingSegment is part of an abandoned prototype.  Use SharedMatrix instead.
 */
class PaddingSegment extends _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_0__.BaseSegment {
    constructor(size) {
        super();
        this.type = PaddingSegment.typeString;
        this.cachedLength = size;
    }
    static is(segment) {
        return segment.type === PaddingSegment.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "pad" in spec) {
            const segment = new PaddingSegment(spec.pad);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    toJSONObject() {
        return { pad: this.cachedLength, props: this.properties };
    }
    clone(start = 0, end) {
        const b = new PaddingSegment(this.cachedLength);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return PaddingSegment.is(segment);
    }
    toString() {
        return `[padding: ${this.cachedLength}]`;
    }
    append(segment) {
        if (!PaddingSegment.is(segment)) {
            throw new Error("can only append padding segment");
        }
        // Note: Must call 'appendLocalRefs' before modifying this segment's length as
        //       'this.cachedLength' is used to adjust the offsets of the local refs.
        _fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_1__.LocalReferenceCollection.append(this, segment);
        this.cachedLength += segment.cachedLength;
    }
    // Returns true if entire run removed
    removeRange(start, end) {
        this.cachedLength -= (end - start);
        return (this.cachedLength === 0);
    }
    createSplitSegmentAt(pos) {
        const leftLength = pos;
        const rightLength = this.cachedLength - pos;
        this.cachedLength = leftLength;
        return new PaddingSegment(rightLength);
    }
}
PaddingSegment.typeString = "PaddingSegment";
/**
 * @deprecated RunSegment is part of an abandoned prototype.  Use SharedMatrix instead.
 */
class RunSegment extends _sharedSequence__WEBPACK_IMPORTED_MODULE_2__.SubSequence {
    constructor(items) {
        super(items);
        this.items = items;
        this.type = RunSegment.typeString;
        this.tags = new Array(items.length).fill(undefined);
    }
    static is(segment) {
        return segment.type === RunSegment.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "items" in spec) {
            const segment = new RunSegment(spec.items);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    clone(start = 0, end) {
        const b = new RunSegment(this.items.slice(start, end));
        if (this.tags) {
            b.tags = this.tags.slice(start, end);
        }
        this.cloneInto(b);
        return b;
    }
    append(segment) {
        super.append(segment);
        const asRun = segment;
        if (asRun.tags) {
            if (this.tags) {
                this.tags.splice(this.items.length, 0, ...asRun.tags);
            }
        }
        return this;
    }
    // TODO: retain removed items for undo
    // returns true if entire run removed
    removeRange(start, end) {
        this.tags.splice(start, end - start);
        return super.removeRange(start, end);
    }
    getTag(pos) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.tags[pos];
    }
    setTag(pos, tag) {
        this.tags[pos] = tag;
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingItems = this.items.slice(pos);
            this.items = this.items.slice(0, pos);
            this.cachedLength = this.items.length;
            const leafSegment = new RunSegment(remainingItems);
            leafSegment.tags = this.tags.slice(pos);
            this.tags.length = pos;
            return leafSegment;
        }
    }
}
RunSegment.typeString = "RunSegment";
/**
 * @deprecated maxCol is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const maxCol = 0x200000; // X128 Excel maximum of 16,384 columns
/**
 * @deprecated maxCols is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const maxCols = maxCol + 1;
/**
 * @deprecated maxRow is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const maxRow = 0xFFFFFFFF; // X4096 Excel maximum of 1,048,576 rows
/**
 * @deprecated maxRows is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const maxRows = maxRow + 1;
/**
 * @deprecated maxCellPosition is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const maxCellPosition = maxCol * maxRow;
/**
 * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const rowColToPosition = (row, col) => row * maxCols + col;
/**
 * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.
 */
function positionToRowCol(position) {
    const row = Math.floor(position / maxCols);
    const col = position - (row * maxCols);
    return { row, col };
}
/**
 * @deprecated SparseMatrix is an abandoned prototype.  Use SharedMatrix instead.
 */
class SparseMatrix extends _sequence__WEBPACK_IMPORTED_MODULE_3__.SharedSegmentSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, SparseMatrixFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new sparse matrix
     *
     * @param runtime - data store runtime the new sparse matrix belongs to
     * @param id - optional name of the sparse matrix
     * @returns newly create sparse matrix (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, SparseMatrixFactory.Type);
    }
    /**
     * Get a factory for SharedMap to register with the data store.
     *
     * @returns a factory that creates and load SharedMap
     */
    static getFactory() {
        return new SparseMatrixFactory();
    }
    get numRows() {
        return positionToRowCol(this.getLength()).row;
    }
    setItems(row, col, values, props) {
        const start = rowColToPosition(row, col);
        const end = start + values.length;
        const segment = new RunSegment(values);
        if (props) {
            segment.addProperties(props);
        }
        this.replaceRange(start, end, segment);
    }
    getItem(row, col) {
        const pos = rowColToPosition(row, col);
        const { segment, offset } = this.getContainingSegment(pos);
        if (segment && RunSegment.is(segment)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return segment.items[offset];
        }
        else if (segment && PaddingSegment.is(segment)) {
            return undefined;
        }
        throw new Error(`Unrecognized Segment type`);
    }
    getTag(row, col) {
        const { segment, offset } = this.getSegment(row, col);
        if (RunSegment.is(segment)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return segment.getTag(offset);
        }
        return undefined;
    }
    setTag(row, col, tag) {
        const { segment, offset } = this.getSegment(row, col);
        if (RunSegment.is(segment)) {
            segment.setTag(offset, tag);
        }
        else if (tag !== undefined) {
            throw new Error(`Must not attempt to set tags on '${segment.constructor.name}'.`);
        }
    }
    insertRows(row, numRows) {
        const pos = rowColToPosition(row, 0);
        const size = maxCols * numRows;
        const segment = new PaddingSegment(size);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    removeRows(row, numRows) {
        const pos = rowColToPosition(row, 0);
        const size = maxCols * numRows;
        this.removeRange(pos, pos + size);
    }
    insertCols(col, numCols) {
        this.moveAsPadding(maxCol - numCols, col, numCols);
    }
    removeCols(col, numCols) {
        this.moveAsPadding(col, maxCol - numCols, numCols);
    }
    annotatePosition(row, col, props) {
        const pos = rowColToPosition(row, col);
        this.annotateRange(pos, pos + 1, props);
    }
    getPositionProperties(row, col) {
        const pos = rowColToPosition(row, col);
        return this.getPropertiesAtPosition(pos);
    }
    // For each row, moves 'numCols' items starting from 'srcCol' and inserts 'numCols' padding
    // at 'destCol'.  Used by insertCols and removeCols.
    moveAsPadding(srcCol, destCol, numCols) {
        const removeColStart = srcCol;
        const removeColEnd = srcCol + numCols;
        const ops = [];
        for (let r = 0, rowStart = 0; r < this.numRows; r++, rowStart += maxCols) {
            ops.push(this.client.removeRangeLocal(rowStart + removeColStart, rowStart + removeColEnd));
            const insertPos = rowStart + destCol;
            const segment = new PaddingSegment(numCols);
            ops.push(this.client.insertSegmentLocal(insertPos, segment));
        }
        this.submitSequenceMessage((0,_fluidframework_merge_tree__WEBPACK_IMPORTED_MODULE_4__.createGroupOp)(...ops));
    }
    getSegment(row, col) {
        const pos = rowColToPosition(row, col);
        return this.getContainingSegment(pos);
    }
}
/**
 * @deprecated SparseMatrixFactory is an abandoned prototype.  Use SharedMatrixFactory instead.
 */
class SparseMatrixFactory {
    static segmentFromSpec(spec) {
        const maybePadding = PaddingSegment.fromJSONObject(spec);
        if (maybePadding) {
            return maybePadding;
        }
        const maybeRun = RunSegment.fromJSONObject(spec);
        if (maybeRun) {
            return maybeRun;
        }
        throw new Error(`Unrecognized IJSONObject: '${JSON.stringify(spec)}'`);
    }
    get type() {
        return SparseMatrixFactory.Type;
    }
    get attributes() {
        return SparseMatrixFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const sharedObject = new SparseMatrix(runtime, id, attributes);
        await sharedObject.load(services);
        return sharedObject;
    }
    create(document, id) {
        const sharedObject = new SparseMatrix(document, id, this.attributes);
        sharedObject.initializeLocal();
        return sharedObject;
    }
}
SparseMatrixFactory.Type = "https://graph.microsoft.com/types/mergeTree/sparse-matrix";
SparseMatrixFactory.Attributes = {
    type: SparseMatrixFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_5__.pkgVersion,
};
//# sourceMappingURL=sparsematrix.js.map

/***/ }),
/* 323 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SharedIntervalCollection": () => (/* binding */ SharedIntervalCollection),
/* harmony export */   "SharedIntervalCollectionFactory": () => (/* binding */ SharedIntervalCollectionFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(314);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(316);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(138);
/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(279);
/* harmony import */ var _defaultMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(312);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(318);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;






const snapshotFileName = "header";
/**
 * The factory that defines the SharedIntervalCollection
 * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.
 */
class SharedIntervalCollectionFactory {
    get type() {
        return SharedIntervalCollectionFactory.Type;
    }
    get attributes() {
        return SharedIntervalCollectionFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const map = new SharedIntervalCollection(id, runtime, attributes);
        await map.load(services);
        return map;
    }
    create(runtime, id) {
        const map = new SharedIntervalCollection(id, runtime, this.attributes);
        map.initializeLocal();
        return map;
    }
}
SharedIntervalCollectionFactory.Type = "https://graph.microsoft.com/types/sharedIntervalCollection";
SharedIntervalCollectionFactory.Attributes = {
    type: SharedIntervalCollectionFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion,
};
/**
 * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.
 */
class SharedIntervalCollection extends _fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_1__.SharedObject {
    /**
     * Constructs a new shared SharedIntervalCollection. If the object is non-local an id and service interfaces will
     * be provided
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes, "fluid_sharedIntervalCollection_");
        this[_a] = "SharedIntervalCollection";
        this.intervalCollections = new _defaultMap__WEBPACK_IMPORTED_MODULE_2__.DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new _intervalCollection__WEBPACK_IMPORTED_MODULE_3__.IntervalCollectionValueType());
    }
    /**
     * Create a SharedIntervalCollection
     *
     * @param runtime - data store runtime the new shared map belongs to
     * @param id - optional name of the shared map
     * @returns newly create shared map (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, SharedIntervalCollectionFactory.Type);
    }
    /**
     * Get a factory for SharedIntervalCollection to register with the data store.
     *
     * @returns a factory that creates and load SharedIntervalCollection
     */
    static getFactory() {
        return new SharedIntervalCollectionFactory();
    }
    /**
     * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates
     * are supported. Use `getIntervalCollection` instead.
     */
    async waitIntervalCollection(label) {
        return this.intervalCollections.get(this.getIntervalCollectionPath(label));
    }
    getIntervalCollection(label) {
        const realLabel = this.getIntervalCollectionPath(label);
        const sharedCollection = this.intervalCollections.get(realLabel);
        return sharedCollection;
    }
    summarizeCore(serializer) {
        return (0,_fluidframework_shared_object_base__WEBPACK_IMPORTED_MODULE_4__.createSingleBlobSummary)(snapshotFileName, this.intervalCollections.serialize(serializer));
    }
    reSubmitCore(content, localOpMetadata) {
        this.intervalCollections.tryResubmitMessage(content, localOpMetadata);
    }
    onDisconnect() { }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        const blob = await storage.readBlob(snapshotFileName);
        const header = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.bufferToString)(blob, "utf8");
        this.intervalCollections.populate(header);
    }
    processCore(message, local, localOpMetadata) {
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.MessageType.Operation) {
            this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);
        }
    }
    /**
     * Creates the full path of the intervalCollection label
     * @param label - the incoming label
     */
    getIntervalCollectionPath(label) {
        return label;
    }
    applyStashedOp() {
        throw new Error("not implemented");
    }
}
_a = Symbol.toStringTag;
//# sourceMappingURL=sharedIntervalCollection.js.map

/***/ }),
/* 324 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureAudience": () => (/* reexport safe */ _AzureAudience__WEBPACK_IMPORTED_MODULE_0__.AzureAudience),
/* harmony export */   "AzureClient": () => (/* reexport safe */ _AzureClient__WEBPACK_IMPORTED_MODULE_1__.AzureClient),
/* harmony export */   "AzureFunctionTokenProvider": () => (/* reexport safe */ _AzureFunctionTokenProvider__WEBPACK_IMPORTED_MODULE_2__.AzureFunctionTokenProvider),
/* harmony export */   "ScopeType": () => (/* reexport safe */ _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType)
/* harmony export */ });
/* harmony import */ var _AzureAudience__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(325);
/* harmony import */ var _AzureClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(327);
/* harmony import */ var _AzureFunctionTokenProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(553);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(554);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A simple and powerful way to consume collaborative Fluid data with the Azure Fluid Relay.
 *
 * @packageDocumentation
 */




//# sourceMappingURL=index.js.map

/***/ }),
/* 325 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureAudience": () => (/* binding */ AzureAudience)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(326);
/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(274);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Azure-specific {@link @fluidframework/fluid-static#ServiceAudience} implementation.
 *
 * @remarks Operates in terms of {@link AzureMember}s.
 */
class AzureAudience extends _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_0__.ServiceAudience {
    /**
     * Creates a {@link @fluidframework/fluid-static#ServiceAudience} from the provided
     * {@link @fluidframework/protocol-definitions#IClient | audience member}.
     *
     * @param audienceMember - Audience member for which the `ServiceAudience` will be generated.
     * Note: its {@link @fluidframework/protocol-definitions#IClient.user} is required to be an {@link AzureUser}.
     *
     * @internal
     */
    createServiceMember(audienceMember) {
        const azureUser = audienceMember.user;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)((azureUser === null || azureUser === void 0 ? void 0 : azureUser.name) !== undefined, 'Provided user was not an "AzureUser".');
        return {
            userId: audienceMember.user.id,
            userName: azureUser.name,
            connections: [],
            additionalDetails: azureUser.additionalDetails,
        };
    }
}
//# sourceMappingURL=AzureAudience.js.map

/***/ }),
/* 326 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 * A number should not be specificed manually: use a string.
 * Before a release, policy-check should be run, which will convert any asserts still using strings to
 * use numbered error codes instead.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 327 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureClient": () => (/* binding */ AzureClient)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(469);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(332);
/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/* harmony import */ var _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(468);
/* harmony import */ var _fluidframework_routerlicious_driver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(330);
/* harmony import */ var _fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);
/* harmony import */ var _AzureAudience__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(325);
/* harmony import */ var _AzureUrlResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(329);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(328);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */










/**
 * Strongly typed id for connecting to a local Azure Fluid Relay.
 */
const LOCAL_MODE_TENANT_ID = "local";
const getTenantId = (connectionProps) => {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isAzureRemoteConnectionConfig)(connectionProps)
        ? connectionProps.tenantId
        : LOCAL_MODE_TENANT_ID;
};
const MAX_VERSION_COUNT = 5;
/**
 * AzureClient provides the ability to have a Fluid object backed by the Azure Fluid Relay or,
 * when running with local tenantId, have it be backed by a local Azure Fluid Relay instance.
 */
class AzureClient {
    /**
     * Creates a new client instance using configuration parameters.
     * @param props - Properties for initializing a new AzureClient instance
     */
    constructor(props) {
        this.props = props;
        // remove trailing slash from URL if any
        props.connection.endpoint = props.connection.endpoint.replace(/\/$/, "");
        this.urlResolver = new _AzureUrlResolver__WEBPACK_IMPORTED_MODULE_1__.AzureUrlResolver();
        // The local service implementation differs from the Azure Fluid Relay in blob
        // storage format. Azure Fluid Relay supports whole summary upload. Local currently does not.
        const isRemoteConnection = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isAzureRemoteConnectionConfig)(this.props.connection);
        this.documentServiceFactory = new _fluidframework_routerlicious_driver__WEBPACK_IMPORTED_MODULE_2__.RouterliciousDocumentServiceFactory(this.props.connection.tokenProvider, { enableWholeSummaryUpload: isRemoteConnection, enableDiscovery: isRemoteConnection });
    }
    /**
     * Creates a new detached container instance in the Azure Fluid Relay.
     * @param containerSchema - Container schema for the new container.
     * @returns New detached container instance along with associated services.
     */
    async createContainer(containerSchema) {
        const loader = this.createLoader(containerSchema);
        const container = await loader.createDetachedContainer({
            package: "no-dynamic-package",
            config: {},
        });
        const fluidContainer = await this.createFluidContainer(container, this.props.connection);
        const services = this.getContainerServices(container);
        return { container: fluidContainer, services };
    }
    /**
     * Creates new detached container out of specific version of another container.
     * @param id - Unique ID of the source container in Azure Fluid Relay.
     * @param containerSchema - Container schema used to access data objects in the container.
     * @param version - Unique version of the source container in Azure Fluid Relay.
     * It defaults to latest version if parameter not provided.
     * @returns New detached container instance along with associated services.
     */
    async copyContainer(id, containerSchema, version) {
        var _a;
        const loader = this.createLoader(containerSchema);
        const url = new URL(this.props.connection.endpoint);
        url.searchParams.append("storage", encodeURIComponent(this.props.connection.endpoint));
        url.searchParams.append("tenantId", encodeURIComponent(getTenantId(this.props.connection)));
        url.searchParams.append("containerId", encodeURIComponent(id));
        const sourceContainer = await loader.resolve({ url: url.href });
        if (sourceContainer.resolvedUrl === undefined) {
            throw new Error("Source container cannot resolve URL.");
        }
        const documentService = await this.documentServiceFactory.createDocumentService(sourceContainer.resolvedUrl);
        const storage = await documentService.connectToStorage();
        const handle = {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Handle,
            handleType: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Tree,
            handle: (_a = version === null || version === void 0 ? void 0 : version.id) !== null && _a !== void 0 ? _a : "latest",
        };
        const tree = await storage.downloadSummary(handle);
        const container = await loader.rehydrateDetachedContainerFromSnapshot(JSON.stringify(tree));
        const fluidContainer = await this.createFluidContainer(container, this.props.connection);
        const services = this.getContainerServices(container);
        return { container: fluidContainer, services };
    }
    /**
     * Accesses the existing container given its unique ID in the Azure Fluid Relay.
     * @param id - Unique ID of the container in Azure Fluid Relay.
     * @param containerSchema - Container schema used to access data objects in the container.
     * @returns Existing container instance along with associated services.
     */
    async getContainer(id, containerSchema) {
        const loader = this.createLoader(containerSchema);
        const url = new URL(this.props.connection.endpoint);
        url.searchParams.append("storage", encodeURIComponent(this.props.connection.endpoint));
        url.searchParams.append("tenantId", encodeURIComponent(getTenantId(this.props.connection)));
        url.searchParams.append("containerId", encodeURIComponent(id));
        const container = await loader.resolve({ url: url.href });
        const rootDataObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__.requestFluidObject)(container, "/");
        const fluidContainer = new _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_5__.FluidContainer(container, rootDataObject);
        const services = this.getContainerServices(container);
        return { container: fluidContainer, services };
    }
    /**
     * Get the list of versions for specific container.
     * @param id - Unique ID of the source container in Azure Fluid Relay.
     * @param options - "Get" options. If options are not provided, API
     * will assume maxCount of versions to retreive to be 5.
     * @returns Array of available container versions.
     */
    async getContainerVersions(id, options) {
        var _a;
        const url = new URL(this.props.connection.endpoint);
        url.searchParams.append("storage", encodeURIComponent(this.props.connection.endpoint));
        url.searchParams.append("tenantId", encodeURIComponent(getTenantId(this.props.connection)));
        url.searchParams.append("containerId", encodeURIComponent(id));
        const resolvedUrl = await this.urlResolver.resolve({ url: url.href });
        if (!resolvedUrl) {
            throw new Error("Unable to resolved URL");
        }
        const documentService = await this.documentServiceFactory.createDocumentService(resolvedUrl);
        const storage = await documentService.connectToStorage();
        // External API uses null
        // eslint-disable-next-line unicorn/no-null
        const versions = await storage.getVersions(null, (_a = options === null || options === void 0 ? void 0 : options.maxCount) !== null && _a !== void 0 ? _a : MAX_VERSION_COUNT);
        return versions.map((item) => {
            return { id: item.id, date: item.date };
        });
    }
    getContainerServices(container) {
        return {
            audience: new _AzureAudience__WEBPACK_IMPORTED_MODULE_6__.AzureAudience(container),
        };
    }
    createLoader(containerSchema) {
        const runtimeFactory = new _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_7__.DOProviderContainerRuntimeFactory(containerSchema);
        const load = async () => {
            return {
                module: { fluidExport: runtimeFactory },
                details: { package: "no-dynamic-package", config: {} },
            };
        };
        const codeLoader = { load };
        const client = {
            details: {
                capabilities: { interactive: true },
            },
            permission: [],
            scopes: [],
            user: { id: "" },
            mode: "write",
        };
        return new _fluidframework_container_loader__WEBPACK_IMPORTED_MODULE_8__.Loader({
            urlResolver: this.urlResolver,
            documentServiceFactory: this.documentServiceFactory,
            codeLoader,
            logger: this.props.logger,
            options: { client },
        });
    }
    async createFluidContainer(container, connection) {
        const createNewRequest = (0,_AzureUrlResolver__WEBPACK_IMPORTED_MODULE_1__.createAzureCreateNewRequest)(connection.endpoint, getTenantId(connection));
        const rootDataObject = await (0,_fluidframework_runtime_utils__WEBPACK_IMPORTED_MODULE_4__.requestFluidObject)(container, "/");
        /**
         * See {@link FluidContainer.attach}
         */
        const attach = async () => {
            if (container.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_9__.AttachState.Detached) {
                throw new Error("Cannot attach container. Container is not in detached state");
            }
            await container.attach(createNewRequest);
            const resolved = container.resolvedUrl;
            (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_10__.ensureFluidResolvedUrl)(resolved);
            return resolved.id;
        };
        const fluidContainer = new _fluidframework_fluid_static__WEBPACK_IMPORTED_MODULE_5__.FluidContainer(container, rootDataObject);
        fluidContainer.attach = attach;
        return fluidContainer;
    }
}
//# sourceMappingURL=AzureClient.js.map

/***/ }),
/* 328 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isAzureLocalConnectionConfig": () => (/* binding */ isAzureLocalConnectionConfig),
/* harmony export */   "isAzureRemoteConnectionConfig": () => (/* binding */ isAzureRemoteConnectionConfig)
/* harmony export */ });
/**
 * Type guard for validating a given AzureConnectionConfig is a remote connection type (AzureRemoteConnectionConfig)
 */
function isAzureRemoteConnectionConfig(connectionConfig) {
    return connectionConfig.type === "remote";
}
/**
 * Type guard for validating a given AzureConnectionConfig is a local connection type (AzureLocalConnectionConfig)
 */
function isAzureLocalConnectionConfig(connectionConfig) {
    return connectionConfig.type === "local";
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 329 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureUrlResolver": () => (/* binding */ AzureUrlResolver),
/* harmony export */   "createAzureCreateNewRequest": () => (/* binding */ createAzureCreateNewRequest)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);

/**
 * Implementation of {@link @fluidframework/driver-definitions#IUrlResolver} to resolve documents stored using the
 * Azure Fluid Relay based off of the orderer and storage URLs provide.
 *
 * @remarks The token provider here can be an `InsecureTokenProvider` for basic scenarios or more robust, secure
 * providers that fulfill the {@link @fluidframework/routerlicious-driver#ITokenProvider} interface.
 */
class AzureUrlResolver {
    constructor() { }
    async resolve(request) {
        const { ordererUrl, storageUrl, tenantId, containerId } = decodeAzureUrl(request.url);
        // determine whether the request is for creating of a new container.
        // such request has the `createNew` header set to true and doesn't have a container ID.
        if (request.headers && request.headers[_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__.DriverHeader.createNew] === true) {
            return {
                endpoints: {
                    deltaStorageUrl: `${ordererUrl}/deltas/${tenantId}/new`,
                    ordererUrl,
                    storageUrl: `${storageUrl}/repos/${tenantId}`,
                },
                // id is a mandatory attribute, but it's ignored by the driver for new container requests.
                id: "",
                // tokens attribute is redundant as all tokens are generated via ITokenProvider
                tokens: {},
                type: "fluid",
                url: `${ordererUrl}/${tenantId}/new`,
            };
        }
        if (containerId === undefined) {
            throw new Error("Azure URL did not contain containerId");
        }
        const documentUrl = `${ordererUrl}/${tenantId}/${containerId}`;
        return {
            endpoints: {
                deltaStorageUrl: `${ordererUrl}/deltas/${tenantId}/${containerId}`,
                ordererUrl,
                storageUrl: `${storageUrl}/repos/${tenantId}`,
            },
            id: containerId,
            tokens: {},
            type: "fluid",
            url: documentUrl,
        };
    }
    async getAbsoluteUrl(resolvedUrl, relativeUrl) {
        if (resolvedUrl.type !== "fluid") {
            throw new Error("Invalid Resolved Url");
        }
        return `${resolvedUrl.url}/${relativeUrl}`;
    }
}
function decodeAzureUrl(urlString) {
    const url = new URL(urlString);
    const ordererUrl = url.origin;
    const searchParams = url.searchParams;
    const storageUrl = searchParams.get("storage");
    if (storageUrl === null) {
        throw new Error("Azure URL did not contain a storage URL");
    }
    const tenantId = searchParams.get("tenantId");
    if (tenantId === null) {
        throw new Error("Azure URL did not contain a tenant ID");
    }
    const storageUrlDecoded = decodeURIComponent(storageUrl);
    const tenantIdDecoded = decodeURIComponent(tenantId);
    const containerId = searchParams.get("containerId");
    const containerIdDecoded = containerId !== null ? decodeURIComponent(containerId) : undefined;
    return {
        ordererUrl,
        storageUrl: storageUrlDecoded,
        tenantId: tenantIdDecoded,
        containerId: containerIdDecoded,
    };
}
/**
 * Creates a request object that can be passed to {@link @fluidframework/fluid-static#IFluidContainer.attach} to
 * request creation of a new Fluid Container on the Azure service.
 *
 * @param endpointUrl - URI to the Azure Fluid Relay service discovery endpoint.
 * @param tenantId - Unique tenant identifier.
 */
const createAzureCreateNewRequest = (endpointUrl, tenantId) => {
    const url = new URL(endpointUrl);
    url.searchParams.append("storage", encodeURIComponent(endpointUrl));
    url.searchParams.append("tenantId", encodeURIComponent(tenantId));
    return {
        url: url.href,
        headers: {
            [_fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_0__.DriverHeader.createNew]: true,
        },
    };
};
//# sourceMappingURL=AzureUrlResolver.js.map

/***/ }),
/* 330 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentPostCreateError": () => (/* binding */ DocumentPostCreateError),
/* harmony export */   "RouterliciousDocumentServiceFactory": () => (/* binding */ RouterliciousDocumentServiceFactory)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(333);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(338);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(340);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _documentService__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(406);
/* harmony import */ var _restWrapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(341);
/* harmony import */ var _createNewUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(404);
/* harmony import */ var _urlUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(334);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(397);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */









const defaultRouterliciousDriverPolicies = {
    enablePrefetch: true,
    maxConcurrentStorageRequests: 100,
    maxConcurrentOrdererRequests: 100,
    aggregateBlobsSmallerThanBytes: undefined,
    enableDiscovery: false,
    enableWholeSummaryUpload: false,
    enableRestLess: true,
};
/**
 * Factory for creating the routerlicious document service. Use this if you want to
 * use the routerlicious implementation.
 */
class RouterliciousDocumentServiceFactory {
    constructor(tokenProvider, driverPolicies = {}) {
        this.tokenProvider = tokenProvider;
        this.protocolName = "fluid:";
        this.blobCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();
        this.snapshotTreeCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();
        this.driverPolicies = Object.assign(Object.assign({}, defaultRouterliciousDriverPolicies), driverPolicies);
    }
    /**
     * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createContainer}
     *
     * @throws {@link DocumentPostCreateError}
     * If an exception is thrown while invoking the provided {@link ITokenProvider.documentPostCreateCallback}.
     */
    async createContainer(createNewSummary, resolvedUrl, logger, clientIsSummarizer) {
        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);
        if (createNewSummary === undefined) {
            throw new Error("Empty file summary creation isn't supported in this driver.");
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!!resolvedUrl.endpoints.ordererUrl, 0x0b2 /* "Missing orderer URL!" */);
        let parsedUrl = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.parseFluidUrl)(resolvedUrl.url);
        if (!parsedUrl.pathname) {
            throw new Error("Parsed url should contain tenant and doc Id!!");
        }
        const [, tenantId] = parsedUrl.pathname.split("/");
        const protocolSummary = createNewSummary.tree[".protocol"];
        const appSummary = createNewSummary.tree[".app"];
        if (!(protocolSummary && appSummary)) {
            throw new Error("Protocol and App Summary required in the full summary");
        }
        const documentAttributes = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getDocAttributesFromProtocolSummary)(protocolSummary);
        const quorumValues = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.getQuorumValuesFromProtocolSummary)(protocolSummary);
        const logger2 = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(logger, "RouterliciousDriver");
        const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);
        const ordererRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_7__.RouterliciousOrdererRestWrapper.load(tenantId, undefined, this.tokenProvider, logger2, rateLimiter, this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl);
        const res = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.PerformanceEvent.timedExecAsync(logger2, {
            eventName: "CreateNew",
            details: JSON.stringify({
                enableDiscovery: this.driverPolicies.enableDiscovery,
                sequenceNumber: documentAttributes.sequenceNumber,
            }),
        }, async (event) => {
            // @TODO: Remove returned "string" type when removing back-compat code
            const postRes = await ordererRestWrapper.post(`/documents/${tenantId}`, {
                summary: (0,_createNewUtils__WEBPACK_IMPORTED_MODULE_8__.convertSummaryToCreateNewSummary)(appSummary),
                sequenceNumber: documentAttributes.sequenceNumber,
                values: quorumValues,
                enableDiscovery: this.driverPolicies.enableDiscovery,
                generateToken: this.tokenProvider.documentPostCreateCallback !==
                    undefined,
            });
            event.end({
                docId: typeof postRes === "string" ? postRes : postRes.id,
            });
            return postRes;
        });
        // For supporting backward compatibility, when the request has generateToken === true, it will return
        // an object instead of string
        // @TODO: Remove the logic when no need to support back-compat
        let documentId;
        let token;
        let session;
        if (typeof res === "string") {
            documentId = res;
        }
        else {
            documentId = res.id;
            token = res.token;
            session = this.driverPolicies.enableDiscovery ? res.session : undefined;
        }
        parsedUrl = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.parseFluidUrl)(resolvedUrl.url);
        // @TODO: Remove token from the condition, checking the documentPostCreateCallback !== undefined
        // is sufficient to determine if the token will be undefined or not.
        try {
            await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.PerformanceEvent.timedExecAsync(logger2, {
                eventName: "DocPostCreateCallback",
                docId: documentId,
            }, async () => {
                if (token && this.tokenProvider.documentPostCreateCallback !== undefined) {
                    return this.tokenProvider.documentPostCreateCallback(documentId, token);
                }
            });
        }
        catch (error) {
            throw new DocumentPostCreateError(error);
        }
        parsedUrl.set("pathname", (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.replaceDocumentIdInPath)(parsedUrl.pathname, documentId));
        const deltaStorageUrl = resolvedUrl.endpoints.deltaStorageUrl;
        if (!deltaStorageUrl) {
            throw new Error(`All endpoints urls must be provided. [deltaStorageUrl:${deltaStorageUrl}]`);
        }
        const parsedDeltaStorageUrl = new URL(deltaStorageUrl);
        parsedDeltaStorageUrl.pathname = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.replaceDocumentIdInPath)(parsedDeltaStorageUrl.pathname, documentId);
        return this.createDocumentService(Object.assign(Object.assign({}, resolvedUrl), { url: parsedUrl.toString(), id: documentId, endpoints: Object.assign(Object.assign({}, resolvedUrl.endpoints), { deltaStorageUrl: parsedDeltaStorageUrl.toString() }) }), logger, clientIsSummarizer, session);
    }
    /**
     * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createDocumentService}
     *
     * @returns Routerlicious document service.
     */
    async createDocumentService(resolvedUrl, logger, clientIsSummarizer, session) {
        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);
        const parsedUrl = (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.parseFluidUrl)(resolvedUrl.url);
        const [, tenantId, documentId] = parsedUrl.pathname.split("/");
        if (!documentId || !tenantId) {
            throw new Error(`Couldn't parse documentId and/or tenantId. [documentId:${documentId}][tenantId:${tenantId}]`);
        }
        const logger2 = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.ChildLogger.create(logger, "RouterliciousDriver", { all: { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_9__.pkgVersion } });
        const discoverFluidResolvedUrl = async () => {
            if (!this.driverPolicies.enableDiscovery) {
                return resolvedUrl;
            }
            const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_6__.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);
            const ordererRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_7__.RouterliciousOrdererRestWrapper.load(tenantId, documentId, this.tokenProvider, logger2, rateLimiter, this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl);
            const discoveredSession = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.PerformanceEvent.timedExecAsync(logger2, {
                eventName: "DiscoverSession",
                docId: documentId,
            }, async () => {
                // The service responds with the current document session associated with the container.
                return ordererRestWrapper.get(`/documents/${tenantId}/session/${documentId}`);
            });
            return (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.getDiscoveredFluidResolvedUrl)(resolvedUrl, discoveredSession);
        };
        const fluidResolvedUrl = session !== undefined
            ? (0,_urlUtils__WEBPACK_IMPORTED_MODULE_3__.getDiscoveredFluidResolvedUrl)(resolvedUrl, session)
            : await discoverFluidResolvedUrl();
        const storageUrl = fluidResolvedUrl.endpoints.storageUrl;
        const ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;
        const deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;
        if (!ordererUrl || !deltaStorageUrl) {
            throw new Error(`All endpoints urls must be provided. [ordererUrl:${ordererUrl}][deltaStorageUrl:${deltaStorageUrl}]`);
        }
        return new _documentService__WEBPACK_IMPORTED_MODULE_10__.DocumentService(fluidResolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger2, this.tokenProvider, tenantId, documentId, this.driverPolicies, this.blobCache, this.snapshotTreeCache, discoverFluidResolvedUrl);
    }
}
/**
 * Error returned by {@link RouterliciousDocumentServiceFactory.createContainer} when an error is thrown
 * in {@link ITokenProvider.documentPostCreateCallback}.
 * It is the consumer's responsibility to ensure that any state related to container creation is appropriately
 * cleaned up in the event of failure.
 * This includes the document itself, which will have been created by the time this error was thrown.
 *
 * @remarks TODO: examples of suggested actions for recovery.
 * - How would a user delete the created document?
 * - What would a retry pattern look like here?
 */
class DocumentPostCreateError extends Error {
    constructor(
    /**
     * Inner error being wrapped.
     */
    innerError) {
        super(innerError.message);
        this.innerError = innerError;
        this.name = "DocumentPostCreateError";
    }
    get stack() { return this.innerError.stack; }
}
//# sourceMappingURL=documentServiceFactory.js.map

/***/ }),
/* 331 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InMemoryCache": () => (/* binding */ InMemoryCache)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
class InMemoryCache {
    constructor() {
        this.cache = new Map();
    }
    async get(key) {
        return this.cache.get(key);
    }
    async put(key, value) {
        this.cache.set(key, value);
    }
}
//# sourceMappingURL=cache.js.map

/***/ }),
/* 332 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ensureFluidResolvedUrl": () => (/* binding */ ensureFluidResolvedUrl),
/* harmony export */   "isFluidResolvedUrl": () => (/* binding */ isFluidResolvedUrl)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const isFluidResolvedUrl = (resolved) => (resolved === null || resolved === void 0 ? void 0 : resolved.type) === "fluid";
function ensureFluidResolvedUrl(resolved) {
    if (!isFluidResolvedUrl(resolved)) {
        throw new Error(`resolved is not a Fluid url. Type: ${resolved === null || resolved === void 0 ? void 0 : resolved.type}`);
    }
}
//# sourceMappingURL=fluidResolvedUrl.js.map

/***/ }),
/* 333 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 334 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDiscoveredFluidResolvedUrl": () => (/* binding */ getDiscoveredFluidResolvedUrl),
/* harmony export */   "parseFluidUrl": () => (/* binding */ parseFluidUrl),
/* harmony export */   "replaceDocumentIdInPath": () => (/* binding */ replaceDocumentIdInPath)
/* harmony export */ });
/* harmony import */ var url_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(335);
/* harmony import */ var url_parse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_parse__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

const parseFluidUrl = (fluidUrl) => {
    return new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(fluidUrl, true);
};
/**
 * Assume documentId is at end of url path.
 * This is true for Routerlicious' and Tinylicious' documentUrl and deltaStorageUrl.
 * Routerlicious and Tinylicious do not use documentId in storageUrl nor ordererUrl.
 * TODO: Ideally we would be able to regenerate the resolvedUrl, rather than patching the current one.
 */
const replaceDocumentIdInPath = (urlPath, documentId) => urlPath.split("/").slice(0, -1).concat([documentId]).join("/");
const getDiscoveredFluidResolvedUrl = (resolvedUrl, session) => {
    if (session) {
        const discoveredOrdererUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(session.ordererUrl);
        const deltaStorageUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(resolvedUrl.endpoints.deltaStorageUrl);
        deltaStorageUrl.set("host", discoveredOrdererUrl.host);
        const discoveredStorageUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(session.historianUrl);
        const storageUrl = new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(resolvedUrl.endpoints.storageUrl);
        storageUrl.set("host", discoveredStorageUrl.host);
        const parsedUrl = parseFluidUrl(resolvedUrl.url);
        const discoveredResolvedUrl = {
            endpoints: {
                deltaStorageUrl: deltaStorageUrl.toString(),
                ordererUrl: session.ordererUrl,
                storageUrl: storageUrl.toString(),
            },
            id: resolvedUrl.id,
            tokens: resolvedUrl.tokens,
            type: resolvedUrl.type,
            url: new (url_parse__WEBPACK_IMPORTED_MODULE_0___default())(`fluid://${discoveredOrdererUrl.host}${parsedUrl.pathname}`).toString(),
        };
        return discoveredResolvedUrl;
    }
    else {
        return resolvedUrl;
    }
};
//# sourceMappingURL=urlUtils.js.map

/***/ }),
/* 335 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(336)
  , qs = __webpack_require__(337)
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),
/* 336 */
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),
/* 337 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),
/* 338 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combineAppAndProtocolSummary": () => (/* binding */ combineAppAndProtocolSummary),
/* harmony export */   "getDocAttributesFromProtocolSummary": () => (/* binding */ getDocAttributesFromProtocolSummary),
/* harmony export */   "getQuorumValuesFromProtocolSummary": () => (/* binding */ getQuorumValuesFromProtocolSummary)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Combine the app summary and protocol summary in 1 tree.
 * @param appSummary - Summary of the app.
 * @param protocolSummary - Summary of the protocol.
 */
function combineAppAndProtocolSummary(appSummary, protocolSummary) {
    const createNewSummary = {
        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,
        tree: {
            ".protocol": protocolSummary,
            ".app": appSummary,
        },
    };
    return createNewSummary;
}
/**
 * Extract the attributes from the protocol summary.
 * @param protocolSummary - protocol summary from which the values are to be extracted.
 */
function getDocAttributesFromProtocolSummary(protocolSummary) {
    var _a;
    const attributesBlob = protocolSummary.tree.attributes;
    const documentAttributes = JSON.parse(attributesBlob.content);
    documentAttributes.term = (_a = documentAttributes.term) !== null && _a !== void 0 ? _a : 1;
    return documentAttributes;
}
/**
 * Extract quorum values from the protocol summary.
 * @param protocolSummary - protocol summary from which the values are to be extracted.
 */
function getQuorumValuesFromProtocolSummary(protocolSummary) {
    const quorumValuesBlob = protocolSummary.tree.quorumValues;
    const quorumValues = JSON.parse(quorumValuesBlob.content);
    return quorumValues;
}
//# sourceMappingURL=summaryForCreateNew.js.map

/***/ }),
/* 339 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 340 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RateLimiter": () => (/* binding */ RateLimiter)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class RateLimiter {
    constructor(maxRequests) {
        this.maxRequests = maxRequests;
        this.tasks = [];
        // Run when one of the tasks finished running.
        // Release next task if we have one, or allow more tasks to run in future.
        this.release = () => {
            const task = this.tasks.shift();
            if (task !== undefined) {
                return task();
            }
            this.maxRequests++;
        };
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(maxRequests > 0, 0x0ae /* "Tried to create rate limiter with 0 max requests!" */);
    }
    get waitQueueLength() {
        return this.tasks.length;
    }
    async acquire() {
        if (this.maxRequests > 0) {
            this.maxRequests--;
            return;
        }
        return new Promise((resolve) => {
            this.tasks.push(resolve);
        });
    }
    async schedule(work) {
        await this.acquire();
        return work().finally(this.release);
    }
}
//# sourceMappingURL=rateLimiter.js.map

/***/ }),
/* 341 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterliciousOrdererRestWrapper": () => (/* binding */ RouterliciousOrdererRestWrapper),
/* harmony export */   "RouterliciousRestWrapper": () => (/* binding */ RouterliciousRestWrapper),
/* harmony export */   "RouterliciousStorageRestWrapper": () => (/* binding */ RouterliciousStorageRestWrapper)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(398);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(344);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(395);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(400);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(45);
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(342);
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(343);
/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(27);
/* harmony import */ var _errorUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(396);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(397);








const axiosRequestConfigToFetchRequestConfig = (requestConfig) => {
    var _a, _b;
    const requestInfo = requestConfig.baseURL !== undefined
        ? `${requestConfig.baseURL}${(_a = requestConfig.url) !== null && _a !== void 0 ? _a : ""}`
        : (_b = requestConfig.url) !== null && _b !== void 0 ? _b : "";
    const requestInit = {
        method: requestConfig.method,
        // NOTE: I believe that although the Axios type permits non-string values in the header, here we are
        // guaranteed the requestConfig only has string values in its header.
        headers: requestConfig.headers,
        body: requestConfig.data,
    };
    return [requestInfo, requestInit];
};
class RouterliciousRestWrapper extends _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_2__.RestWrapper {
    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {
        super(baseurl, defaultQueryString);
        this.rateLimiter = rateLimiter;
        this.getAuthorizationHeader = getAuthorizationHeader;
        this.useRestLess = useRestLess;
        this.restLess = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_3__.RestLessClient();
    }
    async load() {
        this.authorizationHeader = await this.getAuthorizationHeader();
    }
    async request(requestConfig, statusCode, canRetry = true) {
        var _a;
        const config = Object.assign(Object.assign({}, requestConfig), { headers: this.generateHeaders(requestConfig.headers) });
        const translatedConfig = this.useRestLess ? this.restLess.translate(config) : config;
        const fetchRequestConfig = axiosRequestConfigToFetchRequestConfig(translatedConfig);
        const response = await this.rateLimiter.schedule(async () => cross_fetch__WEBPACK_IMPORTED_MODULE_0___default()(...fetchRequestConfig)
            .catch(async (error) => {
            // Browser Fetch throws a TypeError on network error, `node-fetch` throws a FetchError
            const isNetworkError = ["TypeError", "FetchError"].includes(error === null || error === void 0 ? void 0 : error.name);
            (0,_errorUtils__WEBPACK_IMPORTED_MODULE_4__.throwR11sNetworkError)(isNetworkError ? `NetworkError: ${error.message}` : json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default()(error));
        }));
        const responseBody = ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json"))
            ? await response.json()
            : await response.text();
        // Success
        if (response.ok || response.status === statusCode) {
            const result = responseBody;
            return result;
        }
        // Failure
        if (response.status === 401 && canRetry) {
            // Refresh Authorization header and retry once
            this.authorizationHeader = await this.getAuthorizationHeader(true /* refreshToken */);
            return this.request(config, statusCode, false);
        }
        if (response.status === 429 && (responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter) > 0) {
            // Retry based on retryAfter[Seconds]
            return new Promise((resolve, reject) => setTimeout(() => {
                this.request(config, statusCode)
                    .then(resolve)
                    .catch(reject);
            }, responseBody.retryAfter * 1000));
        }
        const responseSummary = responseBody !== undefined
            ? typeof responseBody === "string" ? responseBody : json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default()(responseBody)
            : response.statusText;
        (0,_errorUtils__WEBPACK_IMPORTED_MODULE_4__.throwR11sNetworkError)(`R11s fetch error: ${responseSummary}`, response.status, responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter);
    }
    generateHeaders(requestHeaders) {
        const correlationId = (requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders["x-correlation-id"]) || (0,uuid__WEBPACK_IMPORTED_MODULE_5__["default"])();
        return Object.assign(Object.assign({}, requestHeaders), { 
            // TODO: replace header names with CorrelationIdHeaderName and DriverVersionHeaderName from services-client
            // NOTE: Can correlationId actually be number | true?
            "x-correlation-id": correlationId, "x-driver-version": _packageVersion__WEBPACK_IMPORTED_MODULE_6__.pkgVersion, 
            // NOTE: If this.authorizationHeader is undefined, should "Authorization" be removed entirely?
            "Authorization": this.authorizationHeader });
    }
}
class RouterliciousStorageRestWrapper extends RouterliciousRestWrapper {
    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {
        super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);
    }
    static async load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {
        const defaultQueryString = {
            token: `${(0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.fromUtf8ToBase64)(tenantId)}`,
        };
        const getAuthorizationHeader = async (refreshToken) => {
            return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__.PerformanceEvent.timedExecAsync(logger, {
                eventName: "FetchStorageToken",
                docId: documentId,
            }, async () => {
                // Craft credentials using tenant id and token
                const storageToken = await tokenProvider.fetchStorageToken(tenantId, documentId, refreshToken);
                const credentials = {
                    password: storageToken.jwt,
                    user: tenantId,
                };
                return (0,_fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_9__.getAuthorizationTokenFromCredentials)(credentials);
            });
        };
        const restWrapper = new RouterliciousStorageRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);
        try {
            await restWrapper.load();
        }
        catch (e) {
            logger.sendErrorEvent({
                eventName: "R11sRestWrapperLoadFailure",
            }, e);
            await restWrapper.load();
        }
        return restWrapper;
    }
}
class RouterliciousOrdererRestWrapper extends RouterliciousRestWrapper {
    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {
        super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);
    }
    static async load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {
        const getAuthorizationHeader = async (refreshToken) => {
            return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__.PerformanceEvent.timedExecAsync(logger, {
                eventName: "FetchOrdererToken",
                docId: documentId,
            }, async () => {
                const ordererToken = await tokenProvider.fetchOrdererToken(tenantId, documentId, refreshToken);
                return `Basic ${ordererToken.jwt}`;
            });
        };
        const restWrapper = new RouterliciousOrdererRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl);
        try {
            await restWrapper.load();
        }
        catch (e) {
            logger.sendErrorEvent({
                eventName: "R11sRestWrapperLoadFailure",
            }, e);
            await restWrapper.load();
        }
        return restWrapper;
    }
}
//# sourceMappingURL=restWrapper.js.map

/***/ }),
/* 342 */
/***/ (function(module, exports) {

var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports["default"] = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports


/***/ }),
/* 343 */
/***/ ((module, exports) => {

exports = module.exports = stringify
exports.getSerialize = serializer

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return "[Circular ~]"
    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this)
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
    }
    else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}


/***/ }),
/* 344 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicRestWrapper": () => (/* binding */ BasicRestWrapper),
/* harmony export */   "RestWrapper": () => (/* binding */ RestWrapper)
/* harmony export */ });
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);
/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(343);
/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(348);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(388);
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(394);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(393);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */







class RestWrapper {
    constructor(baseurl, defaultQueryString = {}, maxBodyLength = 1000 * 1024 * 1024, maxContentLength = 1000 * 1024 * 1024) {
        this.baseurl = baseurl;
        this.defaultQueryString = defaultQueryString;
        this.maxBodyLength = maxBodyLength;
        this.maxContentLength = maxContentLength;
    }
    async get(url, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "GET",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 200);
    }
    async post(url, requestBody, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            data: requestBody,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "POST",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 201);
    }
    async delete(url, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "DELETE",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 204);
    }
    async patch(url, requestBody, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            data: requestBody,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "PATCH",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 200);
    }
    generateQueryString(queryStringValues) {
        if (this.defaultQueryString || queryStringValues) {
            const queryStringMap = Object.assign(Object.assign({}, this.defaultQueryString), queryStringValues);
            const queryString = querystring__WEBPACK_IMPORTED_MODULE_0__.stringify(queryStringMap);
            if (queryString !== "") {
                return `?${queryString}`;
            }
        }
        return "";
    }
}
class BasicRestWrapper extends RestWrapper {
    constructor(baseurl, defaultQueryString = {}, maxBodyLength = 1000 * 1024 * 1024, maxContentLength = 1000 * 1024 * 1024, defaultHeaders = {}, axios = (axios__WEBPACK_IMPORTED_MODULE_2___default()), refreshDefaultQueryString, refreshDefaultHeaders, getCorrelationId) {
        super(baseurl, defaultQueryString, maxBodyLength, maxContentLength);
        this.defaultHeaders = defaultHeaders;
        this.axios = axios;
        this.refreshDefaultQueryString = refreshDefaultQueryString;
        this.refreshDefaultHeaders = refreshDefaultHeaders;
        this.getCorrelationId = getCorrelationId;
    }
    async request(requestConfig, statusCode, canRetry = true) {
        var _a, _b;
        const options = Object.assign({}, requestConfig);
        options.headers = this.generateHeaders(options.headers, (_b = (_a = this.getCorrelationId) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : (0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
        return new Promise((resolve, reject) => {
            this.axios.request(options)
                .then((response) => { resolve(response.data); })
                .catch((error) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                if (((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) === statusCode) {
                    // Axios misinterpreted as error, return as successful response
                    resolve((_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.data);
                }
                if (error === null || error === void 0 ? void 0 : error.config) {
                    // eslint-disable-next-line max-len
                    (0,_debug__WEBPACK_IMPORTED_MODULE_4__.debug)(`[${error.config.method}] request to [${(_c = error.config.baseURL) !== null && _c !== void 0 ? _c : ""}${(_d = error.config.url) !== null && _d !== void 0 ? _d : ""}] failed with [${(_e = error.response) === null || _e === void 0 ? void 0 : _e.status}] [${json_stringify_safe__WEBPACK_IMPORTED_MODULE_1___default()((_f = error.response) === null || _f === void 0 ? void 0 : _f.data, undefined, 2)}]`);
                }
                else {
                    (0,_debug__WEBPACK_IMPORTED_MODULE_4__.debug)(`request to ${options.url} failed ${error ? error.message : ""}`);
                }
                if (((_g = error === null || error === void 0 ? void 0 : error.response) === null || _g === void 0 ? void 0 : _g.status) === 429 && ((_j = (_h = error === null || error === void 0 ? void 0 : error.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.retryAfter) > 0 && canRetry) {
                    setTimeout(() => {
                        this.request(options, statusCode)
                            .then(resolve)
                            .catch(reject);
                    }, error.response.data.retryAfter * 1000);
                }
                else if (((_k = error === null || error === void 0 ? void 0 : error.response) === null || _k === void 0 ? void 0 : _k.status) === 401 && canRetry && this.refreshOnAuthError()) {
                    const retryConfig = Object.assign({}, requestConfig);
                    retryConfig.headers = this.generateHeaders(retryConfig.headers, options.headers[_constants__WEBPACK_IMPORTED_MODULE_5__.CorrelationIdHeaderName]);
                    this.request(retryConfig, statusCode, false)
                        .then(resolve)
                        .catch(reject);
                }
                else {
                    // From https://axios-http.com/docs/handling_errors
                    if (error === null || error === void 0 ? void 0 : error.response) {
                        // The request was made and the server responded with a status code
                        // that falls out of the range of 2xx
                        reject((0,_error__WEBPACK_IMPORTED_MODULE_6__.createFluidServiceNetworkError)((_l = error === null || error === void 0 ? void 0 : error.response) === null || _l === void 0 ? void 0 : _l.status, (_m = error === null || error === void 0 ? void 0 : error.response) === null || _m === void 0 ? void 0 : _m.data));
                    }
                    else if (error === null || error === void 0 ? void 0 : error.request) {
                        // The request was made but no response was received. That can happen if a service is
                        // temporarily down or inaccessible due to network failures. We leverage that in here
                        // to detect network failures and transform them into a NetworkError with code 502,
                        // which can be retried and is not fatal.
                        reject((0,_error__WEBPACK_IMPORTED_MODULE_6__.createFluidServiceNetworkError)(502, `Network Error: ${(_o = error === null || error === void 0 ? void 0 : error.message) !== null && _o !== void 0 ? _o : "undefined"}`));
                    }
                    else {
                        // Something happened in setting up the request that triggered an Error
                        const details = {
                            canRetry: false,
                            isFatal: false,
                            message: (_p = error === null || error === void 0 ? void 0 : error.message) !== null && _p !== void 0 ? _p : "Unknown Error",
                        };
                        reject((0,_error__WEBPACK_IMPORTED_MODULE_6__.createFluidServiceNetworkError)(500, details));
                    }
                }
            });
        });
    }
    generateHeaders(headers, fallbackCorrelationId) {
        let result = headers !== null && headers !== void 0 ? headers : {};
        if (this.defaultHeaders) {
            result = Object.assign(Object.assign({}, this.defaultHeaders), headers);
        }
        if (result[_constants__WEBPACK_IMPORTED_MODULE_5__.CorrelationIdHeaderName]) {
            return result;
        }
        return Object.assign({ [_constants__WEBPACK_IMPORTED_MODULE_5__.CorrelationIdHeaderName]: fallbackCorrelationId }, result);
    }
    refreshOnAuthError() {
        if (this.refreshDefaultQueryString === undefined && this.refreshDefaultHeaders === undefined) {
            // retry will not succeed with the same params and headers
            return false;
        }
        if (this.refreshDefaultHeaders !== undefined) {
            this.defaultHeaders = this.refreshDefaultHeaders();
        }
        if (this.refreshDefaultQueryString !== undefined) {
            this.defaultQueryString = this.refreshDefaultQueryString();
        }
        return true;
    }
}
//# sourceMappingURL=restWrapper.js.map

/***/ }),
/* 345 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(346);
exports.encode = exports.stringify = __webpack_require__(347);


/***/ }),
/* 346 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 347 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).filter(Boolean).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 348 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(349);

/***/ }),
/* 349 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var bind = __webpack_require__(351);
var Axios = __webpack_require__(352);
var mergeConfig = __webpack_require__(382);
var defaults = __webpack_require__(362);
var formDataToJSON = __webpack_require__(370);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = __webpack_require__(379);
axios.CancelToken = __webpack_require__(385);
axios.isCancel = __webpack_require__(381);
axios.VERSION = (__webpack_require__(384).version);
axios.toFormData = __webpack_require__(355);

// Expose AxiosError class
axios.AxiosError = __webpack_require__(356);

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(386);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(387);

axios.formToJSON = function(thing) {
  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
};

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),
/* 350 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(351);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a empty Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a empty Object, otherwise false
 */
function isEmptyObject(val) {
  return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  var product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter, propFilter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 * @param {*} [thing]
 * @returns {?Array}
 */
function toArray(thing) {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  var i = thing.length;
  if (!isNumber(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

function forEachEntry(obj, fn) {
  var generator = obj && obj[Symbol.iterator];

  var iterator = generator.call(obj);

  var result;

  while ((result = iterator.next()) && !result.done) {
    var pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

function matchAll(regExp, str) {
  var matches;
  var arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

var isHTMLForm = kindOfTest('HTMLFormElement');

var hasOwnProperty = (function resolver(_hasOwnProperty) {
  return function(obj, prop) {
    return _hasOwnProperty.call(obj, prop);
  };
})(Object.prototype.hasOwnProperty);

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isEmptyObject: isEmptyObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList,
  forEachEntry: forEachEntry,
  matchAll: matchAll,
  isHTMLForm: isHTMLForm,
  hasOwnProperty: hasOwnProperty
};


/***/ }),
/* 351 */
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
};


/***/ }),
/* 352 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var buildURL = __webpack_require__(353);
var InterceptorManager = __webpack_require__(359);
var dispatchRequest = __webpack_require__(360);
var mergeConfig = __webpack_require__(382);
var buildFullPath = __webpack_require__(374);
var validator = __webpack_require__(383);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
 * @param {?Object} config
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  var paramsSerializer = config.paramsSerializer;

  utils.isFunction(paramsSerializer) && (config.paramsSerializer = {serialize: paramsSerializer});

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;


/***/ }),
/* 353 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var AxiosURLSearchParams = __webpack_require__(354);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var hashmarkIndex = url.indexOf('#');

  if (hashmarkIndex !== -1) {
    url = url.slice(0, hashmarkIndex);
  }

  var _encode = options && options.encode || encode;

  var serializerParams = utils.isURLSearchParams(params) ?
    params.toString() :
    new AxiosURLSearchParams(params, options).toString(_encode);

  if (serializerParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializerParams;
  }

  return url;
};


/***/ }),
/* 354 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toFormData = __webpack_require__(355);

function encode(str) {
  var charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

var prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  var _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

module.exports = AxiosURLSearchParams;


/***/ }),
/* 355 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var AxiosError = __webpack_require__(356);
var envFormData = __webpack_require__(357);

function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

var predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

function isSpecCompliant(thing) {
  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];
}

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 * @returns {Object}
 **/

function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (envFormData || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  var metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  var visitor = options.visitor || defaultVisitor;
  var dots = options.dots;
  var indexes = options.indexes;
  var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  var useBlob = _Blob && isSpecCompliant(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    var arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !utils.isUndefined(el) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  var stack = [];

  var exposedHelpers = Object.assign(predicates, {
    defaultVisitor: defaultVisitor,
    convertValue: convertValue,
    isVisitable: isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      var result = !utils.isUndefined(el) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

module.exports = toFormData;


/***/ }),
/* 356 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;


/***/ }),
/* 357 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// eslint-disable-next-line strict
module.exports = __webpack_require__(358);


/***/ }),
/* 358 */
/***/ ((module) => {

/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;


/***/ }),
/* 359 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Clear all interceptors from the stack
 */
InterceptorManager.prototype.clear = function clear() {
  if (this.handlers) {
    this.handlers = [];
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 360 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var transformData = __webpack_require__(361);
var isCancel = __webpack_require__(381);
var defaults = __webpack_require__(362);
var CanceledError = __webpack_require__(379);
var normalizeHeaderName = __webpack_require__(363);

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    null,
    config.transformRequest
  );

  normalizeHeaderName(config.headers, 'Accept');
  normalizeHeaderName(config.headers, 'Content-Type');

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      response.status,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          reason.response.status,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 361 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var defaults = __webpack_require__(362);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Number} status HTTP status code
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, status, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers, status);
  });

  return data;
};


/***/ }),
/* 362 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var normalizeHeaderName = __webpack_require__(363);
var AxiosError = __webpack_require__(356);
var transitionalDefaults = __webpack_require__(364);
var toFormData = __webpack_require__(355);
var toURLEncodedForm = __webpack_require__(365);
var platform = __webpack_require__(366);
var formDataToJSON = __webpack_require__(370);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(371);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(371);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    var contentType = headers && headers['Content-Type'] || '';
    var hasJSONContentType = contentType.indexOf('application/json') > -1;
    var isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    var isFormData = utils.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') !== -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        var _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      var silentJSONParsing = transitional && transitional.silentJSONParsing;
      var strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),
/* 363 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 364 */
/***/ ((module) => {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};


/***/ }),
/* 365 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var toFormData = __webpack_require__(355);
var platform = __webpack_require__(366);

module.exports = function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
};


/***/ }),
/* 366 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(367);


/***/ }),
/* 367 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  isBrowser: true,
  classes: {
    URLSearchParams: __webpack_require__(368),
    FormData: __webpack_require__(369),
    Blob: Blob
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};


/***/ }),
/* 368 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosURLSearchParams = __webpack_require__(354);

module.exports = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;


/***/ }),
/* 369 */
/***/ ((module) => {

"use strict";


module.exports = FormData;


/***/ }),
/* 370 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(function(match) {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

function arrayToObject(arr) {
  var obj = {};
  var keys = Object.keys(arr);
  var i;
  var len = keys.length;
  var key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    var name = path[index++];
    var isNumericKey = Number.isFinite(+name);
    var isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProperty(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    var result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    var obj = {};

    utils.forEachEntry(formData, function(name, value) {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

module.exports = formDataToJSON;


/***/ }),
/* 371 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);
var settle = __webpack_require__(372);
var cookies = __webpack_require__(373);
var buildURL = __webpack_require__(353);
var buildFullPath = __webpack_require__(374);
var parseHeaders = __webpack_require__(377);
var isURLSameOrigin = __webpack_require__(378);
var transitionalDefaults = __webpack_require__(364);
var AxiosError = __webpack_require__(356);
var CanceledError = __webpack_require__(379);
var parseProtocol = __webpack_require__(380);
var platform = __webpack_require__(366);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var withXSRFToken = config.withXSRFToken;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
        // Add xsrf header
        var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, req) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    // false, 0 (zero number), and '' (empty string) are valid JSON values
    if (!requestData && requestData !== false && requestData !== 0 && requestData !== '') {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 372 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(356);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 373 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),
/* 374 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(375);
var combineURLs = __webpack_require__(376);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),
/* 375 */
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),
/* 376 */
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 377 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.slice(0, i)).toLowerCase();
    val = utils.trim(line.slice(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 378 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
      function resolveURL(url) {
        var href = url;

        if (msie) {
          // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),
/* 379 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(356);
var utils = __webpack_require__(350);

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;


/***/ }),
/* 380 */
/***/ ((module) => {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};


/***/ }),
/* 381 */
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 382 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isEmptyObject(source)) {
      return utils.merge({}, target);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'withXSRFToken': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),
/* 383 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = (__webpack_require__(384).version);
var AxiosError = __webpack_require__(356);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),
/* 384 */
/***/ ((module) => {

module.exports = {
  "version": "0.28.0"
};

/***/ }),
/* 385 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CanceledError = __webpack_require__(379);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i = token._listeners.length;

    while (i-- > 0) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message, config, request) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message, config, request);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 386 */
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 387 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(350);

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};


/***/ }),
/* 388 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(389);
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(392);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


const debug = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)("fluid:services-client");
debug(`Package: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgName} - Version: ${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`);
//# sourceMappingURL=debug.js.map

/***/ }),
/* 389 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(390)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 390 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(391);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 391 */
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 392 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/server-services-client";
const pkgVersion = "0.1036.5002";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 393 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CorrelationIdHeaderName": () => (/* binding */ CorrelationIdHeaderName),
/* harmony export */   "DriverVersionHeaderName": () => (/* binding */ DriverVersionHeaderName)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const CorrelationIdHeaderName = "x-correlation-id";
const DriverVersionHeaderName = "x-driver-version";
//# sourceMappingURL=constants.js.map

/***/ }),
/* 394 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NetworkError": () => (/* binding */ NetworkError),
/* harmony export */   "createFluidServiceNetworkError": () => (/* binding */ createFluidServiceNetworkError),
/* harmony export */   "isNetworkError": () => (/* binding */ isNetworkError),
/* harmony export */   "throwFluidServiceNetworkError": () => (/* binding */ throwFluidServiceNetworkError)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Represents errors associated with network communication.
 *
 * @remarks
 * The Fluid Framework server implementation includes a collection of services that communicate with each other
 * over the network. Network communication is subject to a diverse range of errors. {@link NetworkError} helps
 * convey more information than a simple HTTP status code, allowing services to be aware of the context of a
 * network error and making those services more prepared to react to such kinds of errors.
 */
class NetworkError extends Error {
    constructor(
    /**
     * HTTP status code that describes the error.
     * @public
     */
    code, 
    /**
     * The message associated with the error.
     * @public
     */
    message, 
    /**
     * Optional boolean indicating whether this is an error that can be retried.
     * Only relevant when {@link NetworkError.isFatal} is false.
     * @public
     */
    canRetry, 
    /**
     * Optional boolean indicating whether this error is fatal. This generally indicates that the error causes
     * negative, non-recoverable impact to the component/caller and cannot be ignored.
     * @public
     */
    isFatal, 
    /**
     * Optional value representing the time in milliseconds that should be waited before retrying.
     * @public
     */
    retryAfterMs) {
        super(message);
        this.code = code;
        this.canRetry = canRetry;
        this.isFatal = isFatal;
        this.retryAfterMs = retryAfterMs;
        this.name = "NetworkError";
        this.retryAfter = retryAfterMs !== undefined ? retryAfterMs / 1000 : undefined;
    }
    /**
     * Gets the details associated with this {@link NetworkError}.
     * @returns A simple string conveying the message if no other details are included in this {@link NetworkError},
     * or an {@link INetworkErrorDetails} object otherwise.
     * @public
     */
    get details() {
        if (this.canRetry === undefined && this.isFatal === undefined && this.retryAfterMs === undefined) {
            return this.message;
        }
        return {
            message: this.message,
            canRetry: this.canRetry,
            isFatal: this.isFatal,
            retryAfter: this.retryAfter,
            retryAfterMs: this.retryAfterMs,
        };
    }
    /**
     * Explicitly define how to serialize as JSON so that socket.io can emit relevant info.
     * @public
     */
    toJSON() {
        return {
            code: this.code,
            message: this.message,
            canRetry: this.canRetry,
            isFatal: this.isFatal,
            retryAfterMs: this.retryAfterMs,
            retryAfter: this.retryAfter,
        };
    }
}
function isNetworkError(error) {
    return error.name === "NetworkError" &&
        typeof error.code === "number" &&
        typeof error.message === "string";
}
/**
 * Convenience function for generating a {@link NetworkError}.
 * @remarks Generates a {@link NetworkError} instance appropriately configured given the status code and error data
 * provided. This function is intended to be used in situations where a {@link NetworkError} is dynamically created
 * based variable parameters. That is, when it is not known whether the status code can be 404 or 500.
 * @param statusCode - HTTP status code that describes the error.
 * @param errorData - Optional additional data associated with the error. Can either be a simple string representing
 *  the message, or an {@link INetworkErrorDetails} object.
 * @returns A {@link NetworkError} instance properly configured according to the parameters provided.
 * @public
 */
function createFluidServiceNetworkError(statusCode, errorData) {
    var _a;
    let message;
    let canRetry;
    let isFatal;
    let retryAfter;
    if (errorData && typeof errorData === "object") {
        message = (_a = errorData.message) !== null && _a !== void 0 ? _a : "Unknown Error";
        canRetry = errorData.canRetry;
        isFatal = errorData.isFatal;
        retryAfter = errorData.retryAfter;
    }
    else if (errorData && typeof errorData === "string") {
        message = errorData;
    }
    else {
        message = "Unknown Error";
    }
    switch (statusCode) {
        case 401:
        case 403:
        case 404:
            return new NetworkError(statusCode, message, false, /* canRetry */ false); /* isFatal */
        case 413:
        case 422:
            return new NetworkError(statusCode, message, canRetry !== null && canRetry !== void 0 ? canRetry : false, /* canRetry */ isFatal !== null && isFatal !== void 0 ? isFatal : false, /* isFatal */ canRetry ? retryAfter : undefined);
        case 429:
            return new NetworkError(statusCode, message, true, /* canRetry */ false, /* isFatal */ retryAfter);
        case 500: {
            return new NetworkError(statusCode, message, canRetry !== null && canRetry !== void 0 ? canRetry : true, /* canRetry */ isFatal !== null && isFatal !== void 0 ? isFatal : false, /* isFatal */ canRetry ? retryAfter : undefined);
        }
        case 502:
        case 503:
        case 504:
            return new NetworkError(statusCode, message, true, /* canRetry */ false, /* isFatal */ retryAfter);
        default:
            return new NetworkError(statusCode, message, false, /* canRetry */ true); /* isFatal */
    }
}
/**
 * Convenience function to both generate and throw a {@link NetworkError}.
 * @remarks Similarly to {@link createFluidServiceNetworkError}, this function generates a {@link NetworkError}
 * instance appropriately configured given the status code and error data provided. The difference is that this
 * function also throws the {@link NetworkError}.
 * @param statusCode - HTTP status code that describes the error.
 * @param errorData - Optional additional data associated with the error. Can either be a simple string representing
 *  the message, or an {@link INetworkErrorDetails} object.
 * @public
 */
function throwFluidServiceNetworkError(statusCode, errorData) {
    const networkError = createFluidServiceNetworkError(statusCode, errorData);
    throw networkError;
}
//# sourceMappingURL=error.js.map

/***/ }),
/* 395 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RestLessClient": () => (/* binding */ RestLessClient),
/* harmony export */   "RestLessFieldNames": () => (/* binding */ RestLessFieldNames)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var RestLessFieldNames;
(function (RestLessFieldNames) {
    RestLessFieldNames["Method"] = "method";
    RestLessFieldNames["Header"] = "header";
    RestLessFieldNames["Body"] = "body";
})(RestLessFieldNames || (RestLessFieldNames = {}));
const encodeHeader = (headerKey, headerValue) => {
    return `${headerKey}: ${headerValue}`;
};
/**
 * Client for communicating with a "RestLess" server.
 * Translates a typical RESTful HTTP request into "RestLess" HTTP format:
 *
 * POST \<path\> HTTP/\<1.1|2\>
 *
 * HOST \<hostname\>
 *
 * Content-Type: application/x-www-form-urlencoded
 *
 * <url-encoded-headers-body-and-method>
 */
class RestLessClient {
    /**
     * Translates request from REST to "RestLess" out-of-place.
     */
    translate(request) {
        var _a, _b;
        const newRequest = Object.assign({}, request);
        const body = new URLSearchParams();
        body.append(RestLessFieldNames.Method, (_a = newRequest.method) !== null && _a !== void 0 ? _a : "GET");
        if (newRequest.headers) {
            for (const [headerKey, headerValue] of Object.entries(newRequest.headers)) {
                const encodedHeader = encodeHeader(headerKey, headerValue);
                body.append(RestLessFieldNames.Header, encodedHeader);
            }
        }
        if (newRequest.data && ["post", "put", "patch"].includes((_b = newRequest.method) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            const stringifiedBody = JSON.stringify(newRequest.data);
            body.append(RestLessFieldNames.Body, stringifiedBody);
        }
        newRequest.data = body.toString();
        newRequest.method = "POST";
        newRequest.headers = {
            // TODO: when we support blob/file uploads, we should potentially add compatibility with multipart/form-data
            "Content-Type": "application/x-www-form-urlencoded;restless",
        };
        return newRequest;
    }
}
//# sourceMappingURL=restLessClient.js.map

/***/ }),
/* 396 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R11sErrorType": () => (/* binding */ R11sErrorType),
/* harmony export */   "createR11sNetworkError": () => (/* binding */ createR11sNetworkError),
/* harmony export */   "errorObjectFromSocketError": () => (/* binding */ errorObjectFromSocketError),
/* harmony export */   "throwR11sNetworkError": () => (/* binding */ throwR11sNetworkError)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(397);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


var R11sErrorType;
(function (R11sErrorType) {
    R11sErrorType["fileNotFoundOrAccessDeniedError"] = "fileNotFoundOrAccessDeniedError";
})(R11sErrorType || (R11sErrorType = {}));
function createR11sNetworkError(errorMessage, statusCode, retryAfterMs) {
    const props = { statusCode, driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_0__.pkgVersion };
    switch (statusCode) {
        case undefined:
            // If a service is temporarily down or a browser resource limit is reached, RestWrapper will throw
            // a network error with no status code (e.g. err:ERR_CONN_REFUSED or err:ERR_FAILED) and
            // the error message will start with NetworkError as defined in restWrapper.ts
            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.GenericNetworkError(errorMessage, errorMessage.startsWith("NetworkError"), props);
        case 401:
        // The first 401 is manually retried in RouterliciousRestWrapper with a refreshed token,
        // so we treat repeat 401s the same as 403.
        case 403:
            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.AuthorizationError(errorMessage, undefined, undefined, props);
        case 404:
            const errorType = R11sErrorType.fileNotFoundOrAccessDeniedError;
            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.NonRetryableError(errorMessage, errorType, props);
        case 429:
            return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createGenericNetworkError)(errorMessage, { canRetry: true, retryAfterMs }, props);
        case 500:
        case 502:
            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.GenericNetworkError(errorMessage, true, props);
        default:
            const retryInfo = { canRetry: retryAfterMs !== undefined, retryAfterMs };
            return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createGenericNetworkError)(errorMessage, retryInfo, props);
    }
}
function throwR11sNetworkError(errorMessage, statusCode, retryAfterMs) {
    const networkError = createR11sNetworkError(errorMessage, statusCode, retryAfterMs);
    // eslint-disable-next-line @typescript-eslint/no-throw-literal
    throw networkError;
}
/**
 * Returns network error based on error object from R11s socket (IR11sSocketError)
 */
function errorObjectFromSocketError(socketError, handler) {
    // pre-0.58 error message prefix: R11sSocketError
    const message = `R11s socket error (${handler}): ${socketError.message}`;
    return createR11sNetworkError(message, socketError.code, socketError.retryAfterMs);
}
//# sourceMappingURL=errorUtils.js.map

/***/ }),
/* 397 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/routerlicious-driver";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 398 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromBase64ToUtf8": () => (/* binding */ fromBase64ToUtf8),
/* harmony export */   "fromUtf8ToBase64": () => (/* binding */ fromUtf8ToBase64),
/* harmony export */   "toUtf8": () => (/* binding */ toUtf8)
/* harmony export */ });
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(399);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

const fromBase64ToUtf8 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "base64").toString("utf-8");
const fromUtf8ToBase64 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "utf8").toString("base64");
/**
 * Convenience function to convert unknown encoding to utf8 that avoids
 * buffer copies/encode ops when no conversion is needed
 * @param input - The source string to convert
 * @param encoding - The source string's encoding
 */
const toUtf8 = (input, encoding) => {
    switch (encoding) {
        case "utf8":
        case "utf-8":
            return input;
        default:
            return _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, encoding).toString();
    }
};
//# sourceMappingURL=base64Encoding.js.map

/***/ }),
/* 399 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(333);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 400 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Historian": () => (/* binding */ Historian),
/* harmony export */   "getAuthorizationTokenFromCredentials": () => (/* binding */ getAuthorizationTokenFromCredentials)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(401);
/* harmony import */ var _restWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(344);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


function endsWith(value, endings) {
    for (const ending of endings) {
        if (value.endsWith(ending)) {
            return true;
        }
    }
    return false;
}
const getAuthorizationTokenFromCredentials = (credentials) => `Basic ${(0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.fromUtf8ToBase64)(`${credentials.user}:${credentials.password}`)}`;
/**
 * Implementation of the IHistorian interface that calls out to a REST interface
 */
class Historian {
    constructor(endpoint, historianApi, disableCache, restWrapper) {
        this.endpoint = endpoint;
        this.historianApi = historianApi;
        this.restWrapper = restWrapper;
        this.defaultQueryString = {};
        if (disableCache && this.historianApi) {
            this.defaultQueryString.disableCache = disableCache;
            this.cacheBust = false;
        }
        else {
            this.cacheBust = disableCache;
        }
        if (this.restWrapper === undefined) {
            this.restWrapper = new _restWrapper__WEBPACK_IMPORTED_MODULE_1__.BasicRestWrapper(this.endpoint);
        }
    }
    async getHeader(sha) {
        if (this.historianApi) {
            return this.restWrapper.get(`/headers/${encodeURIComponent(sha)}`, this.getQueryString());
        }
        else {
            return this.getHeaderDirect(sha);
        }
    }
    async getFullTree(sha) {
        return this.restWrapper.get(`/tree/${encodeURIComponent(sha)}`, this.getQueryString());
    }
    async getBlob(sha) {
        return this.restWrapper.get(`/git/blobs/${encodeURIComponent(sha)}`, this.getQueryString());
    }
    async createBlob(blob) {
        return this.restWrapper.post(`/git/blobs`, blob, this.getQueryString());
    }
    async getContent(path, ref) {
        return this.restWrapper.get(`/contents/${path}`, this.getQueryString({ ref }));
    }
    async getCommits(sha, count) {
        return this.restWrapper.get(`/commits`, this.getQueryString({ count, sha }))
            .catch((error) => (error === 400 || error === 404) ?
            [] : Promise.reject(error));
    }
    async getCommit(sha) {
        return this.restWrapper.get(`/git/commits/${encodeURIComponent(sha)}`, this.getQueryString());
    }
    async createCommit(commit) {
        return this.restWrapper.post(`/git/commits`, commit, this.getQueryString());
    }
    async getRefs() {
        return this.restWrapper.get(`/git/refs`, this.getQueryString());
    }
    async getRef(ref) {
        return this.restWrapper.get(`/git/refs/${ref}`, this.getQueryString());
    }
    async createRef(params) {
        return this.restWrapper.post(`/git/refs`, params, this.getQueryString());
    }
    async updateRef(ref, params) {
        return this.restWrapper.patch(`/git/refs/${ref}`, params, this.getQueryString());
    }
    async deleteRef(ref) {
        await this.restWrapper.delete(`/git/refs/${ref}`, this.getQueryString());
    }
    async createTag(tag) {
        return this.restWrapper.post(`/git/tags`, tag, this.getQueryString());
    }
    async getTag(tag) {
        return this.restWrapper.get(`/git/tags/${tag}`, this.getQueryString());
    }
    async createTree(tree) {
        return this.restWrapper.post(`/git/trees`, tree, this.getQueryString());
    }
    async getTree(sha, recursive) {
        return this.restWrapper.get(`/git/trees/${encodeURIComponent(sha)}`, this.getQueryString({ recursive: recursive ? 1 : 0 }));
    }
    async createSummary(summary) {
        return this.restWrapper.post(`/git/summaries`, summary, this.getQueryString());
    }
    async deleteSummary(softDelete) {
        const headers = { "Soft-Delete": softDelete };
        return this.restWrapper.delete(`/git/summaries`, this.getQueryString(), headers);
    }
    async getSummary(sha) {
        return this.restWrapper.get(`/git/summaries/${sha}`, this.getQueryString());
    }
    async getHeaderDirect(sha) {
        const tree = await this.getTree(sha, true);
        const includeBlobs = [".attributes", ".blobs", ".messages", "header"];
        const blobsP = [];
        for (const entry of tree.tree) {
            if (entry.type === "blob" && endsWith(entry.path, includeBlobs)) {
                const blobP = this.getBlob(entry.sha);
                blobsP.push(blobP);
            }
        }
        const blobs = await Promise.all(blobsP);
        return {
            blobs,
            tree,
        };
    }
    getQueryString(queryString) {
        if (this.cacheBust) {
            return Object.assign(Object.assign({ cacheBust: Date.now() }, this.defaultQueryString), queryString);
        }
        return Object.assign(Object.assign({}, this.defaultQueryString), queryString);
    }
}
//# sourceMappingURL=historian.js.map

/***/ }),
/* 401 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromBase64ToUtf8": () => (/* binding */ fromBase64ToUtf8),
/* harmony export */   "fromUtf8ToBase64": () => (/* binding */ fromUtf8ToBase64),
/* harmony export */   "toUtf8": () => (/* binding */ toUtf8)
/* harmony export */ });
/* harmony import */ var _indexNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(402);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

const fromBase64ToUtf8 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "base64").toString("utf-8");
const fromUtf8ToBase64 = (input) => _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, "utf8").toString("base64");
/**
 * Convenience function to convert unknown encoding to utf8 that avoids
 * buffer copies/encode ops when no conversion is needed
 * @param input - The source string to convert
 * @param encoding - The source string's encoding
 */
const toUtf8 = (input, encoding) => {
    switch (encoding) {
        case "utf8":
        case "utf-8":
            return input;
        default:
            return _indexNode__WEBPACK_IMPORTED_MODULE_0__.IsoBuffer.from(input, encoding).toString();
    }
};
//# sourceMappingURL=base64Encoding.js.map

/***/ }),
/* 402 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(403);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 403 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 404 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertSummaryToCreateNewSummary": () => (/* binding */ convertSummaryToCreateNewSummary)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(399);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(405);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Utility api to convert ISummaryTree to a summary tree where blob contents are only utf8 strings.
 * @param summary - Summary supplied by the runtime to upload.
 * @returns - Modified summary tree where the blob contents could be utf8 string only.
 */
function convertSummaryToCreateNewSummary(summary) {
    const keys = Object.keys(summary.tree);
    for (const key of keys) {
        const summaryObject = summary.tree[key];
        switch (summaryObject.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {
                summary.tree[key] = convertSummaryToCreateNewSummary(summaryObject);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {
                summaryObject.content = typeof summaryObject.content === "string" ?
                    summaryObject.content : (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayToString)(summaryObject.content, "utf8");
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {
                throw new Error("No handle should be present for first summary!!");
            }
            default: {
                throw new Error(`Unknown tree type ${summaryObject.type}`);
            }
        }
    }
    return summary;
}
//# sourceMappingURL=createNewUtils.js.map

/***/ }),
/* 405 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 406 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentService": () => (/* binding */ DocumentService)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(333);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(440);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(340);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(400);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(438);
/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(407);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(45);
/* harmony import */ var _deltaStorageService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(457);
/* harmony import */ var _documentStorageService__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(441);
/* harmony import */ var _documentDeltaConnection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(462);
/* harmony import */ var _nullBlobStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(437);
/* harmony import */ var _restWrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(341);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */











/**
 * Amount of time between discoveries within which we don't need to rediscover on re-connect.
 * Currently, R11s defines session length at 10 minutes. To avoid any weird unknown edge-cases though,
 * we set the limit to 5 minutes here.
 * In the future, we likely want to retrieve this information from service's "inactive session" definition.
 */
const RediscoverAfterTimeSinceDiscoveryMs = 5 * 60000; // 5 minute
/**
 * The DocumentService manages the Socket.IO connection and manages routing requests to connected
 * clients.
 */
class DocumentService {
    constructor(_resolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger, tokenProvider, tenantId, documentId, driverPolicies, blobCache, snapshotTreeCache, discoverFluidResolvedUrl) {
        this._resolvedUrl = _resolvedUrl;
        this.ordererUrl = ordererUrl;
        this.deltaStorageUrl = deltaStorageUrl;
        this.storageUrl = storageUrl;
        this.logger = logger;
        this.tokenProvider = tokenProvider;
        this.tenantId = tenantId;
        this.documentId = documentId;
        this.driverPolicies = driverPolicies;
        this.blobCache = blobCache;
        this.snapshotTreeCache = snapshotTreeCache;
        this.discoverFluidResolvedUrl = discoverFluidResolvedUrl;
        this.lastDiscoveredAt = Date.now();
    }
    get resolvedUrl() {
        return this._resolvedUrl;
    }
    dispose() { }
    /**
     * Connects to a storage endpoint for snapshot service.
     *
     * @returns returns the document storage service for routerlicious driver.
     */
    async connectToStorage() {
        if (this.documentStorageService !== undefined) {
            return this.documentStorageService;
        }
        if (this.storageUrl === undefined) {
            return new _nullBlobStorageService__WEBPACK_IMPORTED_MODULE_1__.NullBlobStorageService();
        }
        const getStorageManager = async (disableCache) => {
            const shouldUpdateDiscoveredSessionInfo = this.shouldUpdateDiscoveredSessionInfo();
            if (shouldUpdateDiscoveredSessionInfo) {
                await this.refreshDiscovery();
            }
            if (!this.storageManager || !this.noCacheStorageManager || shouldUpdateDiscoveredSessionInfo) {
                const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.RateLimiter(this.driverPolicies.maxConcurrentStorageRequests);
                const storageRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_3__.RouterliciousStorageRestWrapper.load(this.tenantId, this.documentId, this.tokenProvider, this.logger, rateLimiter, this.driverPolicies.enableRestLess, this.storageUrl);
                const historian = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.Historian(this.storageUrl, true, false, storageRestWrapper);
                this.storageManager = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_5__.GitManager(historian);
                const noCacheHistorian = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.Historian(this.storageUrl, true, true, storageRestWrapper);
                this.noCacheStorageManager = new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_5__.GitManager(noCacheHistorian);
            }
            return disableCache ? this.noCacheStorageManager : this.storageManager;
        };
        // Initialize storageManager and noCacheStorageManager
        const storageManager = await getStorageManager();
        const noCacheStorageManager = await getStorageManager(true);
        const documentStorageServicePolicies = {
            caching: this.driverPolicies.enablePrefetch
                ? _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__.LoaderCachingPolicy.Prefetch
                : _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_6__.LoaderCachingPolicy.NoCaching,
            minBlobSize: this.driverPolicies.aggregateBlobsSmallerThanBytes,
        };
        this.documentStorageService = new _documentStorageService__WEBPACK_IMPORTED_MODULE_7__.DocumentStorageService(this.documentId, storageManager, this.logger, documentStorageServicePolicies, this.driverPolicies, this.blobCache, this.snapshotTreeCache, noCacheStorageManager, getStorageManager);
        return this.documentStorageService;
    }
    /**
     * Connects to a delta storage endpoint for getting ops between a range.
     *
     * @returns returns the document delta storage service for routerlicious driver.
     */
    async connectToDeltaStorage() {
        await this.connectToStorage();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.assert)(!!this.documentStorageService, 0x0b1 /* "Storage service not initialized" */);
        const getRestWrapper = async () => {
            const shouldUpdateDiscoveredSessionInfo = this.shouldUpdateDiscoveredSessionInfo();
            if (shouldUpdateDiscoveredSessionInfo) {
                await this.refreshDiscovery();
            }
            if (!this.ordererRestWrapper || shouldUpdateDiscoveredSessionInfo) {
                const rateLimiter = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);
                this.ordererRestWrapper = await _restWrapper__WEBPACK_IMPORTED_MODULE_3__.RouterliciousOrdererRestWrapper.load(this.tenantId, this.documentId, this.tokenProvider, this.logger, rateLimiter, this.driverPolicies.enableRestLess);
            }
            return this.ordererRestWrapper;
        };
        const restWrapper = await getRestWrapper();
        const deltaStorageService = new _deltaStorageService__WEBPACK_IMPORTED_MODULE_9__.DeltaStorageService(this.deltaStorageUrl, restWrapper, this.logger, getRestWrapper, () => this.deltaStorageUrl);
        return new _deltaStorageService__WEBPACK_IMPORTED_MODULE_9__.DocumentDeltaStorageService(this.tenantId, this.documentId, deltaStorageService, this.documentStorageService);
    }
    /**
     * Connects to a delta stream endpoint for emitting ops.
     *
     * @returns returns the document delta stream service for routerlicious driver.
     */
    async connectToDeltaStream(client) {
        const connect = async (refreshToken) => {
            if (this.shouldUpdateDiscoveredSessionInfo()) {
                await this.refreshDiscovery();
            }
            const ordererToken = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.PerformanceEvent.timedExecAsync(this.logger, {
                eventName: "GetDeltaStreamToken",
                docId: this.documentId,
                details: JSON.stringify({
                    refreshToken,
                }),
            }, async () => {
                return this.tokenProvider.fetchOrdererToken(this.tenantId, this.documentId, refreshToken);
            });
            return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.PerformanceEvent.timedExecAsync(this.logger, {
                eventName: "ConnectToDeltaStream",
                docId: this.documentId,
            }, async () => {
                return _documentDeltaConnection__WEBPACK_IMPORTED_MODULE_11__.R11sDocumentDeltaConnection.create(this.tenantId, this.documentId, ordererToken.jwt, socket_io_client__WEBPACK_IMPORTED_MODULE_0__["default"], client, this.ordererUrl, this.logger);
            });
        };
        // Attempt to establish connection.
        // Retry with new token on authorization error; otherwise, allow container layer to handle.
        try {
            const connection = await connect();
            return connection;
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.statusCode) === 401) {
                // Fetch new token and retry once,
                // otherwise 401 will be bubbled up as non-retriable AuthorizationError.
                return connect(true /* refreshToken */);
            }
            throw error;
        }
    }
    /**
     * Re-discover session URLs if necessary.
     */
    async refreshDiscovery() {
        if (!this.discoverP) {
            this.discoverP = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.PerformanceEvent.timedExecAsync(this.logger, {
                eventName: "RefreshDiscovery",
            }, async () => this.refreshDiscoveryCore());
        }
        return this.discoverP;
    }
    async refreshDiscoveryCore() {
        const fluidResolvedUrl = await this.discoverFluidResolvedUrl();
        this._resolvedUrl = fluidResolvedUrl;
        this.storageUrl = fluidResolvedUrl.endpoints.storageUrl;
        this.ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;
        this.deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;
    }
    /**
     * Whether enough time has passed since last disconnect to warrant a new discovery call on reconnect.
     */
    shouldUpdateDiscoveredSessionInfo() {
        if (!this.driverPolicies.enableDiscovery) {
            return false;
        }
        const now = Date.now();
        // When connection is disconnected, we cannot know if session has moved or document has been deleted
        // without re-doing discovery on the next attempt to connect.
        // Disconnect event is not so reliable in local testing. To ensure re-discovery when necessary,
        // re-discover if enough time has passed since last discovery.
        const pastLastDiscoveryTimeThreshold = (now - this.lastDiscoveredAt) > RediscoverAfterTimeSinceDiscoveryMs;
        if (pastLastDiscoveryTimeThreshold) {
            // Reset discover promise and refresh discovery.
            this.lastDiscoveredAt = Date.now();
            this.discoverP = undefined;
            this.refreshDiscovery().catch(() => {
                // Undo discovery time set on failure, so that next check refreshes.
                this.lastDiscoveredAt = 0;
            });
        }
        return pastLastDiscoveryTimeThreshold;
    }
}
//# sourceMappingURL=documentService.js.map

/***/ }),
/* 407 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Manager": () => (/* reexport safe */ _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager),
/* harmony export */   "Socket": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket),
/* harmony export */   "connect": () => (/* binding */ lookup),
/* harmony export */   "default": () => (/* binding */ lookup),
/* harmony export */   "io": () => (/* binding */ lookup),
/* harmony export */   "protocol": () => (/* reexport safe */ socket_io_parser__WEBPACK_IMPORTED_MODULE_3__.protocol)
/* harmony export */ });
/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(408);
/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(430);
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(431);
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(432);



/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0,_url_js__WEBPACK_IMPORTED_MODULE_0__.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager,
    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */

/**
 * Expose constructors for standalone build.
 *
 * @public
 */



/***/ }),
/* 408 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "url": () => (/* binding */ url)
/* harmony export */ });
/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(409);

/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        obj = (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.parse)(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}


/***/ }),
/* 409 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Socket": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket),
/* harmony export */   "Transport": () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.Transport),
/* harmony export */   "TransportError": () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.TransportError),
/* harmony export */   "installTimerFunctions": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.installTimerFunctions),
/* harmony export */   "nextTick": () => (/* reexport safe */ _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__.nextTick),
/* harmony export */   "parse": () => (/* reexport safe */ _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__.parse),
/* harmony export */   "protocol": () => (/* binding */ protocol),
/* harmony export */   "transports": () => (/* reexport safe */ _transports_index_js__WEBPACK_IMPORTED_MODULE_2__.transports)
/* harmony export */ });
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(410);
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(413);
/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(411);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(420);
/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(429);
/* harmony import */ var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(427);


const protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket.protocol;







/***/ }),
/* 410 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Socket": () => (/* binding */ Socket)
/* harmony export */ });
/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(411);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(420);
/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(422);
/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(429);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(419);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(414);
/* harmony import */ var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(427);







class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts = {}) {
        super();
        this.binaryType = _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_6__.defaultBinaryType;
        this.writeBuffer = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            uri = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query)
                opts.query = uri.query;
        }
        else if (opts.host) {
            opts.hostname = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(opts.host).host;
        }
        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.installTimerFunctions)(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = opts.transports || [
            "polling",
            "websocket",
            "webtransport",
        ];
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024,
            },
            transportOptions: {},
            closeOnBeforeunload: false,
        }, opts);
        this.opts.path =
            this.opts.path.replace(/\/$/, "") +
                (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
            this.opts.query = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__.decode)(this.opts.query);
        }
        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        // set on heartbeat
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this.beforeunloadEventListener = () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this.beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                this.offlineEventListener = () => {
                    this.onClose("transport close", {
                        description: "network connection lost",
                    });
                };
                addEventListener("offline", this.offlineEventListener, false);
            }
        }
        this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port,
        }, this.opts.transportOptions[name]);
        return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__.transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    open() {
        let transport;
        if (this.opts.rememberUpgrade &&
            Socket.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1) {
            transport = "websocket";
        }
        else if (0 === this.transports.length) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        else {
            transport = this.transports[0];
        }
        this.readyState = "opening";
        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
            transport = this.createTransport(transport);
        }
        catch (e) {
            this.transports.shift();
            this.open();
            return;
        }
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
        if (this.transport) {
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this.onDrain.bind(this))
            .on("packet", this.onPacket.bind(this))
            .on("error", this.onError.bind(this))
            .on("close", (reason) => this.onClose("transport close", reason));
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    probe(name) {
        let transport = this.createTransport(name);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    Socket.priorWebsocketSuccess = "websocket" === transport.name;
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err) => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this.upgrades.indexOf("webtransport") !== -1 &&
            name !== "webtransport") {
            // favor WebTransport
            this.setTimeoutFn(() => {
                if (!failed) {
                    transport.open();
                }
            }, 200);
        }
        else {
            transport.open();
        }
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        // we check for `readyState` in case an `open`
        // listener already closed the socket
        if ("open" === this.readyState && this.opts.upgrade) {
            let i = 0;
            const l = this.upgrades.length;
            for (; i < l; i++) {
                this.probe(this.upgrades[i]);
            }
        }
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            this.resetPingTimeout();
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this.sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this.onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            const packets = this.getWritablePackets();
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this.prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    getWritablePackets() {
        const shouldCheckPayloadSize = this.maxPayload &&
            this.transport.name === "polling" &&
            this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for (let i = 0; i < this.writeBuffer.length; i++) {
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.byteLength)(data);
            }
            if (i > 0 && payloadSize > this.maxPayload) {
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options,
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
        const close = () => {
            this.onClose("forced close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    onError(err) {
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    onClose(reason, description) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            // clear timers
            this.clearTimeoutFn(this.pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
                removeEventListener("beforeunload", this.beforeunloadEventListener, false);
                removeEventListener("offline", this.offlineEventListener, false);
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this.prevBufferLen = 0;
        }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
Socket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;


/***/ }),
/* 411 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transports": () => (/* binding */ transports)
/* harmony export */ });
/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(412);
/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(426);
/* harmony import */ var _webtransport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(428);



const transports = {
    websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__.WS,
    webtransport: _webtransport_js__WEBPACK_IMPORTED_MODULE_2__.WT,
    polling: _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling,
};


/***/ }),
/* 412 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polling": () => (/* binding */ Polling),
/* harmony export */   "Request": () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);
/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(423);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(414);
/* harmony import */ var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(424);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(419);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(420);
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(421);







function empty() { }
const hasXHR2 = (function () {
    const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__.XHR({
        xdomain: false,
    });
    return null != xhr.responseType;
})();
class Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        this.polling = false;
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
        }
        /**
         * XHR supports binary
         */
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
        if (this.opts.withCredentials) {
            this.cookieJar = (0,_xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__.createCookieJar)();
        }
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            this.readyState = "paused";
            onPause();
        };
        if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
                total++;
                this.once("pollComplete", function () {
                    --total || pause();
                });
            }
            if (!this.writable) {
                total++;
                this.once("drain", function () {
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    poll() {
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this.polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this.poll();
            }
            else {
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.encodePayload)(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0,_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__.yeast)();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
        return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
class Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(uri, opts) {
        super();
        (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.data = undefined !== opts.data ? opts.data : null;
        this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    create() {
        var _a;
        const opts = (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        const xhr = (this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_3__.XHR(opts));
        try {
            xhr.open(this.method, this.uri, true);
            try {
                if (this.opts.extraHeaders) {
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this.opts.extraHeaders) {
                        if (this.opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this.method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
                xhr.timeout = this.opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);
                }
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this.onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            xhr.send(this.data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this.onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
            return;
        }
        this.xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this.xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this.index];
        }
        this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this.cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this.cleanup();
    }
}
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in _globalThis_js__WEBPACK_IMPORTED_MODULE_6__.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}


/***/ }),
/* 413 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transport": () => (/* binding */ Transport),
/* harmony export */   "TransportError": () => (/* binding */ TransportError)
/* harmony export */ });
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(414);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(419);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(420);
/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(422);




class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
class Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_0__.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
    createUri(schema, query = {}) {
        return (schema +
            "://" +
            this._hostname() +
            this._port() +
            this.opts.path +
            this._query(query));
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port &&
            ((this.opts.secure && Number(this.opts.port !== 443)) ||
                (!this.opts.secure && Number(this.opts.port) !== 80))) {
            return ":" + this.opts.port;
        }
        else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__.encode)(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}


/***/ }),
/* 414 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPacketDecoderStream": () => (/* binding */ createPacketDecoderStream),
/* harmony export */   "createPacketEncoderStream": () => (/* binding */ createPacketEncoderStream),
/* harmony export */   "decodePacket": () => (/* reexport safe */ _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket),
/* harmony export */   "decodePayload": () => (/* binding */ decodePayload),
/* harmony export */   "encodePacket": () => (/* reexport safe */ _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacket),
/* harmony export */   "encodePayload": () => (/* binding */ encodePayload),
/* harmony export */   "protocol": () => (/* binding */ protocol)
/* harmony export */ });
/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(415);
/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(417);
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(416);



const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacket)(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
function createPacketEncoderStream() {
    // @ts-expect-error
    return new TransformStream({
        transform(packet, controller) {
            (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacketToBinary)(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    // @ts-expect-error
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* READ_PAYLOAD */;
                }
                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(_commons_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(_commons_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
const protocol = 4;



/***/ }),
/* 415 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "encodePacket": () => (/* binding */ encodePacket),
/* harmony export */   "encodePacketToBinary": () => (/* binding */ encodePacketToBinary)
/* harmony export */ });
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(416);

const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
        return packet.data.arrayBuffer().then(toArray).then(callback);
    }
    else if (withNativeArrayBuffer &&
        (packet.data instanceof ArrayBuffer || isView(packet.data))) {
        return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
        if (!TEXT_ENCODER) {
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}



/***/ }),
/* 416 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERROR_PACKET": () => (/* binding */ ERROR_PACKET),
/* harmony export */   "PACKET_TYPES": () => (/* binding */ PACKET_TYPES),
/* harmony export */   "PACKET_TYPES_REVERSE": () => (/* binding */ PACKET_TYPES_REVERSE)
/* harmony export */ });
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };



/***/ }),
/* 417 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodePacket": () => (/* binding */ decodePacket)
/* harmony export */ });
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(416);
/* harmony import */ var _contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(418);


const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
        };
    }
    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return _commons_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type],
        };
};
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = (0,_contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__.decode)(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            if (data instanceof Blob) {
                // from WebSocket + binaryType "blob"
                return data;
            }
            else {
                // from HTTP long-polling or WebTransport
                return new Blob([data]);
            }
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) {
                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
    }
};


/***/ }),
/* 418 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};


/***/ }),
/* 419 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Emitter": () => (/* binding */ Emitter)
/* harmony export */ });
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 420 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "byteLength": () => (/* binding */ byteLength),
/* harmony export */   "installTimerFunctions": () => (/* binding */ installTimerFunctions),
/* harmony export */   "pick": () => (/* binding */ pick)
/* harmony export */ });
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(421);

function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);
    }
    else {
        obj.setTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);
        obj.clearTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}


/***/ }),
/* 421 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "globalThisShim": () => (/* binding */ globalThisShim)
/* harmony export */ });
const globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();


/***/ }),
/* 422 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
function encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}


/***/ }),
/* 423 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "yeast": () => (/* binding */ yeast)
/* harmony export */ });
// imported from https://github.com/unshiftio/yeast

const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};
let seed = 0, i = 0, prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
    let encoded = '';
    do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
}
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
    let decoded = 0;
    for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
    }
    return decoded;
}
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
    const now = encode(+new Date());
    if (now !== prev)
        return seed = 0, prev = now;
    return now + '.' + encode(seed++);
}
//
// Map each character to its index.
//
for (; i < length; i++)
    map[alphabet[i]] = i;


/***/ }),
/* 424 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XHR": () => (/* binding */ XHR),
/* harmony export */   "createCookieJar": () => (/* binding */ createCookieJar)
/* harmony export */ });
/* harmony import */ var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(425);
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(421);
// browser shim for xmlhttprequest module


function XHR(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__.hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}
function createCookieJar() { }


/***/ }),
/* 425 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasCORS": () => (/* binding */ hasCORS)
/* harmony export */ });
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
const hasCORS = value;


/***/ }),
/* 426 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WS": () => (/* binding */ WS)
/* harmony export */ });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);
/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(423);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(420);
/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(427);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(414);





// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {
    /**
     * WebSocket transport constructor.
     *
     * @param {Object} opts - connection options
     * @protected
     */
    constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
    }
    get name() {
        return "websocket";
    }
    doOpen() {
        if (!this.check()) {
            // let probe timeout
            return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws =
                _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.usingBrowserWebSocket && !isReactNative
                    ? protocols
                        ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket(uri, protocols)
                        : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket(uri)
                    : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_4__.encodePacket)(packet, this.supportsBinary, (data) => {
                // always create a new object (GH-437)
                const opts = {};
                if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.usingBrowserWebSocket) {
                    if (packet.options) {
                        opts.compress = packet.options.compress;
                    }
                    if (this.opts.perMessageDeflate) {
                        const len = 
                        // @ts-ignore
                        "string" === typeof data ? Buffer.byteLength(data) : data.length;
                        if (len < this.opts.perMessageDeflate.threshold) {
                            opts.compress = false;
                        }
                    }
                }
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.usingBrowserWebSocket) {
                        // TypeError is thrown when passing the second argument on Safari
                        this.ws.send(data);
                    }
                    else {
                        this.ws.send(data, opts);
                    }
                }
                catch (e) {
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0,_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0,_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__.yeast)();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */
    check() {
        return !!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_3__.WebSocket;
    }
}


/***/ }),
/* 427 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocket": () => (/* binding */ WebSocket),
/* harmony export */   "defaultBinaryType": () => (/* binding */ defaultBinaryType),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "usingBrowserWebSocket": () => (/* binding */ usingBrowserWebSocket)
/* harmony export */ });
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(421);

const nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
const WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";


/***/ }),
/* 428 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WT": () => (/* binding */ WT)
/* harmony export */ });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);
/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(427);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(414);



class WT extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
        // @ts-ignore
        if (typeof WebTransport !== "function") {
            return;
        }
        // @ts-ignore
        this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        this.transport.closed
            .then(() => {
            this.onClose();
        })
            .catch((err) => {
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this.transport.ready.then(() => {
            this.transport.createBidirectionalStream().then((stream) => {
                const decoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketEncoderStream)();
                encoderStream.readable.pipeTo(stream.writable);
                this.writer = encoderStream.writable.getWriter();
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            return;
                        }
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this.writer.write(packet).then(() => this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this.writer.write(packet).then(() => {
                if (lastPacket) {
                    (0,_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}


/***/ }),
/* 429 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parse": () => (/* binding */ parse)
/* harmony export */ });
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];
function parse(str) {
    if (str.length > 2000) {
        throw "URI too long";
    }
    const src = str, b = str.indexOf('['), e = str.indexOf(']');
    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    let m = re.exec(str || ''), uri = {}, i = 14;
    while (i--) {
        uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
}
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
        names.splice(names.length - 1, 1);
    }
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });
    return data;
}


/***/ }),
/* 430 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Manager": () => (/* binding */ Manager)
/* harmony export */ });
/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(409);
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(431);
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(432);
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(435);
/* harmony import */ var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(436);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(419);






class Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__.Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.installTimerFunctions)(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__.Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        const onError = (err) => {
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            // set timer
            const timer = this.setTimeoutFn(() => {
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, "ping", this.onping.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, "data", this.ondata.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, "error", this.onerror.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, "close", this.onclose.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
            this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason, description) {
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}


/***/ }),
/* 431 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Socket": () => (/* binding */ Socket)
/* harmony export */ });
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(432);
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(435);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(419);



/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, "open", this.onopen.bind(this)),
            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, "packet", this.onpacket.bind(this)),
            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, "error", this.onerror.bind(this)),
            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = this.io.engine &&
            this.io.engine.transport &&
            this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
        }
        else if (this.connected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    this.sendBuffer.splice(i, 1);
                }
            }
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            const fn = (arg1, arg2) => {
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT:
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK:
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        if (null != packet.id) {
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            self.packet({
                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            return;
        }
        delete this.acks[packet.id];
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}


/***/ }),
/* 432 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Decoder": () => (/* binding */ Decoder),
/* harmony export */   "Encoder": () => (/* binding */ Encoder),
/* harmony export */   "PacketType": () => (/* binding */ PacketType),
/* harmony export */   "protocol": () => (/* binding */ protocol)
/* harmony export */ });
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(419);
/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(433);
/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(434);



/**
 * These strings must not be used as event names, as they have a special meaning.
 */
const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener", // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
const protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.hasBinary)(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.isBinary)(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return (Array.isArray(payload) &&
                    (typeof payload[0] === "number" ||
                        (typeof payload[0] === "string" &&
                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.reconstructPacket)(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}


/***/ }),
/* 433 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deconstructPacket": () => (/* binding */ deconstructPacket),
/* harmony export */   "reconstructPacket": () => (/* binding */ reconstructPacket)
/* harmony export */ });
/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(434);

/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_0__.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}


/***/ }),
/* 434 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasBinary": () => (/* binding */ hasBinary),
/* harmony export */   "isBinary": () => (/* binding */ isBinary)
/* harmony export */ });
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}


/***/ }),
/* 435 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "on": () => (/* binding */ on)
/* harmony export */ });
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}


/***/ }),
/* 436 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Backoff": () => (/* binding */ Backoff)
/* harmony export */ });
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};


/***/ }),
/* 437 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullBlobStorageService": () => (/* binding */ NullBlobStorageService)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Document access to underlying storage. It is default implementation of a storage service.
 * Does not read/write anything.
 */
class NullBlobStorageService {
    get repositoryUrl() {
        throw new Error("Invalid operation");
    }
    async getSnapshotTree(version) {
        return version ? Promise.reject(new Error("Invalid operation")) : null;
    }
    async getVersions(versionId, count) {
        return [];
    }
    async uploadSummaryWithContext(summary, context) {
        return Promise.reject(new Error("Invalid operation"));
    }
    async downloadSummary(handle) {
        return Promise.reject(new Error("Invalid operation"));
    }
    async createBlob(file) {
        return Promise.reject(new Error("Null blob storage can not create blob"));
    }
    async readBlob(blobId) {
        return Promise.reject(new Error("Null blob storage can not read blob"));
    }
}
//# sourceMappingURL=nullBlobStorageService.js.map

/***/ }),
/* 438 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GitManager": () => (/* binding */ GitManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(403);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(439);
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(388);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




class GitManager {
    constructor(historian) {
        this.historian = historian;
        this.blobCache = new Map();
        this.commitCache = new Map();
        this.treeCache = new Map();
        this.refCache = new Map();
    }
    async getHeader(id, sha) {
        const header = await this.historian.getHeader(sha);
        // Cache blobs that were sent in the header
        for (const blob of header.blobs) {
            this.blobCache.set(blob.sha, blob);
        }
        return (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.buildHierarchy)(header.tree);
    }
    async getFullTree(sha) {
        return this.historian.getFullTree(sha);
    }
    async getCommit(sha) {
        if (this.commitCache.has(sha)) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Cache hit on ${sha}`);
            return this.commitCache.get(sha);
        }
        return this.historian.getCommit(sha);
    }
    /**
     * Reads the object with the given ID. We defer to the client implementation to do the actual read.
     */
    async getCommits(shaOrRef, count) {
        let sha = shaOrRef;
        // See if the sha is really a ref and convert
        if (this.refCache.has(shaOrRef)) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Commit cache hit on ${shaOrRef}`);
            sha = this.refCache.get(shaOrRef);
            // Delete refcache after first use
            this.refCache.delete(shaOrRef);
            // If null is stored for the ref then there are no commits - return an empty array
            if (!sha) {
                return [];
            }
        }
        // See if the commit sha is hashed and return it if so
        if (this.commitCache.has(sha)) {
            const commit = this.commitCache.get(sha);
            return [{
                    commit: {
                        author: commit.author,
                        committer: commit.committer,
                        message: commit.message,
                        tree: commit.tree,
                        url: commit.url,
                    },
                    parents: commit.parents,
                    sha: commit.sha,
                    url: commit.url,
                }];
        }
        // Otherwise fall back to the historian
        return this.historian.getCommits(sha, count);
    }
    /**
     * Reads the object with the given ID. We defer to the client implementation to do the actual read.
     */
    async getTree(root, recursive = true) {
        if (this.treeCache.has(root)) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Tree cache hit on ${root}`);
            return this.treeCache.get(root);
        }
        return this.historian.getTree(root, recursive);
    }
    async getBlob(sha) {
        if (this.blobCache.has(sha)) {
            (0,_debug__WEBPACK_IMPORTED_MODULE_1__.debug)(`Blob cache hit on ${sha}`);
            return this.blobCache.get(sha);
        }
        return this.historian.getBlob(sha);
    }
    getRawUrl(sha) {
        return `${this.historian.endpoint}/git/blobs/raw/${sha}`;
    }
    /**
     * Retrieves the object at the given revision number
     */
    async getContent(commit, path) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.historian.getContent(path, commit);
    }
    async createBlob(content, encoding) {
        const blob = {
            content,
            encoding,
        };
        return this.historian.createBlob(blob);
    }
    async createGitTree(params) {
        const treeP = this.historian.createTree(params);
        return treeP;
    }
    async createTree(files) {
        return this.createTreeCore(files, 0);
    }
    async createCommit(commit) {
        return this.historian.createCommit(commit);
    }
    async createSummary(summary) {
        return this.historian.createSummary(summary);
    }
    async deleteSummary(softDelete) {
        return this.historian.deleteSummary(softDelete);
    }
    async getSummary(sha) {
        return this.historian.getSummary(sha);
    }
    async getRef(ref) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.historian
            .getRef(`heads/${ref}`)
            .catch((error) => {
            if (error === 400 || error === 404) {
                return null;
            }
            else {
                throw error;
            }
        });
    }
    async createRef(branch, sha) {
        const createRefParams = {
            ref: `refs/heads/${branch}`,
            sha,
            config: { enabled: true },
        };
        return this.historian.createRef(createRefParams);
    }
    async upsertRef(branch, commitSha) {
        // Update (force) the ref to the new commit
        const ref = {
            force: true,
            sha: commitSha,
            config: { enabled: true },
        };
        return this.historian.updateRef(`heads/${branch}`, ref);
    }
    addRef(ref, sha) {
        this.refCache.set(ref, sha);
    }
    addCommit(commit) {
        this.commitCache.set(commit.sha, commit);
    }
    addTree(tree) {
        this.treeCache.set(tree.sha, tree);
    }
    addBlob(blob) {
        this.blobCache.set(blob.sha, blob);
    }
    /**
     * Writes to the object with the given ID
     */
    async write(branch, inputTree, parents, message) {
        const tree = await this.createTree(inputTree);
        // Construct a commit for the tree
        const commitParams = {
            author: {
                date: new Date().toISOString(),
                email: "kurtb@microsoft.com",
                name: "Kurt Berglund",
            },
            message,
            parents,
            tree: tree.sha,
        };
        const commit = await this.historian.createCommit(commitParams);
        // Create or update depending on if ref exists.
        // TODO optimize the update to know up front if the ref exists
        const existingRef = await this.getRef(branch);
        if (existingRef) {
            await this.upsertRef(branch, commit.sha);
        }
        else {
            await this.createRef(branch, commit.sha);
        }
        return commit;
    }
    async createTreeCore(files, depth) {
        // If a id is specified use it rather than creating new
        if (files.id) {
            return this.getTree(files.id);
        }
        // Kick off the work to create all the tree values
        const entriesP = [];
        for (const entry of files.entries) {
            switch (_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry[entry.type]) {
                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Blob: {
                    const entryAsBlob = entry.value;
                    // Symlinks currently directly references a folder off the root of the tree. We adjust
                    // the path based on the depth of the tree
                    if (entry.mode === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.FileMode.Symlink) {
                        entryAsBlob.contents = this.translateSymlink(entryAsBlob.contents, depth);
                    }
                    const blobP = this.createBlob(entryAsBlob.contents, entryAsBlob.encoding);
                    entriesP.push(blobP);
                    break;
                }
                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Tree: {
                    const entryAsTree = entry.value;
                    const treeBlobP = this.createTreeCore(entryAsTree, depth + 1);
                    entriesP.push(treeBlobP);
                    break;
                }
                default:
                    throw new Error("Unknown entry type");
            }
        }
        // Wait for them all to resolve
        const entries = await Promise.all(entriesP);
        const tree = [];
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(entries.length === files.entries.length, "File entries length is not correct");
        // Construct a new tree from the collection of hashes
        for (let i = 0; i < files.entries.length; i++) {
            const type = files.entries[i].type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Tree
                ? "tree"
                : (files.entries[i].type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_2__.TreeEntry.Blob ? "blob" : "commit");
            tree.push({
                mode: files.entries[i].mode,
                path: files.entries[i].path,
                sha: entries[i].sha,
                type,
            });
        }
        const requestBody = {
            tree,
        };
        const treeP = this.historian.createTree(requestBody);
        return treeP;
    }
    translateSymlink(link, depth) {
        let prefix = "";
        for (let i = 0; i <= depth; i++) {
            prefix += "../";
        }
        return `${prefix}${link}`;
    }
}
//# sourceMappingURL=gitManager.js.map

/***/ }),
/* 439 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileMode": () => (/* binding */ FileMode),
/* harmony export */   "TreeEntry": () => (/* binding */ TreeEntry)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Symlink"] = "120000";
})(FileMode || (FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry["Blob"] = "Blob";
    TreeEntry["Tree"] = "Tree";
    TreeEntry["Attachment"] = "Attachment";
})(TreeEntry || (TreeEntry = {}));
//# sourceMappingURL=storage.js.map

/***/ }),
/* 440 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoaderCachingPolicy": () => (/* binding */ LoaderCachingPolicy)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var LoaderCachingPolicy;
(function (LoaderCachingPolicy) {
    /**
     * The loader should not implement any prefetching or caching policy.
     */
    LoaderCachingPolicy[LoaderCachingPolicy["NoCaching"] = 0] = "NoCaching";
    /**
     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.
     */
    LoaderCachingPolicy[LoaderCachingPolicy["Prefetch"] = 1] = "Prefetch";
})(LoaderCachingPolicy || (LoaderCachingPolicy = {}));
//# sourceMappingURL=storage.js.map

/***/ }),
/* 441 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentStorageService": () => (/* binding */ DocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(440);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(456);
/* harmony import */ var _wholeSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(442);
/* harmony import */ var _shreddedSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(448);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




class DocumentStorageService extends _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {
    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) {
        super(DocumentStorageService.loadInternalDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager));
        this.id = id;
        this.manager = manager;
        this.noCacheGitManager = noCacheGitManager;
        this._logTailSha = undefined;
    }
    get logTailSha() {
        return this._logTailSha;
    }
    static loadInternalDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) {
        const storageService = (driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableWholeSummaryUpload) ?
            new _wholeSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_1__.WholeSummaryDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) :
            new _shreddedSummaryDocumentStorageService__WEBPACK_IMPORTED_MODULE_2__.ShreddedSummaryDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, getStorageManager);
        // TODO: worth prefetching latest summary making version + snapshot call with WholeSummary storage?
        if (!(driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableWholeSummaryUpload) && policies.caching === _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_3__.LoaderCachingPolicy.Prefetch) {
            return new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.PrefetchDocumentStorageService(storageService);
        }
        return storageService;
    }
    async getSnapshotTree(version) {
        const tree = await this.internalStorageService.getSnapshotTree(version);
        if (tree !== null) {
            this._logTailSha = ".logTail" in tree.trees ? tree.trees[".logTail"].blobs.logTail : undefined;
        }
        return tree;
    }
}
//# sourceMappingURL=documentStorageService.js.map

/***/ }),
/* 442 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WholeSummaryDocumentStorageService": () => (/* binding */ WholeSummaryDocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(399);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(333);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(447);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(443);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(444);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





const latestSnapshotId = "latest";
class WholeSummaryDocumentStorageService {
    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache(), snapshotTreeCache = new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache(), noCacheGitManager, getStorageManager = async (disableCache) => disableCache && this.noCacheGitManager !== undefined ? this.noCacheGitManager : this.manager) {
        this.id = id;
        this.manager = manager;
        this.logger = logger;
        this.policies = policies;
        this.driverPolicies = driverPolicies;
        this.blobCache = blobCache;
        this.snapshotTreeCache = snapshotTreeCache;
        this.noCacheGitManager = noCacheGitManager;
        this.getStorageManager = getStorageManager;
        this.firstVersionsCall = true;
    }
    get repositoryUrl() {
        return "";
    }
    async getSummaryUploadManager() {
        const manager = await this.getStorageManager();
        return new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__.WholeSummaryUploadManager(manager);
    }
    async getVersions(versionId, count) {
        var _a;
        if (versionId !== this.id && versionId !== null) {
            // Blobs/Trees in this scenario will never have multiple versions, so return versionId as is
            return [{
                    id: versionId,
                    treeId: undefined,
                }];
        }
        // If this is the first versions call for the document, we know we will want the latest summary.
        // Fetch latest summary, cache it, and return its id.
        if (this.firstVersionsCall && count === 1) {
            this.firstVersionsCall = false;
            const { id: _id, snapshotTree } = !((_a = this.driverPolicies) === null || _a === void 0 ? void 0 : _a.enableDiscovery) ?
                await this.fetchAndCacheSnapshotTree(latestSnapshotId, false) :
                await this.fetchAndCacheSnapshotTree(latestSnapshotId, true);
            return [{
                    id: _id,
                    treeId: snapshotTree.id,
                }];
        }
        // Otherwise, get the latest version of the document as normal.
        const id = versionId ? versionId : this.id;
        const commits = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getVersions",
            versionId: id,
            count,
        }, async () => {
            const manager = await this.getStorageManager();
            return manager.getCommits(id, count);
        });
        return commits.map((commit) => ({
            date: commit.commit.author.date,
            id: commit.sha,
            treeId: commit.commit.tree.sha,
        }));
    }
    async getSnapshotTree(version) {
        let requestVersion = version;
        if (!requestVersion) {
            const versions = await this.getVersions(this.id, 1);
            if (versions.length === 0) {
                return null;
            }
            requestVersion = versions[0];
        }
        return (await this.fetchAndCacheSnapshotTree(requestVersion.id)).snapshotTree;
    }
    async readBlob(blobId) {
        const cachedBlob = await this.blobCache.get(this.getCacheKey(blobId));
        if (cachedBlob !== undefined) {
            return cachedBlob;
        }
        const blob = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "readBlob",
            blobId,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.getBlob(blobId);
            event.end({
                size: response.size,
            });
            return response;
        });
        const bufferValue = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.stringToBuffer)(blob.content, blob.encoding);
        await this.blobCache.put(this.getCacheKey(blob.sha), bufferValue);
        return bufferValue;
    }
    async uploadSummaryWithContext(summary, context) {
        const summaryHandle = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "uploadSummaryWithContext",
        }, async () => {
            var _a;
            const summaryUploadManager = await this.getSummaryUploadManager();
            return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : "", "channel");
        });
        return summaryHandle;
    }
    async downloadSummary(summaryHandle) {
        const wholeFlatSummary = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getWholeFlatSummary",
            treeId: summaryHandle.handle,
        }, async (event) => {
            var _a;
            const manager = await this.getStorageManager();
            const response = await manager.getSummary(summaryHandle.handle);
            event.end({
                size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length,
            });
            return response;
        });
        const { blobs, snapshotTree } = (0,_fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.convertWholeFlatSummaryToSnapshotTreeAndBlobs)(wholeFlatSummary, "");
        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_5__.convertSnapshotAndBlobsToSummaryTree)(snapshotTree, blobs);
    }
    async createBlob(file) {
        const uint8ArrayFile = new Uint8Array(file);
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "createBlob",
            size: uint8ArrayFile.length,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.createBlob((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Uint8ArrayToString)(uint8ArrayFile, "base64"), "base64").then((r) => ({ id: r.sha, url: r.url }));
            event.end({
                blobId: response.id,
            });
            return response;
        });
    }
    async fetchAndCacheSnapshotTree(versionId, disableCache) {
        const cachedSnapshotTreeVersion = await this.snapshotTreeCache.get(this.getCacheKey(versionId));
        if (cachedSnapshotTreeVersion !== undefined) {
            return { id: cachedSnapshotTreeVersion.id, snapshotTree: cachedSnapshotTreeVersion.snapshotTree };
        }
        const wholeFlatSummary = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getWholeFlatSummary",
            treeId: versionId,
        }, async (event) => {
            var _a;
            const manager = await this.getStorageManager(disableCache);
            const response = await manager.getSummary(versionId);
            event.end({
                size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length,
            });
            return response;
        });
        const normalizedWholeSummary = (0,_fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_4__.convertWholeFlatSummaryToSnapshotTreeAndBlobs)(wholeFlatSummary);
        const wholeFlatSummaryId = wholeFlatSummary.id;
        const snapshotTreeId = normalizedWholeSummary.snapshotTree.id;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.assert)(snapshotTreeId !== undefined, 0x275 /* "Root tree should contain the id" */);
        const snapshotTreeVersion = { id: wholeFlatSummaryId, snapshotTree: normalizedWholeSummary.snapshotTree };
        const cachePs = [
            this.snapshotTreeCache.put(this.getCacheKey(snapshotTreeId), snapshotTreeVersion),
            this.initBlobCache(normalizedWholeSummary.blobs),
        ];
        if (snapshotTreeId !== versionId) {
            // versionId could be "latest". When summarizer checks cache for "latest", we want it to be available.
            // TODO: For in-memory cache, <latest,snapshotTree> will be a shared pointer with <snapshotId,snapshotTree>,
            // However, for something like Redis, this will cache the same value twice. Alternatively, could we simply
            // cache with versionId?
            cachePs.push(this.snapshotTreeCache.put(this.getCacheKey(versionId), snapshotTreeVersion));
        }
        await Promise.all(cachePs);
        return snapshotTreeVersion;
    }
    async initBlobCache(blobs) {
        const blobCachePutPs = [];
        blobs.forEach((value, id) => {
            const cacheKey = this.getCacheKey(id);
            blobCachePutPs.push(this.blobCache.put(cacheKey, value));
        });
        await Promise.all(blobCachePutPs);
    }
    getCacheKey(blobId) {
        return `${this.id}:${blobId}`;
    }
}
//# sourceMappingURL=wholeSummaryDocumentStorageService.js.map

/***/ }),
/* 443 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WholeSummaryUploadManager": () => (/* binding */ WholeSummaryUploadManager)
/* harmony export */ });
/* harmony import */ var _storageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(444);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Converts summary to snapshot tree and uploads with single snaphot tree payload.
 */
class WholeSummaryUploadManager {
    constructor(manager) {
        this.manager = manager;
    }
    async writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {
        const id = await this.writeSummaryTreeCore(parentHandle, summaryTree, summaryType, sequenceNumber !== null && sequenceNumber !== void 0 ? sequenceNumber : 0);
        if (!id) {
            throw new Error(`Failed to write summary tree`);
        }
        return id;
    }
    async writeSummaryTreeCore(parentHandle, tree, type, sequenceNumber) {
        const snapshotTree = (0,_storageUtils__WEBPACK_IMPORTED_MODULE_0__.convertSummaryTreeToWholeSummaryTree)(parentHandle, tree, "", type === "channel" ? ".app" : "");
        const snapshotPayload = {
            entries: snapshotTree.entries,
            message: undefined,
            sequenceNumber,
            type,
        };
        return this.manager.createSummary(snapshotPayload).then((response) => response.id);
    }
}
//# sourceMappingURL=wholeSummaryUploadManager.js.map

/***/ }),
/* 444 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildTreePath": () => (/* binding */ buildTreePath),
/* harmony export */   "convertSummaryTreeToWholeSummaryTree": () => (/* binding */ convertSummaryTreeToWholeSummaryTree),
/* harmony export */   "convertWholeFlatSummaryToSnapshotTreeAndBlobs": () => (/* binding */ convertWholeFlatSummaryToSnapshotTreeAndBlobs)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(402);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(446);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(403);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(445);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Convert a list of nodes to a tree path.
 * If a node is empty (blank) it will be removed.
 * If a node's name begins and/or ends with a "/", it will be removed.
 * @param nodeNames - node names in path
 */
const buildTreePath = (...nodeNames) => nodeNames
    .map((nodeName) => nodeName.replace(/^\//, "").replace(/\/$/, ""))
    .filter((nodeName) => !!nodeName)
    .join("/");
/**
 * Converts the summary tree to a whole summary tree to be uploaded. Always upload full whole summary tree.
 * @param parentHandle - Handle of the last uploaded summary or detach new summary.
 * @param tree - Summary Tree which will be converted to whole summary tree to be uploaded.
 * @param path - Current path of node which is getting evaluated.
 */
function convertSummaryTreeToWholeSummaryTree(parentHandle, tree, path = "", rootNodeName = "") {
    const wholeSummaryTree = {
        type: "tree",
        entries: [],
    };
    const keys = Object.keys(tree.tree);
    for (const key of keys) {
        const summaryObject = tree.tree[key];
        let id;
        let value;
        let unreferenced;
        const currentPath = path === ""
            ? buildTreePath(rootNodeName, key)
            : buildTreePath(path, key);
        switch (summaryObject.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree: {
                const result = convertSummaryTreeToWholeSummaryTree(parentHandle, summaryObject, currentPath, rootNodeName);
                value = result;
                unreferenced = summaryObject.unreferenced || undefined;
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob: {
                if (typeof summaryObject.content === "string") {
                    value = {
                        type: "blob",
                        content: summaryObject.content,
                        encoding: "utf-8",
                    };
                }
                else {
                    value = {
                        type: "blob",
                        content: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayToString)(summaryObject.content, "base64"),
                        encoding: "base64",
                    };
                }
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle: {
                const handleValue = summaryObject;
                if (handleValue.embedded) {
                    id = summaryObject.handle;
                }
                else {
                    if (!parentHandle) {
                        throw Error("Parent summary does not exist to reference by handle.");
                    }
                    id = buildTreePath(parentHandle, rootNodeName, summaryObject.handle);
                }
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment: {
                id = summaryObject.id;
                break;
            }
            default: {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(summaryObject, `Unknown type: ${summaryObject.type}`);
            }
        }
        const baseEntry = {
            path: encodeURIComponent(key),
            type: (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_3__.getGitType)(summaryObject),
        };
        let entry;
        if (value) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.assert)(id === undefined, 0x0ad /* "Snapshot entry has both a tree value and a referenced id!" */);
            entry = Object.assign({ value,
                unreferenced }, baseEntry);
        }
        else if (id) {
            entry = Object.assign(Object.assign({}, baseEntry), { id });
        }
        else {
            throw new Error(`Invalid tree entry for ${summaryObject.type}`);
        }
        wholeSummaryTree.entries.push(entry);
    }
    return wholeSummaryTree;
}
/**
 * Build a tree heirarchy from a flat tree.
 *
 * @param flatTree - a flat tree
 * @param treePrefixToRemove - tree prefix to strip
 * @returns the heirarchical tree
 */
function buildHierarchy(flatTree, treePrefixToRemove) {
    const lookup = {};
    // Root tree id will be used to determine which version was downloaded.
    const root = { id: flatTree.id, blobs: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.entries) {
        // Strip the `treePrefixToRemove` path from tree entries such that they are stored under root.
        const entryPath = entry.path.replace(new RegExp(`^${treePrefixToRemove}/`), "");
        const lastIndex = entryPath.lastIndexOf("/");
        const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entryPath.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { blobs: {}, trees: {}, unreferenced: entry.unreferenced };
            node.trees[decodeURIComponent(entryPathBase)] = newTree;
            lookup[entryPath] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[decodeURIComponent(entryPathBase)] = entry.id;
        }
        else {
            throw new Error(`Unknown entry type!!`);
        }
    }
    return root;
}
/**
 * Converts existing IWholeFlatSummary to snapshot tree, blob array, and sequence number.
 *
 * @param flatSummary - flat summary
 * @param treePrefixToRemove - tree prefix to strip. By default we are stripping ".app" prefix
 * @returns snapshot tree, blob array, and sequence number
 */
function convertWholeFlatSummaryToSnapshotTreeAndBlobs(flatSummary, treePrefixToRemove = ".app") {
    var _a;
    const blobs = new Map();
    if (flatSummary.blobs) {
        flatSummary.blobs.forEach((blob) => {
            var _a;
            blobs.set(blob.id, (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.stringToBuffer)(blob.content, (_a = blob.encoding) !== null && _a !== void 0 ? _a : "utf-8"));
        });
    }
    const flatSummaryTree = (_a = flatSummary.trees) === null || _a === void 0 ? void 0 : _a[0];
    const sequenceNumber = flatSummaryTree === null || flatSummaryTree === void 0 ? void 0 : flatSummaryTree.sequenceNumber;
    const snapshotTree = buildHierarchy(flatSummaryTree, treePrefixToRemove);
    return {
        blobs,
        snapshotTree,
        sequenceNumber,
    };
}
//# sourceMappingURL=storageUtils.js.map

/***/ }),
/* 445 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 446 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 447 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryTreeAssembler": () => (/* binding */ SummaryTreeAssembler),
/* harmony export */   "convertSnapshotAndBlobsToSummaryTree": () => (/* binding */ convertSnapshotAndBlobsToSummaryTree)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Summary tree assembler (without stats collection).
 */
class SummaryTreeAssembler {
    constructor(props) {
        this.props = props;
        this.attachmentCounter = 0;
        this.summaryTree = {};
    }
    /**
    * Get final summary
    */
    get summary() {
        var _a;
        return {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Tree,
            tree: Object.assign({}, this.summaryTree),
            unreferenced: (_a = this.props) === null || _a === void 0 ? void 0 : _a.unreferenced,
        };
    }
    /**
    * Add blob to summary
    */
    addBlob(key, content) {
        this.summaryTree[key] = {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Blob,
            content,
        };
    }
    /**
    * Add handle to summary
    */
    addHandle(key, handleType, handle) {
        this.summaryTree[key] = {
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Handle,
            handleType,
            handle,
        };
    }
    /**
    * Add tree to summary
    */
    addTree(key, summary) {
        this.summaryTree[key] = summary;
    }
    /**
    * Add attachment to summary
    */
    addAttachment(id) {
        this.summaryTree[this.attachmentCounter++] = { id, type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.SummaryType.Attachment };
    }
}
/**
 * Helper function that converts ISnapshotTree and blobs to ISummaryTree
 * @param snapshot - Source snapshot tree
 * @param blobs - Blobs cache
 * @returns Converted snapshot in ISummaryTree format
 */
function convertSnapshotAndBlobsToSummaryTree(snapshot, blobs) {
    const assembler = new SummaryTreeAssembler({
        unreferenced: snapshot.unreferenced,
    });
    for (const [path, id] of Object.entries(snapshot.blobs)) {
        const blob = blobs.get(id);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(blob !== undefined, 0x2dd /* "Cannot find blob for a given id" */);
        assembler.addBlob(path, _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.IsoBuffer.from(blob).toString("utf-8"));
    }
    for (const [key, tree] of Object.entries(snapshot.trees)) {
        const subtree = convertSnapshotAndBlobsToSummaryTree(tree, blobs);
        assembler.addTree(key, subtree);
    }
    return assembler.summary;
}
//# sourceMappingURL=treeUtils.js.map

/***/ }),
/* 448 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShreddedSummaryDocumentStorageService": () => (/* binding */ ShreddedSummaryDocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(399);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);
/* harmony import */ var _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(449);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/* harmony import */ var _retriableGitManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(451);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */






const isNode = typeof window === "undefined";
/**
 * Document access to underlying storage for routerlicious driver.
 * Uploads summaries piece-by-piece traversing the tree recursively.
 * Downloads summaries piece-by-piece on-demand, or up-front when prefetch is enabled.
 */
class ShreddedSummaryDocumentStorageService {
    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, getStorageManager = async () => this.manager) {
        this.id = id;
        this.manager = manager;
        this.logger = logger;
        this.policies = policies;
        this.getStorageManager = getStorageManager;
        // The values of this cache is useless. We only need the keys. So we are always putting
        // empty strings as values.
        this.blobsShaCache = new Map();
        if ((driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableRestLess) === true || isNode) {
            this.blobCache = blobCache !== null && blobCache !== void 0 ? blobCache : new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();
            this.snapshotTreeCache = snapshotTreeCache !== null && snapshotTreeCache !== void 0 ? snapshotTreeCache : new _cache__WEBPACK_IMPORTED_MODULE_0__.InMemoryCache();
        }
    }
    get repositoryUrl() {
        return "";
    }
    async getSummaryUploadManager() {
        const manager = await this.getStorageManager();
        return new _fluidframework_server_services_client__WEBPACK_IMPORTED_MODULE_1__.SummaryTreeUploadManager(new _retriableGitManager__WEBPACK_IMPORTED_MODULE_2__.RetriableGitManager(manager, this.logger), this.blobsShaCache, this.getPreviousFullSnapshot.bind(this));
    }
    async getVersions(versionId, count) {
        const id = versionId ? versionId : this.id;
        const commits = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getVersions",
            versionId: id,
            count,
        }, async () => {
            const manager = await this.getStorageManager();
            return manager.getCommits(id, count);
        });
        return commits.map((commit) => ({
            date: commit.commit.author.date,
            id: commit.sha,
            treeId: commit.commit.tree.sha,
        }));
    }
    async getSnapshotTree(version) {
        var _a, _b;
        let requestVersion = version;
        if (!requestVersion) {
            const versions = await this.getVersions(this.id, 1);
            if (versions.length === 0) {
                return null;
            }
            requestVersion = versions[0];
        }
        const cachedSnapshotTree = await ((_a = this.snapshotTreeCache) === null || _a === void 0 ? void 0 : _a.get(this.getCacheKey(requestVersion.treeId)));
        if (cachedSnapshotTree) {
            return cachedSnapshotTree.snapshotTree;
        }
        const rawTree = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getSnapshotTree",
            treeId: requestVersion.treeId,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.getTree(requestVersion.treeId);
            event.end({
                size: response.tree.length,
            });
            return response;
        });
        const tree = (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_4__.buildHierarchy)(rawTree, this.blobsShaCache, true);
        await ((_b = this.snapshotTreeCache) === null || _b === void 0 ? void 0 : _b.put(this.getCacheKey(tree.id), { id: requestVersion.id, snapshotTree: tree }));
        return tree;
    }
    async readBlob(blobId) {
        var _a, _b;
        const cachedBlob = await ((_a = this.blobCache) === null || _a === void 0 ? void 0 : _a.get(this.getCacheKey(blobId)));
        if (cachedBlob) {
            return cachedBlob;
        }
        const value = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "readBlob",
            blobId,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.getBlob(blobId);
            event.end({
                size: response.size,
            });
            return response;
        });
        this.blobsShaCache.set(value.sha, "");
        const bufferContent = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.stringToBuffer)(value.content, value.encoding);
        await ((_b = this.blobCache) === null || _b === void 0 ? void 0 : _b.put(this.getCacheKey(value.sha), bufferContent));
        return bufferContent;
    }
    async uploadSummaryWithContext(summary, context) {
        const summaryHandle = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "uploadSummaryWithContext",
        }, async () => {
            var _a;
            const summaryUploadManager = await this.getSummaryUploadManager();
            return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : "", "channel");
        });
        return summaryHandle;
    }
    async downloadSummary(handle) {
        throw new Error("NOT IMPLEMENTED!");
    }
    async createBlob(file) {
        const uint8ArrayFile = new Uint8Array(file);
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "createBlob",
            size: uint8ArrayFile.length,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.createBlob((0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.Uint8ArrayToString)(uint8ArrayFile, "base64"), "base64").then((r) => ({ id: r.sha, url: r.url }));
            event.end({
                blobId: response.id,
            });
            return response;
        });
    }
    async getPreviousFullSnapshot(parentHandle) {
        return parentHandle
            ? this.getVersions(parentHandle, 1)
                .then(async (versions) => {
                // Clear the cache as the getSnapshotTree call will fill the cache.
                this.blobsShaCache.clear();
                return this.getSnapshotTree(versions[0]);
            })
            : undefined;
    }
    getCacheKey(blobId) {
        return `${this.id}:${blobId}`;
    }
}
//# sourceMappingURL=shreddedSummaryDocumentStorageService.js.map

/***/ }),
/* 449 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryTreeUploadManager": () => (/* binding */ SummaryTreeUploadManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(446);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(402);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(450);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(403);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(445);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Recursively writes summary tree as individual summary blobs.
 */
class SummaryTreeUploadManager {
    constructor(manager, blobsShaCache, getPreviousFullSnapshot) {
        this.manager = manager;
        this.blobsShaCache = blobsShaCache;
        this.getPreviousFullSnapshot = getPreviousFullSnapshot;
    }
    async writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {
        const previousFullSnapshot = await this.getPreviousFullSnapshot(parentHandle);
        return this.writeSummaryTreeCore(summaryTree, previousFullSnapshot !== null && previousFullSnapshot !== void 0 ? previousFullSnapshot : undefined);
    }
    async writeSummaryTreeCore(summaryTree, previousFullSnapshot) {
        const entries = await Promise.all(Object.keys(summaryTree.tree).map(async (key) => {
            const entry = summaryTree.tree[key];
            const pathHandle = await this.writeSummaryTreeObject(entry, previousFullSnapshot);
            const treeEntry = {
                mode: (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.getGitMode)(entry),
                path: encodeURIComponent(key),
                sha: pathHandle,
                type: (0,_fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_0__.getGitType)(entry),
            };
            return treeEntry;
        }));
        const treeHandle = await this.manager.createGitTree({ tree: entries });
        return treeHandle.sha;
    }
    async writeSummaryTreeObject(object, previousFullSnapshot) {
        switch (object.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Blob: {
                return this.writeSummaryBlob(object.content);
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Handle: {
                if (previousFullSnapshot === undefined) {
                    throw Error("Parent summary does not exist to reference by handle.");
                }
                return this.getIdFromPath(object.handleType, object.handle, previousFullSnapshot);
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Tree: {
                return this.writeSummaryTreeCore(object, previousFullSnapshot);
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Attachment: {
                return object.id;
            }
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.unreachableCase)(object, `Unknown type: ${object.type}`);
        }
    }
    async writeSummaryBlob(content) {
        const { parsedContent, encoding } = typeof content === "string"
            ? { parsedContent: content, encoding: "utf-8" }
            : { parsedContent: (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.Uint8ArrayToString)(content, "base64"), encoding: "base64" };
        // The gitHashFile would return the same hash as returned by the server as blob.sha
        const hash = await (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.gitHashFile)(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.IsoBuffer.from(parsedContent, encoding));
        if (!this.blobsShaCache.has(hash)) {
            this.blobsShaCache.set(hash, "");
            const blob = await this.manager.createBlob(parsedContent, encoding);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(hash === blob.sha, 0x0b6 /* "Blob.sha and hash do not match!!" */);
        }
        return hash;
    }
    getIdFromPath(handleType, handlePath, previousFullSnapshot) {
        const path = handlePath.split("/").map((part) => decodeURIComponent(part));
        if (path[0] === "") {
            // root of tree should be unnamed
            path.shift();
        }
        if (path.length === 0) {
            return previousFullSnapshot.id;
        }
        return this.getIdFromPathCore(handleType, path, previousFullSnapshot);
    }
    getIdFromPathCore(handleType, path, 
    /** Previous snapshot, subtree relative to this path part */
    previousSnapshot) {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(path.length > 0, 0x0b3 /* "Expected at least 1 path part" */);
        const key = path[0];
        if (path.length === 1) {
            switch (handleType) {
                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Blob: {
                    const tryId = previousSnapshot.blobs[key];
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!tryId, 0x0b4 /* "Parent summary does not have blob handle for specified path." */);
                    return tryId;
                }
                case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_1__.SummaryType.Tree: {
                    const tryId = (_a = previousSnapshot.trees[key]) === null || _a === void 0 ? void 0 : _a.id;
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.assert)(!!tryId, 0x0b5 /* "Parent summary does not have tree handle for specified path." */);
                    return tryId;
                }
                default:
                    throw Error(`Unexpected handle summary object type: "${handleType}".`);
            }
        }
        return this.getIdFromPathCore(handleType, path.slice(1), previousSnapshot.trees[key]);
    }
}
//# sourceMappingURL=summaryTreeUploadManager.js.map

/***/ }),
/* 450 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gitHashFile": () => (/* binding */ gitHashFile),
/* harmony export */   "hashFile": () => (/* binding */ hashFile)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _bufferBrowser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(402);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


async function digestBuffer(file, algorithm) {
    const hash = await crypto.subtle.digest(algorithm, file);
    return new Uint8Array(hash);
}
function encodeDigest(hashArray, encoding) {
    // eslint-disable-next-line default-case
    switch (encoding) {
        case "hex": {
            const hashHex = Array.prototype.map.call(hashArray, (byte) => {
                return byte.toString(16).padStart(2, "0");
            }).join("");
            return hashHex;
        }
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(hashArray);
        }
    }
}
/**
 * Hash a file. Consistent within a session, but should not be persisted and
 * is not consistent with git.
 * If called under an insecure context for a browser, this will fallback to
 * using the node implementation.
 *
 * @param file - The contents of the file in a buffer
 * @param algorithm - The hash algorithm to use, artificially constrained by what is used internally
 * @param hashEncoding - The encoding of the returned hash, also artificially constrained
 * @returns The hash of the content of the buffer
 */
async function hashFile(file, algorithm = "SHA-1", hashEncoding = "hex") {
    // Handle insecure contexts (e.g. running with local services)
    // by deferring to Node version, which uses a hash polyfill
    // When packed, this chunk will show as "FluidFramework-HashFallback" separately
    // from the main chunk and will be of non-trivial size.  It will not be served
    // under normal circumstances.
    if (crypto.subtle === undefined) {
        return __webpack_require__.e(/* import() | FluidFramework-HashFallback */ 0).then(__webpack_require__.bind(__webpack_require__, 556)).then(async (m) => m.hashFile(file, algorithm, hashEncoding));
    }
    // This is split up this way to facilitate testing (see the test for more info)
    const hashArray = await digestBuffer(file, algorithm);
    return encodeDigest(hashArray, hashEncoding);
}
/**
 * Create a github hash (Github hashes the string with blob and size)
 * Must be called under secure context for browsers
 *
 * @param file - The contents of the file in a buffer
 * @returns The sha1 hash of the content of the buffer with the `blob` prefix and size
 */
async function gitHashFile(file) {
    const size = file.byteLength;
    const filePrefix = `blob ${size.toString()}${String.fromCharCode(0)}`;
    const hashBuffer = _bufferBrowser__WEBPACK_IMPORTED_MODULE_1__.IsoBuffer.from(filePrefix + file.toString());
    // hashFile uses sha1; if that changes this will need to change too
    return hashFile(hashBuffer);
}
//# sourceMappingURL=hashFileBrowser.js.map

/***/ }),
/* 451 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RetriableGitManager": () => (/* binding */ RetriableGitManager)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(452);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class RetriableGitManager {
    constructor(internalGitManager, logger) {
        this.internalGitManager = internalGitManager;
        this.logger = logger;
    }
    async getHeader(id, sha) {
        return this.runWithRetry(async () => this.internalGitManager.getHeader(id, sha), "gitManager_getHeader");
    }
    async getFullTree(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getFullTree(sha), "gitManager_getFullTree");
    }
    async getCommit(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getCommit(sha), "gitManager_getCommit");
    }
    async getCommits(sha, count) {
        return this.runWithRetry(async () => this.internalGitManager.getCommits(sha, count), "gitManager_getCommits");
    }
    async getTree(root, recursive) {
        return this.runWithRetry(async () => this.internalGitManager.getTree(root, recursive), "gitManager_getTree");
    }
    async getBlob(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getBlob(sha), "gitManager_getBlob");
    }
    getRawUrl(sha) {
        return this.internalGitManager.getRawUrl(sha);
    }
    async getContent(commit, path) {
        return this.runWithRetry(async () => this.internalGitManager.getContent(commit, path), "gitManager_getContent");
    }
    async createBlob(content, encoding) {
        return this.runWithRetry(async () => this.internalGitManager.createBlob(content, encoding), "gitManager_createBlob");
    }
    async createGitTree(params) {
        return this.runWithRetry(async () => this.internalGitManager.createGitTree(params), "gitManager_createGitTree");
    }
    async createTree(files) {
        return this.runWithRetry(async () => this.internalGitManager.createTree(files), "gitManager_createTree");
    }
    async createCommit(commit) {
        return this.runWithRetry(async () => this.internalGitManager.createCommit(commit), "gitManager_createCommit");
    }
    async getRef(ref) {
        return this.runWithRetry(async () => this.internalGitManager.getRef(ref), "gitManager_getRef");
    }
    async createRef(branch, sha) {
        return this.runWithRetry(async () => this.internalGitManager.createRef(branch, sha), "gitManager_createRef");
    }
    async upsertRef(branch, commitSha) {
        return this.runWithRetry(async () => this.internalGitManager.upsertRef(branch, commitSha), "gitManager_upsertRef");
    }
    async write(branch, inputTree, parents, message) {
        return this.runWithRetry(async () => this.internalGitManager.write(branch, inputTree, parents, message), "gitManager_write");
    }
    async createSummary(summary) {
        return this.runWithRetry(async () => this.internalGitManager.createSummary(summary), "gitManager_createSummary");
    }
    async deleteSummary(softDelete) {
        return this.runWithRetry(async () => this.internalGitManager.deleteSummary(softDelete), "gitManager_deleteSummary");
    }
    async getSummary(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getSummary(sha), "gitManager_getSummary");
    }
    async runWithRetry(api, callName) {
        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.runWithRetry)(api, callName, this.logger, {});
    }
}
//# sourceMappingURL=retriableGitManager.js.map

/***/ }),
/* 452 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runWithRetry": () => (/* binding */ runWithRetry)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(453);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(455);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(454);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





async function runWithRetry(api, fetchCallName, logger, progress) {
    var _a, _b;
    let result;
    let success = false;
    let retryAfterMs = 1000; // has to be positive!
    let numRetries = 0;
    const startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now();
    let lastError;
    do {
        try {
            result = await api(progress.cancel);
            success = true;
        }
        catch (err) {
            // If it is not retriable, then just throw the error.
            if (!(0,_network__WEBPACK_IMPORTED_MODULE_1__.canRetryOnError)(err)) {
                logger.sendTelemetryEvent({
                    eventName: `${fetchCallName}_cancel`,
                    retry: numRetries,
                    duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - startTime,
                    fetchCallName,
                }, err);
                throw err;
            }
            if (((_a = progress.cancel) === null || _a === void 0 ? void 0 : _a.aborted) === true) {
                logger.sendTelemetryEvent({
                    eventName: `${fetchCallName}_runWithRetryAborted`,
                    retry: numRetries,
                    duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - startTime,
                    fetchCallName,
                }, err);
                throw new _network__WEBPACK_IMPORTED_MODULE_1__.NonRetryableError("runWithRetry was Aborted", _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_2__.DriverErrorType.genericError, { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_3__.pkgVersion, fetchCallName });
            }
            numRetries++;
            lastError = err;
            // If the error is throttling error, then wait for the specified time before retrying.
            // If the waitTime is not specified, then we start with retrying immediately to max of 8s.
            retryAfterMs = (_b = (0,_network__WEBPACK_IMPORTED_MODULE_1__.getRetryDelayFromError)(err)) !== null && _b !== void 0 ? _b : Math.min(retryAfterMs * 2, 8000);
            if (progress.onRetry) {
                progress.onRetry(retryAfterMs, err);
            }
            await (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.delay)(retryAfterMs);
        }
    } while (!success);
    if (numRetries > 0) {
        logger.sendTelemetryEvent({
            eventName: `${fetchCallName}_lastError`,
            retry: numRetries,
            duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.performance.now() - startTime,
            fetchCallName,
        }, lastError);
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return result;
}
//# sourceMappingURL=runWithRetry.js.map

/***/ }),
/* 453 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "performance": () => (/* binding */ performance)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const performance = window.performance;
//# sourceMappingURL=performanceBrowser.js.map

/***/ }),
/* 454 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/driver-utils";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 455 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delay": () => (/* binding */ delay)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Returns a promise that resolves after timeMs
 * @param timeMs - time in milliseconds to wait
 */
const delay = async (timeMs) => new Promise((resolve) => setTimeout(() => resolve(), timeMs));
//# sourceMappingURL=delay.js.map

/***/ }),
/* 456 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrefetchDocumentStorageService": () => (/* binding */ PrefetchDocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(440);
/* harmony import */ var _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



class PrefetchDocumentStorageService extends _documentStorageServiceProxy__WEBPACK_IMPORTED_MODULE_0__.DocumentStorageServiceProxy {
    constructor() {
        super(...arguments);
        // BlobId -> blob prefetchCache cache
        this.prefetchCache = new Map();
        this.prefetchEnabled = true;
    }
    get policies() {
        const policies = this.internalStorageService.policies;
        if (policies) {
            return Object.assign(Object.assign({}, policies), { caching: _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_1__.LoaderCachingPolicy.NoCaching });
        }
    }
    async getSnapshotTree(version) {
        const p = this.internalStorageService.getSnapshotTree(version);
        if (this.prefetchEnabled) {
            // We don't care if the prefetch succeeds
            void p.then((tree) => {
                if (tree === null || tree === undefined) {
                    return;
                }
                this.prefetchTree(tree);
            });
        }
        return p;
    }
    async readBlob(blobId) {
        return this.cachedRead(blobId);
    }
    stopPrefetch() {
        this.prefetchEnabled = false;
        this.prefetchCache.clear();
    }
    async cachedRead(blobId) {
        if (this.prefetchEnabled) {
            const prefetchedBlobP = this.prefetchCache.get(blobId);
            if (prefetchedBlobP !== undefined) {
                return prefetchedBlobP;
            }
            const prefetchedBlobPFromStorage = this.internalStorageService.readBlob(blobId);
            this.prefetchCache.set(blobId, prefetchedBlobPFromStorage.catch((error) => {
                if ((0,_network__WEBPACK_IMPORTED_MODULE_2__.canRetryOnError)(error)) {
                    this.prefetchCache.delete(blobId);
                }
                throw error;
            }));
            return prefetchedBlobPFromStorage;
        }
        return this.internalStorageService.readBlob(blobId);
    }
    prefetchTree(tree) {
        const secondary = [];
        this.prefetchTreeCore(tree, secondary);
        for (const blob of secondary) {
            // We don't care if the prefetch succeeds
            void this.cachedRead(blob);
        }
    }
    prefetchTreeCore(tree, secondary) {
        for (const blobKey of Object.keys(tree.blobs)) {
            const blob = tree.blobs[blobKey];
            if (blobKey.startsWith(".") || blobKey === "header" || blobKey.startsWith("quorum")) {
                if (blob !== null) {
                    // We don't care if the prefetch succeeds
                    void this.cachedRead(blob);
                }
            }
            else if (!blobKey.startsWith("deltas")) {
                if (blob !== null) {
                    secondary.push(blob);
                }
            }
        }
        for (const subTree of Object.keys(tree.trees)) {
            this.prefetchTreeCore(tree.trees[subTree], secondary);
        }
    }
}
//# sourceMappingURL=prefetchDocumentStorageService.js.map

/***/ }),
/* 457 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaStorageService": () => (/* binding */ DeltaStorageService),
/* harmony export */   "DocumentDeltaStorageService": () => (/* binding */ DocumentDeltaStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(458);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(461);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



const MaxBatchDeltas = 2000; // Maximum number of ops we can fetch at a time
/**
 * Storage service limited to only being able to fetch documents for a specific document
 */
class DocumentDeltaStorageService {
    constructor(tenantId, id, deltaStorageService, documentStorageService) {
        this.tenantId = tenantId;
        this.id = id;
        this.deltaStorageService = deltaStorageService;
        this.documentStorageService = documentStorageService;
        this.logtailSha = this.documentStorageService.logTailSha;
    }
    fetchMessages(from, to, abortSignal, cachedOnly, fetchReason) {
        if (cachedOnly) {
            return _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.emptyMessageStream;
        }
        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.requestOps)(this.getCore.bind(this), 
        // Staging: starting with no concurrency, listening for feedback first.
        // In future releases we will switch to actual concurrency
        1, // concurrency
        from, // inclusive
        to, // exclusive
        MaxBatchDeltas, new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TelemetryNullLogger(), abortSignal, fetchReason);
    }
    async getCore(from, to) {
        const opsFromLogTail = this.logtailSha
            ? await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.readAndParse)(this.documentStorageService, this.logtailSha)
            : [];
        this.logtailSha = undefined;
        if (opsFromLogTail.length > 0) {
            const messages = opsFromLogTail.filter((op) => op.sequenceNumber >= from);
            if (messages.length > 0) {
                return { messages, partialResult: true };
            }
        }
        return this.deltaStorageService.get(this.tenantId, this.id, from, to);
    }
}
/**
 * Provides access to the underlying delta storage on the server for routerlicious driver.
 */
class DeltaStorageService {
    constructor(url, restWrapper, logger, getRestWrapper = async () => this.restWrapper, getDeltaStorageUrl = () => this.url) {
        this.url = url;
        this.restWrapper = restWrapper;
        this.logger = logger;
        this.getRestWrapper = getRestWrapper;
        this.getDeltaStorageUrl = getDeltaStorageUrl;
    }
    async get(tenantId, id, from, // inclusive
    to) {
        const ops = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getDeltas",
            from,
            to,
        }, async (event) => {
            const restWrapper = await this.getRestWrapper();
            const url = this.getDeltaStorageUrl();
            const response = await restWrapper.get(url, { from: from - 1, to });
            event.end({
                count: response.length,
            });
            return response;
        });
        // It is assumed that server always returns all the ops that it has in the range that was requested.
        // This may change in the future, if so, we need to adjust and receive "end" value from server in such case.
        return { messages: ops, partialResult: false };
    }
}
//# sourceMappingURL=deltaStorageService.js.map

/***/ }),
/* 458 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParallelRequests": () => (/* binding */ ParallelRequests),
/* harmony export */   "Queue": () => (/* binding */ Queue),
/* harmony export */   "emptyMessageStream": () => (/* binding */ emptyMessageStream),
/* harmony export */   "requestOps": () => (/* binding */ requestOps),
/* harmony export */   "streamFromMessages": () => (/* binding */ streamFromMessages),
/* harmony export */   "streamObserver": () => (/* binding */ streamObserver)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(459);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(453);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(45);
/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(117);
/* harmony import */ var _networkUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(460);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(454);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




// For now, this package is versioned and released in unison with the specific drivers

const MaxFetchDelayInMs = 10000;
const MissingFetchDelayInMs = 100;
/**
 * Helper class to organize parallel fetching of data
 * It can be used to concurrently do many requests, while consuming
 * data in the right order. Take a look at UT for examples.
 * @param concurrency - level of concurrency
 * @param from - starting point of fetching data (inclusive)
 * @param to  - ending point of fetching data. exclusive, or undefined if unknown
 * @param payloadSize - batch size
 * @param logger - logger to use
 * @param requestCallback - callback to request batches
 * @returns - Queue that can be used to retrieve data
 */
class ParallelRequests {
    constructor(from, to, payloadSize, logger, requestCallback, responseCallback) {
        this.to = to;
        this.payloadSize = payloadSize;
        this.logger = logger;
        this.requestCallback = requestCallback;
        this.responseCallback = responseCallback;
        this.results = new Map();
        this.workingState = "working";
        this.requestsInFlight = 0;
        this.endEvent = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.requests = 0;
        this.latestRequested = from;
        this.nextToDeliver = from;
        this.knewTo = (to !== undefined);
    }
    get working() { return this.workingState === "working"; }
    get canceled() { return this.workingState === "canceled"; }
    cancel() {
        if (this.working) {
            this.workingState = "canceled";
            this.endEvent.resolve();
        }
    }
    async run(concurrency) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(concurrency > 0, 0x102 /* "invalid level of concurrency" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.working, 0x103 /* "trying to parallel run while not working" */);
        let c = concurrency;
        while (c > 0) {
            c--;
            this.addRequest();
        }
        this.dispatch(); // will recalculate and trigger this.endEvent if needed
        return this.endEvent.promise;
    }
    done() {
        // We should satisfy request fully.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.to !== undefined, 0x104 /* "undefined end point for parallel fetch" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.nextToDeliver >= this.to, 0x105 /* "unexpected end point for parallel fetch" */);
        if (this.working) {
            this.workingState = "done";
            this.endEvent.resolve();
        }
    }
    fail(error) {
        if (this.working) {
            this.workingState = "done";
            this.endEvent.reject(error);
        }
    }
    dispatch() {
        while (this.working) {
            const value = this.results.get(this.nextToDeliver);
            if (value === undefined) {
                break;
            }
            this.results.delete(this.nextToDeliver);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(value.length <= this.payloadSize, 0x1d9 /* "addRequestCore() should break into smaller chunks" */);
            this.nextToDeliver += value.length;
            this.responseCallback(value);
        }
        // Account for cancellation - state might be not in consistent state on cancelling operation
        if (this.working) {
            if (this.requestsInFlight === 0) {
                // we should have dispatched everything, no matter whether we knew about the end or not.
                // see comment in addRequestCore() around throwing away chunk if it's above this.to
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.results.size === 0, 0x107 /* "ending dispatch with remaining results to be sent" */);
                this.done();
            }
            else if (this.to !== undefined && this.nextToDeliver >= this.to) {
                // Learned about the end and dispatched all the ops up to it.
                // Ignore all the in-flight requests above boundary - unblock caller sooner.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x108 /* "ending results dispatch but knew in advance about more requests" */);
                this.done();
            }
        }
    }
    getNextChunk() {
        if (!this.working) {
            return undefined;
        }
        const from = this.latestRequested;
        if (this.to !== undefined) {
            if (this.to <= from) {
                return undefined;
            }
        }
        // this.latestRequested
        // inclusive on the right side! Exclusive on the left.
        this.latestRequested += this.payloadSize;
        if (this.to !== undefined) {
            this.latestRequested = Math.min(this.to, this.latestRequested);
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(from < this.latestRequested, 0x109 /* "unexpected next chunk position" */);
        return { from, to: this.latestRequested };
    }
    addRequest() {
        const chunk = this.getNextChunk();
        if (chunk === undefined) {
            return;
        }
        this.addRequestCore(chunk.from, chunk.to).catch(this.fail.bind(this));
    }
    async addRequestCore(fromArg, toArg) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.working, 0x10a /* "cannot add parallel request while not working" */);
        let from = fromArg;
        let to = toArg;
        // to & from are exclusive
        this.requestsInFlight++;
        while (this.working) {
            const requestedLength = to - from;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(requestedLength > 0, 0x10b /* "invalid parallel request range" */);
            // We should not be wasting time asking for something useless.
            if (this.to !== undefined) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(from < this.to, 0x10c /* "invalid parallel request start point" */);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(to <= this.to, 0x10d /* "invalid parallel request end point" */);
            }
            this.requests++;
            const promise = this.requestCallback(this.requests, from, to, this.to !== undefined, {});
            // dispatch any prior received data
            this.dispatch();
            const { payload, cancel, partial } = await promise;
            if (cancel) {
                this.cancel();
            }
            if (this.to !== undefined && from >= this.to) {
                // while we were waiting for response, we learned on what is the boundary
                // We can get here (with actual result!) if situation changed while this request was in
                // flight, i.e. the end was extended over what we learn in some other request
                // While it's useful not to throw this result, this is very corner cases and makes logic
                // (including consistency checks) much harder to write correctly.
                // So for now, we are throwing this result out the window.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x10e /* "should not throw result if we knew about boundary in advance" */);
                // Learn how often it happens and if it's too wasteful to throw these chunks.
                // If it pops into our view a lot, we would need to reconsider how we approach it.
                // Note that this is not visible to user other than potentially not hitting 100% of
                // what we can in perf domain.
                if (payload.length !== 0) {
                    this.logger.sendErrorEvent({
                        eventName: "ParallelRequests_GotExtra",
                        from,
                        to,
                        end: this.to,
                        length: payload.length,
                    });
                }
                break;
            }
            if (this.working) {
                const fromOrig = from;
                const length = payload.length;
                let fullChunk = (requestedLength <= length); // we can possible get more than we asked.
                if (length !== 0) {
                    // We can get more than we asked for!
                    // This can screw up logic in dispatch!
                    // So push only batch size, and keep the rest for later - if conditions are favorable, we
                    // will be able to use it. If not (parallel request overlapping these ops), it's easier to
                    // discard them and wait for another (overlapping) request to come in later.
                    if (requestedLength < length) {
                        // This is error in a sense that it's not expected and likely points bug in other layer.
                        // This layer copes with this situation just fine.
                        this.logger.sendTelemetryEvent({
                            eventName: "ParallelRequests_Over",
                            from,
                            to,
                            length,
                        });
                    }
                    const data = payload.splice(0, requestedLength);
                    this.results.set(from, data);
                    from += data.length;
                }
                else {
                    // 1. empty (partial) chunks should not be returned by various caching / adapter layers -
                    //    they should fall back to next layer. This might be important invariant to hold to ensure
                    //    that we are less likely have bugs where such layer would keep returning empty partial
                    //    result on each call.
                    // 2. Current invariant is that callback does retries until it gets something,
                    //    with the goal of failing if zero data is retrieved in given amount of time.
                    //    This is very specific property of storage / ops, so this logic is not here, but given only
                    //    one user of this class, we assert that to catch issues earlier.
                    // These invariant can be relaxed if needed.
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!partial, 0x10f /* "empty/partial chunks should not be returned by caching" */);
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.knewTo, 0x110 /* "callback should retry until valid fetch before it learns new boundary" */);
                }
                if (!partial && !fullChunk) {
                    if (!this.knewTo) {
                        if (this.to === undefined || this.to > from) {
                            // The END
                            this.to = from;
                        }
                        break;
                    }
                    // We know that there are more items to be retrieved
                    // Can we get partial chunk? Ideally storage indicates that's not a full chunk
                    // Note that it's possible that not all ops hit storage yet.
                    // We will come back to request more, and if we can't get any more ops soon, it's
                    // catastrophic failure (see comment above on responsibility of callback to return something)
                    // This layer will just keep trying until it gets full set.
                    this.logger.sendPerformanceEvent({
                        eventName: "ParallelRequests_Partial",
                        from: fromOrig,
                        to,
                        length,
                    });
                }
                if (to === this.latestRequested) {
                    // we can go after full chunk at the end if we received partial chunk, or more than asked
                    // Also if we got more than we asked to, we can actually use those ops!
                    if (payload.length !== 0) {
                        this.results.set(from, payload);
                        from += payload.length;
                    }
                    this.latestRequested = from;
                    fullChunk = true;
                }
                if (fullChunk) {
                    const chunk = this.getNextChunk();
                    if (chunk === undefined) {
                        break;
                    }
                    from = chunk.from;
                    to = chunk.to;
                }
            }
        }
        this.requestsInFlight--;
        this.dispatch();
    }
}
/**
 * Helper queue class to allow async push / pull
 * It's essentially a pipe allowing multiple writers, and single reader
 */
class Queue {
    constructor() {
        this.queue = [];
        this.done = false;
    }
    pushValue(value) {
        this.pushCore(Promise.resolve({ done: false, value }));
    }
    pushError(error) {
        this.pushCore(Promise.reject(error));
        this.done = true;
    }
    pushDone() {
        this.pushCore(Promise.resolve({ done: true }));
        this.done = true;
    }
    pushCore(value) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.done, 0x112 /* "cannot push onto queue if done" */);
        if (this.deferred) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.queue.length === 0, 0x113 /* "deferred queue should be empty" */);
            this.deferred.resolve(value);
            this.deferred = undefined;
        }
        else {
            this.queue.push(value);
        }
    }
    async read() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this.deferred === undefined, 0x114 /* "cannot pop if deferred" */);
        const value = this.queue.shift();
        if (value !== undefined) {
            return value;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.done, 0x115 /* "queue should not be done during pop" */);
        this.deferred = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        return this.deferred.promise;
    }
}
/**
 * Retrieve single batch of ops
 * @param request - request index
 * @param from - inclusive boundary
 * @param to - exclusive boundary
 * @param telemetryEvent - telemetry event used to track consecutive batch of requests
 * @param strongTo - tells if ops in range from...to have to be there and have to be retrieved.
 * If false, returning less ops would mean we reached end of file.
 * @param logger - logger object to use to log progress & errors
 * @param signal - cancelation signal
 * @param scenarioName - reason for fetching ops
 * @returns - an object with resulting ops and cancellation / partial result flags
 */
async function getSingleOpBatch(get, props, strongTo, logger, signal, scenarioName) {
    let lastSuccessTime;
    let retry = 0;
    const deltas = [];
    const nothing = { partial: false, cancel: true, payload: [] };
    while ((signal === null || signal === void 0 ? void 0 : signal.aborted) !== true) {
        retry++;
        let delay = Math.min(MaxFetchDelayInMs, MissingFetchDelayInMs * Math.pow(2, retry));
        const startTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now();
        try {
            // Issue async request for deltas - limit the number fetched to MaxBatchDeltas
            const deltasP = get(Object.assign(Object.assign({}, props), { retry }));
            const { messages, partialResult } = await deltasP;
            deltas.push(...messages);
            const deltasRetrievedLast = messages.length;
            if (deltasRetrievedLast !== 0 || !strongTo) {
                return { payload: deltas, cancel: false, partial: partialResult };
            }
            // Storage does not have ops we need.
            // Attempt to fetch more deltas. If we didn't receive any in the previous call we up our retry
            // count since something prevented us from seeing those deltas
            if (lastSuccessTime === undefined) {
                lastSuccessTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now();
            }
            else if (_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now() - lastSuccessTime > 30000) {
                // If we are connected and receiving proper responses from server, but can't get any ops back,
                // then give up after some time. This likely indicates the issue with ordering service not flushing
                // ops to storage quick enough, and possibly waiting for summaries, while summarizer can't get
                // current as it can't get ops.
                throw (0,_network__WEBPACK_IMPORTED_MODULE_3__.createGenericNetworkError)(
                // pre-0.58 error message: failedToRetrieveOpsFromStorage:TooManyRetries
                "Failed to retrieve ops from storage (Too Many Retries)", { canRetry: false }, Object.assign({ retry,
                    driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_4__.pkgVersion }, props));
            }
        }
        catch (error) {
            const canRetry = (0,_network__WEBPACK_IMPORTED_MODULE_3__.canRetryOnError)(error);
            lastSuccessTime = undefined;
            const retryAfter = (0,_network__WEBPACK_IMPORTED_MODULE_3__.getRetryDelayFromError)(error);
            // This will log to error table only if the error is non-retryable
            (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.logNetworkFailure)(logger, Object.assign(Object.assign({ eventName: "GetDeltas_Error" }, props), { retry, duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now() - startTime, retryAfter, reason: scenarioName }), error);
            if (!canRetry) {
                // It's game over scenario.
                throw error;
            }
            if (retryAfter !== undefined && retryAfter >= 0) {
                delay = retryAfter;
            }
        }
        await (0,_networkUtils__WEBPACK_IMPORTED_MODULE_5__.waitForConnectedState)(delay);
    }
    return nothing;
}
/**
 * Request ops from storage
 * @param get - Getter callback to get individual batches
 * @param concurrency - Number of concurrent requests to make
 * @param fromTotal - starting sequence number to fetch (inclusive)
 * @param toTotal - max (exclusive) sequence number to fetch
 * @param payloadSize - Payload size
 * @param logger - Logger to log progress and errors
 * @param signal - Cancelation signal
 * @param scenarioName - Reason for fetching ops
 * @returns - Messages fetched
 */
function requestOps(get, concurrency, fromTotal, toTotal, payloadSize, logger, signal, scenarioName) {
    let requests = 0;
    let lastFetch;
    let length = 0;
    const queue = new Queue();
    const propsTotal = {
        fromTotal,
        toTotal,
    };
    const telemetryEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.start(logger, Object.assign(Object.assign({ eventName: "GetDeltas" }, propsTotal), { reason: scenarioName }));
    const manager = new ParallelRequests(fromTotal, toTotal, payloadSize, logger, async (request, from, to, strongTo, propsPerRequest) => {
        requests++;
        return getSingleOpBatch(async (propsAll) => get(from, to, propsAll), Object.assign(Object.assign({ request, from, to }, propsTotal), propsPerRequest), strongTo, logger, signal, scenarioName);
    }, (deltas) => {
        // Assert continuing and right start.
        if (lastFetch === undefined) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(deltas[0].sequenceNumber === fromTotal, 0x26d /* "wrong start" */);
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(deltas[0].sequenceNumber === lastFetch + 1, 0x26e /* "wrong start" */);
        }
        lastFetch = deltas[deltas.length - 1].sequenceNumber;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(lastFetch - deltas[0].sequenceNumber + 1 === deltas.length, 0x26f /* "continuous and no duplicates" */);
        length += deltas.length;
        queue.pushValue(deltas);
    });
    // Implement faster cancellation. getSingleOpBatch() checks signal, but only in between
    // waits (up to 10 seconds) and fetches (can take infinite amount of time).
    // While every such case should be improved and take into account signal (and thus cancel immediately),
    // it is beneficial to have catch-all
    const listener = (event) => { manager.cancel(); };
    if (signal !== undefined) {
        signal.addEventListener("abort", listener);
    }
    manager.run(concurrency)
        .finally(() => {
        if (signal !== undefined) {
            signal.removeEventListener("abort", listener);
        }
    }).then(() => {
        const props = {
            lastFetch,
            length,
            requests,
        };
        if (manager.canceled) {
            telemetryEvent.cancel(Object.assign(Object.assign({}, props), { error: "ops request cancelled by client" }));
        }
        else {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(toTotal === undefined || lastFetch !== undefined && lastFetch >= toTotal - 1, 0x270 /* "All requested ops fetched" */);
            telemetryEvent.end(props);
        }
        queue.pushDone();
    })
        .catch((error) => {
        telemetryEvent.cancel({
            lastFetch,
            length,
            requests,
        }, error);
        queue.pushError(error);
    });
    return queue;
}
const emptyMessageStream = {
    read: async () => { return { done: true }; },
};
function streamFromMessages(messagesArg) {
    let messages = messagesArg;
    return {
        read: async () => {
            if (messages === undefined) {
                return { done: true };
            }
            const value = await messages;
            messages = undefined;
            return value.length === 0 ? { done: true } : { done: false, value };
        },
    };
}
function streamObserver(stream, handler) {
    return {
        read: async () => {
            const value = await stream.read();
            handler(value);
            return value;
        },
    };
}
//# sourceMappingURL=parallelRequests.js.map

/***/ }),
/* 459 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),
/* 460 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logNetworkFailure": () => (/* binding */ logNetworkFailure),
/* harmony export */   "waitForConnectedState": () => (/* binding */ waitForConnectedState)
/* harmony export */ });
/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

function logNetworkFailure(logger, event, error) {
    var _a, _b;
    const newEvent = Object.assign({}, event);
    const errorOnlineProp = error.online;
    newEvent.online = typeof errorOnlineProp === "string"
        ? errorOnlineProp
        : _network__WEBPACK_IMPORTED_MODULE_0__.OnlineStatus[(0,_network__WEBPACK_IMPORTED_MODULE_0__.isOnline)()];
    if (typeof navigator === "object" && navigator !== null) {
        const nav = navigator;
        const connection = (_b = (_a = nav.connection) !== null && _a !== void 0 ? _a : nav.mozConnection) !== null && _b !== void 0 ? _b : nav.webkitConnection;
        if (connection !== null && typeof connection === "object") {
            newEvent.connectionType = connection.type;
        }
    }
    // non-retryable errors are fatal and should be logged as errors
    newEvent.category = (0,_network__WEBPACK_IMPORTED_MODULE_0__.canRetryOnError)(error) ? "generic" : "error";
    logger.sendTelemetryEvent(newEvent, error);
}
/**
 * Wait for browser to get to connected state.
 * If connected, waits minimum of minDelay anyway (between network retries)
 * If disconnected, polls every 30 seconds anyway, to make sure we are not getting stuck because of wrong signal
 * Note that browsers will have false positives (like having Hyper-V adapter on machine,
 * or machine connected to router that is not connected to internet)
 * But there should be no false negatives.
 * The only exception - Opera returns false when user enters "Work Offline" mode, regardless of actual connectivity.
 */
// eslint-disable-next-line @typescript-eslint/promise-function-async
function waitForConnectedState(minDelay) {
    // Use this frequency to poll even when we are offline and able to setup online/offline listener
    // This is mostly safety net
    const offlinePollFrequency = 30000;
    return new Promise((resolve) => {
        let listener = resolve;
        let delay = minDelay;
        if ((0,_network__WEBPACK_IMPORTED_MODULE_0__.isOnline)() === _network__WEBPACK_IMPORTED_MODULE_0__.OnlineStatus.Offline) {
            if ((window === null || window === void 0 ? void 0 : window.addEventListener) !== undefined) {
                listener = () => {
                    resolve();
                    window.removeEventListener("online", listener);
                };
                window.addEventListener("online", listener, false);
                delay = Math.max(minDelay, offlinePollFrequency);
            }
        }
        setTimeout(listener, delay);
    });
}
//# sourceMappingURL=networkUtils.js.map

/***/ }),
/* 461 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTelemetryNullLogger": () => (/* binding */ BaseTelemetryNullLogger),
/* harmony export */   "TelemetryNullLogger": () => (/* binding */ TelemetryNullLogger),
/* harmony export */   "extractLogSafeErrorProperties": () => (/* binding */ extractLogSafeErrorProperties)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class BaseTelemetryNullLogger {
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        return;
    }
}
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryNullLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
    }
    sendPerformanceEvent(event, error) {
    }
}
function extractLogSafeErrorProperties(error) {
    const isRegularObject = (value) => {
        return value !== null && !Array.isArray(value) && typeof value === "object";
    };
    const removeMessageFromStack = (stack, errorName) => {
        const stackFrames = stack.split("\n");
        stackFrames.shift(); // Remove "[ErrorName]: [ErrorMessage]"
        if (errorName !== undefined) {
            stackFrames.unshift(errorName); // Add "[ErrorName]"
        }
        return stackFrames.join("\n");
    };
    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === "string")
        ? error.message
        : String(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack, name } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            const errorName = (typeof name === "string") ? name : undefined;
            safeProps.stack = removeMessageFromStack(stack, errorName);
        }
    }
    return safeProps;
}
//# sourceMappingURL=logger.js.map

/***/ }),
/* 462 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R11sDocumentDeltaConnection": () => (/* binding */ R11sDocumentDeltaConnection)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(463);
/* harmony import */ var _errorUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(396);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(397);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



const protocolVersions = ["^0.4.0", "^0.3.0", "^0.2.0", "^0.1.0"];
/**
 * Wrapper over the shared one for driver specific translation.
 */
class R11sDocumentDeltaConnection extends _fluidframework_driver_base__WEBPACK_IMPORTED_MODULE_0__.DocumentDeltaConnection {
    static async create(tenantId, id, token, io, client, url, logger, timeoutMs = 20000) {
        const socket = io(url, {
            query: {
                documentId: id,
                tenantId,
            },
            reconnection: false,
            // Default to websocket connection, with long-polling disabled
            transports: ["websocket"],
            timeout: timeoutMs,
        });
        const connectMessage = {
            client,
            id,
            mode: client.mode,
            tenantId,
            token,
            versions: protocolVersions,
            relayUserAgent: [client.details.environment, ` driverVersion:${_packageVersion__WEBPACK_IMPORTED_MODULE_1__.pkgVersion}`].join(";"),
        };
        // TODO: expose to host at factory level
        const enableLongPollingDowngrades = true;
        const deltaConnection = new R11sDocumentDeltaConnection(socket, id, logger, enableLongPollingDowngrades);
        await deltaConnection.initialize(connectMessage, timeoutMs);
        return deltaConnection;
    }
    /**
     * Error raising for socket.io issues
     */
    createErrorObject(handler, error, canRetry = true) {
        // Note: we suspect the incoming error object is either:
        // - a socketError: add it to the R11sError object for driver to be able to parse it and reason over it.
        // - anything else: let base class handle it
        if (canRetry && Number.isInteger(error === null || error === void 0 ? void 0 : error.code) && typeof (error === null || error === void 0 ? void 0 : error.message) === "string") {
            return (0,_errorUtils__WEBPACK_IMPORTED_MODULE_2__.errorObjectFromSocketError)(error, handler);
        }
        else {
            return super.createErrorObject(handler, error, canRetry);
        }
    }
}
//# sourceMappingURL=documentDeltaConnection.js.map

/***/ }),
/* 463 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentDeltaConnection": () => (/* binding */ DocumentDeltaConnection)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(464);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(467);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(466);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(465);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




// For now, this package is versioned and released in unison with the specific drivers

/**
 * Represents a connection to a stream of delta updates
 */
class DocumentDeltaConnection extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitterWithErrorHandling {
    /**
     * @param socket - websocket to be used
     * @param documentId - ID of the document
     * @param logger - for reporting telemetry events
     * @param enableLongPollingDowngrades - allow connection to be downgraded to long-polling on websocket failure
     */
    constructor(socket, documentId, logger, enableLongPollingDowngrades = false) {
        super((name, error) => {
            logger.sendErrorEvent({
                eventName: "DeltaConnection:EventException",
                name,
            }, error);
        });
        this.socket = socket;
        this.documentId = documentId;
        this.enableLongPollingDowngrades = enableLongPollingDowngrades;
        // Listen for ops sent before we receive a response to connect_document
        this.queuedMessages = [];
        this.queuedSignals = [];
        /**
         * A flag to indicate whether we have our handler attached.  If it's attached, we're queueing incoming ops
         * to later be retrieved via initialMessages.
         */
        this.earlyOpHandlerAttached = false;
        // Listeners only needed while the connection is in progress
        this.connectionListeners = new Map();
        // Listeners used throughout the lifetime of the DocumentDeltaConnection
        this.trackedListeners = new Map();
        /**
         * Flag to indicate whether the DocumentDeltaConnection is expected to still be capable of sending messages.
         * After disconnection, we flip this to prevent any stale messages from being emitted.
         */
        this._disposed = false;
        this.earlyOpHandler = (documentId, msgs) => {
            this.queuedMessages.push(...msgs);
        };
        this.earlySignalHandler = (msg) => {
            this.queuedSignals.push(msg);
        };
        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.ChildLogger.create(logger, "DeltaConnection"));
        this.on("newListener", (event, listener) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.disposed, 0x20a /* "register for event on disposed object" */);
            // Some events are already forwarded - see this.addTrackedListener() calls in initialize().
            if (DocumentDeltaConnection.eventsAlwaysForwarded.includes(event)) {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.trackedListeners.has(event), 0x245 /* "tracked listener" */);
                return;
            }
            if (!DocumentDeltaConnection.eventsToForward.includes(event)) {
                throw new Error(`DocumentDeltaConnection: Registering for unknown event: ${event}`);
            }
            // Whenever listener is added, we should subscribe on same event on socket, so these two things
            // should be in sync. This currently assumes that nobody unregisters and registers back listeners,
            // and that there are no "internal" listeners installed (like "error" case we skip above)
            // Better flow might be to always unconditionally register all handlers on successful connection,
            // though some logic (naming assert in initialMessages getter) might need to be adjusted (it becomes noop)
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)((this.listeners(event).length !== 0) === this.trackedListeners.has(event), 0x20b /* "mismatch" */);
            if (!this.trackedListeners.has(event)) {
                this.addTrackedListener(event, (...args) => {
                    this.emit(event, ...args);
                });
            }
        });
    }
    get hasDetails() {
        return !!this._details;
    }
    get disposed() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._disposed || this.socket.connected, 0x244 /* "Socket is closed, but connection is not!" */);
        return this._disposed;
    }
    /**
     * @deprecated - Implementors should manage their own logger or monitoring context
     */
    get logger() {
        return this.mc.logger;
    }
    get details() {
        if (!this._details) {
            throw new Error("Internal error: calling method before _details is initialized!");
        }
        return this._details;
    }
    /**
     * Get the ID of the client who is sending the message
     *
     * @returns the client ID
     */
    get clientId() {
        return this.details.clientId;
    }
    /**
     * Get the mode of the client
     *
     * @returns the client mode
     */
    get mode() {
        return this.details.mode;
    }
    /**
     * Get the claims of the client who is sending the message
     *
     * @returns client claims
     */
    get claims() {
        return this.details.claims;
    }
    /**
     * Get whether or not this is an existing document
     *
     * @returns true if the document exists
     */
    get existing() {
        return this.details.existing;
    }
    /**
     * Get the maximum size of a message before chunking is required
     *
     * @returns the maximum size of a message before chunking is required
     */
    get maxMessageSize() {
        return this.details.serviceConfiguration.maxMessageSize;
    }
    /**
     * Semver of protocol being used with the service
     */
    get version() {
        return this.details.version;
    }
    /**
     * Configuration details provided by the service
     */
    get serviceConfiguration() {
        return this.details.serviceConfiguration;
    }
    checkNotClosed() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.disposed, 0x20c /* "connection disposed" */);
    }
    /**
     * Get messages sent during the connection
     *
     * @returns messages sent during the connection
     */
    get initialMessages() {
        this.checkNotClosed();
        // If we call this when the earlyOpHandler is not attached, then the queuedMessages may not include the
        // latest ops.  This could possibly indicate that initialMessages was called twice.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.earlyOpHandlerAttached, 0x08e /* "Potentially missed initial messages" */);
        // We will lose ops and perf will tank as we need to go to storage to become current!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.listeners("op").length !== 0, 0x08f /* "No op handler is setup!" */);
        this.removeEarlyOpHandler();
        if (this.queuedMessages.length > 0) {
            // Some messages were queued.
            // add them to the list of initialMessages to be processed
            this.details.initialMessages.push(...this.queuedMessages);
            this.details.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
            this.queuedMessages.length = 0;
        }
        return this.details.initialMessages;
    }
    /**
     * Get signals sent during the connection
     *
     * @returns signals sent during the connection
     */
    get initialSignals() {
        this.checkNotClosed();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.listeners("signal").length !== 0, 0x090 /* "No signal handler is setup!" */);
        this.removeEarlySignalHandler();
        if (this.queuedSignals.length > 0) {
            // Some signals were queued.
            // add them to the list of initialSignals to be processed
            this.details.initialSignals.push(...this.queuedSignals);
            this.queuedSignals.length = 0;
        }
        return this.details.initialSignals;
    }
    /**
     * Get initial client list
     *
     * @returns initial client list sent during the connection
     */
    get initialClients() {
        this.checkNotClosed();
        return this.details.initialClients;
    }
    emitMessages(type, messages) {
        // Although the implementation here disconnects the socket and does not reuse it, other subclasses
        // (e.g. OdspDocumentDeltaConnection) may reuse the socket.  In these cases, we need to avoid emitting
        // on the still-live socket.
        if (!this.disposed) {
            this.socket.emit(type, this.clientId, messages);
        }
    }
    submitCore(type, messages) {
        this.emitMessages(type, [messages]);
    }
    /**
     * Submits a new delta operation to the server
     *
     * @param message - delta operation to submit
     */
    submit(messages) {
        this.checkNotClosed();
        this.submitCore("submitOp", messages);
    }
    /**
     * Submits a new signal to the server
     *
     * @param message - signal to submit
     */
    submitSignal(message) {
        this.checkNotClosed();
        this.submitCore("submitSignal", [message]);
    }
    /**
     * Disconnect from the websocket, and permanently disable this DocumentDeltaConnection.
     */
    dispose() {
        this.disposeCore(false, // socketProtocolError
        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.createGenericNetworkError)(
        // pre-0.58 error message: clientClosingConnection
        "Client closing delta connection", { canRetry: true }, { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_5__.pkgVersion }));
    }
    disposeCore(socketProtocolError, err) {
        // Can't check this.disposed here, as we get here on socket closure,
        // so _disposed & socket.connected might be not in sync while processing
        // "dispose" event.
        if (this._disposed) {
            return;
        }
        // We set the disposed flag as a part of the contract for overriding the disconnect method. This is used by
        // DocumentDeltaConnection to determine if emitting messages (ops) on the socket is allowed, which is
        // important since OdspDocumentDeltaConnection reuses the socket rather than truly disconnecting it. Note that
        // OdspDocumentDeltaConnection may still send disconnect_document which is allowed; this is only intended
        // to prevent normal messages from being emitted.
        this._disposed = true;
        this.removeTrackedListeners();
        this.disconnect(socketProtocolError, err);
    }
    /**
     * Disconnect from the websocket.
     * @param socketProtocolError - true if error happened on socket / socket.io protocol level
     *  (not on Fluid protocol level)
     * @param reason - reason for disconnect
     */
    disconnect(socketProtocolError, reason) {
        this.socket.disconnect();
    }
    async initialize(connectMessage, timeout) {
        this.socket.on("op", this.earlyOpHandler);
        this.socket.on("signal", this.earlySignalHandler);
        this.earlyOpHandlerAttached = true;
        // Socket.io's reconnect_attempt event is unreliable, so we track connect_error count instead.
        let internalSocketConnectionFailureCount = 0;
        const isInternalSocketReconnectionEnabled = () => this.socket.io.reconnection();
        const getMaxInternalSocketReconnectionAttempts = () => isInternalSocketReconnectionEnabled()
            ? this.socket.io.reconnectionAttempts()
            : 0;
        const getMaxAllowedInternalSocketConnectionFailures = () => getMaxInternalSocketReconnectionAttempts() + 1;
        this._details = await new Promise((resolve, reject) => {
            const fail = (socketProtocolError, err) => {
                this.disposeCore(socketProtocolError, err);
                reject(err);
            };
            // Listen for connection issues
            this.addConnectionListener("connect_error", (error) => {
                var _a;
                internalSocketConnectionFailureCount++;
                let isWebSocketTransportError = false;
                try {
                    const description = error === null || error === void 0 ? void 0 : error.description;
                    if (description && typeof description === "object") {
                        if (error.type === "TransportError") {
                            isWebSocketTransportError = true;
                        }
                        // That's a WebSocket. Clear it as we can't log it.
                        description.target = undefined;
                    }
                }
                catch (_e) { }
                // Handle socket transport downgrading when not offline.
                if (isWebSocketTransportError &&
                    this.enableLongPollingDowngrades &&
                    ((_a = this.socket.io.opts.transports) === null || _a === void 0 ? void 0 : _a[0]) !== "polling") {
                    // Downgrade transports to polling upgrade mechanism.
                    this.socket.io.opts.transports = ["polling", "websocket"];
                    // Don't alter reconnection behavior if already enabled.
                    if (!isInternalSocketReconnectionEnabled()) {
                        // Allow single reconnection attempt using polling upgrade mechanism.
                        this.socket.io.reconnection(true);
                        this.socket.io.reconnectionAttempts(1);
                    }
                }
                // Allow built-in socket.io reconnection handling.
                if (isInternalSocketReconnectionEnabled() &&
                    internalSocketConnectionFailureCount < getMaxAllowedInternalSocketConnectionFailures()) {
                    // Reconnection is enabled and maximum reconnect attempts have not been reached.
                    return;
                }
                fail(true, this.createErrorObject("connect_error", error));
            });
            // Listen for timeouts
            this.addConnectionListener("connect_timeout", () => {
                fail(true, this.createErrorObject("connect_timeout"));
            });
            this.addConnectionListener("connect_document_success", (response) => {
                // If we sent a nonce and the server supports nonces, check that the nonces match
                if (connectMessage.nonce !== undefined &&
                    response.nonce !== undefined &&
                    response.nonce !== connectMessage.nonce) {
                    return;
                }
                const requestedMode = connectMessage.mode;
                const actualMode = response.mode;
                const writingPermitted = response.claims.scopes.includes(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_6__.ScopeType.DocWrite);
                if (writingPermitted) {
                    // The only time we expect a mismatch in requested/actual is if we lack write permissions
                    // In this case we will get "read", even if we requested "write"
                    if (actualMode !== requestedMode) {
                        fail(false, this.createErrorObject("connect_document_success", "Connected in a different mode than was requested", false));
                        return;
                    }
                }
                else {
                    if (actualMode === "write") {
                        fail(false, this.createErrorObject("connect_document_success", "Connected in write mode without write permissions", false));
                        return;
                    }
                }
                this.checkpointSequenceNumber = response.checkpointSequenceNumber;
                this.removeConnectionListeners();
                resolve(response);
            });
            // Socket can be disconnected while waiting for Fluid protocol messages
            // (connect_document_error / connect_document_success), as well as before DeltaManager
            // had a chance to register its handlers.
            this.addTrackedListener("disconnect", (reason) => {
                const err = this.createErrorObject("disconnect", reason);
                this.emit("disconnect", err);
                fail(true, err);
            });
            this.addTrackedListener("error", ((error) => {
                // First, raise an error event, to give clients a chance to observe error contents
                // This includes "Invalid namespace" error, which we consider critical (reconnecting will not help)
                const err = this.createErrorObject("error", error, error !== "Invalid namespace");
                this.emit("error", err);
                // Disconnect socket - required if happened before initial handshake
                fail(true, err);
            }));
            this.addConnectionListener("connect_document_error", ((error) => {
                // If we sent a nonce and the server supports nonces, check that the nonces match
                if (connectMessage.nonce !== undefined &&
                    error.nonce !== undefined &&
                    error.nonce !== connectMessage.nonce) {
                    return;
                }
                // This is not an socket.io error - it's Fluid protocol error.
                // In this case fail connection and indicate that we were unable to create connection
                fail(false, this.createErrorObject("connect_document_error", error));
            }));
            this.socket.emit("connect_document", connectMessage);
            // Give extra 2 seconds for handshake on top of socket connection timeout
            this.socketConnectionTimeout = setTimeout(() => {
                fail(false, this.createErrorObject("orderingServiceHandshakeTimeout"));
            }, timeout + 2000);
        });
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.disposed, 0x246 /* "checking consistency of socket & _disposed flags" */);
    }
    removeEarlyOpHandler() {
        this.socket.removeListener("op", this.earlyOpHandler);
        this.earlyOpHandlerAttached = false;
    }
    removeEarlySignalHandler() {
        this.socket.removeListener("signal", this.earlySignalHandler);
    }
    addConnectionListener(event, listener) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!DocumentDeltaConnection.eventsAlwaysForwarded.includes(event), 0x247 /* "Use addTrackedListener instead" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!DocumentDeltaConnection.eventsToForward.includes(event), 0x248 /* "should not subscribe to forwarded events" */);
        this.socket.on(event, listener);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.connectionListeners.has(event), 0x20d /* "double connection listener" */);
        this.connectionListeners.set(event, listener);
    }
    addTrackedListener(event, listener) {
        this.socket.on(event, listener);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.trackedListeners.has(event), 0x20e /* "double tracked listener" */);
        this.trackedListeners.set(event, listener);
    }
    removeTrackedListeners() {
        for (const [event, listener] of this.trackedListeners.entries()) {
            this.socket.off(event, listener);
        }
        // removeTrackedListeners removes all listeners, including connection listeners
        this.removeConnectionListeners();
        this.removeEarlyOpHandler();
        this.removeEarlySignalHandler();
        this.trackedListeners.clear();
    }
    removeConnectionListeners() {
        if (this.socketConnectionTimeout !== undefined) {
            clearTimeout(this.socketConnectionTimeout);
        }
        for (const [event, listener] of this.connectionListeners.entries()) {
            this.socket.off(event, listener);
        }
        this.connectionListeners.clear();
    }
    /**
     * Error raising for socket.io issues
     */
    createErrorObject(handler, error, canRetry = true) {
        // Note: we suspect the incoming error object is either:
        // - a string: log it in the message (if not a string, it may contain PII but will print as [object Object])
        // - an Error object thrown by socket.io engine. Be careful with not recording PII!
        let message;
        if ((error === null || error === void 0 ? void 0 : error.type) === "TransportError") {
            // JSON.stringify drops Error.message
            const messagePrefix = ((error === null || error === void 0 ? void 0 : error.message) !== undefined)
                ? `${error.message}: `
                : "";
            // Websocket errors reported by engine.io-client.
            // They are Error objects with description containing WS error and description = "TransportError"
            // Please see https://github.com/socketio/engine.io-client/blob/7245b80/lib/transport.ts#L44,
            message = `${messagePrefix}${JSON.stringify(error, (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.getCircularReplacer)())}`;
        }
        else {
            message = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_8__.extractLogSafeErrorProperties)(error).message;
        }
        const errorObj = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_4__.createGenericNetworkError)(`socket.io (${handler}): ${message}`, { canRetry }, { driverVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_5__.pkgVersion });
        return errorObj;
    }
}
DocumentDeltaConnection.eventsToForward = ["nack", "op", "signal", "pong"];
// WARNING: These are critical events that we can't miss, so registration for them has to be in place at all times!
// Including before handshake is over, and after that (but before DeltaManager had a chance to put its own handlers)
DocumentDeltaConnection.eventsAlwaysForwarded = ["disconnect", "error"];
//# sourceMappingURL=documentDeltaConnection.js.map

/***/ }),
/* 464 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 465 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/driver-base";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 466 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScopeType": () => (/* binding */ ScopeType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var ScopeType;
(function (ScopeType) {
    ScopeType["DocRead"] = "doc:read";
    ScopeType["DocWrite"] = "doc:write";
    ScopeType["SummaryWrite"] = "summary:write";
})(ScopeType || (ScopeType = {}));
//# sourceMappingURL=scopes.js.map

/***/ }),
/* 467 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTelemetryNullLogger": () => (/* binding */ BaseTelemetryNullLogger),
/* harmony export */   "TelemetryNullLogger": () => (/* binding */ TelemetryNullLogger),
/* harmony export */   "extractLogSafeErrorProperties": () => (/* binding */ extractLogSafeErrorProperties)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class BaseTelemetryNullLogger {
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        return;
    }
}
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryNullLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
    }
    sendPerformanceEvent(event, error) {
    }
}
function extractLogSafeErrorProperties(error) {
    const isRegularObject = (value) => {
        return value !== null && !Array.isArray(value) && typeof value === "object";
    };
    const removeMessageFromStack = (stack, errorName) => {
        const stackFrames = stack.split("\n");
        stackFrames.shift(); // Remove "[ErrorName]: [ErrorMessage]"
        if (errorName !== undefined) {
            stackFrames.unshift(errorName); // Add "[ErrorName]"
        }
        return stackFrames.join("\n");
    };
    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === "string")
        ? error.message
        : String(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack, name } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            const errorName = (typeof name === "string") ? name : undefined;
            safeProps.stack = removeMessageFromStack(stack, errorName);
        }
    }
    return safeProps;
}
//# sourceMappingURL=logger.js.map

/***/ }),
/* 468 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     * Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 469 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Loader": () => (/* binding */ Loader),
/* harmony export */   "RelativeLoader": () => (/* binding */ RelativeLoader)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(550);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(551);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(552);
/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(470);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(499);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(540);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */







function canUseCache(request) {
    if (request.headers === undefined) {
        return true;
    }
    return request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.cache] !== false;
}
class RelativeLoader {
    constructor(container, loader) {
        this.container = container;
        this.loader = loader;
    }
    get IFluidRouter() { return this; }
    async resolve(request) {
        var _a, _b, _c, _d, _e;
        if (request.url.startsWith("/")) {
            if (canUseCache(request)) {
                return this.container;
            }
            else {
                const resolvedUrl = this.container.resolvedUrl;
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);
                const container = await _container__WEBPACK_IMPORTED_MODULE_2__.Container.load(this.loader, {
                    canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.reconnect],
                    clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.clientDetails],
                    resolvedUrl: Object.assign({}, resolvedUrl),
                    version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,
                    loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.loadMode],
                });
                return container;
            }
        }
        if (this.loader === undefined) {
            throw new Error("Cannot resolve external containers");
        }
        return this.loader.resolve(request);
    }
    async request(request) {
        if (request.url.startsWith("/")) {
            const container = await this.resolve(request);
            return container.request(request);
        }
        if (this.loader === undefined) {
            return {
                status: 404,
                value: "Cannot request external containers",
                mimeType: "plain/text",
            };
        }
        return this.loader.request(request);
    }
}
function createCachedResolver(resolver) {
    const cacheResolver = Object.create(resolver);
    const resolveCache = new Map();
    cacheResolver.resolve = async (request) => {
        if (!canUseCache(request)) {
            return resolver.resolve(request);
        }
        if (!resolveCache.has(request.url)) {
            resolveCache.set(request.url, resolver.resolve(request));
        }
        return resolveCache.get(request.url);
    };
    return cacheResolver;
}
/**
 * Manages Fluid resource loading
 */
class Loader {
    constructor(loaderProps) {
        var _a, _b;
        this.containers = new Map();
        const scope = Object.assign({}, loaderProps.scope);
        if (((_a = loaderProps.options) === null || _a === void 0 ? void 0 : _a.provideScopeLoader) !== false) {
            scope.ILoader = this;
        }
        const telemetryProps = {
            loaderId: (0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(),
            loaderVersion: _packageVersion__WEBPACK_IMPORTED_MODULE_4__.pkgVersion,
        };
        const subMc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.mixinMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.DebugLogger.mixinDebugLogger("fluid:telemetry", loaderProps.logger, { all: telemetryProps }), _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.sessionStorageConfigProvider.value, loaderProps.configProvider);
        this.services = {
            urlResolver: createCachedResolver(_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_7__.MultiUrlResolver.create(loaderProps.urlResolver)),
            documentServiceFactory: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_8__.MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),
            codeLoader: loaderProps.codeLoader,
            options: (_b = loaderProps.options) !== null && _b !== void 0 ? _b : {},
            scope,
            subLogger: subMc.logger,
            detachedBlobStorage: loaderProps.detachedBlobStorage,
        };
        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.ChildLogger.create(this.services.subLogger, "Loader"));
    }
    get IFluidRouter() { return this; }
    async createDetachedContainer(codeDetails) {
        const container = await _container__WEBPACK_IMPORTED_MODULE_2__.Container.createDetached(this, codeDetails);
        if (this.cachingEnabled) {
            container.once("attached", () => {
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(container.resolvedUrl);
                const parsedUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.parseUrl)(container.resolvedUrl.url);
                if (parsedUrl !== undefined) {
                    this.addToContainerCache(parsedUrl.id, Promise.resolve(container));
                }
            });
        }
        return container;
    }
    async rehydrateDetachedContainerFromSnapshot(snapshot) {
        return _container__WEBPACK_IMPORTED_MODULE_2__.Container.rehydrateDetachedFromSnapshot(this, snapshot);
    }
    async resolve(request, pendingLocalState) {
        const eventName = pendingLocalState === undefined ? "Resolve" : "ResolveWithPendingState";
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName }, async () => {
            const resolved = await this.resolveCore(request, pendingLocalState !== undefined ? JSON.parse(pendingLocalState) : undefined);
            return resolved.container;
        });
    }
    async request(request) {
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_9__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: "Request" }, async () => {
            const resolved = await this.resolveCore(request);
            return resolved.container.request(Object.assign(Object.assign({}, request), { url: `${resolved.parsed.path}${resolved.parsed.query}` }));
        });
    }
    getKeyForContainerCache(request, parsedUrl) {
        var _a;
        const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]) !== undefined
            ? `${parsedUrl.id}@${request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]}`
            : parsedUrl.id;
        return key;
    }
    addToContainerCache(key, containerP) {
        this.containers.set(key, containerP);
        containerP.then((container) => {
            // If the container is closed or becomes closed after we resolve it, remove it from the cache.
            if (container.closed) {
                this.containers.delete(key);
            }
            else {
                container.once("closed", () => {
                    this.containers.delete(key);
                });
            }
        }).catch((error) => { });
    }
    async resolveCore(request, pendingLocalState) {
        const resolvedAsFluid = await this.services.urlResolver.resolve(request);
        (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedAsFluid);
        // Parse URL into data stores
        const parsed = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.parseUrl)(resolvedAsFluid.url);
        if (parsed === undefined) {
            throw new Error(`Invalid URL ${resolvedAsFluid.url}`);
        }
        if (pendingLocalState !== undefined) {
            const parsedPendingUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.parseUrl)(pendingLocalState.url);
            if ((parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.id) !== parsed.id ||
                (parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.path.replace(/\/$/, "")) !== parsed.path.replace(/\/$/, "")) {
                const message = `URL ${resolvedAsFluid.url} does not match pending state URL ${pendingLocalState.url}`;
                throw new Error(message);
            }
        }
        const { canCache, fromSequenceNumber } = this.parseHeader(parsed, request);
        const shouldCache = pendingLocalState !== undefined ? false : canCache;
        let container;
        if (shouldCache) {
            const key = this.getKeyForContainerCache(request, parsed);
            const maybeContainer = await this.containers.get(key);
            if (maybeContainer !== undefined) {
                container = maybeContainer;
            }
            else {
                const containerP = this.loadContainer(request, resolvedAsFluid);
                this.addToContainerCache(key, containerP);
                container = await containerP;
            }
        }
        else {
            container =
                await this.loadContainer(request, resolvedAsFluid, pendingLocalState);
        }
        if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {
            await new Promise((resolve, reject) => {
                function opHandler(message) {
                    if (message.sequenceNumber > fromSequenceNumber) {
                        resolve();
                        container.removeListener("op", opHandler);
                    }
                }
                container.on("op", opHandler);
            });
        }
        return { container, parsed };
    }
    get cachingEnabled() {
        return this.services.options.cache !== false;
    }
    canCacheForRequest(headers) {
        return this.cachingEnabled && headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.cache] !== false;
    }
    parseHeader(parsed, request) {
        var _a, _b;
        let fromSequenceNumber = -1;
        request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
        const headerSeqNum = request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.sequenceNumber];
        if (headerSeqNum !== undefined) {
            fromSequenceNumber = headerSeqNum;
        }
        // If set in both query string and headers, use query string
        request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version] = (_b = parsed.version) !== null && _b !== void 0 ? _b : request.headers[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version];
        const canCache = this.canCacheForRequest(request.headers);
        return {
            canCache,
            fromSequenceNumber,
        };
    }
    async loadContainer(request, resolved, pendingLocalState) {
        var _a, _b, _c, _d, _e;
        return _container__WEBPACK_IMPORTED_MODULE_2__.Container.load(this, {
            canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.reconnect],
            clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.clientDetails],
            resolvedUrl: resolved,
            version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,
            loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.LoaderHeader.loadMode],
        }, pendingLocalState);
    }
}
//# sourceMappingURL=loader.js.map

/***/ }),
/* 470 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Container": () => (/* binding */ Container),
/* harmony export */   "waitContainerToCatchUp": () => (/* binding */ waitContainerToCatchUp)
/* harmony export */ });
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(471);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(27);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(492);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(525);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(527);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(338);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(332);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(452);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(78);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(117);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(64);
/* harmony import */ var _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(534);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(498);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(539);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(132);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(45);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(46);
/* harmony import */ var _audience__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(493);
/* harmony import */ var _containerContext__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(548);
/* harmony import */ var _contracts__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(526);
/* harmony import */ var _deltaManager__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(541);
/* harmony import */ var _deltaManagerProxy__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(549);
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(469);
/* harmony import */ var _packageVersion__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(540);
/* harmony import */ var _connectionStateHandler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(494);
/* harmony import */ var _retriableDocumentStorageService__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(532);
/* harmony import */ var _protocolTreeDocumentStorageService__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(533);
/* harmony import */ var _containerStorageAdapter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(497);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(499);
/* harmony import */ var _quorum__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(528);
/* harmony import */ var _collabWindowTracker__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(547);
/* harmony import */ var _connectionManager__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(545);
/* harmony import */ var _connectionState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
// eslint-disable-next-line import/no-internal-modules

























const detachedContainerRefSeqNumber = 0;
const dirtyContainerEvent = "dirty";
const savedContainerEvent = "saved";
/**
 * Waits until container connects to delta storage and gets up-to-date
 * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being
 * up to date. Host may chose to wait in such case and retry resolving URI.
 * Warning: Will wait infinitely for connection to establish if there is no connection.
 * May result in deadlock if Container.disconnect() is called and never followed by a call to Container.connect().
 * @returns true: container is up to date, it processed all the ops that were know at the time of first connection
 *          false: storage does not provide indication of how far the client is. Container processed
 *          all the ops known to it, but it maybe still behind.
 * @throws an error beginning with `"Container closed"` if the container is closed before it catches up.
 */
async function waitContainerToCatchUp(container) {
    // Make sure we stop waiting if container is closed.
    if (container.closed) {
        throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError("waitContainerToCatchUp: Container closed");
    }
    return new Promise((resolve, reject) => {
        const deltaManager = container.deltaManager;
        const closedCallback = (err) => {
            container.off("closed", closedCallback);
            const baseMessage = "Container closed while waiting to catch up";
            reject(err !== undefined
                ? (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.wrapError)(err, (innerMessage) => new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(`${baseMessage}: ${innerMessage}`))
                : new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError(baseMessage));
        };
        container.on("closed", closedCallback);
        const waitForOps = () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.CatchingUp
                || container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected, 0x0cd /* "Container disconnected while waiting for ops!" */);
            const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;
            const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(deltaManager.lastSequenceNumber <= connectionOpSeqNumber, 0x266 /* "lastKnownSeqNumber should never be below last processed sequence number" */);
            if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {
                container.off("closed", closedCallback);
                resolve(hasCheckpointSequenceNumber);
                return;
            }
            const callbackOps = (message) => {
                if (connectionOpSeqNumber <= message.sequenceNumber) {
                    container.off("closed", closedCallback);
                    resolve(hasCheckpointSequenceNumber);
                    deltaManager.off("op", callbackOps);
                }
            };
            deltaManager.on("op", callbackOps);
        };
        // We can leverage DeltaManager's "connect" event here and test for ConnectionState.Disconnected
        // But that works only if service provides us checkPointSequenceNumber
        // Our internal testing is based on R11S that does not, but almost all tests connect as "write" and
        // use this function to catch up, so leveraging our own join op as a fence/barrier
        if (container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {
            waitForOps();
            return;
        }
        const callback = () => {
            container.off(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.connectedEventName, callback);
            waitForOps();
        };
        container.on(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.connectedEventName, callback);
        if (container.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected) {
            container.connect();
        }
    });
}
const getCodeProposal = 
// eslint-disable-next-line @typescript-eslint/no-unsafe-return
(quorum) => { var _a; return (_a = quorum.get("code")) !== null && _a !== void 0 ? _a : quorum.get("code2"); };
/**
 * Helper function to report to telemetry cases where operation takes longer than expected (1s)
 * @param logger - logger to use
 * @param eventName - event name
 * @param action - functor to call and measure
 */
async function ReportIfTooLong(logger, eventName, action) {
    const event = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.start(logger, { eventName });
    const props = await action();
    if (event.duration > 1000) {
        event.end(props);
    }
}
const summarizerClientType = "summarizer";
class Container extends _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_7__.EventEmitterWithErrorHandling {
    constructor(loader, config) {
        var _a, _b;
        super((name, error) => {
            this.mc.logger.sendErrorEvent({
                eventName: "ContainerEventHandlerException",
                name: typeof name === "string" ? name : undefined,
            }, error);
        });
        this.loader = loader;
        // Tells if container can reconnect on losing fist connection
        // If false, container gets closed on loss of connection.
        this._canReconnect = true;
        this._lifecycleState = "loading";
        this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached;
        /** During initialization we pause the inbound queues. We track this state to ensure we only call resume once */
        this.inboundQueuePausedFromInit = true;
        this.firstConnection = true;
        this.connectionTransitionTimes = [];
        this.messageCountAfterDisconnection = 0;
        this.attachStarted = false;
        this._dirtyContainer = false;
        this.setAutoReconnectTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();
        this._audience = new _audience__WEBPACK_IMPORTED_MODULE_10__.Audience();
        this.clientDetailsOverride = config.clientDetailsOverride;
        this._resolvedUrl = config.resolvedUrl;
        if (config.canReconnect !== undefined) {
            this._canReconnect = config.canReconnect;
        }
        // Create logger for data stores to use
        const type = this.client.details.type;
        const interactive = this.client.details.capabilities.interactive;
        const clientType = `${interactive ? "interactive" : "noninteractive"}${type !== undefined && type !== "" ? `/${type}` : ""}`;
        // Need to use the property getter for docId because for detached flow we don't have the docId initially.
        // We assign the id later so property getter is used.
        this.subLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(loader.services.subLogger, undefined, {
            all: {
                clientType,
                containerId: (0,uuid__WEBPACK_IMPORTED_MODULE_11__["default"])(),
                docId: () => { var _a, _b; return (_b = (_a = this._resolvedUrl) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : undefined; },
                containerAttachState: () => this._attachState,
                containerLifecycleState: () => this._lifecycleState,
                containerConnectionState: () => _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[this.connectionState],
                serializedContainer: config.serializedContainerState !== undefined,
            },
            // we need to be judicious with our logging here to avoid generating too much data
            // all data logged here should be broadly applicable, and not specific to a
            // specific error or class of errors
            error: {
                // load information to associate errors with the specific load point
                dmInitialSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.initialSequenceNumber; },
                dmLastProcessedSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastSequenceNumber; },
                dmLastKnownSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastKnownSeqNumber; },
                containerLoadedFromVersionId: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.id; },
                containerLoadedFromVersionDate: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.date; },
                // message information to associate errors with the specific execution state
                // dmLastMsqSeqNumber: if present, same as dmLastProcessedSeqNumber
                dmLastMsqSeqNumber: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber; },
                dmLastMsqSeqTimestamp: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp; },
                dmLastMsqSeqClientId: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.clientId; },
                connectionStateDuration: () => _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - this.connectionTransitionTimes[this.connectionState],
            },
        });
        // Prefix all events in this file with container-loader
        this.mc = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_12__.loggerToMonitoringContext)(_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, "Container"));
        const summarizeProtocolTree = (_a = this.mc.config.getBoolean("Fluid.Container.summarizeProtocolTree")) !== null && _a !== void 0 ? _a : this.loader.services.options.summarizeProtocolTree;
        this.options = Object.assign(Object.assign({}, this.loader.services.options), { summarizeProtocolTree });
        this.connectionStateHandler = new _connectionStateHandler__WEBPACK_IMPORTED_MODULE_13__.ConnectionStateHandler({
            quorumClients: () => { var _a; return (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum; },
            logConnectionStateChangeTelemetry: (value, oldState, reason) => this.logConnectionStateChangeTelemetry(value, oldState, reason),
            shouldClientJoinWrite: () => this._deltaManager.connectionManager.shouldJoinWrite(),
            maxClientLeaveWaitTime: this.loader.services.options.maxClientLeaveWaitTime,
            logConnectionIssue: (eventName, details) => {
                // We get here when socket does not receive any ops on "write" connection, including
                // its own join op. Attempt recovery option.
                this._deltaManager.logConnectionIssue(Object.assign({ eventName, duration: _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.CatchingUp] }, (details === undefined ? {} : { details: JSON.stringify(details) })));
            },
            connectionStateChanged: () => {
                // Fire events only if container is fully loaded and not closed
                if (this._lifecycleState === "loaded") {
                    this.propagateConnectionState();
                }
            },
        }, this.mc.logger, (_b = config.serializedContainerState) === null || _b === void 0 ? void 0 : _b.clientId);
        this.on(savedContainerEvent, () => {
            this.connectionStateHandler.containerSaved();
        });
        this._deltaManager = this.createDeltaManager();
        this._storage = new _containerStorageAdapter__WEBPACK_IMPORTED_MODULE_14__.ContainerStorageAdapter(() => {
            if (this.attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached) {
                if (this.loader.services.detachedBlobStorage !== undefined) {
                    return new _containerStorageAdapter__WEBPACK_IMPORTED_MODULE_14__.BlobOnlyStorage(this.loader.services.detachedBlobStorage, this.mc.logger);
                }
                this.mc.logger.sendErrorEvent({
                    eventName: "NoRealStorageInDetachedContainer",
                });
                throw new Error("Real storage calls not allowed in Unattached container");
            }
            return this.storageService;
        });
        const isDomAvailable = typeof document === "object" &&
            document !== null &&
            typeof document.addEventListener === "function" &&
            document.addEventListener !== null;
        // keep track of last time page was visible for telemetry
        if (isDomAvailable) {
            this.lastVisible = document.hidden ? _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() : undefined;
            this.visibilityEventHandler = () => {
                if (document.hidden) {
                    this.lastVisible = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();
                }
                else {
                    // settimeout so this will hopefully fire after disconnect event if being hidden caused it
                    setTimeout(() => { this.lastVisible = undefined; }, 0);
                }
            };
            document.addEventListener("visibilitychange", this.visibilityEventHandler);
        }
        // We observed that most users of platform do not check Container.connected event on load, causing bugs.
        // As such, we are raising events when new listener pops up.
        // Note that we can raise both "disconnected" & "connect" events at the same time,
        // if we are in connecting stage.
        this.on("newListener", (event, listener) => {
            // Fire events on the end of JS turn, giving a chance for caller to be in consistent state.
            Promise.resolve().then(() => {
                switch (event) {
                    case dirtyContainerEvent:
                        if (this._dirtyContainer) {
                            listener();
                        }
                        break;
                    case savedContainerEvent:
                        if (!this._dirtyContainer) {
                            listener();
                        }
                        break;
                    case _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.connectedEventName:
                        if (this.connected) {
                            listener(this.clientId);
                        }
                        break;
                    case _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.disconnectedEventName:
                        if (!this.connected) {
                            listener();
                        }
                        break;
                    default:
                }
            }).catch((error) => {
                this.mc.logger.sendErrorEvent({ eventName: "RaiseConnectedEventError" }, error);
            });
        });
    }
    /**
     * Load an existing container.
     */
    static async load(loader, loadOptions, pendingLocalState) {
        const container = new Container(loader, {
            clientDetailsOverride: loadOptions.clientDetailsOverride,
            resolvedUrl: loadOptions.resolvedUrl,
            canReconnect: loadOptions.canReconnect,
            serializedContainerState: pendingLocalState,
        });
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: "Load" }, async (event) => new Promise((resolve, reject) => {
            var _a, _b;
            const version = loadOptions.version;
            const defaultMode = { opsBeforeReturn: "cached" };
            // if we have pendingLocalState, anything we cached is not useful and we shouldn't wait for connection
            // to return container, so ignore this value and use undefined for opsBeforeReturn
            const mode = pendingLocalState
                ? Object.assign(Object.assign({}, ((_a = loadOptions.loadMode) !== null && _a !== void 0 ? _a : defaultMode)), { opsBeforeReturn: undefined }) : (_b = loadOptions.loadMode) !== null && _b !== void 0 ? _b : defaultMode;
            const onClosed = (err) => {
                // pre-0.58 error message: containerClosedWithoutErrorDuringLoad
                reject(err !== null && err !== void 0 ? err : new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError("Container closed without error during load"));
            };
            container.on("closed", onClosed);
            container.load(version, mode, pendingLocalState)
                .finally(() => {
                container.removeListener("closed", onClosed);
            })
                .then((props) => {
                event.end(Object.assign(Object.assign({}, props), loadOptions.loadMode));
                resolve(container);
            }, (error) => {
                const err = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeError)(error);
                // Depending where error happens, we can be attempting to connect to web socket
                // and continuously retrying (consider offline mode)
                // Host has no container to close, so it's prudent to do it here
                container.close(err);
                onClosed(err);
            });
        }), { start: true, end: true, cancel: "generic" });
    }
    /**
     * Create a new container in a detached state.
     */
    static async createDetached(loader, codeDetails) {
        const container = new Container(loader, {});
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: "CreateDetached" }, async (_event) => {
            await container.createDetached(codeDetails);
            return container;
        }, { start: true, end: true, cancel: "generic" });
    }
    /**
     * Create a new container in a detached state that is initialized with a
     * snapshot from a previous detached container.
     */
    static async rehydrateDetachedFromSnapshot(loader, snapshot) {
        const container = new Container(loader, {});
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: "RehydrateDetachedFromSnapshot" }, async (_event) => {
            const deserializedSummary = JSON.parse(snapshot);
            await container.rehydrateDetachedFromSnapshot(deserializedSummary);
            return container;
        }, { start: true, end: true, cancel: "generic" });
    }
    setLoaded() {
        // It's conceivable the container could be closed when this is called
        // Only transition states if currently loading
        if (this._lifecycleState === "loading") {
            // Propagate current connection state through the system.
            this.propagateConnectionState();
            this._lifecycleState = "loaded";
        }
    }
    get closed() {
        return (this._lifecycleState === "closing" || this._lifecycleState === "closed");
    }
    get storage() {
        return this._storage;
    }
    get storageService() {
        if (this._storageService === undefined) {
            throw new Error("Attempted to access storageService before it was defined");
        }
        return this._storageService;
    }
    get context() {
        if (this._context === undefined) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError("Attempted to access context before it was defined");
        }
        return this._context;
    }
    get protocolHandler() {
        if (this._protocolHandler === undefined) {
            throw new Error("Attempted to access protocolHandler before it was defined");
        }
        return this._protocolHandler;
    }
    get connectionMode() { return this._deltaManager.connectionManager.connectionMode; }
    get IFluidRouter() { return this; }
    get resolvedUrl() {
        return this._resolvedUrl;
    }
    get loadedFromVersion() {
        return this._loadedFromVersion;
    }
    get readOnlyInfo() {
        return this._deltaManager.readOnlyInfo;
    }
    get closeSignal() {
        return this._deltaManager.closeAbortController.signal;
    }
    /**
     * Tracks host requiring read-only mode.
     */
    forceReadonly(readonly) {
        this._deltaManager.connectionManager.forceReadonly(readonly);
    }
    get deltaManager() {
        return this._deltaManager;
    }
    get connectionState() {
        return this.connectionStateHandler.connectionState;
    }
    get connected() {
        return this.connectionStateHandler.connected;
    }
    /**
     * Service configuration details. If running in offline mode will be undefined otherwise will contain service
     * configuration details returned as part of the initial connection.
     */
    get serviceConfiguration() {
        return this._deltaManager.serviceConfiguration;
    }
    /**
     * The server provided id of the client.
     * Set once this.connected is true, otherwise undefined
     */
    get clientId() {
        return this.connectionStateHandler.clientId;
    }
    /**
     * The server provided claims of the client.
     * Set once this.connected is true, otherwise undefined
     */
    get scopes() {
        return this._deltaManager.connectionManager.scopes;
    }
    get clientDetails() {
        return this._deltaManager.clientDetails;
    }
    /**
     * Get the code details that are currently specified for the container.
     * @returns The current code details if any are specified, undefined if none are specified.
     */
    getSpecifiedCodeDetails() {
        return this.getCodeDetailsFromQuorum();
    }
    /**
     * Get the code details that were used to load the container.
     * @returns The code details that were used to load the container if it is loaded, undefined if it is not yet
     * loaded.
     */
    getLoadedCodeDetails() {
        var _a;
        return (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails;
    }
    /**
     * Retrieves the audience associated with the document
     */
    get audience() {
        return this._audience;
    }
    /**
     * Returns true if container is dirty.
     * Which means data loss if container is closed at that same moment
     * Most likely that happens when there is no network connection to ordering service
     */
    get isDirty() {
        return this._dirtyContainer;
    }
    get serviceFactory() { return this.loader.services.documentServiceFactory; }
    get urlResolver() { return this.loader.services.urlResolver; }
    get scope() { return this.loader.services.scope; }
    get codeLoader() { return this.loader.services.codeLoader; }
    /**
     * Retrieves the quorum associated with the document
     */
    getQuorum() {
        return this.protocolHandler.quorum;
    }
    close(error) {
        // 1. Ensure that close sequence is exactly the same no matter if it's initiated by host or by DeltaManager
        // 2. We need to ensure that we deliver disconnect event to runtime properly. See connectionStateChanged
        //    handler. We only deliver events if container fully loaded. Transitioning from "loading" ->
        //    "closing" will lose that info (can also solve by tracking extra state).
        this._deltaManager.close(error);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected, 0x0cf /* "disconnect event was not raised!" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._lifecycleState === "closed", 0x314 /* Container properly closed */);
    }
    closeCore(error) {
        var _a, _b, _c, _d;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x315 /* re-entrancy */);
        try {
            // Ensure that we raise all key events even if one of these throws
            try {
                // Raise event first, to ensure we capture _lifecycleState before transition.
                // This gives us a chance to know what errors happened on open vs. on fully loaded container.
                this.mc.logger.sendTelemetryEvent({
                    eventName: "ContainerClose",
                    category: error === undefined ? "generic" : "error",
                }, error);
                this._lifecycleState = "closing";
                (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();
                this.connectionStateHandler.dispose();
                (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);
                (_c = this._storageService) === null || _c === void 0 ? void 0 : _c.dispose();
                // Notify storage about critical errors. They may be due to disconnect between client & server knowledge
                // about file, like file being overwritten in storage, but client having stale local cache.
                // Driver need to ensure all caches are cleared on critical errors
                (_d = this.service) === null || _d === void 0 ? void 0 : _d.dispose(error);
            }
            catch (exception) {
                this.mc.logger.sendErrorEvent({ eventName: "ContainerCloseException" }, exception);
            }
            this.emit("closed", error);
            this.removeAllListeners();
            if (this.visibilityEventHandler !== undefined) {
                document.removeEventListener("visibilitychange", this.visibilityEventHandler);
            }
        }
        finally {
            this._lifecycleState = "closed";
        }
    }
    closeAndGetPendingLocalState() {
        // runtime matches pending ops to successful ones by clientId and client seq num, so we need to close the
        // container at the same time we get pending state, otherwise this container could reconnect and resubmit with
        // a new clientId and a future container using stale pending state without the new clientId would resubmit them
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached, 0x0d1 /* "Container should be attached before close" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.resolvedUrl !== undefined && this.resolvedUrl.type === "fluid", 0x0d2 /* "resolved url should be valid Fluid url" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this._protocolHandler, 0x2e3 /* "Must have a valid protocol handler instance" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._protocolHandler.attributes.term !== undefined, 0x30b /* Must have a valid protocol handler instance */);
        const pendingState = {
            pendingRuntimeState: this.context.getPendingLocalState(),
            url: this.resolvedUrl.url,
            protocol: this.protocolHandler.getProtocolState(),
            term: this._protocolHandler.attributes.term,
            clientId: this.clientId,
        };
        this.close();
        return JSON.stringify(pendingState);
    }
    get attachState() {
        return this._attachState;
    }
    serialize() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached, 0x0d3 /* "Should only be called in detached container" */);
        const appSummary = this.context.createSummary();
        const protocolSummary = this.captureProtocolSummary();
        const combinedSummary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);
        if (this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0) {
            combinedSummary.tree[".hasAttachmentBlobs"] = { type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob, content: "true" };
        }
        return JSON.stringify(combinedSummary);
    }
    async attach(request) {
        await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: "Attach" }, async () => {
            if (this._lifecycleState !== "loaded") {
                // pre-0.58 error message: containerNotValidForAttach
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is not in a valid state for attach [${this._lifecycleState}]`);
            }
            // If container is already attached or attach is in progress, throw an error.
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Detached && !this.attachStarted, 0x205 /* "attach() called more than once" */);
            this.attachStarted = true;
            // If attachment blobs were uploaded in detached state we will go through a different attach flow
            const hasAttachmentBlobs = this.loader.services.detachedBlobStorage !== undefined
                && this.loader.services.detachedBlobStorage.size > 0;
            try {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.deltaManager.inbound.length === 0, 0x0d6 /* "Inbound queue should be empty when attaching" */);
                let summary;
                if (!hasAttachmentBlobs) {
                    // Get the document state post attach - possibly can just call attach but we need to change the
                    // semantics around what the attach means as far as async code goes.
                    const appSummary = this.context.createSummary();
                    const protocolSummary = this.captureProtocolSummary();
                    summary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);
                    // Set the state as attaching as we are starting the process of attaching container.
                    // This should be fired after taking the summary because it is the place where we are
                    // starting to attach the container to storage.
                    // Also, this should only be fired in detached container.
                    this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attaching;
                    this.context.notifyAttaching((0,_utils__WEBPACK_IMPORTED_MODULE_17__.getSnapshotTreeFromSerializedContainer)(summary));
                }
                // Actually go and create the resolved document
                const createNewResolvedUrl = await this.urlResolver.resolve(request);
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.ensureFluidResolvedUrl)(createNewResolvedUrl);
                if (this.service === undefined) {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.client.details.type !== summarizerClientType, 0x2c4 /* "client should not be summarizer before container is created" */);
                    this.service = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_19__.runWithRetry)(async () => this.serviceFactory.createContainer(summary, createNewResolvedUrl, this.subLogger, false), "containerAttach", this.mc.logger, {
                        cancel: this.closeSignal,
                    });
                }
                const resolvedUrl = this.service.resolvedUrl;
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.ensureFluidResolvedUrl)(resolvedUrl);
                this._resolvedUrl = resolvedUrl;
                await this.connectStorageService();
                if (hasAttachmentBlobs) {
                    // upload blobs to storage
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.loader.services.detachedBlobStorage, 0x24e /* "assertion for type narrowing" */);
                    // build a table mapping IDs assigned locally to IDs assigned by storage and pass it to runtime to
                    // support blob handles that only know about the local IDs
                    const redirectTable = new Map();
                    // if new blobs are added while uploading, upload them too
                    while (redirectTable.size < this.loader.services.detachedBlobStorage.size) {
                        const newIds = this.loader.services.detachedBlobStorage.getBlobIds().filter((id) => !redirectTable.has(id));
                        for (const id of newIds) {
                            const blob = await this.loader.services.detachedBlobStorage.readBlob(id);
                            const response = await this.storageService.createBlob(blob);
                            redirectTable.set(id, response.id);
                        }
                    }
                    // take summary and upload
                    const appSummary = this.context.createSummary(redirectTable);
                    const protocolSummary = this.captureProtocolSummary();
                    summary = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_15__.combineAppAndProtocolSummary)(appSummary, protocolSummary);
                    this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attaching;
                    this.context.notifyAttaching((0,_utils__WEBPACK_IMPORTED_MODULE_17__.getSnapshotTreeFromSerializedContainer)(summary));
                    await this.storageService.uploadSummaryWithContext(summary, {
                        referenceSequenceNumber: 0,
                        ackHandle: undefined,
                        proposalHandle: undefined,
                    });
                }
                this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached;
                this.emit("attached");
                // Propagate current connection state through the system.
                this.propagateConnectionState();
                if (!this.closed) {
                    this.resumeInternal({ fetchOpsFromStorage: false, reason: "createDetached" });
                }
            }
            catch (error) {
                // add resolved URL on error object so that host has the ability to find this document and delete it
                const newError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeError)(error);
                const resolvedUrl = this.resolvedUrl;
                if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_18__.isFluidResolvedUrl)(resolvedUrl)) {
                    newError.addTelemetryProperties({ resolvedUrl: resolvedUrl.url });
                }
                this.close(newError);
                throw newError;
            }
        }, { start: true, end: true, cancel: "generic" });
    }
    async request(path) {
        return _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: "Request" }, async () => this.context.request(path), { end: true, cancel: "error" });
    }
    setAutoReconnectInternal(mode) {
        const currentMode = this._deltaManager.connectionManager.reconnectMode;
        if (currentMode === mode) {
            return;
        }
        const now = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();
        const duration = now - this.setAutoReconnectTime;
        this.setAutoReconnectTime = now;
        this.mc.logger.sendTelemetryEvent({
            eventName: mode === _contracts__WEBPACK_IMPORTED_MODULE_20__.ReconnectMode.Enabled ? "AutoReconnectEnabled" : "AutoReconnectDisabled",
            connectionMode: this.connectionMode,
            connectionState: _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[this.connectionState],
            duration,
        });
        this._deltaManager.connectionManager.setAutoReconnect(mode);
    }
    connect() {
        if (this.closed) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is closed and cannot be connected`);
        }
        else if (this._attachState !== _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is not attached and cannot be connected`);
        }
        else if (!this.connected) {
            // Note: no need to fetch ops as we do it preemptively as part of DeltaManager.attachOpHandler().
            // If there is gap, we will learn about it once connected, but the gap should be small (if any),
            // assuming that connect() is called quickly after initial container boot.
            this.connectInternal({ reason: "DocumentConnect", fetchOpsFromStorage: false });
        }
    }
    connectInternal(args) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x2c5 /* "Attempting to connect() a closed Container" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this._attachState === _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached, 0x2c6 /* "Attempting to connect() a container that is not attached" */);
        // Resume processing ops and connect to delta stream
        this.resumeInternal(args);
        // Set Auto Reconnect Mode
        const mode = _contracts__WEBPACK_IMPORTED_MODULE_20__.ReconnectMode.Enabled;
        this.setAutoReconnectInternal(mode);
    }
    disconnect() {
        if (this.closed) {
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The Container is closed and cannot be disconnected`);
        }
        else {
            this.disconnectInternal();
        }
    }
    disconnectInternal() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x2c7 /* "Attempting to disconnect() a closed Container" */);
        // Set Auto Reconnect Mode
        const mode = _contracts__WEBPACK_IMPORTED_MODULE_20__.ReconnectMode.Disabled;
        this.setAutoReconnectInternal(mode);
    }
    resumeInternal(args) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.closed, 0x0d9 /* "Attempting to connect() a closed DeltaManager" */);
        // Resume processing ops
        if (this.inboundQueuePausedFromInit) {
            this.inboundQueuePausedFromInit = false;
            this._deltaManager.inbound.resume();
            this._deltaManager.inboundSignal.resume();
        }
        // Ensure connection to web socket
        this.connectToDeltaStream(args);
    }
    async getAbsoluteUrl(relativeUrl) {
        var _a;
        if (this.resolvedUrl === undefined) {
            return undefined;
        }
        return this.urlResolver.getAbsoluteUrl(this.resolvedUrl, relativeUrl, (0,_contracts__WEBPACK_IMPORTED_MODULE_20__.getPackageName)((_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails));
    }
    async proposeCodeDetails(codeDetails) {
        if (!(0,_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.isFluidCodeDetails)(codeDetails)) {
            throw new Error("Provided codeDetails are not IFluidCodeDetails");
        }
        if (this.codeLoader.IFluidCodeDetailsComparer) {
            const comparison = await this.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, this.getCodeDetailsFromQuorum());
            if (comparison !== undefined && comparison <= 0) {
                throw new Error("Proposed code details should be greater than the current");
            }
        }
        return this.protocolHandler.quorum.propose("code", codeDetails)
            .then(() => true)
            .catch(() => false);
    }
    async processCodeProposal() {
        const codeDetails = this.getCodeDetailsFromQuorum();
        await Promise.all([
            this.deltaManager.inbound.pause(),
            this.deltaManager.inboundSignal.pause()
        ]);
        if ((await this.context.satisfies(codeDetails) === true)) {
            this.deltaManager.inbound.resume();
            this.deltaManager.inboundSignal.resume();
            return;
        }
        // pre-0.58 error message: existingContextDoesNotSatisfyIncomingProposal
        this.close(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError("Existing context does not satisfy incoming proposal"));
    }
    async getVersion(version) {
        const versions = await this.storageService.getVersions(version, 1);
        return versions[0];
    }
    recordConnectStartTime() {
        if (this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected] === undefined) {
            this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected] = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();
        }
    }
    connectToDeltaStream(args) {
        this.recordConnectStartTime();
        // All agents need "write" access, including summarizer.
        if (!this._canReconnect || !this.client.details.capabilities.interactive) {
            args.mode = "write";
        }
        this._deltaManager.connect(args);
    }
    /**
     * Load container.
     *
     * @param specifiedVersion - one of the following
     *   - undefined - fetch latest snapshot
     *   - otherwise, version sha to load snapshot
     */
    async load(specifiedVersion, loadMode, pendingLocalState) {
        if (this._resolvedUrl === undefined) {
            throw new Error("Attempting to load without a resolved url");
        }
        this.service = await this.serviceFactory.createDocumentService(this._resolvedUrl, this.subLogger, this.client.details.type === summarizerClientType);
        // Ideally we always connect as "read" by default.
        // Currently that works with SPO & r11s, because we get "write" connection when connecting to non-existing file.
        // We should not rely on it by (one of them will address the issue, but we need to address both)
        // 1) switching create new flow to one where we create file by posting snapshot
        // 2) Fixing quorum workflows (have retry logic)
        // That all said, "read" does not work with memorylicious workflows (that opens two simultaneous
        // connections to same file) in two ways:
        // A) creation flow breaks (as one of the clients "sees" file as existing, and hits #2 above)
        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.
        const connectionArgs = { reason: "DocumentOpen", mode: "write", fetchOpsFromStorage: false };
        // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the
        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.
        if (loadMode.deltaConnection === undefined) {
            this.connectToDeltaStream(connectionArgs);
        }
        if (!pendingLocalState) {
            await this.connectStorageService();
        }
        else {
            // if we have pendingLocalState we can load without storage; don't wait for connection
            this.connectStorageService().catch((error) => this.close(error));
        }
        this._attachState = _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_8__.AttachState.Attached;
        // Fetch specified snapshot.
        const { snapshot, versionId } = pendingLocalState === undefined
            ? await this.fetchSnapshotTree(specifiedVersion)
            : { snapshot: undefined, versionId: undefined };
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(snapshot !== undefined || pendingLocalState !== undefined, 0x237 /* "Snapshot should exist" */);
        const attributes = pendingLocalState === undefined
            ? await this.getDocumentAttributes(this.storageService, snapshot)
            : {
                sequenceNumber: pendingLocalState.protocol.sequenceNumber,
                minimumSequenceNumber: pendingLocalState.protocol.minimumSequenceNumber,
                term: pendingLocalState.term,
            };
        let opsBeforeReturnP;
        // Attach op handlers to finish initialization and be able to start processing ops
        // Kick off any ops fetching if required.
        switch (loadMode.opsBeforeReturn) {
            case undefined:
                // Start prefetch, but not set opsBeforeReturnP - boot is not blocked by it!
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.attachDeltaManagerOpHandler(attributes, loadMode.deltaConnection !== "none" ? "all" : "none");
                break;
            case "cached":
                opsBeforeReturnP = this.attachDeltaManagerOpHandler(attributes, "cached");
                break;
            case "all":
                opsBeforeReturnP = this.attachDeltaManagerOpHandler(attributes, "all");
                break;
            default:
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_22__.unreachableCase)(loadMode.opsBeforeReturn);
        }
        // ...load in the existing quorum
        // Initialize the protocol handler
        this._protocolHandler = pendingLocalState === undefined
            ? await this.initializeProtocolStateFromSnapshot(attributes, this.storageService, snapshot)
            : await this.initializeProtocolState(attributes, pendingLocalState.protocol.members, pendingLocalState.protocol.proposals, pendingLocalState.protocol.values);
        const codeDetails = this.getCodeDetailsFromQuorum();
        await this.instantiateContext(true, // existing
        codeDetails, snapshot, pendingLocalState === null || pendingLocalState === void 0 ? void 0 : pendingLocalState.pendingRuntimeState);
        // We might have hit some failure that did not manifest itself in exception in this flow,
        // do not start op processing in such case - static version of Container.load() will handle it correctly.
        if (!this.closed) {
            if (opsBeforeReturnP !== undefined) {
                this._deltaManager.inbound.resume();
                await ReportIfTooLong(this.mc.logger, "WaitOps", async () => { await opsBeforeReturnP; return {}; });
                await ReportIfTooLong(this.mc.logger, "WaitOpProcessing", async () => this._deltaManager.inbound.waitTillProcessingDone());
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this._deltaManager.inbound.pause();
            }
            switch (loadMode.deltaConnection) {
                case undefined:
                case "delayed":
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.inboundQueuePausedFromInit, 0x346 /* inboundQueuePausedFromInit should be true */);
                    this.inboundQueuePausedFromInit = false;
                    this._deltaManager.inbound.resume();
                    this._deltaManager.inboundSignal.resume();
                    break;
                case "none":
                    break;
                default:
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_22__.unreachableCase)(loadMode.deltaConnection);
            }
        }
        // Safety net: static version of Container.load() should have learned about it through "closed" handler.
        // But if that did not happen for some reason, fail load for sure.
        // Otherwise we can get into situations where container is closed and does not try to connect to ordering
        // service, but caller does not know that (callers do expect container to be not closed on successful path
        // and listen only on "closed" event)
        if (this.closed) {
            throw new Error("Container was closed while load()");
        }
        // Internal context is fully loaded at this point
        this.setLoaded();
        return {
            sequenceNumber: attributes.sequenceNumber,
            version: versionId,
            dmLastProcessedSeqNumber: this._deltaManager.lastSequenceNumber,
            dmLastKnownSeqNumber: this._deltaManager.lastKnownSeqNumber,
        };
    }
    async createDetached(source) {
        const attributes = {
            sequenceNumber: detachedContainerRefSeqNumber,
            term: 1,
            minimumSequenceNumber: 0,
        };
        await this.attachDeltaManagerOpHandler(attributes);
        // Need to just seed the source data in the code quorum. Quorum itself is empty
        const qValues = (0,_quorum__WEBPACK_IMPORTED_MODULE_23__.initQuorumValuesFromCodeDetails)(source);
        this._protocolHandler = await this.initializeProtocolState(attributes, [], // members
        [], // proposals
        qValues);
        // The load context - given we seeded the quorum - will be great
        await this.instantiateContextDetached(false);
        this.setLoaded();
    }
    async rehydrateDetachedFromSnapshot(detachedContainerSnapshot) {
        if (detachedContainerSnapshot.tree[".hasAttachmentBlobs"] !== undefined) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!!this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0, 0x250 /* "serialized container with attachment blobs must be rehydrated with detached blob storage" */);
            delete detachedContainerSnapshot.tree[".hasAttachmentBlobs"];
        }
        const snapshotTree = (0,_utils__WEBPACK_IMPORTED_MODULE_17__.getSnapshotTreeFromSerializedContainer)(detachedContainerSnapshot);
        this._storage.loadSnapshotForRehydratingContainer(snapshotTree);
        const attributes = await this.getDocumentAttributes(this._storage, snapshotTree);
        await this.attachDeltaManagerOpHandler(attributes);
        // Initialize the protocol handler
        const baseTree = (0,_utils__WEBPACK_IMPORTED_MODULE_17__.getProtocolSnapshotTree)(snapshotTree);
        const qValues = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(this._storage, baseTree.blobs.quorumValues);
        const codeDetails = (0,_quorum__WEBPACK_IMPORTED_MODULE_23__.getCodeDetailsFromQuorumValues)(qValues);
        this._protocolHandler =
            await this.initializeProtocolState(attributes, [], // members
            [], // proposals
            codeDetails !== undefined ? (0,_quorum__WEBPACK_IMPORTED_MODULE_23__.initQuorumValuesFromCodeDetails)(codeDetails) : []);
        await this.instantiateContextDetached(true, // existing
        snapshotTree);
        this.setLoaded();
    }
    async connectStorageService() {
        var _a, _b;
        if (this._storageService !== undefined) {
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.service !== undefined, 0x1ef /* "services must be defined" */);
        const storageService = await this.service.connectToStorage();
        this._storageService =
            new _retriableDocumentStorageService__WEBPACK_IMPORTED_MODULE_25__.RetriableDocumentStorageService(storageService, this.mc.logger);
        if (this.options.summarizeProtocolTree === true) {
            this.mc.logger.sendTelemetryEvent({ eventName: "summarizeProtocolTreeEnabled" });
            this._storageService =
                new _protocolTreeDocumentStorageService__WEBPACK_IMPORTED_MODULE_26__.ProtocolTreeStorageService(this._storageService, () => this.captureProtocolSummary());
        }
        // ensure we did not lose that policy in the process of wrapping
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(((_a = storageService.policies) === null || _a === void 0 ? void 0 : _a.minBlobSize) === ((_b = this.storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize), 0x0e0 /* "lost minBlobSize policy" */);
    }
    async getDocumentAttributes(storage, tree) {
        if (tree === undefined) {
            return {
                minimumSequenceNumber: 0,
                sequenceNumber: 0,
                term: 1,
            };
        }
        // Backward compatibility: old docs would have ".attributes" instead of "attributes"
        const attributesHash = ".protocol" in tree.trees
            ? tree.trees[".protocol"].blobs.attributes
            : tree.blobs[".attributes"];
        const attributes = await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, attributesHash);
        // Backward compatibility for older summaries with no term
        if (attributes.term === undefined) {
            attributes.term = 1;
        }
        return attributes;
    }
    async initializeProtocolStateFromSnapshot(attributes, storage, snapshot) {
        let members = [];
        let proposals = [];
        let values = [];
        if (snapshot !== undefined) {
            const baseTree = (0,_utils__WEBPACK_IMPORTED_MODULE_17__.getProtocolSnapshotTree)(snapshot);
            [members, proposals, values] = await Promise.all([
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, baseTree.blobs.quorumMembers),
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, baseTree.blobs.quorumProposals),
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_24__.readAndParse)(storage, baseTree.blobs.quorumValues),
            ]);
        }
        const protocolHandler = await this.initializeProtocolState(attributes, members, proposals, values);
        return protocolHandler;
    }
    async initializeProtocolState(attributes, members, proposals, values) {
        const protocol = new _fluidframework_protocol_base__WEBPACK_IMPORTED_MODULE_27__.ProtocolOpHandlerWithClientValidation(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => this.submitMessage(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.Propose, { key, value }));
        const protocolLogger = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, "ProtocolHandler");
        protocol.quorum.on("error", (error) => {
            protocolLogger.sendErrorEvent(error);
        });
        // Track membership changes and update connection state accordingly
        this.connectionStateHandler.initProtocol(protocol);
        protocol.quorum.on("addProposal", (proposal) => {
            if (proposal.key === "code" || proposal.key === "code2") {
                this.emit("codeDetailsProposed", proposal.value, proposal);
            }
        });
        protocol.quorum.on("approveProposal", (sequenceNumber, key, value) => {
            if (key === "code" || key === "code2") {
                if (!(0,_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_21__.isFluidCodeDetails)(value)) {
                    this.mc.logger.sendErrorEvent({
                        eventName: "CodeProposalNotIFluidCodeDetails",
                    });
                }
                this.processCodeProposal().catch((error) => {
                    this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeError)(error));
                    throw error;
                });
            }
        });
        return protocol;
    }
    captureProtocolSummary() {
        const quorumSnapshot = this.protocolHandler.snapshot();
        const summary = {
            tree: {
                attributes: {
                    content: JSON.stringify(this.protocolHandler.attributes),
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,
                },
                quorumMembers: {
                    content: JSON.stringify(quorumSnapshot.members),
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,
                },
                quorumProposals: {
                    content: JSON.stringify(quorumSnapshot.proposals),
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,
                },
                quorumValues: {
                    content: JSON.stringify(quorumSnapshot.values),
                    type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Blob,
                },
            },
            type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_16__.SummaryType.Tree,
        };
        return summary;
    }
    getCodeDetailsFromQuorum() {
        const quorum = this.protocolHandler.quorum;
        const pkg = getCodeProposal(quorum);
        return pkg;
    }
    get client() {
        var _a;
        const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined
            ? this.options.client
            : {
                details: {
                    capabilities: { interactive: true },
                },
                mode: "read",
                permission: [],
                scopes: [],
                user: { id: "" },
            };
        if (this.clientDetailsOverride !== undefined) {
            lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()(client.details, this.clientDetailsOverride);
        }
        client.details.environment = [client.details.environment, ` loaderVersion:${_packageVersion__WEBPACK_IMPORTED_MODULE_29__.pkgVersion}`].join(";");
        return client;
    }
    /**
     * Returns true if connection is active, i.e. it's "write" connection and
     * container runtime was notified about this connection (i.e. we are up-to-date and could send ops).
     * This happens after client received its own joinOp and thus is in the quorum.
     * If it's not true, runtime is not in position to send ops.
     */
    activeConnection() {
        return this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected &&
            this.connectionMode === "write";
    }
    createDeltaManager() {
        const serviceProvider = () => this.service;
        const deltaManager = new _deltaManager__WEBPACK_IMPORTED_MODULE_30__.DeltaManager(serviceProvider, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, "DeltaManager"), () => this.activeConnection(), (props) => new _connectionManager__WEBPACK_IMPORTED_MODULE_31__.ConnectionManager(serviceProvider, this.client, this._canReconnect, _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.ChildLogger.create(this.subLogger, "ConnectionManager"), props));
        // Disable inbound queues as Container is not ready to accept any ops until we are fully loaded!
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        deltaManager.inbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        deltaManager.inboundSignal.pause();
        deltaManager.on("connect", (details, opsBehind) => {
            var _a;
            // Back-compat for new client and old server.
            this._audience.clear();
            for (const priorClient of (_a = details.initialClients) !== null && _a !== void 0 ? _a : []) {
                this._audience.addMember(priorClient.clientId, priorClient.client);
            }
            this.connectionStateHandler.receivedConnectEvent(this.connectionMode, details);
        });
        deltaManager.on("disconnect", (reason) => {
            var _a;
            (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();
            this.connectionStateHandler.receivedDisconnectEvent(reason);
        });
        deltaManager.on("throttled", (warning) => {
            const warn = warning;
            // Some "warning" events come from outside the container and are logged
            // elsewhere (e.g. summarizing container). We shouldn't log these here.
            if (warn.logged !== true) {
                this.logContainerError(warn);
            }
            this.emit("warning", warn);
        });
        deltaManager.on("readonly", (readonly) => {
            this.emit("readonly", readonly);
        });
        deltaManager.on("closed", (error) => {
            this.closeCore(error);
        });
        return deltaManager;
    }
    async attachDeltaManagerOpHandler(attributes, prefetchType) {
        var _a;
        return this._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term) !== null && _a !== void 0 ? _a : 1, {
            process: (message) => this.processRemoteMessage(message),
            processSignal: (message) => {
                this.processSignal(message);
            },
        }, prefetchType);
    }
    logConnectionStateChangeTelemetry(value, oldState, reason) {
        var _a;
        // Log actual event
        const time = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();
        this.connectionTransitionTimes[value] = time;
        const duration = time - this.connectionTransitionTimes[oldState];
        let durationFromDisconnected;
        let connectionInitiationReason;
        let autoReconnect;
        let checkpointSequenceNumber;
        let opsBehind;
        if (value === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected) {
            autoReconnect = this._deltaManager.connectionManager.reconnectMode;
        }
        else {
            if (value === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {
                durationFromDisconnected = time - this.connectionTransitionTimes[_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Disconnected];
                durationFromDisconnected = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.TelemetryLogger.formatTick(durationFromDisconnected);
            }
            else {
                // This info is of most interest on establishing connection only.
                checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;
                if (this.deltaManager.hasCheckpointSequenceNumber) {
                    opsBehind = checkpointSequenceNumber - this.deltaManager.lastSequenceNumber;
                }
            }
            if (this.firstConnection) {
                connectionInitiationReason = "InitialConnect";
            }
            else {
                connectionInitiationReason = "AutoReconnect";
            }
        }
        this.mc.logger.sendPerformanceEvent(Object.assign({ eventName: `ConnectionStateChange_${_connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[value]}`, from: _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState[oldState], duration,
            durationFromDisconnected,
            reason,
            connectionInitiationReason, pendingClientId: this.connectionStateHandler.pendingClientId, clientId: this.clientId, autoReconnect,
            opsBehind, online: _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_32__.OnlineStatus[(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_32__.isOnline)()], lastVisible: this.lastVisible !== undefined ? _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - this.lastVisible : undefined, checkpointSequenceNumber, quorumSize: (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum.getMembers().size }, this._deltaManager.connectionProps));
        if (value === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {
            this.firstConnection = false;
        }
    }
    propagateConnectionState() {
        var _a;
        const logOpsOnReconnect = this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected &&
            !this.firstConnection &&
            this.connectionMode === "write";
        if (logOpsOnReconnect) {
            this.messageCountAfterDisconnection = 0;
        }
        const state = this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected;
        // Both protocol and context should not be undefined if we got so far.
        if (((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) === false) {
            this.context.setConnectionState(state, this.clientId);
        }
        this.protocolHandler.setConnectionState(state, this.clientId);
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_5__.raiseConnectedEvent)(this.mc.logger, this, state, this.clientId);
        if (logOpsOnReconnect) {
            this.mc.logger.sendTelemetryEvent({ eventName: "OpsSentOnReconnect", count: this.messageCountAfterDisconnection });
        }
    }
    submitContainerMessage(type, contents, batch, metadata) {
        const outboundMessageType = type;
        switch (outboundMessageType) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.Operation:
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.RemoteHelp:
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.Summarize: {
                // github #6451: this is only needed for staging so the server
                // know when the protocol tree is included
                // this can be removed once all clients send
                // protocol tree by default
                const summary = contents;
                if (summary.details === undefined) {
                    summary.details = {};
                }
                summary.details.includesProtocolTree =
                    this.options.summarizeProtocolTree === true;
                break;
            }
            default:
                this.close(new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError("invalidContainerSubmitOpType", undefined /* error */, { messageType: type }));
                return -1;
        }
        return this.submitMessage(type, contents, batch, metadata);
    }
    submitMessage(type, contents, batch, metadata) {
        var _a;
        if (this.connectionState !== _connectionState__WEBPACK_IMPORTED_MODULE_4__.ConnectionState.Connected) {
            this.mc.logger.sendErrorEvent({ eventName: "SubmitMessageWithNoConnection", type });
            return -1;
        }
        this.messageCountAfterDisconnection += 1;
        (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();
        return this._deltaManager.submit(type, contents, batch, metadata);
    }
    processRemoteMessage(message) {
        const local = this.clientId === message.clientId;
        // Allow the protocol handler to process the message
        let result = { immediateNoOp: false };
        try {
            result = this.protocolHandler.processMessage(message, local);
        }
        catch (error) {
            this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_2__.wrapError)(error, (errorMessage) => new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.DataCorruptionError(errorMessage, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.extractSafePropertiesFromMessage)(message))));
        }
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isUnpackedRuntimeMessage)(message) && !(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isRuntimeMessage)(message)) {
            this.mc.logger.sendTelemetryEvent({ eventName: "UnpackedRuntimeMessage", type: message.type });
        }
        // Forward non system messages to the loaded runtime for processing
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isRuntimeMessage)(message) || (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_33__.isUnpackedRuntimeMessage)(message)) {
            this.context.process(message, local, undefined);
        }
        // Inactive (not in quorum or not writers) clients don't take part in the minimum sequence number calculation.
        if (this.activeConnection()) {
            if (this.collabWindowTracker === undefined) {
                // Note that config from first connection will be used for this container's lifetime.
                // That means that if relay service changes settings, such changes will impact only newly booted
                // clients.
                // All existing will continue to use settings they got earlier.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.serviceConfiguration !== undefined, 0x2e4 /* "there should be service config for active connection" */);
                this.collabWindowTracker = new _collabWindowTracker__WEBPACK_IMPORTED_MODULE_34__.CollabWindowTracker((type, contents) => {
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.activeConnection(), 0x241 /* "disconnect should result in stopSequenceNumberUpdate() call" */);
                    this.submitMessage(type, contents);
                }, this.serviceConfiguration.noopTimeFrequency, this.serviceConfiguration.noopCountFrequency);
            }
            this.collabWindowTracker.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);
        }
        this.emit("op", message);
        return result;
    }
    submitSignal(message) {
        this._deltaManager.submitSignal(JSON.stringify(message));
    }
    processSignal(message) {
        // No clientId indicates a system signal message.
        if (message.clientId === null) {
            const innerContent = message.content;
            if (innerContent.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.ClientJoin) {
                const newClient = innerContent.content;
                this._audience.addMember(newClient.clientId, newClient.client);
            }
            else if (innerContent.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_28__.MessageType.ClientLeave) {
                const leftClientId = innerContent.content;
                this._audience.removeMember(leftClientId);
            }
        }
        else {
            const local = this.clientId === message.clientId;
            this.context.processSignal(message, local);
        }
    }
    /**
     * Get the most recent snapshot, or a specific version.
     * @param specifiedVersion - The specific version of the snapshot to retrieve
     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID
     */
    async fetchSnapshotTree(specifiedVersion) {
        var _a;
        const version = await this.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : null);
        if (version === undefined && specifiedVersion !== undefined) {
            // We should have a defined version to load from if specified version requested
            this.mc.logger.sendErrorEvent({ eventName: "NoVersionFoundWhenSpecified", id: specifiedVersion });
        }
        this._loadedFromVersion = version;
        const snapshot = (_a = await this.storageService.getSnapshotTree(version)) !== null && _a !== void 0 ? _a : undefined;
        if (snapshot === undefined && version !== undefined) {
            this.mc.logger.sendErrorEvent({ eventName: "getSnapshotTreeFailed", id: version.id });
        }
        return { snapshot, versionId: version === null || version === void 0 ? void 0 : version.id };
    }
    async instantiateContextDetached(existing, snapshot) {
        const codeDetails = this.getCodeDetailsFromQuorum();
        if (codeDetails === undefined) {
            throw new Error("pkg should be provided in create flow!!");
        }
        await this.instantiateContext(existing, codeDetails, snapshot);
    }
    async instantiateContext(existing, codeDetails, snapshot, pendingLocalState) {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, 0x0dd /* "Existing context not disposed" */);
        // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags
        // are set. Global requests will still go directly to the loader
        const loader = new _loader__WEBPACK_IMPORTED_MODULE_35__.RelativeLoader(this, this.loader);
        this._context = await _containerContext__WEBPACK_IMPORTED_MODULE_36__.ContainerContext.createOrLoad(this, this.scope, this.codeLoader, codeDetails, snapshot, new _deltaManagerProxy__WEBPACK_IMPORTED_MODULE_37__.DeltaManagerProxy(this._deltaManager), new _quorum__WEBPACK_IMPORTED_MODULE_23__.QuorumProxy(this.protocolHandler.quorum), loader, (type, contents, batch, metadata) => this.submitContainerMessage(type, contents, batch, metadata), (message) => this.submitSignal(message), (error) => this.close(error), Container.version, (dirty) => this.updateDirtyContainerState(dirty), existing, pendingLocalState);
        this.emit("contextChanged", codeDetails);
    }
    updateDirtyContainerState(dirty) {
        if (this._dirtyContainer === dirty) {
            return;
        }
        this._dirtyContainer = dirty;
        this.emit(dirty ? dirtyContainerEvent : savedContainerEvent);
    }
    logContainerError(warning) {
        this.mc.logger.sendErrorEvent({ eventName: "ContainerWarning" }, warning);
    }
}
Container.version = "^0.1.0";
//# sourceMappingURL=container.js.map

/***/ }),
/* 471 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(472),
    createAssigner = __webpack_require__(481);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 472 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(160),
    assignMergeValue = __webpack_require__(473),
    baseFor = __webpack_require__(474),
    baseMergeDeep = __webpack_require__(476),
    isObject = __webpack_require__(184),
    keysIn = __webpack_require__(231),
    safeGet = __webpack_require__(479);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 473 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(206),
    eq = __webpack_require__(165);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 474 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(475);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 475 */
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 476 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(473),
    cloneBuffer = __webpack_require__(234),
    cloneTypedArray = __webpack_require__(259),
    copyArray = __webpack_require__(235),
    initCloneObject = __webpack_require__(260),
    isArguments = __webpack_require__(213),
    isArray = __webpack_require__(216),
    isArrayLikeObject = __webpack_require__(477),
    isBuffer = __webpack_require__(217),
    isFunction = __webpack_require__(177),
    isObject = __webpack_require__(184),
    isPlainObject = __webpack_require__(478),
    isTypedArray = __webpack_require__(220),
    safeGet = __webpack_require__(479),
    toPlainObject = __webpack_require__(480);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 477 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(229),
    isObjectLike = __webpack_require__(215);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 478 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(178),
    getPrototype = __webpack_require__(243),
    isObjectLike = __webpack_require__(215);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 479 */
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 480 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(209),
    keysIn = __webpack_require__(231);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 481 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(482),
    isIterateeCall = __webpack_require__(490);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 482 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(483),
    overRest = __webpack_require__(484),
    setToString = __webpack_require__(486);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 483 */
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 484 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(485);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 485 */
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 486 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(487),
    shortOut = __webpack_require__(489);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 487 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(488),
    defineProperty = __webpack_require__(207),
    identity = __webpack_require__(483);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 488 */
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 489 */
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 490 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(165),
    isArrayLike = __webpack_require__(229),
    isIndex = __webpack_require__(219),
    isObject = __webpack_require__(184);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 491 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 492 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "performance": () => (/* binding */ performance)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const performance = window.performance;
//# sourceMappingURL=performanceBrowser.js.map

/***/ }),
/* 493 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Audience": () => (/* binding */ Audience)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Audience represents all clients connected to the op stream.
 */
class Audience extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super(...arguments);
        this.members = new Map();
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    /**
     * Adds a new client to the audience
     */
    addMember(clientId, details) {
        this.members.set(clientId, details);
        this.emit("addMember", clientId, details);
    }
    /**
     * Removes a client from the audience. Only emits an event if a client is actually removed
     * @returns if a client was removed from the audience
     */
    removeMember(clientId) {
        const removedClient = this.members.get(clientId);
        if (removedClient !== undefined) {
            this.members.delete(clientId);
            this.emit("removeMember", clientId, removedClient);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Retrieves all the members in the audience
     */
    getMembers() {
        return new Map(this.members);
    }
    /**
     * Retrieves a specific member of the audience
     */
    getMember(clientId) {
        return this.members.get(clientId);
    }
    /**
     * Clears the audience
     */
    clear() {
        const clientIds = this.members.keys();
        for (const clientId of clientIds) {
            this.removeMember(clientId);
        }
    }
}
//# sourceMappingURL=audience.js.map

/***/ }),
/* 494 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionStateHandler": () => (/* binding */ ConnectionStateHandler)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(495);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _connectionState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



const JoinOpTimeoutMs = 45000;
/**
 * In the lifetime of a container, the connection will likely disconnect and reconnect periodically.
 * This class ensures that any ops sent by this container instance on previous connection are either
 * sequenced or blocked by the server before emitting the new "connected" event and allowing runtime to resubmit ops.
 *
 * Each connection is assigned a clientId by the service, and the connection is book-ended by a Join and a Leave op
 * generated by the service. Due to the distributed nature of the ordering service, in the case of reconnect we cannot
 * make any assumptions about ordering of operations between the old and new connections - i.e. new Join op could
 * be sequenced before old Leave op (and some acks from pending ops that were in flight when we disconnected).
 *
 * The job of this class is to encapsulate the transition period during reconnect, which is identified by
 * ConnectionState.CatchingUp. Specifically, before moving to Connected state with the new clientId, it ensures that:
 * (A) We process the Leave op for the previous clientId. This allows us to properly handle any acks from in-flight ops
 *     that got sequenced with the old clientId (we'll recognize them as local ops). After the Leave op, any other
 *     pending ops can safely be submitted with the new clientId without fear of duplication in the sequenced op stream.
 * (B) We process the Join op for the new clientId (identified when the underlying connection was first established),
 *     indicating the service is ready to sequence ops sent with the new clientId.
 *
 * For (A) we give up waiting after some time (same timeout as server uses), and go ahead and transition to Connected.
 * For (B) we log telemetry if it takes too long, but still only transition to Connected when the Join op is processed
 * and we are added to the Quorum.
 */
class ConnectionStateHandler {
    constructor(handler, logger, _clientId) {
        var _a;
        this.handler = handler;
        this.logger = logger;
        this._clientId = _clientId;
        this._connectionState = _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Disconnected;
        this.prevClientLeftTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Timer(
        // Default is 5 min for which we are going to wait for its own "leave" message. This is same as
        // the max time on server after which leave op is sent.
        (_a = this.handler.maxClientLeaveWaitTime) !== null && _a !== void 0 ? _a : 300000, () => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.connected, 0x2ac /* "Connected when timeout waiting for leave from previous session fired!" */);
            this.applyForConnectedState("timeout");
        });
        // Based on recent data, it looks like majority of cases where we get stuck are due to really slow or
        // timing out ops fetches. So attempt recovery infrequently. Also fetch uses 30 second timeout, so
        // if retrying fixes the problem, we should not see these events.
        this.joinOpTimer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.Timer(JoinOpTimeoutMs, () => {
            var _a;
            // I've observed timer firing within couple ms from disconnect event, looks like
            // queued timer callback is not cancelled if timer is cancelled while callback sits in the queue.
            if (this.connectionState !== _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp) {
                return;
            }
            const quorumClients = this.handler.quorumClients();
            const details = {
                quorumInitialized: quorumClients !== undefined,
                hasPendingClientId: this.pendingClientId !== undefined,
                inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_a = this.pendingClientId) !== null && _a !== void 0 ? _a : "")) !== undefined,
                waitingForLeaveOp: this.waitingForLeaveOp,
            };
            this.handler.logConnectionIssue("NoJoinOp", details);
        });
    }
    get connectionState() {
        return this._connectionState;
    }
    get connected() {
        return this.connectionState === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected;
    }
    get clientId() {
        return this._clientId;
    }
    get pendingClientId() {
        return this._pendingClientId;
    }
    startJoinOpTimer() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.joinOpTimer.hasTimer, 0x234 /* "has joinOpTimer" */);
        this.joinOpTimer.start();
    }
    stopJoinOpTimer() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.joinOpTimer.hasTimer, 0x235 /* "no joinOpTimer" */);
        this.joinOpTimer.clear();
    }
    get waitingForLeaveOp() {
        return this.prevClientLeftTimer.hasTimer;
    }
    dispose() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.joinOpTimer.hasTimer, 0x2a5 /* "join timer" */);
        this.prevClientLeftTimer.clear();
    }
    containerSaved() {
        // If we were waiting for moving to Connected state, then only apply for state change. Since the container
        // is now saved and we don't have any ops to roundtrip, we can clear the timer and apply for connected state.
        if (this.waitingForLeaveOp) {
            this.prevClientLeftTimer.clear();
            this.applyForConnectedState("containerSaved");
        }
    }
    receivedAddMemberEvent(clientId) {
        // This is the only one that requires the pending client ID
        if (clientId === this.pendingClientId) {
            if (this.joinOpTimer.hasTimer) {
                this.stopJoinOpTimer();
            }
            else {
                // timer has already fired, meaning it took too long to get join on.
                // Record how long it actually took to recover.
                this.handler.logConnectionIssue("ReceivedJoinOp");
            }
            // Start the event in case we are waiting for leave or timeout.
            if (this.waitingForLeaveOp) {
                this.waitEvent = _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.PerformanceEvent.start(this.logger, {
                    eventName: "WaitBeforeClientLeave",
                    details: JSON.stringify({
                        waitOnClientId: this._clientId,
                        hadOutstandingOps: this.handler.shouldClientJoinWrite(),
                    }),
                });
            }
            this.applyForConnectedState("addMemberEvent");
        }
    }
    applyForConnectedState(source) {
        var _a, _b;
        const quorumClients = this.handler.quorumClients();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(quorumClients !== undefined, 0x236 /* "In all cases it should be already installed" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.waitingForLeaveOp === false ||
            (this.clientId !== undefined && quorumClients.getMember(this.clientId) !== undefined), 0x2e2 /* "Must only wait for leave message when clientId in quorum" */);
        // Move to connected state only if we are in Connecting state, we have seen our join op
        // and there is no timer running which means we are not waiting for previous client to leave
        // or timeout has occurred while doing so.
        if (this.pendingClientId !== this.clientId
            && this.pendingClientId !== undefined
            && quorumClients.getMember(this.pendingClientId) !== undefined
            && !this.waitingForLeaveOp) {
            (_a = this.waitEvent) === null || _a === void 0 ? void 0 : _a.end({ source });
            this.setConnectionState(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected);
        }
        else {
            // Adding this event temporarily so that we can get help debugging if something goes wrong.
            this.logger.sendTelemetryEvent({
                eventName: "connectedStateRejected",
                category: source === "timeout" ? "error" : "generic",
                details: JSON.stringify({
                    source,
                    pendingClientId: this.pendingClientId,
                    clientId: this.clientId,
                    waitingForLeaveOp: this.waitingForLeaveOp,
                    inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_b = this.pendingClientId) !== null && _b !== void 0 ? _b : "")) !== undefined,
                }),
            });
        }
    }
    receivedRemoveMemberEvent(clientId) {
        // If the client which has left was us, then finish the timer.
        if (this.clientId === clientId) {
            this.prevClientLeftTimer.clear();
            this.applyForConnectedState("removeMemberEvent");
        }
    }
    receivedDisconnectEvent(reason) {
        if (this.joinOpTimer.hasTimer) {
            this.stopJoinOpTimer();
        }
        this.setConnectionState(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Disconnected, reason);
    }
    /**
     * The "connect" event indicates the connection to the Relay Service is live.
     * However, some additional conditions must be met before we can fully transition to
     * "Connected" state. This function handles that interim period, known as "Connecting" state.
     * @param connectionMode - Read or Write connection
     * @param details - Connection details returned from the ordering service
     */
    receivedConnectEvent(connectionMode, details) {
        const oldState = this._connectionState;
        this._connectionState = _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp;
        const writeConnection = connectionMode === "write";
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(writeConnection || !this.handler.shouldClientJoinWrite(), 0x30a /* shouldClientJoinWrite should imply this is a writeConnection */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(writeConnection || !this.waitingForLeaveOp, 0x2a6 /* "waitingForLeaveOp should imply writeConnection (we need to be ready to flush pending ops)" */);
        // Note that this may be undefined since the connection is established proactively on load
        // and the quorum may still be under initialization.
        const quorumClients = this.handler.quorumClients();
        // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected
        // (have received the join message for the client ID)
        // This is especially important in the reconnect case. It's possible there could be outstanding
        // ops sent by this client, so we should keep the old client id until we see our own client's
        // join message. after we see the join message for our new connection with our new client id,
        // we know there can no longer be outstanding ops that we sent with the previous client id.
        this._pendingClientId = details.clientId;
        // IMPORTANT: Report telemetry after we set _pendingClientId, but before transitioning to Connected state
        this.handler.logConnectionStateChangeTelemetry(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp, oldState);
        // For write connections, this pending clientId could be in the quorum already (i.e. join op already processed).
        // We are fetching ops from storage in parallel to connecting to Relay Service,
        // and given async processes, it's possible that we have already processed our own join message before
        // connection was fully established.
        // If quorumClients itself is undefined, we expect it will process the join op after it's initialized.
        const waitingForJoinOp = writeConnection && (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._pendingClientId)) === undefined;
        if (waitingForJoinOp) {
            // Previous client left, and we are waiting for our own join op. When it is processed we'll join the quorum
            // and attempt to transition to Connected state via receivedAddMemberEvent.
            this.startJoinOpTimer();
        }
        else if (!this.waitingForLeaveOp) {
            // We're not waiting for Join or Leave op (if read-only connection those don't even apply),
            // go ahead and declare the state to be Connected!
            // If we are waiting for Leave op still, do nothing for now, we will transition to Connected later.
            this.setConnectionState(_connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected);
        }
    }
    setConnectionState(value, reason) {
        if (this.connectionState === value) {
            // Already in the desired state - exit early
            this.logger.sendErrorEvent({ eventName: "setConnectionStateSame", value });
            return;
        }
        const oldState = this._connectionState;
        this._connectionState = value;
        const quorumClients = this.handler.quorumClients();
        let client;
        if (this._clientId !== undefined) {
            client = quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._clientId);
        }
        if (value === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Connected) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(oldState === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.CatchingUp, 0x1d8 /* "Should only transition from Connecting state" */);
            // Mark our old client should have left in the quorum if it's still there
            if (client !== undefined) {
                client.shouldHaveLeft = true;
            }
            this._clientId = this.pendingClientId;
        }
        else if (value === _connectionState__WEBPACK_IMPORTED_MODULE_0__.ConnectionState.Disconnected) {
            // Important as we process our own joinSession message through delta request
            this._pendingClientId = undefined;
            // Only wait for "leave" message if the connected client exists in the quorum because only the write
            // client will exist in the quorum and only for those clients we will receive "removeMember" event and
            // the client has some unacked ops.
            // Also server would not accept ops from read client. Also check if the timer is not already running as
            // we could receive "Disconnected" event multiple times without getting connected and in that case we
            // don't want to reset the timer as we still want to wait on original client which started this timer.
            if (client !== undefined
                && this.handler.shouldClientJoinWrite()
                && this.prevClientLeftTimer.hasTimer === false) {
                this.prevClientLeftTimer.restart();
            }
            else {
                // Adding this event temporarily so that we can get help debugging if something goes wrong.
                this.logger.sendTelemetryEvent({
                    eventName: "noWaitOnDisconnected",
                    details: JSON.stringify({
                        inQuorum: client !== undefined,
                        waitingForLeaveOp: this.waitingForLeaveOp,
                        hadOutstandingOps: this.handler.shouldClientJoinWrite(),
                    }),
                });
            }
        }
        // Report transition before we propagate event across layers
        this.handler.logConnectionStateChangeTelemetry(this._connectionState, oldState, reason);
        // Propagate event across layers
        this.handler.connectionStateChanged();
    }
    initProtocol(protocol) {
        protocol.quorum.on("addMember", (clientId, _details) => {
            this.receivedAddMemberEvent(clientId);
        });
        protocol.quorum.on("removeMember", (clientId) => {
            this.receivedRemoveMemberEvent(clientId);
        });
        // if we have a clientId from a previous container we need to wait for its leave message
        if (this.clientId !== undefined && protocol.quorum.getMember(this.clientId) !== undefined) {
            this.prevClientLeftTimer.restart();
        }
    }
}
//# sourceMappingURL=connectionStateHandler.js.map

/***/ }),
/* 495 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromiseTimer": () => (/* binding */ PromiseTimer),
/* harmony export */   "Timer": () => (/* binding */ Timer)
/* harmony export */ });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(491);
/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(496);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * This class is a thin wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the same
 * or similar handlers and timeouts.
 */
class Timer {
    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {
        this.defaultTimeout = defaultTimeout;
        this.defaultHandler = defaultHandler;
        this.getCurrentTick = getCurrentTick;
    }
    /**
     * Returns true if the timer is running.
     */
    get hasTimer() {
        return !!this.runningState;
    }
    /**
     * Calls setTimeout and tracks the resulting timeout.
     * @param ms - overrides default timeout in ms
     * @param handler - overrides default handler
     */
    start(ms = this.defaultTimeout, handler = this.defaultHandler) {
        this.startCore(ms, handler, ms);
    }
    /**
     * Calls clearTimeout on the underlying timeout if running.
     */
    clear() {
        if (!this.runningState) {
            return;
        }
        clearTimeout(this.runningState.timeout);
        this.runningState = undefined;
    }
    /**
     * Restarts the timer with the new handler and duration.
     * If a new handler is passed, the original handler may
     * never execute.
     * This is a potentially more efficient way to clear and start
     * a new timer.
     * @param ms - overrides previous or default timeout in ms
     * @param handler - overrides previous or default handler
     */
    restart(ms, handler) {
        var _a, _b;
        if (!this.runningState) {
            // If restart is called first, it behaves as a call to start
            this.start(ms, handler);
        }
        else {
            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;
            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;
            const remainingTime = this.calculateRemainingTime(this.runningState);
            if (duration < remainingTime) {
                // If remaining time exceeds restart duration, do a hard restart.
                // The existing timeout time is too long.
                this.start(duration, handlerToUse);
            }
            else if (duration === remainingTime) {
                // The existing timeout time is perfect, just update handler and data.
                this.runningState.handler = handlerToUse;
                this.runningState.restart = undefined;
                this.runningState.intendedDuration = duration;
            }
            else {
                // If restart duration exceeds remaining time, set restart info.
                // Existing timeout will start a new timeout for remaining time.
                this.runningState.restart = {
                    startTick: this.getCurrentTick(),
                    duration,
                    handler: handlerToUse,
                };
            }
        }
    }
    startCore(duration, handler, intendedDuration) {
        this.clear();
        this.runningState = {
            startTick: this.getCurrentTick(),
            duration,
            intendedDuration,
            handler,
            timeout: setTimeout(() => this.handler(), duration),
        };
    }
    handler() {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.runningState, 0x00a /* "Running timer missing handler" */);
        const restart = this.runningState.restart;
        if (restart !== undefined) {
            // Restart with remaining time
            const remainingTime = this.calculateRemainingTime(restart);
            this.startCore(remainingTime, () => restart.handler(), restart.duration);
        }
        else {
            // Run clear first, in case the handler decides to start again
            const handler = this.runningState.handler;
            this.clear();
            handler();
        }
    }
    calculateRemainingTime(runningTimeout) {
        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;
        return runningTimeout.duration - elapsedTime;
    }
}
/**
 * This class is a wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the
 * same handlers and timeouts, while also providing a promise that
 * resolves when it times out.
 */
class PromiseTimer {
    constructor(defaultTimeout, defaultHandler) {
        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));
    }
    get hasTimer() {
        return this.timer.hasTimer;
    }
    async start(ms, handler) {
        this.clear();
        this.deferred = new _promises__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);
        return this.deferred.promise;
    }
    clear() {
        this.timer.clear();
        if (this.deferred) {
            this.deferred.resolve({ timerResult: "cancel" });
            this.deferred = undefined;
        }
    }
    wrapHandler(handler) {
        handler();
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.deferred, 0x00b /* "Handler executed without deferred" */);
        this.deferred.resolve({ timerResult: "timeout" });
        this.deferred = undefined;
    }
}
//# sourceMappingURL=timer.js.map

/***/ }),
/* 496 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "LazyPromise": () => (/* binding */ LazyPromise)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
//# sourceMappingURL=promises.js.map

/***/ }),
/* 497 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobOnlyStorage": () => (/* binding */ BlobOnlyStorage),
/* harmony export */   "ContainerStorageAdapter": () => (/* binding */ ContainerStorageAdapter)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class wraps the actual storage and make sure no wrong apis are called according to
 * container attach state.
 */
class ContainerStorageAdapter {
    constructor(storageGetter) {
        this.storageGetter = storageGetter;
        this.blobContents = {};
    }
    loadSnapshotForRehydratingContainer(snapshotTree) {
        this.getBlobContents(snapshotTree);
    }
    getBlobContents(snapshotTree) {
        for (const [id, value] of Object.entries(snapshotTree.blobsContents)) {
            this.blobContents[id] = value;
        }
        for (const [_, tree] of Object.entries(snapshotTree.trees)) {
            this.getBlobContents(tree);
        }
    }
    get policies() {
        // back-compat 0.40 containerRuntime requests policies even in detached container if storage is present
        // and storage is always present in >=0.41.
        try {
            return this.storageGetter().policies;
        }
        catch (e) { }
        return undefined;
    }
    get repositoryUrl() {
        return this.storageGetter().repositoryUrl;
    }
    async getSnapshotTree(version, scenarioName) {
        return this.storageGetter().getSnapshotTree(version, scenarioName);
    }
    async readBlob(id) {
        const blob = this.blobContents[id];
        if (blob !== undefined) {
            return blob;
        }
        return this.storageGetter().readBlob(id);
    }
    async getVersions(versionId, count, scenarioName) {
        return this.storageGetter().getVersions(versionId, count, scenarioName);
    }
    async uploadSummaryWithContext(summary, context) {
        return this.storageGetter().uploadSummaryWithContext(summary, context);
    }
    async downloadSummary(handle) {
        return this.storageGetter().downloadSummary(handle);
    }
    async createBlob(file) {
        return this.storageGetter().createBlob(file);
    }
}
/**
 * Storage which only supports createBlob() and readBlob(). This is used with IDetachedBlobStorage to support
 * blobs in detached containers.
 */
class BlobOnlyStorage {
    constructor(blobStorage, logger) {
        this.blobStorage = blobStorage;
        this.logger = logger;
        /* eslint-disable @typescript-eslint/unbound-method */
        this.getSnapshotTree = this.notCalled;
        this.getVersions = this.notCalled;
        this.write = this.notCalled;
        this.uploadSummaryWithContext = this.notCalled;
        this.downloadSummary = this.notCalled;
    }
    async createBlob(content) {
        return this.blobStorage.createBlob(content);
    }
    async readBlob(blobId) {
        return this.blobStorage.readBlob(blobId);
    }
    get policies() {
        return this.notCalled();
    }
    get repositoryUrl() {
        return this.notCalled();
    }
    /* eslint-enable @typescript-eslint/unbound-method */
    notCalled() {
        try {
            // some browsers may not populate stack unless exception is thrown
            throw new Error("BlobOnlyStorage not implemented method used");
        }
        catch (err) {
            this.logger.sendErrorEvent({ eventName: "BlobOnlyStorageWrongCall" }, err);
            throw err;
        }
    }
}
//# sourceMappingURL=containerStorageAdapter.js.map

/***/ }),
/* 498 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SummaryType": () => (/* binding */ SummaryType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType || (SummaryType = {}));
//# sourceMappingURL=summary.js.map

/***/ }),
/* 499 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertProtocolAndAppSummaryToSnapshotTree": () => (/* binding */ convertProtocolAndAppSummaryToSnapshotTree),
/* harmony export */   "getProtocolSnapshotTree": () => (/* binding */ getProtocolSnapshotTree),
/* harmony export */   "getSnapshotTreeFromSerializedContainer": () => (/* binding */ getSnapshotTreeFromSerializedContainer),
/* harmony export */   "parseUrl": () => (/* binding */ parseUrl)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(500);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(523);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(524);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(525);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(498);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */





function parseUrl(url) {
    var _a;
    const parsed = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(url, true);
    if (typeof parsed.pathname !== "string") {
        throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError("Failed to parse pathname");
    }
    const query = (_a = parsed.search) !== null && _a !== void 0 ? _a : "";
    const regex = /^\/([^/]*\/[^/]*)(\/?.*)$/;
    const match = regex.exec(parsed.pathname);
    return ((match === null || match === void 0 ? void 0 : match.length) === 3)
        ? { id: match[1], path: match[2], query, version: parsed.query.version }
        : undefined;
}
/**
 * Converts summary tree (for upload) to snapshot tree (for download).
 * Summary tree blobs contain contents, but snapshot tree blobs normally
 * contain IDs pointing to storage. This will create 2 blob entries in the
 * snapshot tree for each blob in the summary tree. One will be the regular
 * path pointing to a uniquely generated ID. Then there will be another
 * entry with the path as that uniquely generated ID, and value as the
 * blob contents as a base-64 string.
 * @param summary - summary to convert
 */
function convertSummaryToSnapshotWithEmbeddedBlobContents(summary) {
    const treeNode = {
        blobs: {},
        blobsContents: {},
        trees: {},
        id: (0,uuid__WEBPACK_IMPORTED_MODULE_2__["default"])(),
        unreferenced: summary.unreferenced,
    };
    const keys = Object.keys(summary.tree);
    for (const key of keys) {
        const summaryObject = summary.tree[key];
        switch (summaryObject.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Tree: {
                treeNode.trees[key] = convertSummaryToSnapshotWithEmbeddedBlobContents(summaryObject);
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Attachment:
                treeNode.blobs[key] = summaryObject.id;
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Blob: {
                const blobId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__["default"])();
                treeNode.blobs[key] = blobId;
                const contentBuffer = typeof summaryObject.content === "string" ?
                    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_4__.stringToBuffer)(summaryObject.content, "utf8") : (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_5__.Uint8ArrayToArrayBuffer)(summaryObject.content);
                treeNode.blobsContents[blobId] = contentBuffer;
                break;
            }
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Handle:
                throw new _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_1__.LoggingError("No handles should be there in summary in detached container!!");
                break;
            default: {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_6__.unreachableCase)(summaryObject, `Unknown tree type ${summaryObject.type}`);
            }
        }
    }
    return treeNode;
}
/**
 * Combine and convert protocol and app summary tree to format which is readable by container while rehydrating.
 * @param protocolSummaryTree - Protocol Summary Tree
 * @param appSummaryTree - App Summary Tree
 */
function convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree) {
    // Shallow copy is fine, since we are doing a deep clone below.
    const combinedSummary = {
        type: _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.SummaryType.Tree,
        tree: Object.assign({}, appSummaryTree.tree),
    };
    combinedSummary.tree[".protocol"] = protocolSummaryTree;
    const snapshotTreeWithBlobContents = convertSummaryToSnapshotWithEmbeddedBlobContents(combinedSummary);
    return snapshotTreeWithBlobContents;
}
// This function converts the snapshot taken in detached container(by serialize api) to snapshotTree with which
// a detached container can be rehydrated.
const getSnapshotTreeFromSerializedContainer = (detachedContainerSnapshot) => {
    const protocolSummaryTree = detachedContainerSnapshot.tree[".protocol"];
    const appSummaryTree = detachedContainerSnapshot.tree[".app"];
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(protocolSummaryTree !== undefined && appSummaryTree !== undefined, 0x1e0 /* "Protocol and App summary trees should be present" */);
    const snapshotTreeWithBlobContents = convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree);
    return snapshotTreeWithBlobContents;
};
function getProtocolSnapshotTree(snapshot) {
    return ".protocol" in snapshot.trees ? snapshot.trees[".protocol"] : snapshot;
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 500 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(501);

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(502);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),
/* 502 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(503);
var parse = __webpack_require__(522);
var formats = __webpack_require__(521);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 503 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(504);
var utils = __webpack_require__(520);
var formats = __webpack_require__(521);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 504 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(505);
var callBound = __webpack_require__(512);
var inspect = __webpack_require__(518);

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),
/* 505 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(506)();
var hasProto = __webpack_require__(508)();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(509);
var hasOwn = __webpack_require__(511);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),
/* 506 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(507);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),
/* 507 */
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 508 */
/***/ ((module) => {

"use strict";


var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};


/***/ }),
/* 509 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(510);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 510 */
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 511 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(509);

/** @type {(o: {}, p: PropertyKey) => p is keyof o} */
module.exports = bind.call(call, $hasOwn);


/***/ }),
/* 512 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(505);

var callBind = __webpack_require__(513);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),
/* 513 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(509);
var GetIntrinsic = __webpack_require__(505);
var setFunctionLength = __webpack_require__(514);

var $TypeError = GetIntrinsic('%TypeError%');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),
/* 514 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(505);
var define = __webpack_require__(515);
var hasDescriptors = __webpack_require__(516)();
var gOPD = __webpack_require__(517);

var $TypeError = GetIntrinsic('%TypeError%');
var $floor = GetIntrinsic('%Math.floor%');

module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(fn, 'length', length, true, true);
		} else {
			define(fn, 'length', length);
		}
	}
	return fn;
};


/***/ }),
/* 515 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasPropertyDescriptors = __webpack_require__(516)();

var GetIntrinsic = __webpack_require__(505);

var $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

var gopd = __webpack_require__(517);

/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),
/* 516 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(505);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),
/* 517 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(505);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),
/* 518 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(519);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (obj === __webpack_require__.g) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),
/* 519 */
/***/ (() => {

/* (ignored) */

/***/ }),
/* 520 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(521);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),
/* 521 */
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),
/* 522 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(520);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),
/* 523 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoBuffer": () => (/* binding */ IsoBuffer),
/* harmony export */   "Uint8ArrayToString": () => (/* binding */ Uint8ArrayToString),
/* harmony export */   "bufferToString": () => (/* binding */ bufferToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "stringToBuffer": () => (/* binding */ stringToBuffer)
/* harmony export */ });
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(491);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64_js__WEBPACK_IMPORTED_MODULE_0__.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64_js__WEBPACK_IMPORTED_MODULE_0__.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
//# sourceMappingURL=bufferBrowser.js.map

/***/ }),
/* 524 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Uint8ArrayToArrayBuffer": () => (/* binding */ Uint8ArrayToArrayBuffer)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Convert Uint8Array array to ArrayBuffer
 * @param array - array to convert to ArrayBuffer
 */
function Uint8ArrayToArrayBuffer(array) {
    if (array.byteOffset === 0 && array.byteLength === array.buffer.byteLength) {
        return array.buffer;
    }
    return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);
}
//# sourceMappingURL=bufferShared.js.map

/***/ }),
/* 525 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unreachableCase": () => (/* binding */ unreachableCase)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
//# sourceMappingURL=unreachable.js.map

/***/ }),
/* 526 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReconnectMode": () => (/* binding */ ReconnectMode),
/* harmony export */   "getPackageName": () => (/* binding */ getPackageName)
/* harmony export */ });
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(527);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

var ReconnectMode;
(function (ReconnectMode) {
    ReconnectMode["Never"] = "Never";
    ReconnectMode["Disabled"] = "Disabled";
    ReconnectMode["Enabled"] = "Enabled";
})(ReconnectMode || (ReconnectMode = {}));
/**
 *
 * @param codeDetails- - Data structure used to describe the code to load on the Fluid document
 * @returns The name of the Fluid package
 */
const getPackageName = (codeDetails) => {
    let containerPackageName;
    if (codeDetails && "name" in codeDetails) {
        containerPackageName = codeDetails;
    }
    else if ((0,_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_0__.isFluidPackage)(codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package)) {
        containerPackageName = codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package.name;
    }
    else {
        containerPackageName = codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package;
    }
    return { name: containerPackageName };
};
//# sourceMappingURL=contracts.js.map

/***/ }),
/* 527 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IFluidCodeDetailsComparer": () => (/* binding */ IFluidCodeDetailsComparer),
/* harmony export */   "isFluidCodeDetails": () => (/* binding */ isFluidCodeDetails),
/* harmony export */   "isFluidPackage": () => (/* binding */ isFluidPackage)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Check if the package.json defines a Fluid package
 * @param pkg - the package json data to check if it is a Fluid package.
 */
const isFluidPackage = (pkg) => typeof pkg === "object"
    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.name) === "string"
    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.fluid) === "object";
const isFluidCodeDetails = (details) => {
    const maybeCodeDetails = details;
    return typeof maybeCodeDetails === "object"
        && (typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package) === "string" || isFluidPackage(maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package))
        && ((maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === undefined || typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === "object");
};
const IFluidCodeDetailsComparer = "IFluidCodeDetailsComparer";
//# sourceMappingURL=fluidPackage.js.map

/***/ }),
/* 528 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuorumProxy": () => (/* binding */ QuorumProxy),
/* harmony export */   "getCodeDetailsFromQuorumValues": () => (/* binding */ getCodeDetailsFromQuorumValues),
/* harmony export */   "initQuorumValuesFromCodeDetails": () => (/* binding */ initQuorumValuesFromCodeDetails)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(529);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(531);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(491);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Proxies Quorum events.
 */
class QuorumProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(quorum) {
        super(quorum);
        // This is heavily used object, increase limit at which Node prints warnings.
        super.setMaxListeners(50);
        this.propose = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.propose.bind(quorum));
        this.has = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.has.bind(quorum));
        this.get = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.get.bind(quorum));
        this.getMembers = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.getMembers.bind(quorum));
        this.getMember = (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.doIfNotDisposed)(this, quorum.getMember.bind(quorum));
    }
}
function getCodeDetailsFromQuorumValues(quorumValues) {
    const qValuesMap = new Map(quorumValues);
    const proposal = qValuesMap.get("code");
    (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(proposal !== undefined, 0x2dc /* "Cannot find code proposal" */);
    return proposal === null || proposal === void 0 ? void 0 : proposal.value;
}
function initQuorumValuesFromCodeDetails(source) {
    // Seed the base quorum to be an empty list with a code quorum set
    const committedCodeProposal = {
        key: "code",
        value: source,
        approvalSequenceNumber: 0,
        commitSequenceNumber: 0,
        sequenceNumber: 0,
    };
    return [["code", committedCodeProposal]];
}
//# sourceMappingURL=quorum.js.map

/***/ }),
/* 529 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventForwarder": () => (/* binding */ EventForwarder)
/* harmony export */ });
/* harmony import */ var _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(530);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Base class used for forwarding events from a source EventEmitter.
 * This can be useful when all arbitrary listeners need to be removed,
 * but the primary source needs to stay intact.
 */
class EventForwarder extends _typedEventEmitter__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter {
    constructor(source) {
        super();
        this.isDisposed = false;
        this.forwardingEvents = new Map();
        if (source !== undefined) {
            // NewListener event is raised whenever someone starts listening to this events, so
            // we keep track of events being listened to, and start forwarding from the source
            // event emitter per event listened to on this
            const removeListenerHandler = (event) => this.unforwardEvent(source, event);
            const newListenerHandler = (event) => this.forwardEvent(source, event);
            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);
            this.on(EventForwarder.newListenerEvent, newListenerHandler);
        }
    }
    static isEmitterEvent(event) {
        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;
    }
    get disposed() { return this.isDisposed; }
    dispose() {
        this.isDisposed = true;
        for (const listenerRemovers of this.forwardingEvents.values()) {
            for (const listenerRemover of listenerRemovers.values()) {
                try {
                    listenerRemover();
                }
                catch (_a) {
                    // Should be fine because of removeAllListeners below
                }
            }
        }
        this.removeAllListeners();
        this.forwardingEvents.clear();
    }
    forwardEvent(source, ...events) {
        for (const event of events) {
            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                let sources = this.forwardingEvents.get(event);
                if (sources === undefined) {
                    sources = new Map();
                    this.forwardingEvents.set(event, sources);
                }
                if (!sources.has(source)) {
                    const listener = (...args) => this.emit(event, ...args);
                    sources.set(source, () => source.off(event, listener));
                    source.on(event, listener);
                }
            }
        }
    }
    unforwardEvent(source, ...events) {
        for (const event of events) {
            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                const sources = this.forwardingEvents.get(event);
                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {
                    if (this.listenerCount(event) === 0) {
                        const listenerRemover = sources.get(source);
                        if (listenerRemover !== undefined) {
                            listenerRemover();
                        }
                        sources.delete(source);
                        if (sources.size === 0) {
                            this.forwardingEvents.delete(event);
                        }
                    }
                }
            }
        }
    }
}
EventForwarder.newListenerEvent = "newListener";
EventForwarder.removeListenerEvent = "removeListener";
//# sourceMappingURL=eventForwarder.js.map

/***/ }),
/* 530 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 531 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doIfNotDisposed": () => (/* binding */ doIfNotDisposed)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
function doIfNotDisposed(disposable, f) {
    return (...args) => {
        if (disposable.disposed) {
            throw new Error("Already disposed");
        }
        else {
            return f(...args);
        }
    };
}
//# sourceMappingURL=disposal.js.map

/***/ }),
/* 532 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RetriableDocumentStorageService": () => (/* binding */ RetriableDocumentStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(452);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



class RetriableDocumentStorageService {
    constructor(internalStorageService, logger) {
        this.internalStorageService = internalStorageService;
        this.logger = logger;
        this._disposed = false;
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    get disposed() { return this._disposed; }
    dispose() {
        this._disposed = true;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    async getSnapshotTree(version, scenarioName) {
        return this.runWithRetry(async () => this.internalStorageService.getSnapshotTree(version, scenarioName), "storage_getSnapshotTree");
    }
    async readBlob(id) {
        return this.runWithRetry(async () => this.internalStorageService.readBlob(id), "storage_readBlob");
    }
    async getVersions(versionId, count, scenarioName) {
        return this.runWithRetry(async () => this.internalStorageService.getVersions(versionId, count, scenarioName), "storage_getVersions");
    }
    async uploadSummaryWithContext(summary, context) {
        // Not using retry loop here. Couple reasons:
        // 1. If client lost connectivity, then retry loop will result in uploading stale summary
        //    by stale summarizer after connectivity comes back. It will cause failures for this client and for
        //    real (new) summarizer. This problem in particular should be solved in future by supplying abort handle
        //    on all APIs and caller (ContainerRuntime.submitSummary) aborting call on loss of connectivity
        // 2. Similar, if we get 429 with retryAfter = 10 minutes, it's likely not the right call to retry summary
        //    upload in 10 minutes - it's better to keep processing ops and retry later. Though caller needs to take
        //    retryAfter into account!
        // But retry loop is required for creation flow (Container.attach)
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((context.referenceSequenceNumber === 0) === (context.ackHandle === undefined), 0x251 /* "creation summary has to have seq=0 && handle === undefined" */);
        if (context.referenceSequenceNumber !== 0) {
            return this.internalStorageService.uploadSummaryWithContext(summary, context);
        }
        // Creation flow with attachment blobs - need to do retries!
        return this.runWithRetry(async () => this.internalStorageService.uploadSummaryWithContext(summary, context), "storage_uploadSummaryWithContext");
    }
    async downloadSummary(handle) {
        return this.runWithRetry(async () => this.internalStorageService.downloadSummary(handle), "storage_downloadSummary");
    }
    async createBlob(file) {
        return this.runWithRetry(async () => this.internalStorageService.createBlob(file), "storage_createBlob");
    }
    checkStorageDisposed() {
        if (this._disposed) {
            // pre-0.58 error message: storageServiceDisposedCannotRetry
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_1__.GenericError("Storage Service is disposed. Cannot retry", { canRetry: false });
        }
        return undefined;
    }
    async runWithRetry(api, callName) {
        return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_2__.runWithRetry)(api, callName, this.logger, {
            onRetry: () => this.checkStorageDisposed(),
        });
    }
}
//# sourceMappingURL=retriableDocumentStorageService.js.map

/***/ }),
/* 533 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtocolTreeStorageService": () => (/* binding */ ProtocolTreeStorageService)
/* harmony export */ });
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(338);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

class ProtocolTreeStorageService {
    constructor(internalStorageService, generateProtocolTree) {
        this.internalStorageService = internalStorageService;
        this.generateProtocolTree = generateProtocolTree;
        this.getSnapshotTree = this.internalStorageService.getSnapshotTree.bind(this.internalStorageService);
        this.getVersions = this.internalStorageService.getVersions.bind(this.internalStorageService);
        this.createBlob = this.internalStorageService.createBlob.bind(this.internalStorageService);
        this.readBlob = this.internalStorageService.readBlob.bind(this.internalStorageService);
        this.downloadSummary = this.internalStorageService.downloadSummary.bind(this.internalStorageService);
        this.dispose = this.internalStorageService.dispose.bind(this.internalStorageService);
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    get disposed() {
        return this.internalStorageService.disposed;
    }
    async uploadSummaryWithContext(summary, context) {
        return this.internalStorageService.uploadSummaryWithContext((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_0__.combineAppAndProtocolSummary)(summary, this.generateProtocolTree()), context);
    }
}
//# sourceMappingURL=protocolTreeDocumentStorageService.js.map

/***/ }),
/* 534 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtocolOpHandler": () => (/* binding */ ProtocolOpHandler),
/* harmony export */   "ProtocolOpHandlerWithClientValidation": () => (/* binding */ ProtocolOpHandlerWithClientValidation),
/* harmony export */   "isSystemMessage": () => (/* binding */ isSystemMessage)
/* harmony export */ });
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(535);
/* harmony import */ var _quorum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(536);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


function isSystemMessage(message) {
    switch (message.type) {
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoClient:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Summarize:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.SummaryAck:
        case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.SummaryNack:
            return true;
        default:
            return false;
    }
}
/**
 * Handles protocol specific ops.
 */
class ProtocolOpHandler {
    constructor(minimumSequenceNumber, sequenceNumber, term, members, proposals, values, sendProposal) {
        this.minimumSequenceNumber = minimumSequenceNumber;
        this.sequenceNumber = sequenceNumber;
        this.term = term !== null && term !== void 0 ? term : 1;
        this._quorum = new _quorum__WEBPACK_IMPORTED_MODULE_1__.Quorum(members, proposals, values, sendProposal);
    }
    get quorum() {
        return this._quorum;
    }
    get attributes() {
        return {
            minimumSequenceNumber: this.minimumSequenceNumber,
            sequenceNumber: this.sequenceNumber,
            term: this.term,
        };
    }
    setConnectionState(connected, clientId) {
        this._quorum.setConnectionState(connected, clientId);
    }
    snapshot() {
        return this._quorum.snapshot();
    }
    close() {
        this._quorum.close();
    }
    processMessage(message, local) {
        // verify it's moving sequentially
        if (message.sequenceNumber !== this.sequenceNumber + 1) {
            throw new Error(`Protocol state is not moving sequentially. ` +
                `Current is ${this.sequenceNumber}. Next is ${message.sequenceNumber}`);
        }
        // Update tracked sequence numbers
        this.sequenceNumber = message.sequenceNumber;
        this.minimumSequenceNumber = message.minimumSequenceNumber;
        let immediateNoOp = false;
        switch (message.type) {
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin:
                const systemJoinMessage = message;
                const join = JSON.parse(systemJoinMessage.data);
                const member = {
                    client: join.detail,
                    sequenceNumber: systemJoinMessage.sequenceNumber,
                };
                this._quorum.addMember(join.clientId, member);
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientLeave:
                const systemLeaveMessage = message;
                const clientId = JSON.parse(systemLeaveMessage.data);
                this._quorum.removeMember(clientId);
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Propose:
                const proposal = message.contents;
                this._quorum.addProposal(proposal.key, proposal.value, message.sequenceNumber, local, message.clientSequenceNumber);
                // On a quorum proposal, immediately send a response to expedite the approval.
                immediateNoOp = true;
                break;
            case _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.Reject:
                throw new Error("Quorum rejection is removed.");
            default:
        }
        // Notify the quorum of the MSN from the message. We rely on it to handle duplicate values but may
        // want to move that logic to this class.
        this._quorum.updateMinimumSequenceNumber(message);
        return { immediateNoOp };
    }
    /**
     * Gets the scribe protocol state
     */
    getProtocolState() {
        // return a new object every time
        // this ensures future state changes will not affect outside callers
        return Object.assign({ sequenceNumber: this.sequenceNumber, minimumSequenceNumber: this.minimumSequenceNumber }, this._quorum.snapshot());
    }
}
class ProtocolOpHandlerWithClientValidation extends ProtocolOpHandler {
    processMessage(message, local) {
        const client = this._quorum.getMember(message.clientId);
        // Check and report if we're getting messages from a clientId that we previously
        // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be
        if (message.clientId != null) {
            if (client === undefined && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.ClientJoin) {
                // pre-0.58 error message: messageClientIdMissingFromQuorum
                throw new Error("Remote message's clientId is missing from the quorum");
            }
            if ((client === null || client === void 0 ? void 0 : client.shouldHaveLeft) === true && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_0__.MessageType.NoOp) {
                // pre-0.58 error message: messageClientIdShouldHaveLeft
                throw new Error("Remote message's clientId already should have left");
            }
        }
        return super.processMessage(message, local);
    }
}
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 535 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 536 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quorum": () => (/* binding */ Quorum),
/* harmony export */   "QuorumClients": () => (/* binding */ QuorumClients),
/* harmony export */   "QuorumProposals": () => (/* binding */ QuorumProposals)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(158);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(537);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(538);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

// eslint-disable-next-line import/no-internal-modules


/**
 * Structure for tracking proposals that have been sequenced but not approved yet.
 */
class PendingProposal {
    constructor(sequenceNumber, key, value, local) {
        this.sequenceNumber = sequenceNumber;
        this.key = key;
        this.value = value;
        this.local = local;
    }
}
/**
 * The QuorumClients is used to track members joining and leaving the collaboration session.
 */
class QuorumClients extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(snapshot) {
        super();
        this.isDisposed = false;
        this.members = new Map(snapshot);
        this.snapshotCache = snapshot;
    }
    get disposed() { return this.isDisposed; }
    /**
     * Snapshots the current state of the QuorumClients
     * @returns a snapshot of the clients in the quorum
     */
    snapshot() {
        var _a;
        (_a = this.snapshotCache) !== null && _a !== void 0 ? _a : (this.snapshotCache = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(Array.from(this.members)));
        return this.snapshotCache;
    }
    /**
     * Adds a new client to the quorum
     */
    addMember(clientId, details) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.members.has(clientId), 0x1ce /* clientId not found */);
        this.members.set(clientId, details);
        this.emit("addMember", clientId, details);
        // clear the cache
        this.snapshotCache = undefined;
    }
    /**
     * Removes a client from the quorum
     */
    removeMember(clientId) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(this.members.has(clientId), 0x1cf /* clientId not found */);
        this.members.delete(clientId);
        this.emit("removeMember", clientId);
        // clear the cache
        this.snapshotCache = undefined;
    }
    /**
     * Retrieves all the members in the quorum
     */
    getMembers() {
        return new Map(this.members);
    }
    /**
     * Retrieves a specific member of the quorum
     */
    getMember(clientId) {
        return this.members.get(clientId);
    }
    dispose() {
        this.isDisposed = true;
    }
}
/**
 * The QuorumProposals holds a key/value store.  Proposed values become finalized in the store once all connected
 * clients have seen the proposal.
 */
class QuorumProposals extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(snapshot, sendProposal) {
        super();
        this.sendProposal = sendProposal;
        this.isDisposed = false;
        // Event emitter for changes to the environment that affect pending proposal promises.
        this.stateEvents = new events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.proposals = new Map(snapshot.proposals.map(([, proposal]) => {
            return [
                proposal.sequenceNumber,
                new PendingProposal(proposal.sequenceNumber, proposal.key, proposal.value, false),
            ];
        }));
        this.values = new Map(snapshot.values);
        this.proposalsSnapshotCache = snapshot.proposals;
        this.valuesSnapshotCache = snapshot.values;
    }
    get disposed() { return this.isDisposed; }
    /**
     * Snapshots the current state of the QuorumProposals
     * @returns deep cloned arrays of proposals and values
     */
    snapshot() {
        var _a, _b;
        (_a = this.proposalsSnapshotCache) !== null && _a !== void 0 ? _a : (this.proposalsSnapshotCache = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [
            sequenceNumber,
            { sequenceNumber, key: proposal.key, value: proposal.value },
            [], // rejections, which has been removed
        ]));
        (_b = this.valuesSnapshotCache) !== null && _b !== void 0 ? _b : (this.valuesSnapshotCache = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(Array.from(this.values)));
        return {
            proposals: this.proposalsSnapshotCache,
            values: this.valuesSnapshotCache,
        };
    }
    /**
     * Returns whether the quorum has achieved a consensus for the given key.
     */
    has(key) {
        return this.values.has(key);
    }
    /**
     * Returns the consensus value for the given key
     */
    get(key) {
        var _a;
        return (_a = this.values.get(key)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Returns additional data about the approved consensus value
     * @deprecated Removed in recent protocol-definitions.  Use get() instead.
     */
    getApprovalData(key) {
        const proposal = this.values.get(key);
        return proposal ? lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_1___default()(proposal) : undefined;
    }
    /**
     * Proposes a new value. Returns a promise that will either:
     * - Resolve when the proposal is accepted
     * - Reject if the proposal fails to send or if the QuorumProposals is disposed
     */
    async propose(key, value) {
        const clientSequenceNumber = this.sendProposal(key, value);
        if (clientSequenceNumber < 0) {
            this.emit("error", { eventName: "ProposalInDisconnectedState", key });
            throw new Error("Can't propose in disconnected state");
        }
        return new Promise((resolve, reject) => {
            // The sequence number that our proposal was assigned and went pending.
            // If undefined, then it's not sequenced yet.
            let thisProposalSequenceNumber;
            // A proposal goes through two phases before this promise resolves:
            // 1. Sequencing - waiting for the proposal to be ack'd by the server.
            // 2. Approval - waiting for the proposal to be approved by connected clients.
            const localProposalSequencedHandler = (sequencedCSN, sequenceNumber) => {
                if (sequencedCSN === clientSequenceNumber) {
                    thisProposalSequenceNumber = sequenceNumber;
                    this.stateEvents.off("localProposalSequenced", localProposalSequencedHandler);
                    this.stateEvents.off("disconnected", disconnectedHandler);
                    this.stateEvents.on("localProposalApproved", localProposalApprovedHandler);
                }
            };
            const localProposalApprovedHandler = (sequenceNumber) => {
                // Proposals can be uniquely identified by the sequenceNumber they were assigned.
                if (sequenceNumber === thisProposalSequenceNumber) {
                    resolve();
                    removeListeners();
                }
            };
            // There are two error flows we consider:  disconnect and disposal.
            // If we get disconnected before the proposal is sequenced, it has one of two possible futures:
            // 1. We reconnect and see the proposal was sequenced in the meantime.
            //    -> The promise can still resolve, once it is approved.
            // 2. We reconnect and see the proposal was not sequenced in the meantime, so it will never sequence.
            //    -> The promise rejects.
            const disconnectedHandler = () => {
                // If we haven't seen the ack by the time we disconnect, we hope to see it by the time we reconnect.
                if (thisProposalSequenceNumber === undefined) {
                    this.stateEvents.once("connected", () => {
                        // If we don't see the ack by the time reconnection finishes, it failed to send.
                        if (thisProposalSequenceNumber === undefined) {
                            reject(new Error("Client disconnected without successfully sending proposal"));
                            removeListeners();
                        }
                    });
                }
            };
            // If the QuorumProposals is disposed of, we assume something catastrophic has happened
            // All outstanding proposals are considered rejected.
            const disposedHandler = () => {
                reject(new Error("QuorumProposals was disposed"));
                removeListeners();
            };
            // Convenience function to clean up our listeners.
            const removeListeners = () => {
                this.stateEvents.off("localProposalSequenced", localProposalSequencedHandler);
                this.stateEvents.off("localProposalApproved", localProposalApprovedHandler);
                this.stateEvents.off("disconnected", disconnectedHandler);
                this.stateEvents.off("disposed", disposedHandler);
            };
            this.stateEvents.on("localProposalSequenced", localProposalSequencedHandler);
            this.stateEvents.on("disconnected", disconnectedHandler);
            this.stateEvents.on("disposed", disposedHandler);
        });
    }
    /**
     * Begins tracking a new proposal
     */
    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(!this.proposals.has(sequenceNumber), 0x1d0 /* sequenceNumber not found */);
        const proposal = new PendingProposal(sequenceNumber, key, value, local);
        this.proposals.set(sequenceNumber, proposal);
        // Legacy event, from rejection support.  May still have some use for clients to learn that a proposal is
        // likely to be approved soon.
        this.emit("addProposal", proposal);
        if (local) {
            this.stateEvents.emit("localProposalSequenced", clientSequenceNumber, sequenceNumber);
        }
        // clear the proposal cache
        this.proposalsSnapshotCache = undefined;
    }
    /**
     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it
     * becomes an approved value.
     */
    updateMinimumSequenceNumber(message) {
        const msn = message.minimumSequenceNumber;
        // Accept proposals proposals whose sequenceNumber is <= the minimumSequenceNumber
        // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order
        // TODO this can be optimized if necessary to avoid the linear search+sort
        const completed = [];
        for (const [sequenceNumber, proposal] of this.proposals) {
            if (sequenceNumber <= msn) {
                completed.push(proposal);
            }
        }
        completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        for (const proposal of completed) {
            const committedProposal = {
                approvalSequenceNumber: message.sequenceNumber,
                // No longer used.  We still stamp a -1 for compat with older versions of the quorum.
                // Can be removed after 0.1035 and higher is ubiquitous.
                commitSequenceNumber: -1,
                key: proposal.key,
                sequenceNumber: proposal.sequenceNumber,
                value: proposal.value,
            };
            this.values.set(committedProposal.key, committedProposal);
            // clear the values cache
            this.valuesSnapshotCache = undefined;
            this.emit("approveProposal", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);
            this.proposals.delete(proposal.sequenceNumber);
            // clear the proposals cache
            this.proposalsSnapshotCache = undefined;
            if (proposal.local) {
                this.stateEvents.emit("localProposalApproved", proposal.sequenceNumber);
            }
        }
    }
    setConnectionState(connected) {
        if (connected) {
            this.stateEvents.emit("connected");
        }
        else {
            this.stateEvents.emit("disconnected");
        }
    }
    dispose() {
        this.isDisposed = true;
        this.stateEvents.emit("disposed");
    }
}
/**
 * A quorum represents all clients currently within the collaboration window. As well as the values
 * they have agreed upon and any pending proposals.
 */
class Quorum extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor(members, proposals, values, sendProposal) {
        super();
        this.isDisposed = false;
        this.quorumClients = new QuorumClients(members);
        this.quorumClients.on("addMember", (clientId, details) => {
            this.emit("addMember", clientId, details);
        });
        this.quorumClients.on("removeMember", (clientId) => {
            this.emit("removeMember", clientId);
        });
        this.quorumProposals = new QuorumProposals({ proposals, values }, sendProposal);
        this.quorumProposals.on("addProposal", (proposal) => {
            this.emit("addProposal", proposal);
        });
        this.quorumProposals.on("approveProposal", (sequenceNumber, key, value, approvalSequenceNumber) => {
            this.emit("approveProposal", sequenceNumber, key, value, approvalSequenceNumber);
        });
    }
    get disposed() { return this.isDisposed; }
    close() {
        this.removeAllListeners();
    }
    /**
     * Snapshots the entire quorum
     * @returns a quorum snapshot
     */
    snapshot() {
        const members = this.quorumClients.snapshot();
        const { proposals, values } = this.quorumProposals.snapshot();
        return {
            members,
            proposals,
            values,
        };
    }
    /**
     * Returns whether the quorum has achieved a consensus for the given key.
     */
    has(key) {
        return this.quorumProposals.has(key);
    }
    /**
     * Returns the consensus value for the given key
     */
    get(key) {
        return this.quorumProposals.get(key);
    }
    /**
     * Returns additional data about the approved consensus value
     * @deprecated Removed in recent protocol-definitions.  Use get() instead.
     */
    getApprovalData(key) {
        return this.quorumProposals.getApprovalData(key);
    }
    /**
     * Adds a new client to the quorum
     */
    addMember(clientId, details) {
        this.quorumClients.addMember(clientId, details);
    }
    /**
     * Removes a client from the quorum
     */
    removeMember(clientId) {
        this.quorumClients.removeMember(clientId);
    }
    /**
     * Retrieves all the members in the quorum
     */
    getMembers() {
        return this.quorumClients.getMembers();
    }
    /**
     * Retrieves a specific member of the quorum
     */
    getMember(clientId) {
        return this.quorumClients.getMember(clientId);
    }
    /**
     * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted, or reject if
     * the proposal fails to send.
     */
    async propose(key, value) {
        return this.quorumProposals.propose(key, value);
    }
    /**
     * Begins tracking a new proposal
     */
    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {
        return this.quorumProposals.addProposal(key, value, sequenceNumber, local, clientSequenceNumber);
    }
    /**
     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it
     * becomes an approved value.
     */
    updateMinimumSequenceNumber(message) {
        this.quorumProposals.updateMinimumSequenceNumber(message);
    }
    setConnectionState(connected, clientId) {
        this.quorumProposals.setConnectionState(connected);
    }
    dispose() {
        throw new Error("Not implemented.");
        this.isDisposed = true;
    }
}
//# sourceMappingURL=quorum.js.map

/***/ }),
/* 537 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedEventEmitter": () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
//# sourceMappingURL=typedEventEmitter.js.map

/***/ }),
/* 538 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),
/* 539 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "NackErrorType": () => (/* binding */ NackErrorType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType || (MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType || (NackErrorType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 540 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pkgName": () => (/* binding */ pkgName),
/* harmony export */   "pkgVersion": () => (/* binding */ pkgVersion)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
const pkgName = "@fluidframework/container-loader";
const pkgVersion = "1.4.0";
//# sourceMappingURL=packageVersion.js.map

/***/ }),
/* 541 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaManager": () => (/* binding */ DeltaManager)
/* harmony export */ });
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(542);
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(abort_controller__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(530);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(132);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(544);
/* harmony import */ var _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(539);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(117);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(64);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/* harmony import */ var _deltaQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(543);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */









/**
 * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta
 * messages in order regardless of possible network conditions or timings causing out of order delivery.
 */
class DeltaManager extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TypedEventEmitter {
    constructor(serviceProvider, logger, _active, createConnectionManager) {
        super();
        this.serviceProvider = serviceProvider;
        this.logger = logger;
        this._active = _active;
        this.pending = [];
        // The minimum sequence number and last sequence number received from the server
        this.minSequenceNumber = 0;
        // There are three numbers we track
        // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number
        //   is not updated until we cover that gap, so it increases each time by 1.
        // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially
        //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.
        //   It's never less than lastQueuedSequenceNumber
        // * lastProcessedSequenceNumber - last processed sequence number
        this.lastQueuedSequenceNumber = 0;
        this.lastObservedSeqNumber = 0;
        this.lastProcessedSequenceNumber = 0;
        this.baseTerm = 0;
        /**
         * Track down the ops size.
        */
        this.opsSize = 0;
        // The sequence number we initially loaded from
        this.initSequenceNumber = 0;
        this.closed = false;
        this.throttlingIdSet = new Set();
        this.timeTillThrottling = 0;
        this.closeAbortController = new (abort_controller__WEBPACK_IMPORTED_MODULE_0___default())();
        this.deltaStorageDelayId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__["default"])();
        this.deltaStreamDelayId = (0,uuid__WEBPACK_IMPORTED_MODULE_2__["default"])();
        this.messageBuffer = [];
        const props = {
            incomingOpHandler: (messages, reason) => {
                try {
                    this.enqueueMessages(messages, reason);
                }
                catch (error) {
                    this.logger.sendErrorEvent({ eventName: "EnqueueMessages_Exception" }, error);
                    this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeError)(error));
                }
            },
            signalHandler: (message) => this._inboundSignal.push(message),
            reconnectionDelayHandler: (delayMs, error) => this.emitDelayInfo(this.deltaStreamDelayId, delayMs, error),
            closeHandler: (error) => this.close(error),
            disconnectHandler: (reason) => this.disconnectHandler(reason),
            connectHandler: (connection) => this.connectHandler(connection),
            pongHandler: (latency) => this.emit("pong", latency),
            readonlyChangeHandler: (readonly) => (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.safeRaiseEvent)(this, this.logger, "readonly", readonly),
        };
        this.connectionManager = createConnectionManager(props);
        this._inbound = new _deltaQueue__WEBPACK_IMPORTED_MODULE_5__.DeltaQueue((op) => {
            this.processInboundMessage(op);
        });
        this._inbound.on("error", (error) => {
            this.close(_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataProcessingError.wrapIfUnrecognized(error, "deltaManagerInboundErrorHandler", this.lastMessage));
        });
        // Inbound signal queue
        this._inboundSignal = new _deltaQueue__WEBPACK_IMPORTED_MODULE_5__.DeltaQueue((message) => {
            if (this.handler === undefined) {
                throw new Error("Attempted to process an inbound signal without a handler attached");
            }
            this.handler.processSignal({
                clientId: message.clientId,
                content: JSON.parse(message.content),
            });
        });
        this._inboundSignal.on("error", (error) => {
            this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeError)(error));
        });
        // Initially, all queues are created paused.
        // - outbound is flipped back and forth in setupNewSuccessfulConnection / disconnectFromDeltaStream
        // - inbound & inboundSignal are resumed in attachOpHandler() when we have handler setup
    }
    get active() { return this._active(); }
    get disposed() { return this.closed; }
    get IDeltaSender() { return this; }
    get inbound() {
        return this._inbound;
    }
    get inboundSignal() {
        return this._inboundSignal;
    }
    get initialSequenceNumber() {
        return this.initSequenceNumber;
    }
    get lastSequenceNumber() {
        return this.lastProcessedSequenceNumber;
    }
    get lastMessage() {
        return this.lastProcessedMessage;
    }
    get lastKnownSeqNumber() {
        return this.lastObservedSeqNumber;
    }
    get referenceTerm() {
        return this.baseTerm;
    }
    get minimumSequenceNumber() {
        return this.minSequenceNumber;
    }
    /**
     * Tells if  current connection has checkpoint information.
     * I.e. we know how far behind the client was at the time of establishing connection
     */
    get hasCheckpointSequenceNumber() {
        // Valid to be called only if we have active connection.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connectionManager.connected, 0x0df /* "Missing active connection" */);
        return this._checkpointSequenceNumber !== undefined;
    }
    // Forwarding connection manager properties / IDeltaManager implementation
    get maxMessageSize() { return this.connectionManager.maxMessageSize; }
    get version() { return this.connectionManager.version; }
    get serviceConfiguration() { return this.connectionManager.serviceConfiguration; }
    get outbound() { return this.connectionManager.outbound; }
    get readOnlyInfo() { return this.connectionManager.readOnlyInfo; }
    get clientDetails() { return this.connectionManager.clientDetails; }
    submit(type, contents, batch = false, metadata) {
        const messagePartial = {
            contents: JSON.stringify(contents),
            metadata,
            referenceSequenceNumber: this.lastProcessedSequenceNumber,
            type,
        };
        if (!batch) {
            this.flush();
        }
        const message = this.connectionManager.prepareMessageToSend(messagePartial);
        if (message === undefined) {
            return -1;
        }
        this.opsSize += message.contents.length;
        this.messageBuffer.push(message);
        this.emit("submitOp", message);
        if (!batch) {
            this.flush();
        }
        return message.clientSequenceNumber;
    }
    submitSignal(content) { return this.connectionManager.submitSignal(content); }
    flush() {
        if (this.messageBuffer.length === 0) {
            return;
        }
        // The prepareFlush event allows listeners to append metadata to the batch prior to submission.
        this.emit("prepareSend", this.messageBuffer);
        this.connectionManager.sendMessages(this.messageBuffer);
        this.messageBuffer = [];
    }
    get connectionProps() {
        return Object.assign({ sequenceNumber: this.lastSequenceNumber, opsSize: this.opsSize > 0 ? this.opsSize : undefined }, this.connectionManager.connectionProps);
    }
    /**
     * Log error event with a bunch of internal to DeltaManager information about state of op processing
     * Used to diagnose connectivity issues related to op processing (i.e. cases where for some reason
     * we stop processing ops that results in no processing join op and thus moving to connected state)
     * @param event - Event to log.
     */
    logConnectionIssue(event) {
        var _a;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connectionManager.connected, 0x238 /* "called only in connected state" */);
        const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        this.logger.sendErrorEvent(Object.assign(Object.assign(Object.assign(Object.assign({}, event), { 
            // This directly tells us if fetching ops is in flight, and thus likely the reason of
            // stalled op processing
            fetchReason: this.fetchReason, 
            // A bunch of useful sequence numbers to understand if we are holding some ops from processing
            lastQueuedSequenceNumber: this.lastQueuedSequenceNumber, lastProcessedSequenceNumber: this.lastProcessedSequenceNumber, lastObserved: this.lastObservedSeqNumber }), this.connectionManager.connectionVerboseProps), { pendingOps: this.pending.length, pendingFirst: (_a = pendingSorted[0]) === null || _a === void 0 ? void 0 : _a.sequenceNumber, haveHandler: this.handler !== undefined, inboundLength: this.inbound.length, inboundPaused: this.inbound.paused }));
    }
    connectHandler(connection) {
        this.refreshDelayInfo(this.deltaStreamDelayId);
        const props = this.connectionManager.connectionVerboseProps;
        props.connectionLastQueuedSequenceNumber = this.lastQueuedSequenceNumber;
        props.connectionLastObservedSeqNumber = this.lastObservedSeqNumber;
        const checkpointSequenceNumber = connection.checkpointSequenceNumber;
        this._checkpointSequenceNumber = checkpointSequenceNumber;
        if (checkpointSequenceNumber !== undefined) {
            this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);
        }
        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.
        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),
        // but it's safe to assume (until better design is put into place) that batches should not exist
        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected
        // state. As requirements change, so should these checks.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.messageBuffer.length === 0, 0x0e9 /* "messageBuffer is not empty on new connection" */);
        this.opsSize = 0;
        this.emit("connect", connection, checkpointSequenceNumber !== undefined ?
            this.lastObservedSeqNumber - this.lastSequenceNumber : undefined);
        // If we got some initial ops, then we know the gap and call above fetched ops to fill it.
        // Same is true for "write" mode even if we have no ops - we will get "join" own op very very soon.
        // However if we are connecting as view-only, then there is no good signal to realize if client is behind.
        // Thus we have to hit storage to see if any ops are there.
        if (checkpointSequenceNumber !== undefined) {
            // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.
            if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {
                this.fetchMissingDeltas("AfterConnection");
            }
            // we do not know the gap, and we will not learn about it if socket is quite - have to ask.
        }
        else if (connection.mode === "read") {
            this.fetchMissingDeltas("AfterReadConnection");
        }
    }
    dispose() {
        throw new Error("Not implemented.");
    }
    /**
     * Sets the sequence number from which inbound messages should be returned
     */
    async attachOpHandler(minSequenceNumber, sequenceNumber, term, handler, prefetchType = "none") {
        this.initSequenceNumber = sequenceNumber;
        this.lastProcessedSequenceNumber = sequenceNumber;
        this.baseTerm = term;
        this.minSequenceNumber = minSequenceNumber;
        this.lastQueuedSequenceNumber = sequenceNumber;
        this.lastObservedSeqNumber = sequenceNumber;
        // We will use same check in other places to make sure all the seq number above are set properly.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.handler === undefined, 0x0e2 /* "DeltaManager already has attached op handler!" */);
        this.handler = handler;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this.handler, 0x0e3 /* "Newly set op handler is null/undefined!" */);
        // There should be no pending fetch!
        // This API is called right after attachOpHandler by Container.load().
        // We might have connection already and it might have called fetchMissingDeltas() from
        // setupNewSuccessfulConnection. But it should do nothing, because there is no way to fetch ops before
        // we know snapshot sequence number that is set in attachOpHandler. So all such calls should be noop.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.fetchReason === undefined, 0x268 /* "There can't be pending fetch that early in boot sequence!" */);
        if (this.closed) {
            return;
        }
        this._inbound.resume();
        this._inboundSignal.resume();
        if (prefetchType !== "none") {
            const cacheOnly = prefetchType === "cached";
            await this.fetchMissingDeltasCore(`DocumentOpen_${prefetchType}`, cacheOnly);
            // Keep going with fetching ops from storage once we have all cached ops in.
            // But do not block load and make this request async / not blocking this api.
            // Ops processing will start once cached ops are in and and will stop when queue is empty
            // (which in most cases will happen when we are done processing cached ops)
            if (cacheOnly) {
                // fire and forget
                this.fetchMissingDeltas("PostDocumentOpen");
            }
        }
        // Ensure there is no need to call this.processPendingOps() at the end of boot sequence
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.fetchReason !== undefined || this.pending.length === 0, 0x269 /* "pending ops are not dropped" */);
    }
    connect(args) {
        var _a;
        const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;
        (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_8__.logIfFalse)(this.handler !== undefined || !fetchOpsFromStorage, this.logger, "CantFetchWithoutBaseline"); // can't fetch if no baseline
        // Note: There is race condition here.
        // We want to issue request to storage as soon as possible, to
        // reduce latency of becoming current, thus this code here.
        // But there is no ordering between fetching OPs and connection to delta stream
        // As result, we might be behind by the time we connect to delta stream
        // In case of r/w connection, that's not an issue, because we will hear our
        // own "join" message and realize any gap client has in ops.
        // But for view-only connection, we have no such signal, and with no traffic
        // on the wire, we might be always behind.
        // See comment at the end of "connect" handler
        if (fetchOpsFromStorage) {
            this.fetchMissingDeltas(args.reason);
        }
        this.connectionManager.connect(args.mode);
    }
    async getDeltas(from, // inclusive
    to, // exclusive
    fetchReason, callback, cacheOnly) {
        const docService = this.serviceProvider();
        if (docService === undefined) {
            throw new Error("Delta manager is not attached");
        }
        if (this.deltaStorage === undefined) {
            this.deltaStorage = await docService.connectToDeltaStorage();
        }
        let cancelFetch;
        if (to !== undefined) {
            const lastExpectedOp = to - 1; // make it inclusive!
            // It is possible that due to asynchrony (including await above), required ops were already
            // received through delta stream. Validate that before moving forward.
            if (this.lastQueuedSequenceNumber >= lastExpectedOp) {
                this.logger.sendPerformanceEvent(Object.assign({ reason: fetchReason, eventName: "ExtraStorageCall", early: true, from,
                    to }, this.connectionManager.connectionVerboseProps));
                return;
            }
            // Be prepared for the case where webSocket would receive the ops that we are trying to fill through
            // storage. Ideally it should never happen (i.e. ops on socket are always ordered, and thus once we
            // detected gap, this gap can't be filled in later on through websocket).
            // And in practice that does look like the case. The place where this code gets hit is if we lost
            // connection and reconnected (likely to another box), and new socket's initial ops contains these ops.
            cancelFetch = (op) => op.sequenceNumber >= lastExpectedOp;
        }
        else {
            // Unbound requests are made to proactively fetch ops, but also get up to date in cases where socket
            // is silent (and connection is "read", thus we might not have any data on how far client is behind).
            // Once we have any op coming in from socket, we can cancel it as it's not needed any more.
            // That said, if we have socket connection, make sure we got ops up to checkpointSequenceNumber!
            cancelFetch = (op) => op.sequenceNumber >= this.lastObservedSeqNumber;
        }
        const controller = new (abort_controller__WEBPACK_IMPORTED_MODULE_0___default())();
        let opsFromFetch = false;
        const opListener = (op) => {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(op.sequenceNumber === this.lastQueuedSequenceNumber, 0x23a /* "seq#'s" */);
            // Ops that are coming from this request should not cancel itself.
            // This is useless for known ranges (to is defined) as it means request is over either way.
            // And it will cancel unbound request too early, not allowing us to learn where the end of the file is.
            if (!opsFromFetch && cancelFetch(op)) {
                controller.abort();
                this._inbound.off("push", opListener);
            }
        };
        try {
            this._inbound.on("push", opListener);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.closeAbortController.signal.onabort === null, 0x1e8 /* "reentrancy" */);
            this.closeAbortController.signal.onabort = () => controller.abort();
            const stream = this.deltaStorage.fetchMessages(from, // inclusive
            to, // exclusive
            controller.signal, cacheOnly, fetchReason);
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const result = await stream.read();
                if (result.done) {
                    break;
                }
                try {
                    opsFromFetch = true;
                    callback(result.value);
                }
                finally {
                    opsFromFetch = false;
                }
            }
        }
        finally {
            this.closeAbortController.signal.onabort = null;
            this._inbound.off("push", opListener);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!opsFromFetch, 0x289 /* "logic error" */);
        }
    }
    /**
     * Closes the connection and clears inbound & outbound queues.
     */
    close(error) {
        if (this.closed) {
            return;
        }
        this.closed = true;
        this.connectionManager.dispose(error);
        this.closeAbortController.abort();
        this._inbound.clear();
        this._inboundSignal.clear();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inboundSignal.pause();
        // Drop pending messages - this will ensure catchUp() does not go into infinite loop
        this.pending = [];
        // This needs to be the last thing we do (before removing listeners), as it causes
        // Container to dispose context and break ability of data stores / runtime to "hear"
        // from delta manager, including notification (above) about readonly state.
        this.emit("closed", error);
        this.removeAllListeners();
    }
    refreshDelayInfo(id) {
        this.throttlingIdSet.delete(id);
        if (this.throttlingIdSet.size === 0) {
            this.timeTillThrottling = 0;
        }
    }
    disconnectHandler(reason) {
        this.messageBuffer.length = 0;
        this.emit("disconnect", reason);
    }
    /**
     * Emit info about a delay in service communication on account of throttling.
     * @param id - Id of the connection that is delayed
     * @param delayMs - Duration of the delay
     * @param error - error object indicating the throttling
     */
    emitDelayInfo(id, delayMs, error) {
        const timeNow = Date.now();
        this.throttlingIdSet.add(id);
        if (delayMs > 0 && (timeNow + delayMs > this.timeTillThrottling)) {
            this.timeTillThrottling = timeNow + delayMs;
            const throttlingWarning = _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.ThrottlingWarning.wrap(error, delayMs / 1000 /* retryAfterSeconds */, this.logger);
            this.emit("throttled", throttlingWarning);
        }
    }
    // returns parts of message (in string format) that should never change for a given message.
    // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.
    // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.
    // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number
    // reuse.
    // Also payload goes to telemetry, so no PII, including content!!
    // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.
    comparableMessagePayload(m) {
        return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;
    }
    enqueueMessages(messages, reason, allowGaps = false) {
        var _a, _b;
        if (this.handler === undefined) {
            // We did not setup handler yet.
            // This happens when we connect to web socket faster than we get attributes for container
            // and thus faster than attachOpHandler() is called
            // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()
            // to do the right thing.
            this.pending = this.pending.concat(messages);
            return;
        }
        // Pending ops should never just hang around for nothing.
        // This invariant will stay true through this function execution,
        // so there is no need to process pending ops here.
        // It's responsibility of
        // - attachOpHandler()
        // - fetchMissingDeltas() after it's done with querying storage
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pending.length === 0 || this.fetchReason !== undefined, 0x1e9 /* "Pending ops" */);
        if (messages.length === 0) {
            return;
        }
        const from = messages[0].sequenceNumber;
        const last = messages[messages.length - 1].sequenceNumber;
        // Report stats about missing and duplicate ops
        // This helps better understand why we fetch ops from storage, and thus may delay
        // getting current / sending ops
        // It's possible that this batch is already too late - do not bother
        if (last > this.lastQueuedSequenceNumber) {
            let prev = from - 1;
            const initialGap = prev - this.lastQueuedSequenceNumber;
            let firstMissing;
            let duplicate = 0;
            let gap = 0;
            // Count all gaps and duplicates
            for (const message of messages) {
                if (message.sequenceNumber === prev) {
                    duplicate++;
                }
                else if (message.sequenceNumber !== prev + 1) {
                    gap++;
                    if (firstMissing === undefined) {
                        firstMissing = prev + 1;
                    }
                }
                prev = message.sequenceNumber;
            }
            let eventName;
            // Report if we found some issues
            if (duplicate !== 0 || gap !== 0 && !allowGaps || initialGap > 0 && this.fetchReason === undefined) {
                eventName = "enqueueMessages";
                // Also report if we are fetching ops, and same range comes in, thus making this fetch obsolete.
            }
            else if (this.fetchReason !== undefined && this.fetchReason !== reason &&
                (from <= this.lastQueuedSequenceNumber + 1 && last > this.lastQueuedSequenceNumber)) {
                eventName = "enqueueMessagesExtraFetch";
            }
            // Report if there is something to report
            // Do not report when pending fetch is in progress, as such reporting will not
            // correctly take into account pending ops.
            if (eventName !== undefined) {
                this.logger.sendPerformanceEvent(Object.assign({ eventName,
                    reason, previousReason: this.prevEnqueueMessagesReason, from, to: last + 1, length: messages.length, fetchReason: this.fetchReason, duplicate: duplicate > 0 ? duplicate : undefined, initialGap: initialGap !== 0 ? initialGap : undefined, gap: gap > 0 ? gap : undefined, firstMissing, dmInitialSeqNumber: this.initialSequenceNumber }, this.connectionManager.connectionVerboseProps));
            }
        }
        this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);
        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec /* "Unexpected value for previously processed message's sequence number" */);
        for (const message of messages) {
            // Check that the messages are arriving in the expected order
            if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {
                // Validate that we do not have data loss, i.e. sequencing is reset and started again
                // with numbers that this client already observed before.
                if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {
                    const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);
                    const message2 = this.comparableMessagePayload(message);
                    if (message1 !== message2) {
                        const error = new _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_9__.NonRetryableError(
                        // This looks like a data corruption but the culprit was that the file was overwritten
                        // in storage.  See PR #5882.
                        // Likely to be an issue with Fluid Services. Content does not match previous client
                        // knowledge about this file. If the file is overwritten for any reason, this error can be
                        // hit. One example is that some clients could be submitting ops to two different service
                        // instances such that the same sequence number is reused for two different ops.
                        // pre-0.58 error message: twoMessagesWithSameSeqNumAndDifferentPayload
                        "Found two messages with the same sequenceNumber but different payloads. Likely to be a "
                            + "service issue", _fluidframework_driver_definitions__WEBPACK_IMPORTED_MODULE_10__.DriverErrorType.fileOverwrittenInStorage, {
                            clientId: this.connectionManager.clientId,
                            sequenceNumber: message.sequenceNumber,
                            message1,
                            message2,
                            driverVersion: undefined,
                        });
                        this.close(error);
                    }
                }
            }
            else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {
                this.pending.push(message);
                this.fetchMissingDeltas(reason, message.sequenceNumber);
            }
            else {
                this.lastQueuedSequenceNumber = message.sequenceNumber;
                this.previouslyProcessedMessage = message;
                this._inbound.push(message);
            }
        }
        // When / if we report a gap in ops in the future, we want telemetry to correctly reflect source
        // of prior ops. But if we have some out of order ops (this.pending), then reporting current reason
        // becomes not accurate, as the gap existed before current batch, so we should just report "unknown".
        this.prevEnqueueMessagesReason = this.pending.length > 0 ? "unknown" : reason;
    }
    processInboundMessage(message) {
        const startTime = Date.now();
        this.lastProcessedMessage = message;
        // All non-system messages are coming from some client, and should have clientId
        // System messages may have no clientId (but some do, like propose, noop, summarize)
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(message.clientId !== undefined
            || !((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.isClientMessage)(message)), 0x0ed /* "non-system message have to have clientId" */);
        // TODO Remove after SPO picks up the latest build.
        if (typeof message.contents === "string"
            && message.contents !== ""
            && message.type !== _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.MessageType.ClientLeave) {
            message.contents = JSON.parse(message.contents);
        }
        this.connectionManager.beforeProcessingIncomingOp(message);
        // Watch the minimum sequence number and be ready to update as needed
        if (this.minSequenceNumber > message.minimumSequenceNumber) {
            // pre-0.58 error message: msnMovesBackwards
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError("Found a lower minimumSequenceNumber (msn) than previously recorded", Object.assign(Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.extractSafePropertiesFromMessage)(message)), { clientId: this.connectionManager.clientId }));
        }
        this.minSequenceNumber = message.minimumSequenceNumber;
        if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {
            // pre-0.58 error message: nonSequentialSequenceNumber
            throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.DataCorruptionError("Found a non-Sequential sequenceNumber", Object.assign(Object.assign({}, (0,_fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_6__.extractSafePropertiesFromMessage)(message)), { clientId: this.connectionManager.clientId }));
        }
        this.lastProcessedSequenceNumber = message.sequenceNumber;
        // a bunch of code assumes that this is true
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.lastProcessedSequenceNumber <= this.lastObservedSeqNumber, 0x267 /* "lastObservedSeqNumber should be updated first" */);
        // Back-compat for older server with no term
        if (message.term === undefined) {
            message.term = 1;
        }
        this.baseTerm = message.term;
        if (this.handler === undefined) {
            throw new Error("Attempted to process an inbound message without a handler attached");
        }
        this.handler.process(message);
        const endTime = Date.now();
        // Should be last, after changing this.lastProcessedSequenceNumber above, as many callers
        // test this.lastProcessedSequenceNumber instead of using op.sequenceNumber itself.
        this.emit("op", message, endTime - startTime);
    }
    /**
     * Retrieves the missing deltas between the given sequence numbers
     */
    fetchMissingDeltas(reasonArg, to) {
        this.fetchMissingDeltasCore(reasonArg, false /* cacheOnly */, to).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "fetchMissingDeltasException" }, error);
        });
    }
    /**
    * Retrieves the missing deltas between the given sequence numbers
    */
    async fetchMissingDeltasCore(reason, cacheOnly, to) {
        var _a;
        // Exit out early if we're already fetching deltas
        if (this.fetchReason !== undefined) {
            return;
        }
        if (this.closed) {
            this.logger.sendTelemetryEvent({ eventName: "fetchMissingDeltasClosedConnection", reason });
            return;
        }
        if (this.handler === undefined) {
            // We do not poses yet any information
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.lastQueuedSequenceNumber === 0, 0x26b /* "initial state" */);
            return;
        }
        try {
            let from = this.lastQueuedSequenceNumber + 1;
            const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;
            if (n !== undefined) {
                // If we already processed at least one op, then we have this.previouslyProcessedMessage populated
                // and can use it to validate that we are operating on same file, i.e. it was not overwritten.
                // Knowing about this mechanism, we could ask for op we already observed to increase validation.
                // This is especially useful when coming out of offline mode or loading from
                // very old cached (by client / driver) snapshot.
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(n === this.lastQueuedSequenceNumber, 0x0f2 /* "previouslyProcessedMessage" */);
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(from > 1, 0x0f3 /* "not positive" */);
                from--;
            }
            const fetchReason = `${reason}_fetch`;
            this.fetchReason = fetchReason;
            await this.getDeltas(from, to, fetchReason, (messages) => {
                this.refreshDelayInfo(this.deltaStorageDelayId);
                this.enqueueMessages(messages, fetchReason);
            }, cacheOnly);
        }
        catch (error) {
            this.logger.sendErrorEvent({ eventName: "GetDeltas_Exception" }, error);
            this.close((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeError)(error));
        }
        finally {
            this.refreshDelayInfo(this.deltaStorageDelayId);
            this.fetchReason = undefined;
            this.processPendingOps(reason);
        }
    }
    /**
     * Sorts pending ops and attempts to apply them
     */
    processPendingOps(reason) {
        if (this.closed) {
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.handler !== undefined, 0x26c /* "handler should be installed" */);
        const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        this.pending = [];
        // Given that we do not track where these ops came from any more, it's not very
        // actionably to report gaps in this range.
        this.enqueueMessages(pendingSorted, `${reason}_pending`, true /* allowGaps */);
        // Re-entrancy is ignored by fetchMissingDeltas, execution will come here when it's over
        if (this.fetchReason === undefined) {
            // See issue #7312 for more details
            // We observe cases where client gets into situation where it is not aware of missing ops
            // (i.e. client being behind), and as such, does not attempt to fetch them.
            // In some cases client may not have enough signal (example - "read" connection that is silent -
            // there is no easy way for client to realize it's behind, see a bit of commentary / logic at the
            // end of setupNewSuccessfulConnection). In other cases it should be able to learn that info ("write"
            // connection, learn by receiving its own join op), but data suggest it does not happen.
            // In 50% of these cases we do know we are behind through checkpointSequenceNumber on connection object
            // and thus can leverage that to trigger recovery. But this is not going to solve all the problems
            // (the other 50%), and thus these errors below should be looked at even if code below results in
            // recovery.
            if (this.lastQueuedSequenceNumber < this.lastObservedSeqNumber) {
                this.fetchMissingDeltas("OpsBehind");
            }
        }
    }
    updateLatestKnownOpSeqNumber(seq) {
        if (this.lastObservedSeqNumber < seq) {
            this.lastObservedSeqNumber = seq;
        }
    }
}
//# sourceMappingURL=deltaManager.js.map

/***/ }),
/* 542 */
/***/ ((module) => {

"use strict";
/*globals self, window */


/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports["default"] = AbortController


/***/ }),
/* 543 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaQueue": () => (/* binding */ DeltaQueue)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(530);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(492);
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);
/* harmony import */ var double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(double_ended_queue__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


class DeltaQueue extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_1__.TypedEventEmitter {
    /**
     * @param worker - A callback to process a delta.
     * @param logger - For logging telemetry.
     */
    constructor(worker) {
        super();
        this.worker = worker;
        this.isDisposed = false;
        this.q = new (double_ended_queue__WEBPACK_IMPORTED_MODULE_0___default())();
        /**
         * Tracks the number of pause requests for the queue
         * The DeltaQueue is create initially paused.
         */
        this.pauseCount = 1;
    }
    get disposed() {
        return this.isDisposed;
    }
    /**
     * @returns True if the queue is paused, false if not.
     */
    get paused() {
        return this.pauseCount !== 0;
    }
    get length() {
        return this.q.length;
    }
    get idle() {
        return this.processingPromise === undefined && this.q.length === 0;
    }
    async waitTillProcessingDone() {
        var _a;
        return (_a = this.processingPromise) !== null && _a !== void 0 ? _a : { count: 0, duration: 0 };
    }
    dispose() {
        throw new Error("Not implemented.");
        this.isDisposed = true;
    }
    clear() {
        this.q.clear();
    }
    peek() {
        return this.q.peekFront();
    }
    toArray() {
        return this.q.toArray();
    }
    push(task) {
        try {
            this.q.push(task);
            this.emit("push", task);
            this.ensureProcessing();
        }
        catch (error) {
            this.emit("error", error);
        }
    }
    async pause() {
        this.pauseCount++;
        // If called from within the processing loop, we are in the middle of processing an op. Return a promise
        // that will resolve when processing has actually stopped.
        await this.waitTillProcessingDone();
    }
    resume() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.pauseCount > 0, 0x0f4 /* "Nonzero pause-count on resume()" */);
        this.pauseCount--;
        this.ensureProcessing();
    }
    /**
     * There are several actions that may need to kick off delta processing, so we want to guard against
     * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is
     * not already started.
     */
    ensureProcessing() {
        if (this.anythingToProcess() && this.processingPromise === undefined) {
            // Use a resolved promise to start the processing on a separate stack.
            this.processingPromise = Promise.resolve().then(() => {
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.processingPromise !== undefined, "reentrancy?");
                const result = this.processDeltas();
                (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.processingPromise !== undefined, "reentrancy?");
                // WARNING: Do not move next line to .finally() clause!
                // It runs async and creates a race condition where incoming ensureProcessing() call observes
                // from previous run while previous run is over (but finally clause was not scheduled yet)
                this.processingPromise = undefined;
                return result;
            }).catch((error) => {
                this.error = error;
                this.processingPromise = undefined;
                this.emit("error", error);
                return { count: 0, duration: 0 };
            });
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.processingPromise !== undefined, "processDeltas() should run async");
        }
    }
    anythingToProcess() {
        return this.q.length !== 0 && !this.paused && this.error === undefined;
    }
    /**
     * Executes the delta processing loop until a stop condition is reached.
     */
    processDeltas() {
        const start = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now();
        let count = 0;
        // For grouping to work we must process all local messages immediately and in the single turn.
        // So loop over them until no messages to process, we have become paused, or hit an error.
        while (this.anythingToProcess()) {
            // Get the next message in the queue
            const next = this.q.shift();
            count++;
            // Process the message.
            // We know next is defined since we did a length check just prior to shifting.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.worker(next);
            this.emit("op", next);
        }
        const duration = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_3__.performance.now() - start;
        if (this.q.length === 0) {
            this.emit("idle", count, duration);
        }
        return { count, duration };
    }
}
//# sourceMappingURL=deltaQueue.js.map

/***/ }),
/* 544 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logIfFalse": () => (/* binding */ logIfFalse)
/* harmony export */ });
/**
 * Like assert, but logs only if the condition is false, rather than throwing
 * @param condition - The condition to attest too
 * @param logger - The logger to log with
 * @param event - The string or event to log
 * @returns - The outcome of the condition
 */
function logIfFalse(condition, logger, event) {
    if (condition) {
        return true;
    }
    const newEvent = typeof event === "string"
        ? { eventName: event, category: "error" }
        : Object.assign({ category: "error" }, event);
    logger.send(newEvent);
    return false;
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 545 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionManager": () => (/* binding */ ConnectionManager)
/* harmony export */ });
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(542);
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(abort_controller__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(530);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(492);
/* harmony import */ var _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(460);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(546);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(539);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(45);
/* harmony import */ var _contracts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(526);
/* harmony import */ var _deltaQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(543);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */








const MaxReconnectDelayInMs = 8000;
const InitialReconnectDelayInMs = 1000;
const DefaultChunkSize = 16 * 1024;
const fatalConnectErrorProp = { fatalConnectError: true };
function getNackReconnectInfo(nackContent) {
    const message = `Nack (${nackContent.type}): ${nackContent.message}`;
    const canRetry = nackContent.code !== 403;
    const retryAfterMs = nackContent.retryAfter !== undefined ? nackContent.retryAfter * 1000 : undefined;
    return (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createGenericNetworkError)(message, { canRetry, retryAfterMs }, { statusCode: nackContent.code, driverVersion: undefined });
}
/**
 * Implementation of IDocumentDeltaConnection that does not support submitting
 * or receiving ops. Used in storage-only mode.
 */
class NoDeltaStream extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {
    constructor() {
        super(...arguments);
        this.clientId = "storage-only client";
        this.claims = {
            scopes: [_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType.DocRead],
        };
        this.mode = "read";
        this.existing = true;
        this.maxMessageSize = 0;
        this.version = "";
        this.initialMessages = [];
        this.initialSignals = [];
        this.initialClients = [];
        this.serviceConfiguration = {
            maxMessageSize: 0,
            blockSize: 0,
            summary: undefined,
        };
        this.checkpointSequenceNumber = undefined;
        this._disposed = false;
    }
    submit(messages) {
        this.emit("nack", this.clientId, messages.map((operation) => {
            return {
                operation,
                content: { message: "Cannot submit with storage-only connection", code: 403 },
            };
        }));
    }
    submitSignal(message) {
        this.emit("nack", this.clientId, {
            operation: message,
            content: { message: "Cannot submit signal with storage-only connection", code: 403 },
        });
    }
    get disposed() { return this._disposed; }
    dispose() { this._disposed = true; }
}
/**
 * Implementation of IConnectionManager, used by Container class
 * Implements constant connectivity to relay service, by reconnecting in case of loast connection or error.
 * Exposes various controls to influecen this process, including manual reconnects, forced read-only mode, etc.
 */
class ConnectionManager {
    constructor(serviceProvider, client, reconnectAllowed, logger, props) {
        this.serviceProvider = serviceProvider;
        this.client = client;
        this.logger = logger;
        this.props = props;
        /** tracks host requiring read-only mode. */
        this._forceReadonly = false;
        /** True if there is pending (async) reconnection from "read" to "write" */
        this.pendingReconnect = false;
        this.clientSequenceNumber = 0;
        this.clientSequenceNumberObserved = 0;
        /** Counts the number of noops sent by the client which may not be acked. */
        this.trailingNoopCount = 0;
        this.connectFirstConnection = true;
        this._connectionVerboseProps = {};
        this._connectionProps = {};
        this.closed = false;
        this.opHandler = (documentId, messagesArg) => {
            const messages = Array.isArray(messagesArg) ? messagesArg : [messagesArg];
            this.props.incomingOpHandler(messages, "opHandler");
        };
        // Always connect in write mode after getting nacked.
        this.nackHandler = (documentId, messages) => {
            const message = messages[0];
            if (this._readonlyPermissions === true) {
                this.props.closeHandler((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.createWriteError)("writeOnReadOnlyDocument", { driverVersion: undefined }));
                return;
            }
            const reconnectInfo = getNackReconnectInfo(message.content);
            // If the nack indicates we cannot retry, then close the container outright
            if (!reconnectInfo.canRetry) {
                this.props.closeHandler(reconnectInfo);
                return;
            }
            this.reconnectOnError("write", reconnectInfo);
        };
        // Connection mode is always read on disconnect/error unless the system mode was write.
        this.disconnectHandlerInternal = (disconnectReason) => {
            // Note: we might get multiple disconnect calls on same socket, as early disconnect notification
            // ("server_disconnect", ODSP-specific) is mapped to "disconnect"
            this.reconnectOnError(this.defaultReconnectionMode, disconnectReason);
        };
        this.errorHandler = (error) => {
            this.reconnectOnError(this.defaultReconnectionMode, error);
        };
        this.clientDetails = this.client.details;
        this.defaultReconnectionMode = this.client.mode;
        this._reconnectMode = reconnectAllowed ? _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled : _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never;
        // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained
        // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.
        this._outbound = new _deltaQueue__WEBPACK_IMPORTED_MODULE_5__.DeltaQueue((messages) => {
            if (this.connection === undefined) {
                throw new Error("Attempted to submit an outbound message without connection");
            }
            this.connection.submit(messages);
        });
        this._outbound.on("error", (error) => {
            this.props.closeHandler((0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.normalizeError)(error));
        });
    }
    get connectionVerboseProps() { return this._connectionVerboseProps; }
    /**
     * The current connection mode, initially read.
     */
    get connectionMode() {
        var _a, _b;
        return (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : "read";
    }
    get connected() { return this.connection !== undefined; }
    get clientId() { var _a; return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId; }
    /**
     * Automatic reconnecting enabled or disabled.
     * If set to Never, then reconnecting will never be allowed.
     */
    get reconnectMode() {
        return this._reconnectMode;
    }
    get maxMessageSize() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize) !== null && _c !== void 0 ? _c : DefaultChunkSize;
    }
    get version() {
        if (this.connection === undefined) {
            throw new Error("Cannot check version without a connection");
        }
        return this.connection.version;
    }
    get serviceConfiguration() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;
    }
    get scopes() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;
    }
    get outbound() {
        return this._outbound;
    }
    /**
     * Returns set of props that can be logged in telemetry that provide some insights / statistics
     * about current or last connection (if there is no connection at the moment)
    */
    get connectionProps() {
        if (this.connection !== undefined) {
            return this._connectionProps;
        }
        else {
            return Object.assign(Object.assign({}, this._connectionProps), { 
                // Report how many ops this client sent in last disconnected session
                sentOps: this.clientSequenceNumber });
        }
    }
    shouldJoinWrite() {
        // We don't have to wait for ack for topmost NoOps. So subtract those.
        return this.clientSequenceNumberObserved < (this.clientSequenceNumber - this.trailingNoopCount);
    }
    /**
     * Tells if container is in read-only mode.
     * Data stores should listen for "readonly" notifications and disallow user
     * making changes to data stores.
     * Readonly state can be because of no storage write permission,
     * or due to host forcing readonly mode for container.
     * It is undefined if we have not yet established websocket connection
     * and do not know if user has write access to a file.
     */
    get readonly() {
        if (this._forceReadonly) {
            return true;
        }
        return this._readonlyPermissions;
    }
    get readOnlyInfo() {
        const storageOnly = this.connection !== undefined && this.connection instanceof NoDeltaStream;
        if (storageOnly || this._forceReadonly || this._readonlyPermissions === true) {
            return {
                readonly: true,
                forced: this._forceReadonly,
                permissions: this._readonlyPermissions,
                storageOnly,
            };
        }
        return { readonly: this._readonlyPermissions };
    }
    static detailsFromConnection(connection) {
        return {
            claims: connection.claims,
            clientId: connection.clientId,
            existing: connection.existing,
            checkpointSequenceNumber: connection.checkpointSequenceNumber,
            get initialClients() { return connection.initialClients; },
            mode: connection.mode,
            serviceConfiguration: connection.serviceConfiguration,
            version: connection.version,
        };
    }
    dispose(error) {
        if (this.closed) {
            return;
        }
        this.closed = true;
        this.pendingConnection = undefined;
        // Ensure that things like triggerConnect() will short circuit
        this._reconnectMode = _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never;
        this._outbound.clear();
        const disconnectReason = error !== undefined
            ? `Closing DeltaManager (${error.message})`
            : "Closing DeltaManager";
        // This raises "disconnect" event if we have active connection.
        this.disconnectFromDeltaStream(disconnectReason);
        // Notify everyone we are in read-only state.
        // Useful for data stores in case we hit some critical error,
        // to switch to a mode where user edits are not accepted
        this.set_readonlyPermissions(true);
    }
    /**
     * Enables or disables automatic reconnecting.
     * Will throw an error if reconnectMode set to Never.
    */
    setAutoReconnect(mode) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(mode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never && this._reconnectMode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never, 0x278 /* "API is not supported for non-connecting or closed container" */);
        this._reconnectMode = mode;
        if (mode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled) {
            // immediately disconnect - do not rely on service eventually dropping connection.
            this.disconnectFromDeltaStream("setAutoReconnect");
        }
    }
    /**
     * Sends signal to runtime (and data stores) to be read-only.
     * Hosts may have read only views, indicating to data stores that no edits are allowed.
     * This is independent from this._readonlyPermissions (permissions) and this.connectionMode
     * (server can return "write" mode even when asked for "read")
     * Leveraging same "readonly" event as runtime & data stores should behave the same in such case
     * as in read-only permissions.
     * But this.active can be used by some DDSes to figure out if ops can be sent
     * (for example, read-only view still participates in code proposals / upgrades decisions)
     *
     * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour
     * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If
     * there are pending in the outbound queue, it will stop sending until force readonly is
     * cleared.
     *
     * @param readonly - set or clear force readonly.
     */
    forceReadonly(readonly) {
        if (readonly !== this._forceReadonly) {
            this.logger.sendTelemetryEvent({
                eventName: "ForceReadOnly",
                value: readonly,
            });
        }
        const oldValue = this.readonly;
        this._forceReadonly = readonly;
        if (oldValue !== this.readonly) {
            if (this._reconnectMode === _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never) {
                throw new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.UsageError("API is not supported for non-connecting or closed container");
            }
            let reconnect = false;
            if (this.readonly === true) {
                // If we switch to readonly while connected, we should disconnect first
                // See comment in the "readonly" event handler to deltaManager set up by
                // the ContainerRuntime constructor
                if (this.shouldJoinWrite()) {
                    // If we have pending changes, then we will never send them - it smells like
                    // host logic error.
                    this.logger.sendErrorEvent({ eventName: "ForceReadonlyPendingChanged" });
                }
                reconnect = this.disconnectFromDeltaStream("Force readonly");
            }
            this.props.readonlyChangeHandler(this.readonly);
            if (reconnect) {
                // reconnect if we disconnected from before.
                this.triggerConnect("read");
            }
        }
    }
    set_readonlyPermissions(readonly) {
        const oldValue = this.readonly;
        this._readonlyPermissions = readonly;
        if (oldValue !== this.readonly) {
            this.props.readonlyChangeHandler(this.readonly);
        }
    }
    connect(connectionMode) {
        this.connectCore(connectionMode).catch((error) => {
            const normalizedError = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.normalizeError)(error, { props: fatalConnectErrorProp });
            this.props.closeHandler(normalizedError);
        });
    }
    async connectCore(connectionMode) {
        var _a, _b;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!this.closed, 0x26a /* "not closed" */);
        if (this.connection !== undefined) {
            return; // Connection attempt already completed successfully
        }
        let pendingConnectionMode;
        if (this.pendingConnection !== undefined) {
            pendingConnectionMode = this.pendingConnection.connectionMode;
            this.cancelConnection(); // Throw out in-progress connection attempt in favor of new attempt
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection === undefined, 0x344 /* this.pendingConnection should be undefined */);
        }
        // If there is no specified ConnectionMode, try the previous mode, if there is no previous mode use default
        let requestedMode = (_a = connectionMode !== null && connectionMode !== void 0 ? connectionMode : pendingConnectionMode) !== null && _a !== void 0 ? _a : this.defaultReconnectionMode;
        // if we have any non-acked ops from last connection, reconnect as "write".
        // without that we would connect in view-only mode, which will result in immediate
        // firing of "connected" event from Container and switch of current clientId (as tracked
        // by all DDSes). This will make it impossible to figure out if ops actually made it through,
        // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document
        if (this.shouldJoinWrite()) {
            requestedMode = "write";
        }
        const docService = this.serviceProvider();
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(docService !== undefined, 0x2a7 /* "Container is not attached" */);
        let connection;
        if (((_b = docService.policies) === null || _b === void 0 ? void 0 : _b.storageOnly) === true) {
            connection = new NoDeltaStream();
            this.setupNewSuccessfulConnection(connection, "read");
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection === undefined, 0x2b3 /* "logic error" */);
            return;
        }
        let delayMs = InitialReconnectDelayInMs;
        let connectRepeatCount = 0;
        const connectStartTime = _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now();
        let lastError;
        const abortController = new (abort_controller__WEBPACK_IMPORTED_MODULE_0___default())();
        const abortSignal = abortController.signal;
        this.pendingConnection = { abort: () => { abortController.abort(); }, connectionMode: requestedMode };
        // This loop will keep trying to connect until successful, with a delay between each iteration.
        while (connection === undefined) {
            if (this.closed) {
                throw new Error("Attempting to connect a closed DeltaManager");
            }
            if (abortSignal.aborted === true) {
                this.logger.sendTelemetryEvent({
                    eventName: "ConnectionAttemptCancelled",
                    attempts: connectRepeatCount,
                    duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),
                    connectionEstablished: false,
                });
                return;
            }
            connectRepeatCount++;
            try {
                this.client.mode = requestedMode;
                connection = await docService.connectToDeltaStream(Object.assign(Object.assign({}, this.client), { mode: requestedMode }));
                if (connection.disposed) {
                    // Nobody observed this connection, so drop it on the floor and retry.
                    this.logger.sendTelemetryEvent({ eventName: "ReceivedClosedConnection" });
                    connection = undefined;
                }
            }
            catch (origError) {
                if (typeof origError === "object" && origError !== null &&
                    (origError === null || origError === void 0 ? void 0 : origError.errorType) === _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.DeltaStreamConnectionForbiddenError.errorType) {
                    connection = new NoDeltaStream();
                    requestedMode = "read";
                    break;
                }
                // Socket.io error when we connect to wrong socket, or hit some multiplexing bug
                if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.canRetryOnError)(origError)) {
                    const error = (0,_fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_6__.normalizeError)(origError, { props: fatalConnectErrorProp });
                    this.props.closeHandler(error);
                    throw error;
                }
                // Since the error is retryable this will not log to the error table
                (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.logNetworkFailure)(this.logger, {
                    attempts: connectRepeatCount,
                    delay: delayMs,
                    eventName: "DeltaConnectionFailureToConnect",
                    duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),
                }, origError);
                lastError = origError;
                const retryDelayFromError = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.getRetryDelayFromError)(origError);
                delayMs = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delayMs * 2, MaxReconnectDelayInMs);
                if (retryDelayFromError !== undefined) {
                    this.props.reconnectionDelayHandler(retryDelayFromError, origError);
                }
                await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.waitForConnectedState)(delayMs);
            }
        }
        // If we retried more than once, log an event about how long it took (this will not log to error table)
        if (connectRepeatCount > 1) {
            (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.logNetworkFailure)(this.logger, {
                eventName: "MultipleDeltaConnectionFailures",
                attempts: connectRepeatCount,
                duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),
            }, lastError);
        }
        // Check for abort signal after while loop as well
        if (abortSignal.aborted === true) {
            connection.dispose();
            this.logger.sendTelemetryEvent({
                eventName: "ConnectionAttemptCancelled",
                attempts: connectRepeatCount,
                duration: _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_10__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_9__.performance.now() - connectStartTime),
                connectionEstablished: true,
            });
            return;
        }
        this.setupNewSuccessfulConnection(connection, requestedMode);
    }
    /**
     * Start the connection. Any error should result in container being close.
     * And report the error if it excape for any reason.
     * @param args - The connection arguments
     */
    triggerConnect(connectionMode) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection === undefined, 0x239 /* "called only in disconnected state" */);
        if (this.reconnectMode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled) {
            return;
        }
        this.connect(connectionMode);
    }
    /**
     * Disconnect the current connection.
     * @param reason - Text description of disconnect reason to emit with disconnect event
     * @returns A boolean that indicates if there was an existing connection (or pending connection) to disconnect
     */
    disconnectFromDeltaStream(reason) {
        this.pendingReconnect = false;
        if (this.connection === undefined) {
            if (this.pendingConnection !== undefined) {
                this.cancelConnection();
                return true;
            }
            return false;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection === undefined, 0x27b /* "reentrancy may result in incorrect behavior" */);
        const connection = this.connection;
        // Avoid any re-entrancy - clear object reference
        this.connection = undefined;
        // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError
        connection.off("op", this.opHandler);
        connection.off("signal", this.props.signalHandler);
        connection.off("nack", this.nackHandler);
        connection.off("disconnect", this.disconnectHandlerInternal);
        connection.off("error", this.errorHandler);
        connection.off("pong", this.props.pongHandler);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._outbound.pause();
        this._outbound.clear();
        this.props.disconnectHandler(reason);
        connection.dispose();
        this._connectionVerboseProps = {};
        return true;
    }
    /**
     * Cancel in-progress connection attempt.
     */
    cancelConnection() {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.pendingConnection !== undefined, 0x345 /* this.pendingConnection is undefined when trying to cancel */);
        this.pendingConnection.abort();
        this.pendingConnection = undefined;
        this.logger.sendTelemetryEvent({ eventName: "ConnectionCancelReceived" });
    }
    /**
     * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process
     * initial messages.
     * @param connection - The newly established connection
     */
    setupNewSuccessfulConnection(connection, requestedMode) {
        // Old connection should have been cleaned up before establishing a new one
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection === undefined, 0x0e6 /* "old connection exists on new connection setup" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!connection.disposed, 0x28a /* "can't be disposed - Callers need to ensure that!" */);
        this.pendingConnection = undefined;
        this.connection = connection;
        // Does information in scopes & mode matches?
        // If we asked for "write" and got "read", then file is read-only
        // But if we ask read, server can still give us write.
        const readonly = !connection.claims.scopes.includes(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.ScopeType.DocWrite);
        // This connection mode validation logic is moving to the driver layer in 0.44.  These two asserts can be
        // removed after those packages have released and become ubiquitous.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(requestedMode === "read" || readonly === (this.connectionMode === "read"), 0x0e7 /* "claims/connectionMode mismatch" */);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!readonly || this.connectionMode === "read", 0x0e8 /* "readonly perf with write connection" */);
        this.set_readonlyPermissions(readonly);
        if (this.closed) {
            // Raise proper events, Log telemetry event and close connection.
            this.disconnectFromDeltaStream("ConnectionManager already closed");
            return;
        }
        this._outbound.resume();
        connection.on("op", this.opHandler);
        connection.on("signal", this.props.signalHandler);
        connection.on("nack", this.nackHandler);
        connection.on("disconnect", this.disconnectHandlerInternal);
        connection.on("error", this.errorHandler);
        connection.on("pong", this.props.pongHandler);
        // Initial messages are always sorted. However, due to early op handler installed by drivers and appending those
        // ops to initialMessages, resulting set is no longer sorted, which would result in client hitting storage to
        // fill in gap. We will recover by cancelling this request once we process remaining ops, but it's a waste that
        // we could avoid
        const initialMessages = connection.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        // Some storages may provide checkpointSequenceNumber to identify how far client is behind.
        let checkpointSequenceNumber = connection.checkpointSequenceNumber;
        this._connectionVerboseProps = {
            clientId: connection.clientId,
            mode: connection.mode,
        };
        // reset connection props
        this._connectionProps = {};
        if (connection.relayServiceAgent !== undefined) {
            this._connectionVerboseProps.relayServiceAgent = connection.relayServiceAgent;
            this._connectionProps.relayServiceAgent = connection.relayServiceAgent;
        }
        this._connectionProps.socketDocumentId = connection.claims.documentId;
        this._connectionProps.connectionMode = connection.mode;
        let last = -1;
        if (initialMessages.length !== 0) {
            this._connectionVerboseProps.connectionInitialOpsFrom = initialMessages[0].sequenceNumber;
            last = initialMessages[initialMessages.length - 1].sequenceNumber;
            this._connectionVerboseProps.connectionInitialOpsTo = last + 1;
            // Update knowledge of how far we are behind, before raising "connect" event
            // This is duplication of what incomingOpHandler() does, but we have to raise event before we get there,
            // so duplicating update logic here as well.
            if (checkpointSequenceNumber === undefined || checkpointSequenceNumber < last) {
                checkpointSequenceNumber = last;
            }
        }
        this.props.incomingOpHandler(initialMessages, this.connectFirstConnection ? "InitialOps" : "ReconnectOps");
        if (connection.initialSignals !== undefined) {
            for (const signal of connection.initialSignals) {
                this.props.signalHandler(signal);
            }
        }
        const details = ConnectionManager.detailsFromConnection(connection);
        details.checkpointSequenceNumber = checkpointSequenceNumber;
        this.props.connectHandler(details);
        this.connectFirstConnection = false;
    }
    /**
     * Disconnect the current connection and reconnect. Closes the container if it fails.
     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection
     * @param requestedMode - Read or write
     * @param error - Error reconnect information including whether or not to reconnect
     * @returns A promise that resolves when the connection is reestablished or we stop trying
     */
    reconnectOnError(requestedMode, error) {
        this.reconnect(requestedMode, error.message, error)
            .catch(this.props.closeHandler);
    }
    /**
     * Disconnect the current connection and reconnect.
     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection
     * @param requestedMode - Read or write
     * @param error - Error reconnect information including whether or not to reconnect
     * @returns A promise that resolves when the connection is reestablished or we stop trying
     */
    async reconnect(requestedMode, disconnectMessage, error) {
        // We quite often get protocol errors before / after observing nack/disconnect
        // we do not want to run through same sequence twice.
        // If we're already disconnected/disconnecting it's not appropriate to call this again.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connection !== undefined, 0x0eb /* "Missing connection for reconnect" */);
        this.disconnectFromDeltaStream(disconnectMessage);
        // We will always trigger reconnect, even if canRetry is false.
        // Any truly fatal error state will result in container close upon attempted reconnect,
        // which is a preferable to closing abruptly when a live connection fails.
        if (error !== undefined && !error.canRetry) {
            this.logger.sendTelemetryEvent({
                eventName: "reconnectingDespiteFatalError",
                reconnectMode: this.reconnectMode,
            }, error);
        }
        if (this.reconnectMode === _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Never) {
            // Do not raise container error if we are closing just because we lost connection.
            // Those errors (like IdleDisconnect) would show up in telemetry dashboards and
            // are very misleading, as first initial reaction - some logic is broken.
            this.props.closeHandler();
        }
        // If closed then we can't reconnect
        if (this.closed || this.reconnectMode !== _contracts__WEBPACK_IMPORTED_MODULE_4__.ReconnectMode.Enabled) {
            return;
        }
        const delayMs = (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.getRetryDelayFromError)(error);
        if (error !== undefined && delayMs !== undefined) {
            this.props.reconnectionDelayHandler(delayMs, error);
            await (0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_11__.waitForConnectedState)(delayMs);
        }
        this.triggerConnect(requestedMode);
    }
    prepareMessageToSend(message) {
        var _a, _b;
        if (this.readonly === true) {
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.readOnlyInfo.readonly === true, 0x1f0 /* "Unexpected mismatch in readonly" */);
            const error = new _fluidframework_container_utils__WEBPACK_IMPORTED_MODULE_8__.GenericError("deltaManagerReadonlySubmit", undefined /* error */, {
                readonly: this.readOnlyInfo.readonly,
                forcedReadonly: this.readOnlyInfo.forced,
                readonlyPermissions: this.readOnlyInfo.permissions,
                storageOnly: this.readOnlyInfo.storageOnly,
            });
            this.props.closeHandler(error);
            return undefined;
        }
        // reset clientSequenceNumber if we are using new clientId.
        // we keep info about old connection as long as possible to be able to account for all non-acked ops
        // that we pick up on next connection.
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this.connection, 0x0e4 /* "Lost old connection!" */);
        if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {
            this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;
            this.clientSequenceNumber = 0;
            this.clientSequenceNumberObserved = 0;
        }
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.MessageType.NoOp) {
            this.trailingNoopCount++;
        }
        else {
            this.trailingNoopCount = 0;
        }
        return Object.assign(Object.assign({}, message), { clientSequenceNumber: ++this.clientSequenceNumber });
    }
    submitSignal(content) {
        if (this.connection !== undefined) {
            this.connection.submitSignal(content);
        }
        else {
            this.logger.sendErrorEvent({ eventName: "submitSignalDisconnected" });
        }
    }
    sendMessages(messages) {
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.connected, 0x2b4 /* "not connected on sending ops!" */);
        // If connection is "read" or implicit "read" (got leave op for "write" connection),
        // then op can't make it through - we will get a nack if op is sent.
        // We can short-circuit this process.
        // Note that we also want nacks to be rare and be treated as catastrophic failures.
        // Be careful with reentrancy though - disconnected event should not be be raised in the
        // middle of the current workflow, but rather on clean stack!
        if (this.connectionMode === "read") {
            if (!this.pendingReconnect) {
                this.pendingReconnect = true;
                Promise.resolve().then(async () => {
                    if (this.pendingReconnect) { // still valid?
                        await this.reconnect("write", // connectionMode
                        "Switch to write");
                    }
                })
                    .catch(() => { });
            }
            return;
        }
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(!this.pendingReconnect, 0x2b5 /* "logic error" */);
        this._outbound.push(messages);
    }
    beforeProcessingIncomingOp(message) {
        // if we have connection, and message is local, then we better treat is as local!
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.clientId !== message.clientId || this.lastSubmittedClientId === message.clientId, 0x0ee /* "Not accounting local messages correctly" */);
        if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {
            const clientSequenceNumber = message.clientSequenceNumber;
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(this.clientSequenceNumberObserved < clientSequenceNumber, 0x0ef /* "client seq# not growing" */);
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_7__.assert)(clientSequenceNumber <= this.clientSequenceNumber, 0x0f0 /* "Incoming local client seq# > generated by this client" */);
            this.clientSequenceNumberObserved = clientSequenceNumber;
        }
        if (message.type === _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_12__.MessageType.ClientLeave) {
            const systemLeaveMessage = message;
            const clientId = JSON.parse(systemLeaveMessage.data);
            if (clientId === this.clientId) {
                // We have been kicked out from quorum
                this.logger.sendPerformanceEvent({ eventName: "ReadConnectionTransition" });
                // Please see #8483 for more details on why maintaining connection further as is would not work.
                // Short story - connection properties are immutable, and many processes (consensus DDSes, summarizer)
                // assume that connection stays "write" connection until disconnect, and act accordingly, which may
                // not work well with de-facto "read" connection we are in after receiving own leave op on timeout.
                // Clients need to be able to transition to "read" state after some time of inactivity!
                // Note - this may close container!
                this.reconnect("read", // connectionMode
                "Switch to read").catch((error) => {
                    this.logger.sendErrorEvent({ eventName: "SwitchToReadConnection" }, error);
                });
            }
        }
    }
}
//# sourceMappingURL=connectionManager.js.map

/***/ }),
/* 546 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScopeType": () => (/* binding */ ScopeType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var ScopeType;
(function (ScopeType) {
    ScopeType["DocRead"] = "doc:read";
    ScopeType["DocWrite"] = "doc:write";
    ScopeType["SummaryWrite"] = "summary:write";
})(ScopeType || (ScopeType = {}));
//# sourceMappingURL=scopes.js.map

/***/ }),
/* 547 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollabWindowTracker": () => (/* binding */ CollabWindowTracker)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(495);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(539);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



const defaultNoopTimeFrequency = 2000;
const defaultNoopCountFrequency = 50;
// Here are key considerations when deciding conditions for when to send non-immediate noops:
// 1. Sending them too often results in increase in file size and bandwidth, as well as catch up performance
// 2. Sending too infrequently ensures that collab window is large, and as result Sequence DDS would have
//    large catchUp blobs - see Issue #6364
// 3. Similarly, processes that rely on "core" snapshot (and can't parse trailing ops, including above), like search
//    parser in SPO, will result in non-accurate results due to presence of catch up blobs.
// 4. Ordering service used 250ms timeout to coalesce non-immediate noops. It was changed to 2000 ms to allow more
//    aggressive noop sending from client side.
// 5. Number of ops sent by all clients is proportional to number of "write" clients (every client sends noops),
//    but number of sequenced noops is a function of time (one op per 2 seconds at most).
//    We should consider impact to both outbound traffic (might be huge, depends on number of clients) and file size.
// Please also see Issue #5629 for more discussions.
//
// With that, the current algorithm is as follows:
// 1. Sent noop 2000 ms of receiving an op if no ops were sent by this client within this timeframe.
//    This will ensure that MSN moves forward with reasonable speed. If that results in too many sequenced noops,
//    server timeout of 2000ms should be reconsidered to be increased.
// 2. If there are more than 50 ops received without sending any ops, send noop to keep collab window small.
//    Note that system ops (including noops themselves) are excluded, so it's 1 noop per 50 real ops.
class CollabWindowTracker {
    constructor(submit, NoopTimeFrequency = defaultNoopTimeFrequency, NoopCountFrequency = defaultNoopCountFrequency) {
        this.submit = submit;
        this.NoopCountFrequency = NoopCountFrequency;
        this.opsCountSinceNoop = 0;
        if (NoopTimeFrequency !== Infinity) {
            this.timer = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.Timer(NoopTimeFrequency, () => {
                // Can get here due to this.stopSequenceNumberUpdate() not resetting timer.
                // Also timer callback can fire even after timer cancellation if it was queued before cancellation.
                if (this.opsCountSinceNoop !== 0) {
                    this.submitNoop(false /* immediate */);
                }
            });
        }
    }
    /**
     * Schedules as ack to the server to update the reference sequence number
     */
    scheduleSequenceNumberUpdate(message, immediateNoOp) {
        // While processing a message, an immediate no-op can be requested.
        // i.e. to expedite approve or commit phase of quorum.
        if (immediateNoOp) {
            this.submitNoop(true /* immediate */);
            return;
        }
        // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN
        // update, which updates the MSN, then ack the update, etc...).
        // Intent here is for runtime (and DDSes) not to keep too much tracking state / memory
        // due to runtime ops from other clients.
        if (!(0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.isRuntimeMessage)(message)) {
            return;
        }
        this.opsCountSinceNoop++;
        if (this.opsCountSinceNoop >= this.NoopCountFrequency) {
            this.submitNoop(false /* immediate */);
            return;
        }
        if (this.timer !== undefined) {
            if (this.opsCountSinceNoop === 1) {
                this.timer.restart();
            }
            (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.timer.hasTimer, 0x242 /* "has timer" */);
        }
    }
    submitNoop(immediate) {
        // Anything other than null is immediate noop
        this.submit(_fluidframework_protocol_definitions__WEBPACK_IMPORTED_MODULE_3__.MessageType.NoOp, immediate ? "" : null);
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(this.opsCountSinceNoop === 0, 0x243 /* "stopSequenceNumberUpdate should be called as result of sending any op!" */);
    }
    stopSequenceNumberUpdate() {
        this.opsCountSinceNoop = 0;
        // Ideally, we cancel timer here. But that will result in too often set/reset cycle if this client
        // keeps sending ops. In most cases it's actually better to let it expire (at most - 4 times per second)
        // for nothing, then have a ton of set/reset cycles.
        // Note that Timer.restart() is smart and will not change timer expiration if we keep extending timer
        // expiration - it will restart the timer instead when it fires with adjusted expiration.
        // this.timer.clear();
    }
}
//# sourceMappingURL=collabWindowTracker.js.map

/***/ }),
/* 548 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContainerContext": () => (/* binding */ ContainerContext)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(496);
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(491);
/* harmony import */ var _fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);
/* harmony import */ var _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */




const PackageNotFactoryError = "Code package does not implement IRuntimeFactory";
class ContainerContext {
    constructor(container, scope, codeLoader, _codeDetails, _baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {
        this.container = container;
        this.scope = scope;
        this.codeLoader = codeLoader;
        this._codeDetails = _codeDetails;
        this._baseSnapshot = _baseSnapshot;
        this.deltaManager = deltaManager;
        this.loader = loader;
        this.submitFn = submitFn;
        this.submitSignalFn = submitSignalFn;
        this.closeFn = closeFn;
        this.version = version;
        this.updateDirtyContainerState = updateDirtyContainerState;
        this.existing = existing;
        this.pendingLocalState = pendingLocalState;
        this._disposed = false;
        this._quorum = quorum;
        this.taggedLogger = container.subLogger;
        this._fluidModuleP = new _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.LazyPromise(async () => this.loadCodeModule(_codeDetails));
        this.attachListener();
    }
    static async createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {
        const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState);
        await context.instantiateRuntime(existing);
        return context;
    }
    get clientId() {
        return this.container.clientId;
    }
    /**
     * DISCLAIMER: this id is only for telemetry purposes. Not suitable for any other usages.
     */
    get id() {
        const resolvedUrl = this.container.resolvedUrl;
        if ((0,_fluidframework_driver_utils__WEBPACK_IMPORTED_MODULE_1__.isFluidResolvedUrl)(resolvedUrl)) {
            return resolvedUrl.id;
        }
        return "";
    }
    get clientDetails() {
        return this.container.clientDetails;
    }
    get connected() {
        return this.container.connected;
    }
    get canSummarize() {
        return "summarize" in this.runtime;
    }
    get serviceConfiguration() {
        return this.container.serviceConfiguration;
    }
    get audience() {
        return this.container.audience;
    }
    get options() {
        return this.container.options;
    }
    get baseSnapshot() {
        return this._baseSnapshot;
    }
    get storage() {
        return this.container.storage;
    }
    get runtime() {
        if (this._runtime === undefined) {
            throw new Error("Attempted to access runtime before it was defined");
        }
        return this._runtime;
    }
    get disposed() {
        return this._disposed;
    }
    get codeDetails() { return this._codeDetails; }
    get quorum() { return this._quorum; }
    /**
     * @deprecated - Temporary migratory API, to be removed when customers no longer need it.  When removed,
     * ContainerContext should only take an IQuorumClients rather than an IQuorum.  See IContainerContext for more
     * details.
     */
    getSpecifiedCodeDetails() {
        var _a;
        return ((_a = this._quorum.get("code")) !== null && _a !== void 0 ? _a : this._quorum.get("code2"));
    }
    dispose(error) {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.runtime.dispose(error);
        this._quorum.dispose();
        this.deltaManager.dispose();
    }
    getLoadedFromVersion() {
        return this.container.loadedFromVersion;
    }
    get attachState() {
        return this.container.attachState;
    }
    /**
     * Create a summary. Used when attaching or serializing a detached container.
     *
     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported
     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the
     * new storage IDs so requests can be redirected.
     */
    createSummary(blobRedirectTable) {
        return this.runtime.createSummary(blobRedirectTable);
    }
    setConnectionState(connected, clientId) {
        const runtime = this.runtime;
        (0,_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(connected === this.connected, 0x0de /* "Mismatch in connection state while setting" */);
        runtime.setConnectionState(connected, clientId);
    }
    process(message, local, context) {
        this.runtime.process(message, local, context);
    }
    processSignal(message, local) {
        this.runtime.processSignal(message, local);
    }
    async request(path) {
        return this.runtime.request(path);
    }
    async getAbsoluteUrl(relativeUrl) {
        return this.container.getAbsoluteUrl(relativeUrl);
    }
    getPendingLocalState() {
        return this.runtime.getPendingLocalState();
    }
    /**
     * Determines if the current code details of the context
     * satisfy the incoming constraint code details
     */
    async satisfies(constraintCodeDetails) {
        var _a;
        const comparers = [];
        const maybeCompareCodeLoader = this.codeLoader;
        if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {
            comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);
        }
        const moduleWithDetails = await this._fluidModuleP;
        const maybeCompareExport = (_a = moduleWithDetails.module) === null || _a === void 0 ? void 0 : _a.fluidExport;
        if ((maybeCompareExport === null || maybeCompareExport === void 0 ? void 0 : maybeCompareExport.IFluidCodeDetailsComparer) !== undefined) {
            comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);
        }
        // if there are not comparers it is not possible to know
        // if the current satisfy the incoming, so return false,
        // as assuming they do not satisfy is safer .e.g we will
        // reload, rather than potentially running with
        // incompatible code
        if (comparers.length === 0) {
            return false;
        }
        for (const comparer of comparers) {
            const satisfies = await comparer.satisfies(moduleWithDetails.details, constraintCodeDetails);
            if (satisfies === false) {
                return false;
            }
        }
        return true;
    }
    notifyAttaching(snapshot) {
        var _a, _b;
        this._baseSnapshot = snapshot;
        (_b = (_a = this.runtime).notifyAttaching) === null || _b === void 0 ? void 0 : _b.call(_a, snapshot);
        this.runtime.setAttachState(_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attaching);
    }
    // #region private
    async getRuntimeFactory() {
        var _a;
        const fluidExport = (_a = (await this._fluidModuleP).module) === null || _a === void 0 ? void 0 : _a.fluidExport;
        const runtimeFactory = fluidExport === null || fluidExport === void 0 ? void 0 : fluidExport.IRuntimeFactory;
        if (runtimeFactory === undefined) {
            throw new Error(PackageNotFactoryError);
        }
        return runtimeFactory;
    }
    async instantiateRuntime(existing) {
        const runtimeFactory = await this.getRuntimeFactory();
        this._runtime = await runtimeFactory.instantiateRuntime(this, existing);
    }
    attachListener() {
        this.container.once("attached", () => {
            this.runtime.setAttachState(_fluidframework_container_definitions__WEBPACK_IMPORTED_MODULE_3__.AttachState.Attached);
        });
    }
    async loadCodeModule(codeDetails) {
        const loadCodeResult = await _fluidframework_telemetry_utils__WEBPACK_IMPORTED_MODULE_4__.PerformanceEvent.timedExecAsync(this.taggedLogger, { eventName: "CodeLoad" }, async () => this.codeLoader.load(codeDetails));
        if ("module" in loadCodeResult) {
            const { module, details } = loadCodeResult;
            return {
                module,
                details: details !== null && details !== void 0 ? details : codeDetails,
            };
        }
        else {
            // If "module" is not in the result, we are using a legacy ICodeLoader.  Fix the result up with details.
            // Once usage drops to 0 we can remove this compat path.
            this.taggedLogger.sendTelemetryEvent({ eventName: "LegacyCodeLoader" });
            return loadCodeResult;
        }
    }
}
//# sourceMappingURL=containerContext.js.map

/***/ }),
/* 549 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeltaManagerProxy": () => (/* binding */ DeltaManagerProxy),
/* harmony export */   "DeltaQueueProxy": () => (/* binding */ DeltaQueueProxy)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(529);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Proxy to the real IDeltaQueue - used to restrict access
 */
class DeltaQueueProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(queue) {
        super(queue);
        this.queue = queue;
    }
    get paused() {
        return this.queue.paused;
    }
    get length() {
        return this.queue.length;
    }
    get idle() {
        return this.queue.idle;
    }
    peek() {
        return this.queue.peek();
    }
    toArray() {
        return this.queue.toArray();
    }
    // back-compat: usage removed in 0.33, remove in future versions
    async systemPause() {
        return this.pause();
    }
    async pause() {
        return this.queue.pause();
    }
    // back-compat: usage removed in 0.33, remove in future versions
    async systemResume() {
        return this.resume();
    }
    async resume() {
        this.queue.resume();
    }
    async waitTillProcessingDone() {
        return this.queue.waitTillProcessingDone();
    }
}
/**
 * Proxy to the real IDeltaManager - used to restrict access
 */
class DeltaManagerProxy extends _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_0__.EventForwarder {
    constructor(deltaManager) {
        super(deltaManager);
        this.deltaManager = deltaManager;
        this.inbound = new DeltaQueueProxy(deltaManager.inbound);
        this.outbound = new DeltaQueueProxy(deltaManager.outbound);
        this.inboundSignal = new DeltaQueueProxy(deltaManager.inboundSignal);
    }
    get IDeltaSender() {
        return this;
    }
    get minimumSequenceNumber() {
        return this.deltaManager.minimumSequenceNumber;
    }
    get lastSequenceNumber() {
        return this.deltaManager.lastSequenceNumber;
    }
    get lastMessage() {
        return this.deltaManager.lastMessage;
    }
    get lastKnownSeqNumber() {
        return this.deltaManager.lastKnownSeqNumber;
    }
    get initialSequenceNumber() {
        return this.deltaManager.initialSequenceNumber;
    }
    get hasCheckpointSequenceNumber() {
        return this.deltaManager.hasCheckpointSequenceNumber;
    }
    get clientDetails() {
        return this.deltaManager.clientDetails;
    }
    get version() {
        return this.deltaManager.version;
    }
    get maxMessageSize() {
        return this.deltaManager.maxMessageSize;
    }
    get serviceConfiguration() {
        return this.deltaManager.serviceConfiguration;
    }
    get active() {
        return this.deltaManager.active;
    }
    get readOnlyInfo() {
        return this.deltaManager.readOnlyInfo;
    }
    dispose() {
        this.inbound.dispose();
        this.outbound.dispose();
        this.inboundSignal.dispose();
        super.dispose();
    }
    submitSignal(content) {
        return this.deltaManager.submitSignal(content);
    }
    flush() {
        return this.deltaManager.flush();
    }
}
//# sourceMappingURL=deltaManagerProxy.js.map

/***/ }),
/* 550 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugLogger": () => (/* binding */ DebugLogger)
/* harmony export */ });
/* harmony import */ var _fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(389);
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */



/**
 * Implementation of debug logger
 */
class DebugLogger extends _logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger {
    constructor(debug, debugErr, properties) {
        super(undefined, properties);
        this.debug = debug;
        this.debugErr = debugErr;
    }
    /**
     * Create debug logger - all events are output to debug npm library
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    static create(namespace, properties) {
        // Setup base logger upfront, such that host can disable it (if needed)
        const debug = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(namespace);
        const debugErr = (0,debug__WEBPACK_IMPORTED_MODULE_0__.debug)(namespace);
        debugErr.log = console.error.bind(console);
        debugErr.enabled = true;
        return new DebugLogger(debug, debugErr, properties);
    }
    /**
     * Mix in debug logger with another logger.
     * Returned logger will output events to both newly created debug logger, as well as base logger
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.
     */
    static mixinDebugLogger(namespace, baseLogger, properties) {
        if (!baseLogger) {
            return DebugLogger.create(namespace, properties);
        }
        const multiSinkLogger = new _logger__WEBPACK_IMPORTED_MODULE_1__.MultiSinkLogger(undefined, properties);
        multiSinkLogger.addLogger(DebugLogger.create(namespace, this.tryGetBaseLoggerProps(baseLogger)));
        multiSinkLogger.addLogger(_logger__WEBPACK_IMPORTED_MODULE_1__.ChildLogger.create(baseLogger, namespace));
        return multiSinkLogger;
    }
    static tryGetBaseLoggerProps(baseLogger) {
        if (baseLogger instanceof _logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger) {
            return baseLogger.properties;
        }
        return undefined;
    }
    /**
     * Send an event to debug loggers
     *
     * @param event - the event to send
     */
    send(event) {
        const newEvent = this.prepareEvent(event);
        const isError = newEvent.category === "error";
        let logger = isError ? this.debugErr : this.debug;
        // Use debug's coloring schema for base of the event
        const index = event.eventName.lastIndexOf(_logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.eventNamespaceSeparator);
        const name = event.eventName.substring(index + 1);
        if (index > 0) {
            logger = logger.extend(event.eventName.substring(0, index));
        }
        newEvent.eventName = undefined;
        let tick = "";
        tick = `tick=${_logger__WEBPACK_IMPORTED_MODULE_1__.TelemetryLogger.formatTick(_fluidframework_common_utils__WEBPACK_IMPORTED_MODULE_2__.performance.now())}`;
        // Extract stack to put it last, but also to avoid escaping '\n' in it by JSON.stringify below
        const stack = newEvent.stack ? newEvent.stack : "";
        newEvent.stack = undefined;
        // Watch out for circular references - they can come from two sources
        // 1) error object - we do not control it and should remove it and retry
        // 2) properties supplied by telemetry caller - that's a bug that should be addressed!
        let payload;
        try {
            payload = JSON.stringify(newEvent);
        }
        catch (error) {
            newEvent.error = undefined;
            payload = JSON.stringify(newEvent);
        }
        if (payload === "{}") {
            payload = "";
        }
        // Force errors out, to help with diagnostics
        if (isError) {
            logger.enabled = true;
        }
        // Print multi-line.
        logger(`${name} ${payload} ${tick} ${stack}`);
    }
}
//# sourceMappingURL=debugLogger.js.map

/***/ }),
/* 551 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiUrlResolver": () => (/* binding */ MultiUrlResolver),
/* harmony export */   "configurableUrlResolver": () => (/* binding */ configurableUrlResolver)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Resolver that takes a list of url resolvers and then try each of them to resolve the url.
 * @param resolversList - List of url resolvers to be used to resolve the request.
 * @param request - Request to be resolved.
 */
async function configurableUrlResolver(resolversList, request) {
    let resolved;
    for (const resolver of resolversList) {
        resolved = await resolver.resolve(Object.assign({}, request));
        if (resolved !== undefined) {
            return resolved;
        }
    }
    return undefined;
}
class MultiUrlResolver {
    constructor(urlResolvers) {
        this.urlResolvers = urlResolvers;
    }
    static create(urlResolver) {
        if (Array.isArray(urlResolver)) {
            if (urlResolver.length === 1) {
                return urlResolver[0];
            }
            return new MultiUrlResolver(urlResolver);
        }
        return urlResolver;
    }
    async resolve(request) {
        return configurableUrlResolver(this.urlResolvers, request);
    }
    async getAbsoluteUrl(resolvedUrl, relativeUrl) {
        throw new Error("Not implmented");
    }
}
//# sourceMappingURL=multiUrlResolver.js.map

/***/ }),
/* 552 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiDocumentServiceFactory": () => (/* binding */ MultiDocumentServiceFactory)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(500);
/* harmony import */ var _fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(332);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */


class MultiDocumentServiceFactory {
    constructor(documentServiceFactories) {
        this.protocolName = "none:";
        this.protocolToDocumentFactoryMap = new Map();
        documentServiceFactories.forEach((factory) => {
            this.protocolToDocumentFactoryMap.set(factory.protocolName, factory);
        });
    }
    static create(documentServiceFactory) {
        if (Array.isArray(documentServiceFactory)) {
            const factories = [];
            documentServiceFactory.forEach((factory) => {
                const maybeMulti = factory;
                if (maybeMulti.protocolToDocumentFactoryMap !== undefined) {
                    factories.push(...maybeMulti.protocolToDocumentFactoryMap.values());
                }
                else {
                    factories.push(factory);
                }
            });
            if (factories.length === 1) {
                return factories[0];
            }
            return new MultiDocumentServiceFactory(factories);
        }
        return documentServiceFactory;
    }
    async createDocumentService(resolvedUrl, logger, clientIsSummarizer) {
        (0,_fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(resolvedUrl);
        const urlObj = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(resolvedUrl.url);
        if (urlObj.protocol === undefined || urlObj.protocol === null) {
            throw new Error("No protocol provided");
        }
        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);
        if (factory === undefined) {
            throw new Error("Unknown Fluid protocol");
        }
        return factory.createDocumentService(resolvedUrl, logger, clientIsSummarizer);
    }
    async createContainer(createNewSummary, createNewResolvedUrl, logger, clientIsSummarizer) {
        (0,_fluidResolvedUrl__WEBPACK_IMPORTED_MODULE_1__.ensureFluidResolvedUrl)(createNewResolvedUrl);
        const urlObj = (0,url__WEBPACK_IMPORTED_MODULE_0__.parse)(createNewResolvedUrl.url);
        if (urlObj.protocol === undefined || urlObj.protocol === null) {
            throw new Error("No protocol provided");
        }
        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);
        if (factory === undefined) {
            throw new Error("Unknown Fluid protocol");
        }
        return factory.createContainer(createNewSummary, createNewResolvedUrl, logger, clientIsSummarizer);
    }
}
//# sourceMappingURL=multiDocumentServiceFactory.js.map

/***/ }),
/* 553 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureFunctionTokenProvider": () => (/* binding */ AzureFunctionTokenProvider)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(348);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Token Provider implementation for connecting to an Azure Function endpoint for
 * Azure Fluid Relay token resolution.
 *
 * @deprecated 1.2.0, This API will be removed in 2.0.0
 * No replacement since it is not expected anyone will use this token provider as is
 * See https://github.com/microsoft/FluidFramework/issues/13693 for context
 */
class AzureFunctionTokenProvider {
    /**
     * Creates a new instance using configuration parameters.
     * @param azFunctionUrl - URL to Azure Function endpoint
     * @param user - User object
     */
    constructor(azFunctionUrl, user) {
        this.azFunctionUrl = azFunctionUrl;
        this.user = user;
    }
    async fetchOrdererToken(tenantId, documentId) {
        return {
            jwt: await this.getToken(tenantId, documentId),
        };
    }
    async fetchStorageToken(tenantId, documentId) {
        return {
            jwt: await this.getToken(tenantId, documentId),
        };
    }
    async getToken(tenantId, documentId) {
        var _a, _b, _c;
        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().get(this.azFunctionUrl, {
            params: {
                tenantId,
                documentId,
                userId: (_a = this.user) === null || _a === void 0 ? void 0 : _a.userId,
                userName: (_b = this.user) === null || _b === void 0 ? void 0 : _b.userName,
                additionalDetails: (_c = this.user) === null || _c === void 0 ? void 0 : _c.additionalDetails,
            },
        });
        return response.data;
    }
}
//# sourceMappingURL=AzureFunctionTokenProvider.js.map

/***/ }),
/* 554 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScopeType": () => (/* binding */ ScopeType)
/* harmony export */ });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Defines scope access for a Container/Document
 */
var ScopeType;
(function (ScopeType) {
    /**
     * Read access is supported on the Container/Document
     */
    ScopeType["DocRead"] = "doc:read";
    /**
     * Write access is supported on the Container/Document
     */
    ScopeType["DocWrite"] = "doc:write";
    /**
     * User can generate new summaries operations
     */
    ScopeType["SummaryWrite"] = "summary:write";
})(ScopeType || (ScopeType = {}));
//# sourceMappingURL=scopes.js.map

/***/ }),
/* 555 */
/***/ (function(module, exports) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
module.exports = class DataverseTokenProvider {
    constructor(accessToken, fetchAccessToken) {
        this.cachedAccessToken = accessToken;
        this.fetchAccessToken = fetchAccessToken;
    }
    fetchOrdererToken(tenantId, documentId, refresh) {
        return __awaiter(this, void 0, void 0, function* () {
            if (refresh) {
                this.cachedAccessToken = yield this.fetchAccessToken();
            }
            return {
                jwt: this.cachedAccessToken,
            };
        });
    }
    fetchStorageToken(tenantId, documentId, refresh) {
        return __awaiter(this, void 0, void 0, function* () {
            if (refresh) {
                this.cachedAccessToken = yield this.fetchAccessToken();
            }
            return {
                jwt: this.cachedAccessToken,
            };
        });
    }
};


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + "FluidFramework-HashFallback" + ".worker.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			1: 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkpowerplatform_vscode"] = self["webpackChunkpowerplatform_vscode"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

// eslint-disable-next-line no-undef
self.window = self;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const fluid = __webpack_require__(1);
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { AzureClient } = __webpack_require__(324);
// eslint-disable-next-line @typescript-eslint/no-var-requires
const DataverseTokenProvider = __webpack_require__(555);

const { SharedMap, ConnectionState } = fluid;

const objectTypes = [
    SharedMap
]

const containerSchema = {
    dynamicObjectTypes: objectTypes,
    initialObjects: {
        sharedState: SharedMap,
    },
};

class AzureFluidClient {
    static _clientInstance;
    static _container;
    static _audience;
    static _userSharedMap;

    static getInstance(config) {
        if (!this._clientInstance) {
            const afrClientProps = {
                connection: {
                    type: "remote",
                    tenantId: config.swptenantId,
                    tokenProvider: new DataverseTokenProvider(
                        config.swpAccessToken,
                        () => this.fetchAccessToken()
                    ),
                    endpoint: config.discoveryendpoint,
                },
            };

            AzureFluidClient._clientInstance = new AzureClient(afrClientProps);
        }
        return this._clientInstance;
    }

    static async fetchContainerAndService(config, id) {
        if (
            this._container?.connectionState !== ConnectionState.Connected
        ) {
            const azureClient = this.getInstance(config);
            const { container, services } = await azureClient.getContainer(
                id,
                containerSchema
            );
            if (container.connectionState !== ConnectionState.Connected) {
                await new Promise((resolve) => {
                    container.once("connected", () => {
                        resolve();
                    });
                });
            }
            this._container = container;
            this._audience = services.audience;
            this._userSharedMap = container.initialObjects.sharedState;
        }
        return {
            container: this._container,
            audience: this._audience,
            map: this._userSharedMap,
        };
    }
}

let initialLoad = true;

async function loadContainer(config, swpId, entityInfo) {
    try {
        self.postMessage({
            type: "telemetry-info",
            eventName: "webExtensionWebWorkerLoadContainerStart",
        });

        const { container, audience, map } =
            await AzureFluidClient.fetchContainerAndService(config, swpId);
        const existingMembers = audience.getMembers();
        const myself = audience.getMyself();
        const selectionSharedMap = await (await map.get('selection')).get();

        const getUserIdByConnectionId = (targetConnectionId) => {
            const members = audience.getMembers();
            for (const [userId, member] of members.entries()) {
                const connections = member.connections;
                if (connections.some((connection) => connection.id === targetConnectionId)) {
                    return { userId: userId, userName: member.userName, aadObjectId: member.additionalDetails.AadObjectId };
                }
            }

            throw new Error("Web Extension WebWorker GetUserIdByConnectionId Failed");
        };

        if (audience && myself) {
            const myConnectionId = audience['container'].clientId;
            const entityIdObj = new Array(entityInfo.rootWebPageId);
            selectionSharedMap.set(myConnectionId, entityIdObj);

            if (initialLoad) {
                initialLoad = false;
                audience.getMembers().forEach(async (member) => {
                    try {
                        const userConnections = member.connections;

                        const userConnectionData = [];

                        const connectionIdInContainer = await map
                            .get("selection")
                            .get();

                        userConnections.forEach((connection) => {
                            userConnectionData.push({ connectionId: connection.id, entityId: connectionIdInContainer.get(connection.id) });
                        });

                        // aadObjectId is the unique identifier for a user
                        self.postMessage({
                            type: "client-data",
                            userId: member.additionalDetails.AadObjectId,
                            userName: member.userName,
                            containerId: swpId,
                            connectionData: userConnectionData,
                            currentConnectionId: myConnectionId,
                        });
                    } catch (error) {
                        self.postMessage({
                            type: "telemetry-error",
                            methodName: "webWorker initialLoad",
                            errorMessage: error?.message,
                            error: error,
                        });
                    }
                });

                self.postMessage({
                    type: "telemetry-info",
                    eventName: "webExtensionContainerInitialPopulateSuccess",
                });
            }
        }

        audience.on("memberRemoved", (clientId, member) => {
            if (!existingMembers.get(member.additionalDetails.AadObjectId)) {
                self.postMessage({
                    type: "member-removed",
                    userId: member.additionalDetails.AadObjectId,
                    entityInfo: entityInfo,
                    removeConnectionData: { connectionId: clientId, entityId: entityInfo.rootWebPageId },
                });
                self.postMessage({
                    type: "telemetry-info",
                    eventName: "webExtensionWebWorkerMemberRemovedSuccess",
                    userId: member.additionalDetails.AadObjectId,
                });
            } else {
                self.postMessage({
                    type: "telemetry-error",
                    methodName: "webWorker memberRemoved",
                    errorMessage: "Web Extension WebWorker Member Removed Failed",
                });
            }
        });

        selectionSharedMap.on("valueChanged", async (changed, local) => {
            try {
                const user = getUserIdByConnectionId(changed.key);

                const userConnections = audience
                    .getMembers()
                    .get(user.userId).connections;

                const userConnectionData = [];

                const connectionIdInContainer = await map
                    .get("selection")
                    .get();

                userConnections.forEach((connection) => {
                    userConnectionData.push({ connectionId: connection.id, entityId: connectionIdInContainer.get(connection.id) });
                });

                // aadObjectId is the unique identifier for a user
                self.postMessage({
                    type: "client-data",
                    userId: user.aadObjectId,
                    userName: user.userName,
                    containerId: swpId,
                    connectionData: userConnectionData,
                });

                self.postMessage({
                    type: "telemetry-info",
                    eventName:
                        "webExtensionWebWorkerGetUserIdByConnectionIdSuccess",
                    userId: user.aadObjectId,
                });
            } catch (error) {
                self.postMessage({
                    type: "telemetry-error",
                    methodName: "webWorker valueChanged",
                    errorMessage: error?.message,
                    error: error,
                });
            }
        });
    } catch (error) {
        self.postMessage({
            type: "telemetry-error",
            eventName: "webExtensionWebWorkerLoadContainerFailed",
            methodName: loadContainer.name,
            errorMessage: error?.message,
            error: error,
        });
    }
}

function runFluidApp() {
    // Listen for messages from the extension
    // eslint-disable-next-line no-undef
    self.addEventListener("message", async (event) => {
        const message = event.data;

        await loadContainer(
            message.afrConfig,
            message.afrConfig.swpId,
            message.entityInfo
        );
    });
}

runFluidApp();
})();

/******/ })()
;
//# sourceMappingURL=webworker.worker.js.map